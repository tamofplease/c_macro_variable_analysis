<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/src/jx9_builtin.c"><comment type="block">/*
 * Symisc JX9: A Highly Efficient Embeddable Scripting Engine Based on JSON.
 * Copyright (C) 2012-2013, Symisc Systems http://jx9.symisc.net/
 * Version 1.7.2
 * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES
 * please contact Symisc Systems via:
 *       legal@symisc.net
 *       licensing@symisc.net
 *       contact@symisc.net
 * or visit:
 *      http://jx9.symisc.net/
 */</comment>
 <comment type="block">/* $SymiscID: builtin.c v1.7 Win7 2012-12-13 00:01 stable &lt;chm@symisc.net&gt; $ */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_AMALGAMATION</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jx9Int.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* This file implement built-in 'foreign' functions for the JX9 engine */</comment>
<comment type="block">/*
 * Section:
 *    Variable handling Functions.
 * Authors:
 *    Symisc Systems, devel@symisc.net.
 *    Copyright (C) Symisc Systems, http://jx9.symisc.net
 * Status:
 *    Stable.
 */</comment>
<comment type="block">/*
 * bool is_bool($var)
 *  Finds out whether a variable is a boolean.
 * Parameters
 *   $var: The variable being evaluated.
 * Return
 *  TRUE if var is a boolean. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_is_bool</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume false by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Query result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool is_float($var)
 * bool is_real($var)
 * bool is_double($var)
 *  Finds out whether a variable is a float.
 * Parameters
 *   $var: The variable being evaluated.
 * Return
 *  TRUE if var is a float. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_is_float</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume false by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_float</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Query result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool is_int($var)
 * bool is_integer($var)
 * bool is_long($var)
 *  Finds out whether a variable is an integer.
 * Parameters
 *   $var: The variable being evaluated.
 * Return
 *  TRUE if var is an integer. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_is_int</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume false by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Query result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool is_string($var)
 *  Finds out whether a variable is a string.
 * Parameters
 *   $var: The variable being evaluated.
 * Return
 *  TRUE if var is string. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_is_string</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume false by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Query result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool is_null($var)
 *  Finds out whether a variable is NULL.
 * Parameters
 *   $var: The variable being evaluated.
 * Return
 *  TRUE if var is NULL. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_is_null</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume false by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_null</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Query result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool is_numeric($var)
 *  Find out whether a variable is NULL.
 * Parameters
 *  $var: The variable being evaluated.
 * Return
 *  True if var is numeric. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_is_numeric</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume false by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_numeric</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Query result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool is_scalar($var)
 *  Find out whether a variable is a scalar.
 * Parameters
 *  $var: The variable being evaluated.
 * Return
 *  True if var is scalar. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_is_scalar</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume false by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_scalar</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Query result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool is_array($var)
 *  Find out whether a variable is an array.
 * Parameters
 *  $var: The variable being evaluated.
 * Return
 *  True if var is an array. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_is_array</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume false by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Query result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool is_object($var)
 *  Find out whether a variable is an object.
 * Parameters
 *  $var: The variable being evaluated.
 * Return
 *  True if var is an object. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_is_object</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume false by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_json_object</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Query result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool is_resource($var)
 *  Find out whether a variable is a resource.
 * Parameters
 *  $var: The variable being evaluated.
 * Return
 *  True if a resource. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_is_resource</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume false by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_resource</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float floatval($var)
 *  Get float value of a variable.
 * Parameter
 *  $var: The variable being processed.
 * Return
 *  the float value of a variable.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_floatval</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* return 0.0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type> <name>dval</name></decl>;</decl_stmt>
		<comment type="block">/* Perform the cast */</comment>
		<expr_stmt><expr><name>dval</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int intval($var)
 *  Get integer value of a variable.
 * Parameter
 *  $var: The variable being processed.
 * Return
 *  the int value of a variable.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_intval</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>sxi64</name></type> <name>iVal</name></decl>;</decl_stmt>
		<comment type="block">/* Perform the cast */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string strval($var)
 *  Get the string representation of a variable.
 * Parameter
 *  $var: The variable being processed.
 * Return
 *  the string value of a variable.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strval</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>iLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc -O6 warning */</comment>
		<comment type="block">/* Perform the cast */</comment>
		<expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool empty($var)
 *  Determine whether a variable is empty.
 * Parameters
 *   $var: The variable being checked.
 * Return
 *  0 if var has a non-empty and non-zero value.1 otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_empty</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Assume empty by default */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>jx9_value_is_empty</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
	
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JX9_ENABLE_MATH_FUNC</name></cpp:ifdef>
<comment type="block">/*
 * Section:
 *    Math Functions.
 * Authors:
 *    Symisc Systems, devel@symisc.net.
 *    Copyright (C) Symisc Systems, http://jx9.symisc.net
 * Status:
 *    Stable.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include> <comment type="block">/* abs */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<comment type="block">/*
 * float sqrt(float $arg )
 *  Square root of the given number.
 * Parameter
 *  The number to process.
 * Return
 *  The square root of arg or the special value Nan of failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_sqrt</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float exp(float $arg )
 *  Calculates the exponent of e.
 * Parameter
 *  The number to process.
 * Return
 *  'e' raised to the power of arg.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_exp</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>exp</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float floor(float $arg )
 *  Round fractions down.
 * Parameter
 *  The number to process.
 * Return
 *  Returns the next lowest integer value by rounding down value if necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_floor</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float cos(float $arg )
 *  Cosine.
 * Parameter
 *  The number to process.
 * Return
 *  The cosine of arg.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_cos</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>cos</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float acos(float $arg )
 *  Arc cosine.
 * Parameter
 *  The number to process.
 * Return
 *  The arc cosine of arg.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_acos</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>acos</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float cosh(float $arg )
 *  Hyperbolic cosine.
 * Parameter
 *  The number to process.
 * Return
 *  The hyperbolic cosine of arg.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_cosh</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>cosh</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float sin(float $arg )
 *  Sine.
 * Parameter
 *  The number to process.
 * Return
 *  The sine of arg.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_sin</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sin</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float asin(float $arg )
 *  Arc sine.
 * Parameter
 *  The number to process.
 * Return
 *  The arc sine of arg.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_asin</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>asin</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float sinh(float $arg )
 *  Hyperbolic sine.
 * Parameter
 *  The number to process.
 * Return
 *  The hyperbolic sine of arg.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_sinh</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sinh</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float ceil(float $arg )
 *  Round fractions up.
 * Parameter
 *  The number to process.
 * Return
 *  The next highest integer value by rounding up value if necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ceil</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float tan(float $arg )
 *  Tangent.
 * Parameter
 *  The number to process.
 * Return
 *  The tangent of arg.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_tan</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>tan</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float atan(float $arg )
 *  Arc tangent.
 * Parameter
 *  The number to process.
 * Return
 *  The arc tangent of arg.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_atan</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>atan</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float tanh(float $arg )
 *  Hyperbolic tangent.
 * Parameter
 *  The number to process.
 * Return
 *  The Hyperbolic tangent of arg.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_tanh</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>tanh</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float atan2(float $y, float $x)
 *  Arc tangent of two variable.
 * Parameter
 *  $y = Dividend parameter.
 *  $x = Divisor parameter.
 * Return
 *  The arc tangent of y/x in radian.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_atan2</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>atan2</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float/int64 abs(float/int64 $arg )
 *  Absolute value.
 * Parameter
 *  The number to process.
 * Return
 *  The absolute value of number.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_abs</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>is_float</name></decl>;</decl_stmt>	
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>is_float</name> <operator>=</operator> <call><name>jx9_value_is_float</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>is_float</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Perform the requested operation */</comment>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Perform the requested operation */</comment>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>abs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float log(float $arg, [int/float $base])
 *  Natural logarithm.
 * Parameter
 *  $arg: The number to process.
 *  $base: The optional logarithmic base to use. (only base-10 is supported)
 * Return
 *  The logarithm of arg to base, if given, or the natural logarithm.
 * Note: 
 *  only Natural log and base-10 log are supported. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_log</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>jx9_value_is_numeric</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">10</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Base-10 log */</comment>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>log10</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>log</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float log10(float $arg )
 *  Base-10 logarithm.
 * Parameter
 *  The number to process.
 * Return
 *  The Base-10 logarithm of the given number.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_log10</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>log10</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* store the result back */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * number pow(number $base, number $exp)
 *  Exponential expression.
 * Parameter
 *  base
 *  The base to use.
 * exp
 *  The exponent.
 * Return
 *  base raised to the power of exp.
 *  If the result can be represented as integer it will be returned
 *  as type integer, else it will be returned as type float. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_pow</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float pi(void)
 *  Returns an approximation of pi. 
 * Note
 *  you can use the M_PI constant which yields identical results to pi(). 
 * Return
 *  The value of pi as float.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_pi</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>JX9_PI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float fmod(float $x, float $y)
 *  Returns the floating point remainder (modulo) of the division of the arguments. 
 * Parameters
 * $x
 *  The dividend
 * $y
 *  The divisor
 * Return
 *  The floating point remainder of x/y.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_fmod</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt> 
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments */</comment>
		<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract given arguments */</comment>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fmod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Processing result */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * float hypot(float $x, float $y)
 *  Calculate the length of the hypotenuse of a right-angle triangle . 
 * Parameters
 * $x
 *  Length of first side
 * $y
 *  Length of first side
 * Return
 *  Calculated length of the hypotenuse.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_hypot</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt> 
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments */</comment>
		<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract given arguments */</comment>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>hypot</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Processing result */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_ENABLE_MATH_FUNC */</comment>
<comment type="block">/*
 * float round ( float $val [, int $precision = 0 [, int $mode = JX9_ROUND_HALF_UP ]] )
 *  Exponential expression.
 * Parameter
 *  $val
 *   The value to round.
 * $precision
 *   The optional number of decimal digits to round to.
 * $mode
 *   One of JX9_ROUND_HALF_UP, JX9_ROUND_HALF_DOWN, JX9_ROUND_HALF_EVEN, or JX9_ROUND_HALF_ODD.
 *   (not supported).
 * Return
 *  The rounded value.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_round</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the precision if available */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">30</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">30</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If Y==0 and X will fit in a 64-bit int, 
     * handle the rounding directly.Otherwise 
	 * use our own cutsom printf [i.e:SyBufferFormat()].
     */</comment>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>r</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>r</name><operator>&lt;</operator><name>LARGEST_INT64</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><operator>(</operator><name>jx9_int64</name><operator>)</operator><operator>(</operator><name>r</name><operator>+</operator><literal type="number">0.5</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>r</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>-</operator><name>r</name><operator>)</operator><operator>&lt;</operator><name>LARGEST_INT64</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><operator>(</operator><name>jx9_int64</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>-</operator><name>r</name><operator>)</operator><operator>+</operator><literal type="number">0.5</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
	  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>sxu32</name></type> <name>nLen</name></decl>;</decl_stmt>
	  <expr_stmt><expr><name>nLen</name> <operator>=</operator> <call><name>SyBufferFormat</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.*f"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <comment type="block">/* Convert the string to real number */</comment>
	  <expr_stmt><expr><call><name>SyStrToReal</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Return thr rounded value */</comment>
  <expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string dechex(int $number)
 *  Decimal to hexadecimal.
 * Parameters
 *  $number
 *   Decimal value to convert
 * Return
 *  Hexadecimal string representation of number
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_dechex</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>iVal</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the given number */</comment>
	<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Format */</comment>
	<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%x"</literal></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string decoct(int $number)
 *  Decimal to Octal.
 * Parameters
 *  $number
 *   Decimal value to convert
 * Return
 *  Octal string representation of number
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_decoct</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>iVal</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the given number */</comment>
	<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Format */</comment>
	<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%o"</literal></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string decbin(int $number)
 *  Decimal to binary.
 * Parameters
 *  $number
 *   Decimal value to convert
 * Return
 *  Binary string representation of number
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_decbin</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>iVal</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the given number */</comment>
	<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Format */</comment>
	<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%B"</literal></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int64 hexdec(string $hex_string)
 *  Hexadecimal to decimal.
 * Parameters
 *  $hex_string
 *   The hexadecimal string to convert
 * Return
 *  The decimal representation of hex_string 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_hexdec</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>iVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return -1 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Extract the given string */</comment>
		<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Delimit the string */</comment>
		<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Ignore non hex-stream */</comment>
		<while>while<condition>( <expr><name>zString</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* UTF-8 stream */</comment>
				<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
				<while>while<condition>( <expr><name>zString</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal><operator>)</operator></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if><else>else<block>{<block_content>
				<if_stmt><if>if<condition>( <expr><call><name>SyisHex</name><argument_list>(<argument><expr><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Ignore */</comment>
				<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zString</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Cast */</comment>
			<expr_stmt><expr><call><name>SyHexStrToInt64</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zString</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Extract as a 64-bit integer */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Return the number */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int64 bindec(string $bin_string)
 *  Binary to decimal.
 * Parameters
 *  $bin_string
 *   The binary string to convert
 * Return
 *  Returns the decimal equivalent of the binary number represented by the binary_string argument.  
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_bindec</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>iVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return -1 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Extract the given string */</comment>
		<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Perform a binary cast */</comment>
			<expr_stmt><expr><call><name>SyBinaryStrToInt64</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Extract as a 64-bit integer */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Return the number */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int64 octdec(string $oct_string)
 *  Octal to decimal.
 * Parameters
 *  $oct_string
 *   The octal string to convert
 * Return
 *  Returns the decimal equivalent of the octal number represented by the octal_string argument.  
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_octdec</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>iVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return -1 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Extract the given string */</comment>
		<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Perform the cast */</comment>
			<expr_stmt><expr><call><name>SyOctalStrToInt64</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Extract as a 64-bit integer */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Return the number */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string base_convert(string $number, int $frombase, int $tobase)
 *  Convert a number between arbitrary bases.
 * Parameters
 * $number
 *  The number to convert
 * $frombase
 *  The base number is in
 * $tobase
 *  The base to convert number to
 * Return
 *  Number converted to base tobase 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_base_convert</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>iFbase</name></decl>, <decl><type ref="prev"/><name>iTobase</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>iNum</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return the empty string*/</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Base numbers */</comment>
	<expr_stmt><expr><name>iFbase</name>  <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>iTobase</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Extract the target number */</comment>
		<expr_stmt><expr><name>zNum</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Return the empty string*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Base conversion */</comment>
		<switch>switch<condition>(<expr><name>iFbase</name></expr>)</condition><block>{<block_content>
		<case>case <expr><literal type="number">16</literal></expr>:</case>
			<comment type="block">/* Hex */</comment>
			<expr_stmt><expr><call><name>SyHexStrToInt64</name><argument_list>(<argument><expr><name>zNum</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iNum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">8</literal></expr>:</case>
			<comment type="block">/* Octal */</comment>
			<expr_stmt><expr><call><name>SyOctalStrToInt64</name><argument_list>(<argument><expr><name>zNum</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iNum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<comment type="block">/* Binary */</comment>
			<expr_stmt><expr><call><name>SyBinaryStrToInt64</name><argument_list>(<argument><expr><name>zNum</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iNum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* Decimal */</comment>
			<expr_stmt><expr><call><name>SyStrToInt64</name><argument_list>(<argument><expr><name>zNum</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iNum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name>iNum</name> <operator>=</operator> <call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<switch>switch<condition>(<expr><name>iTobase</name></expr>)</condition><block>{<block_content>
	<case>case <expr><literal type="number">16</literal></expr>:</case>
		<comment type="block">/* Hex */</comment>
		<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%qx"</literal></expr></argument>, <argument><expr><name>iNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Quad hex */</comment>
		<break>break;</break>
	<case>case <expr><literal type="number">8</literal></expr>:</case>
		<comment type="block">/* Octal */</comment>
		<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%qo"</literal></expr></argument>, <argument><expr><name>iNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Quad octal */</comment>
		<break>break;</break>
	<case>case <expr><literal type="number">2</literal></expr>:</case>
		<comment type="block">/* Binary */</comment>
		<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%qB"</literal></expr></argument>, <argument><expr><name>iNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Quad binary */</comment>
		<break>break;</break>
	<default>default:</default>
		<comment type="block">/* Decimal */</comment>
		<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%qd"</literal></expr></argument>, <argument><expr><name>iNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Quad decimal */</comment>
		<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Section:
 *    String handling Functions.
 * Authors:
 *    Symisc Systems, devel@symisc.net.
 *    Copyright (C) Symisc Systems, http://jx9.symisc.net
 * Status:
 *    Stable.
 */</comment>
<comment type="block">/*
 * string substr(string $string, int $start[, int $length ])
 *  Return part of a string.
 * Parameters
 *  $string
 *   The input string. Must be one character or longer.
 * $start
 *   If start is non-negative, the returned string will start at the start'th position
 *   in string, counting from zero. For instance, in the string 'abcdef', the character
 *   at position 0 is 'a', the character at position 2 is 'c', and so forth.
 *   If start is negative, the returned string will start at the start'th character
 *   from the end of string.
 *   If string is less than or equal to start characters long, FALSE will be returned.
 * $length
 *   If length is given and is positive, the string returned will contain at most length
 *   characters beginning from start (depending on the length of string).
 *   If length is given and is negative, then that many characters will be omitted from
 *   the end of string (after the start position has been calculated when a start is negative).
 *   If start denotes the position of this truncation or beyond, false will be returned.
 *   If length is given and is 0, FALSE or NULL an empty string will be returned.
 *   If length is omitted, the substring starting from start until the end of the string
 *   will be returned. 
 * Return
 *  Returns the extracted part of string, or FALSE on failure or an empty string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_substr</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSource</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nOfft</name></decl>, <decl><type ref="prev"/><name>nLen</name></decl>, <decl><type ref="prev"/><name>nSrcLen</name></decl>;</decl_stmt>	
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zSource</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSrcLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nSrcLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>nLen</name> <operator>=</operator> <name>nSrcLen</name></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<comment type="block">/* Extract the offset */</comment>
	<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nOfft</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zOfft</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSource</name><index>[<expr><name>nSrcLen</name><operator>+</operator><name>nOfft</name></expr>]</index></name></expr>;</expr_stmt> 
		<if_stmt><if>if<condition>( <expr><name>zOfft</name> <operator>&lt;</operator> <name>zSource</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid offset */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zSource</name><index>[<expr><name>nSrcLen</name></expr>]</index></name><operator>-</operator><name>zOfft</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zOfft</name><operator>-</operator><name>zSource</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nOfft</name> <operator>&gt;=</operator> <name>nSrcLen</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid offset */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name>zOfft</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSource</name><index>[<expr><name>nOfft</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <name>nSrcLen</name> <operator>-</operator> <name>nOfft</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Extract the length */</comment>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid length, return an empty string */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nLen</name> <operator>=</operator> <name>nSrcLen</name> <operator>+</operator> <name>nLen</name> <operator>-</operator> <name>nOfft</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Invalid  length */</comment>
				<expr_stmt><expr><name>nLen</name> <operator>=</operator> <name>nSrcLen</name> <operator>-</operator> <name>nOfft</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>+</operator> <name>nOfft</name> <operator>&gt;</operator> <name>nSrcLen</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid length */</comment>
			<expr_stmt><expr><name>nLen</name> <operator>=</operator> <name>nSrcLen</name> <operator>-</operator> <name>nOfft</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Return the substring */</comment>
	<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zOfft</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int substr_compare(string $main_str, string $str , int $offset[, int $length[, bool $case_insensitivity = false ]])
 *  Binary safe comparison of two strings from an offset, up to length characters.
 * Parameters
 *  $main_str
 *  The main string being compared.
 *  $str
 *   The secondary string being compared.
 * $offset
 *  The start position for the comparison. If negative, it starts counting from
 *  the end of the string.
 * $length
 *  The length of the comparison. The default value is the largest of the length 
 *  of the str compared to the length of main_str less the offset.
 * $case_insensitivity
 *  If case_insensitivity is TRUE, comparison is case insensitive.
 * Return
 *  Returns &lt; 0 if main_str from position offset is less than str, &gt; 0 if it is greater than
 *  str, and 0 if they are equal. If offset is equal to or greater than the length of main_str
 *  or length is set and is less than 1, substr_compare() prints a warning and returns FALSE. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_substr_compare</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSource</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zOfft</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zSub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nOfft</name></decl>, <decl><type ref="prev"/><name>nLen</name></decl>, <decl><type ref="prev"/><name>nSrcLen</name></decl>, <decl><type ref="prev"/><name>nSublen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iCase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zSource</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSrcLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nSrcLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>nLen</name> <operator>=</operator> <name>nSrcLen</name></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<comment type="block">/* Extract the substring */</comment>
	<expr_stmt><expr><name>zSub</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSublen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>nSublen</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>nSublen</name></expr></argument> &gt;</argument_list></name> <name>nSrcLen</name></expr>)</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the offset */</comment>
	<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nOfft</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zOfft</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSource</name><index>[<expr><name>nSrcLen</name><operator>+</operator><name>nOfft</name></expr>]</index></name></expr>;</expr_stmt> 
		<if_stmt><if>if<condition>( <expr><name>zOfft</name> <operator>&lt;</operator> <name>zSource</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid offset */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zSource</name><index>[<expr><name>nSrcLen</name></expr>]</index></name><operator>-</operator><name>zOfft</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zOfft</name><operator>-</operator><name>zSource</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nOfft</name> <operator>&gt;=</operator> <name>nSrcLen</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid offset */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name>zOfft</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSource</name><index>[<expr><name>nOfft</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <name>nSrcLen</name> <operator>-</operator> <name>nOfft</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Extract the length */</comment>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid  length */</comment>
			<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nLen</name> <operator>+</operator> <name>nOfft</name> <operator>&gt;</operator> <name>nSrcLen</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid length */</comment>
			<expr_stmt><expr><name>nLen</name> <operator>=</operator> <name>nSrcLen</name> <operator>-</operator> <name>nOfft</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">4</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Case-sensitive or not */</comment>
			<expr_stmt><expr><name>iCase</name> <operator>=</operator> <call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the comparison */</comment>
	<if_stmt><if>if<condition>( <expr><name>iCase</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>zOfft</name></expr></argument>, <argument><expr><name>zSub</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyStrncmp</name><argument_list>(<argument><expr><name>zOfft</name></expr></argument>, <argument><expr><name>zSub</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Comparison result */</comment>
	<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int substr_count(string $haystack, string $needle[, int $offset = 0 [, int $length ]])
 *  Count the number of substring occurrences.
 * Parameters
 * $haystack
 *   The string to search in
 * $needle
 *   The substring to search for
 * $offset
 *  The offset where to start counting
 * $length (NOT USED)
 *  The maximum length after the specified offset to search for the substring.
 *  It outputs a warning if the offset plus the length is greater than the haystack length.
 * Return
 *  Toral number of substring occurrences.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_substr_count</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPattern</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nTextlen</name></decl>, <decl><type ref="prev"/><name>nPatlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the haystack */</comment>
	<expr_stmt><expr><name>zText</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTextlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Point to the neddle */</comment>
	<expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPatlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nTextlen</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>nPatlen</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>nPatlen</name></expr></argument> &gt;</argument_list></name> <name>nTextlen</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* NOOP, return zero */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>nOfft</name></decl>;</decl_stmt>
		<comment type="block">/* Extract the offset */</comment>
		<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>nOfft</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nOfft</name></expr></argument> &gt;</argument_list></name> <name>nTextlen</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid offset, return zero */</comment>
			<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the desired offset */</comment>
		<expr_stmt><expr><name>zText</name> <operator>=</operator> <operator>&amp;</operator><name><name>zText</name><index>[<expr><name>nOfft</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Adjust length */</comment>
		<expr_stmt><expr><name>nTextlen</name> <operator>-=</operator> <name>nOfft</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the end of the string */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zText</name><index>[<expr><name>nTextlen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
		<comment type="block">/* Extract the length */</comment>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>nLen</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nLen</name></expr></argument> &gt;</argument_list></name> <name>nTextlen</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid length, return 0 */</comment>
			<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Adjust pointer */</comment>
		<expr_stmt><expr><name>nTextlen</name> <operator>=</operator> <name>nLen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zText</name><index>[<expr><name>nTextlen</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the search */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobSearch</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zText</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zText</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPattern</name></expr></argument>, <argument><expr><name>nPatlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Pattern not found, break immediately */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Increment counter and update the offset */</comment>
		<expr_stmt><expr><name>iCount</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>zText</name> <operator>+=</operator> <name>nOfft</name> <operator>+</operator> <name>nPatlen</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zText</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Pattern count */</comment>
	<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string chunk_split(string $body[, int $chunklen = 76 [, string $end = "\r\n" ]])
 *   Split a string into smaller chunks.
 * Parameters
 *  $body
 *   The string to be chunked.
 * $chunklen
 *   The chunk length.
 * $end
 *   The line ending sequence.
 * Return
 *  The chunked string or NULL on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_chunk_split</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">"\r\n"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nSepLen</name></decl>, <decl><type ref="prev"/><name>nChunkLen</name></decl>, <decl><type ref="prev"/><name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to split, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* initialize/Extract arguments */</comment>
	<expr_stmt><expr><name>nSepLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nChunkLen</name> <operator>=</operator> <literal type="number">76</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Chunk length */</comment>
		<expr_stmt><expr><name>nChunkLen</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nChunkLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Switch back to the default length */</comment>
			<expr_stmt><expr><name>nChunkLen</name> <operator>=</operator> <literal type="number">76</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Separator */</comment>
			<expr_stmt><expr><name>zSep</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSepLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>nSepLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Switch back to the default separator */</comment>
				<expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"\r\n"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>nSepLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<if_stmt><if>if<condition>( <expr><name>nChunkLen</name> <operator>&gt;</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to split, return the string and the separator */</comment>
		<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%.*s%.*s"</literal></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nSepLen</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>nChunkLen</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zIn</name><operator>)</operator></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nChunkLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name>zIn</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Append the chunk and the separator */</comment>
		<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%.*s%.*s"</literal></expr></argument>, <argument><expr><name>nChunkLen</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nSepLen</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Point beyond the chunk */</comment>
		<expr_stmt><expr><name>zIn</name> <operator>+=</operator> <name>nChunkLen</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string htmlspecialchars(string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $charset]])
 *  HTML escaping of special characters.
 *  The translations performed are:
 *   '&amp;' (ampersand) ==&gt; '&amp;amp;'
 *   '"' (double quote) ==&gt; '&amp;quot;' when ENT_NOQUOTES is not set.
 *   "'" (single quote) ==&gt; '&amp;#039;' only when ENT_QUOTES is set.
 *   '&lt;' (less than) ==&gt; '&amp;lt;'
 *   '&gt;' (greater than) ==&gt; '&amp;gt;'
 * Parameters
 *  $string
 *   The string being converted.
 * $flags
 *   A bitmask of one or more of the following flags, which specify how to handle quotes.
 *   The default is ENT_COMPAT | ENT_HTML401.
 *   ENT_COMPAT 	Will convert double-quotes and leave single-quotes alone.
 *   ENT_QUOTES 	Will convert both double and single quotes.
 *   ENT_NOQUOTES 	Will leave both double and single quotes unconverted.
 *   ENT_IGNORE 	Silently discard invalid code unit sequences instead of returning an empty string.
 * $charset
 *  Defines character set used in conversion. The default character set is ISO-8859-1. (Not used)
 * Return
 *  The escaped string or NULL on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_htmlspecialchars</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iFlags</name> <init>= <expr><literal type="number">0x01</literal><operator>|</operator><literal type="number">0x40</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* ENT_COMPAT | ENT_HTML401 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Extract the flags if available */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>iFlags</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iFlags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iFlags</name> <operator>=</operator> <literal type="number">0x01</literal><operator>|</operator><literal type="number">0x40</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&amp;'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Append the raw string verbatim */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Expand '&amp;amp;' */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Expand '&amp;lt;' */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Expand '&amp;gt;' */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>iFlags</name> <operator>&amp;</operator> <literal type="number">0x02</literal></expr> <comment type="block">/*ENT_QUOTES*/</comment> )</condition><block>{<block_content>
				<comment type="block">/* Expand '&amp;#039;' */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&amp;#039;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;#039;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Leave the single quote untouched */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <literal type="number">0x04</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> <comment type="block">/*ENT_NOQUOTES*/</comment> )</condition><block>{<block_content>
				<comment type="block">/* Expand '&amp;quot;' */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Leave the double quote untouched */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Ignore the unsafe HTML character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string htmlspecialchars_decode(string $string[, int $quote_style = ENT_COMPAT ])
 *  Unescape HTML entities.
 * Parameters
 *  $string
 *   The string to decode
 *  $quote_style
 *    The quote style. One of the following constants:
 *   ENT_COMPAT 	Will convert double-quotes and leave single-quotes alone (default)
 *   ENT_QUOTES 	Will convert both double and single quotes
 *   ENT_NOQUOTES 	Will leave both double and single quotes unconverted
 * Return
 *  The unescaped string or NULL on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_htmlspecialchars_decode</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iFlags</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* ENT_COMPAT */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>nJump</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Extract the flags if available */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>iFlags</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iFlags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iFlags</name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&amp;'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Append the raw string verbatim */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zIn</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nJump</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* &amp;amp; ==&gt; '&amp;' */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&amp;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nJump</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nLen</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* &amp;lt; ==&gt; &lt; */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nJump</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nLen</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* &amp;gt; ==&gt; '&gt;' */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nJump</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nLen</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* &amp;quot; ==&gt; '"' */</comment>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <literal type="number">0x04</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> <comment type="block">/*ENT_NOQUOTES*/</comment> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Leave untouched */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>nJump</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nLen</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;#039;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><literal type="string">"&amp;#039;"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;#039;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* &amp;#039; ==&gt; ''' */</comment>
			<if_stmt><if>if<condition>( <expr><name>iFlags</name> <operator>&amp;</operator> <literal type="number">0x02</literal></expr> <comment type="block">/*ENT_QUOTES*/</comment> )</condition><block>{<block_content>
				<comment type="block">/* Expand ''' */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Leave untouched */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&amp;#039;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;#039;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>nJump</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&amp;#039;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nLen</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
			<comment type="block">/* expand '&amp;' */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&amp;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>zIn</name> <operator>+=</operator> <name>nJump</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* HTML encoding/Decoding table 
 * Source: Symisc RunTime API.[chm@symisc.net]
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azHtmlEscape</name><index>[]</index></name> <init>= <expr><block>{
 	<expr><literal type="string">"&amp;lt;"</literal></expr>, <expr><literal type="string">"&lt;"</literal></expr>, <expr><literal type="string">"&amp;gt;"</literal></expr>, <expr><literal type="string">"&gt;"</literal></expr>, <expr><literal type="string">"&amp;amp;"</literal></expr>, <expr><literal type="string">"&amp;"</literal></expr>, <expr><literal type="string">"&amp;quot;"</literal></expr>, <expr><literal type="string">"\""</literal></expr>, <expr><literal type="string">"&amp;#39;"</literal></expr>, <expr><literal type="string">"'"</literal></expr>, 
	<expr><literal type="string">"&amp;#33;"</literal></expr>, <expr><literal type="string">"!"</literal></expr>, <expr><literal type="string">"&amp;#36;"</literal></expr>, <expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"&amp;#35;"</literal></expr>, <expr><literal type="string">"#"</literal></expr>, <expr><literal type="string">"&amp;#37;"</literal></expr>, <expr><literal type="string">"%"</literal></expr>, <expr><literal type="string">"&amp;#40;"</literal></expr>, <expr><literal type="string">"("</literal></expr>, 
	<expr><literal type="string">"&amp;#41;"</literal></expr>, <expr><literal type="string">")"</literal></expr>, <expr><literal type="string">"&amp;#123;"</literal></expr>, <expr><literal type="string">"{"</literal></expr>, <expr><literal type="string">"&amp;#125;"</literal></expr>, <expr><literal type="string">"}"</literal></expr>, <expr><literal type="string">"&amp;#61;"</literal></expr>, <expr><literal type="string">"="</literal></expr>, <expr><literal type="string">"&amp;#43;"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, 
	<expr><literal type="string">"&amp;#63;"</literal></expr>, <expr><literal type="string">"?"</literal></expr>, <expr><literal type="string">"&amp;#91;"</literal></expr>, <expr><literal type="string">"["</literal></expr>, <expr><literal type="string">"&amp;#93;"</literal></expr>, <expr><literal type="string">"]"</literal></expr>, <expr><literal type="string">"&amp;#64;"</literal></expr>, <expr><literal type="string">"@"</literal></expr>, <expr><literal type="string">"&amp;#44;"</literal></expr>, <expr><literal type="string">","</literal></expr> 
 }</block></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * array get_html_translation_table(void)
 *  Returns the translation table used by htmlspecialchars() and htmlentities().
 * Parameters
 *  None
 * Return
 *  The translation table as an array or NULL on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_get_html_translation_table</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<comment type="block">/* Element value */</comment>
	<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>jx9_context_new_scalar</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pValue</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
		<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create a new array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make the table */</comment>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>azHtmlEscape</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr> )</control><block>{<block_content>
		<comment type="block">/* Prepare the value */</comment>
		<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>azHtmlEscape</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* Compute length automatically */</comment>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Insert the value */</comment>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><name><name>azHtmlEscape</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Reset the string cursor */</comment>
		<expr_stmt><expr><call><name>jx9_value_reset_string_cursor</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* 
	 * Return the array.
	 * Don't worry about freeing memory, everything will be automatically
	 * released upon we return from this function.
	 */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string htmlentities( string $string [, int $flags = ENT_COMPAT | ENT_HTML401]);
 *   Convert all applicable characters to HTML entities
 * Parameters
 * $string
 *   The input string.
 * $flags
 *  A bitmask of one or more of the flags (see block-comment on jx9Builtin_htmlspecialchars())
 * Return
 * The encoded string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_htmlentities</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>iFlags</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* ENT_COMPAT */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Extract the flags if available */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>iFlags</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iFlags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iFlags</name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Perform a linear lookup on the decoding table */</comment>
		<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>azHtmlEscape</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr> )</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>azHtmlEscape</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Got one */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>azHtmlEscape</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Output the safe sequence [i.e: '&lt;' ==&gt; '&amp;lt;"] */</comment>
			<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <literal type="number">0x04</literal><operator>)</operator></expr> <comment type="block">/*ENT_NOQUOTES*/</comment> )</condition><block>{<block_content>
				<comment type="block">/* Expand the double quote verbatim */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <literal type="number">0x02</literal> <comment type="block">/*ENT_QUOTES*/</comment><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <literal type="number">0x04</literal><operator>)</operator> <comment type="block">/*ENT_NOQUOTES*/</comment><operator>)</operator></expr> )</condition><block>{<block_content>
				<comment type="block">/* expand single quote verbatim */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>azHtmlEscape</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument><comment type="block">/*Compute length automatically */</comment>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Output character verbatim */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string html_entity_decode(string $string [, int $quote_style = ENT_COMPAT [, string $charset = 'UTF-8' ]])
 *   Perform the reverse operation of html_entity_decode().
 * Parameters
 * $string
 *   The input string.
 * $flags
 *  A bitmask of one or more of the flags (see comment on jx9Builtin_htmlspecialchars())
 * Return
 * The decoded string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_html_entity_decode</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iFlags</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* ENT_COMPAT  */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Extract the flags if available */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>iFlags</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iFlags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iFlags</name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&amp;'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Append raw string verbatim */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zIn</name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* Find an encoded sequence */</comment>
		<for>for<control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>azHtmlEscape</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr> )</control><block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>iLen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>SyStrlen</name><argument_list>(<argument><expr><name><name>azHtmlEscape</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;=</operator> <name>iLen</name> <operator>&amp;&amp;</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name><name>azHtmlEscape</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>iLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Got one */</comment>
				<expr_stmt><expr><name>zIn</name> <operator>+=</operator> <name>iLen</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>azHtmlEscape</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>azHtmlEscape</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Output the decoded character */</comment>
			<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <literal type="number">0x02</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <comment type="block">/*ENT_QUOTES*/</comment><operator>||</operator> <operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <literal type="number">0x04</literal><operator>)</operator> <comment type="block">/*ENT_NOQUOTES*/</comment><operator>)</operator></expr>  )</condition><block>{<block_content>
				<comment type="block">/* Do not process single quotes */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>azHtmlEscape</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <literal type="number">0x04</literal><operator>)</operator></expr> <comment type="block">/*ENT_NOQUOTES*/</comment> )</condition><block>{<block_content>
				<comment type="block">/* Do not process double quotes */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>azHtmlEscape</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>azHtmlEscape</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Compute length automatically */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Append '&amp;' */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&amp;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strlen($string)
 *  return the length of the given string.
 * Parameter
 *  string: The string being measured for length.
 * Return
 *  length of the given string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strlen</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>iLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* String length */</comment>
	<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strcmp(string $str1, string $str2)
 *  Perform a binary safe string comparison.
 * Parameter
 *  str1: The first string
 *  str2: The second string
 * Return
 *  Returns &lt; 0 if str1 is less than str2; &gt; 0 if str1 is greater 
 *  than str2, and 0 if they are equal.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strcmp</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><name>nArg</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the comparison */</comment>
	<expr_stmt><expr><name>z1</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>z2</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>SyStrncmp</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><call><name>SXMAX</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Comparison result */</comment>
	<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strncmp(string $str1, string $str2, int n)
 *  Perform a binary safe string comparison of the first n characters.
 * Parameter
 *  str1: The first string
 *  str2: The second string
 * Return
 *  Returns &lt; 0 if str1 is less than str2; &gt; 0 if str1 is greater 
 *  than str2, and 0 if they are equal.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strncmp</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Perform a standard comparison */</comment>
		<return>return <expr><call><name>jx9Builtin_strcmp</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Desired comparison length */</comment>
	<expr_stmt><expr><name>n</name>  <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid length */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the comparison */</comment>
	<expr_stmt><expr><name>z1</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>z2</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>SyStrncmp</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Comparison result */</comment>
	<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strcasecmp(string $str1, string $str2, int n)
 *  Perform a binary safe case-insensitive string comparison.
 * Parameter
 *  str1: The first string
 *  str2: The second string
 * Return
 *  Returns &lt; 0 if str1 is less than str2; &gt; 0 if str1 is greater 
 *  than str2, and 0 if they are equal.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strcasecmp</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><name>nArg</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the comparison */</comment>
	<expr_stmt><expr><name>z1</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>z2</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><call><name>SXMAX</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Comparison result */</comment>
	<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strncasecmp(string $str1, string $str2, int n)
 *  Perform a binary safe case-insensitive string comparison of the first n characters.
 * Parameter
 *  $str1: The first string
 *  $str2: The second string
 *  $len:  The length of strings to be used in the comparison.
 * Return
 *  Returns &lt; 0 if str1 is less than str2; &gt; 0 if str1 is greater 
 *  than str2, and 0 if they are equal.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strncasecmp</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Perform a standard comparison */</comment>
		<return>return <expr><call><name>jx9Builtin_strcasecmp</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Desired comparison length */</comment>
	<expr_stmt><expr><name>n</name>  <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid length */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the comparison */</comment>
	<expr_stmt><expr><name>z1</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>z2</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Comparison result */</comment>
	<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Implode context [i.e: it's private data].
 * A pointer to the following structure is forwarded
 * verbatim to the array walker callback defined below.
 */</comment>
<struct>struct <name>implode_data</name> <block>{
	<decl_stmt><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>    <comment type="block">/* Call context */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>bRecursive</name></decl>;</decl_stmt>       <comment type="block">/* TRUE if recursive implode [this is a symisc eXtension] */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name></decl>;</decl_stmt>     <comment type="block">/* Arguments separator if any */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nSeplen</name></decl>;</decl_stmt>          <comment type="block">/* Separator length */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>bFirst</name></decl>;</decl_stmt>           <comment type="block">/* TRUE if first call */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nRecCount</name></decl>;</decl_stmt>        <comment type="block">/* Recursion count to avoid infinite loop */</comment>
}</block>;</struct>
<comment type="block">/*
 * Implode walker callback for the [jx9_array_walk()] interface.
 * The following routine is invoked for each array entry passed
 * to the implode() function.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>implode_callback</name><parameter_list>(<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>implode_data</name></name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><operator>(</operator>struct <name>implode_data</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>bRecursive</name></name> <operator>&amp;&amp;</operator> <call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pData</name><operator>-&gt;</operator><name>nRecCount</name></name> <operator>&lt;</operator> <literal type="number">32</literal></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>nSeplen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pData</name><operator>-&gt;</operator><name>bFirst</name></name></expr> )</condition><block>{<block_content>
				<comment type="block">/* append the separator first */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>zSep</name></name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>nSeplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>bFirst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Recurse */</comment>
		<expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>bFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>nRecCount</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9HashmapWalk</name><argument_list>(<argument><expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>pValue</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pOther</name></name></expr></argument>, <argument><expr><name>implode_callback</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>nRecCount</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the string representation of the entry value */</comment>
	<expr_stmt><expr><name>zData</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>nSeplen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pData</name><operator>-&gt;</operator><name>bFirst</name></name></expr> )</condition><block>{<block_content>
				<comment type="block">/* append the separator first */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>zSep</name></name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>nSeplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>bFirst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name><name>pData</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>zData</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string implode(string $glue, array $pieces, ...)
 * string implode(array $pieces, ...)
 *  Join array elements with a string.
 * $glue
 *   Defaults to an empty string. This is not the preferred usage of implode() as glue
 *   would be the second parameter and thus, the bad prototype would be used.
 * $pieces
 *   The array of strings to implode.
 * Return
 *  Returns a string containing a string representation of all the array elements in the same
 *  order, with the glue string between each element. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_implode</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>implode_data</name></name></type> <name>imp_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Prepare the implode context */</comment>
	<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>pCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>bRecursive</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>bFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>nRecCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>zSep</name></name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>imp_data</name><operator>.</operator><name>nSeplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>zSep</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>nSeplen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Set an empty stirng */</comment>
	<comment type="block">/* Start the 'join' process */</comment>
	<while>while<condition>( <expr><name>i</name> <operator>&lt;</operator> <name>nArg</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Iterate throw array entries */</comment>
			<expr_stmt><expr><call><name>jx9_array_walk</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>implode_callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imp_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zData</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
			<comment type="block">/* Extract the string representation of the jx9 value */</comment>
			<expr_stmt><expr><name>zData</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name><name>imp_data</name><operator>.</operator><name>nSeplen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>imp_data</name><operator>.</operator><name>bFirst</name></name></expr> )</condition><block>{<block_content>
						<comment type="block">/* append the separator first */</comment>
						<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>imp_data</name><operator>.</operator><name>zSep</name></name></expr></argument>, <argument><expr><name><name>imp_data</name><operator>.</operator><name>nSeplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if><else>else<block>{<block_content>
						<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>bFirst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zData</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string implode_recursive(string $glue, array $pieces, ...)
 * Purpose
 *  Same as implode() but recurse on arrays.
 * Example:
 *   $a = array('usr', array('home', 'dean'));
 *   print implode_recursive("/", $a);
 *   Will output
 *     usr/home/dean.
 *   While the standard implode would produce.
 *    usr/Array.
 * Parameter
 *  Refer to implode().
 * Return
 *  Refer to implode().
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_implode_recursive</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>implode_data</name></name></type> <name>imp_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Prepare the implode context */</comment>
	<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>pCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>bRecursive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>bFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>nRecCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>zSep</name></name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>imp_data</name><operator>.</operator><name>nSeplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>zSep</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>nSeplen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Set an empty stirng */</comment>
	<comment type="block">/* Start the 'join' process */</comment>
	<while>while<condition>( <expr><name>i</name> <operator>&lt;</operator> <name>nArg</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Iterate throw array entries */</comment>
			<expr_stmt><expr><call><name>jx9_array_walk</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>implode_callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imp_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zData</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
			<comment type="block">/* Extract the string representation of the jx9 value */</comment>
			<expr_stmt><expr><name>zData</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name><name>imp_data</name><operator>.</operator><name>nSeplen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>imp_data</name><operator>.</operator><name>bFirst</name></name></expr> )</condition><block>{<block_content>
						<comment type="block">/* append the separator first */</comment>
						<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>imp_data</name><operator>.</operator><name>zSep</name></name></expr></argument>, <argument><expr><name><name>imp_data</name><operator>.</operator><name>nSeplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if><else>else<block>{<block_content>
						<expr_stmt><expr><name><name>imp_data</name><operator>.</operator><name>bFirst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zData</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array explode(string $delimiter, string $string[, int $limit ])
 *  Returns an array of strings, each of which is a substring of string 
 *  formed by splitting it on boundaries formed by the string delimiter. 
 * Parameters
 *  $delimiter
 *   The boundary string.
 * $string
 *   The input string.
 * $limit
 *   If limit is set and positive, the returned array will contain a maximum
 *   of limit elements with the last element containing the rest of string.
 *   If the limit parameter is negative, all fields except the last -limit are returned.
 *   If the limit parameter is zero, then this is treated as 1.
 * Returns
 *  Returns an array of strings created by splitting the string parameter
 *  on boundaries formed by the delimiter.
 *  If delimiter is an empty string (""), explode() will return FALSE. 
 *  If delimiter contains a value that is not contained in string and a negative
 *  limit is used, then an empty array will be returned, otherwise an array containing string
 *  will be returned. 
 * NOTE:
 *  Negative limit is not supported.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_explode</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDelim</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zString</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nDelim</name></decl>, <decl><type ref="prev"/><name>nStrlen</name></decl>, <decl><type ref="prev"/><name>iLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the delimiter */</comment>
	<expr_stmt><expr><name>zDelim</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDelim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nDelim</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty delimiter, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nStrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nStrlen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty delimiter, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the end of the string */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nStrlen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Create the array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator>  <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>jx9_context_new_scalar</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pValue</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Out of memory, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Set a defualt limit */</comment>
	<expr_stmt><expr><name>iLimit</name> <operator>=</operator> <name>SXI32_HIGH</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>iLimit</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <if_stmt><if>if<condition>( <expr><name>iLimit</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iLimit</name> <operator>=</operator> <operator>-</operator><name>iLimit</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>iLimit</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iLimit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>iLimit</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Start exploding */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zString</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more entry to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobSearch</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zString</name><operator>)</operator></expr></argument>, <argument><expr><name>zDelim</name></expr></argument>, <argument><expr><name>nDelim</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name> <operator>||</operator> <name>iLimit</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>jx9_array_count</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Limit reached, insert the rest of the string and break */</comment>
			<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&gt;</operator> <name>zString</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name>zString</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zString</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index assign*/</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the desired offset */</comment>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nOfft</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&gt;</operator> <name>zString</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Perform the store operation */</comment>
			<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name>zString</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zCur</name><operator>-</operator><name>zString</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index assign*/</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point beyond the delimiter */</comment>
		<expr_stmt><expr><name>zString</name> <operator>=</operator> <operator>&amp;</operator><name><name>zCur</name><index>[<expr><name>nDelim</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Reset the cursor */</comment>
		<expr_stmt><expr><call><name>jx9_value_reset_string_cursor</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Return the freshly created array */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* NOTE that every allocated jx9_value will be automatically 
	 * released as soon we return from this foregin function.
	 */</comment>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string trim(string $str[, string $charlist ])
 *  Strip whitespace (or other characters) from the beginning and end of a string.
 * Parameters
 *  $str
 *   The string that will be trimmed.
 * $charlist
 *   Optionally, the stripped characters can also be specified using the charlist parameter.
 *   Simply list all characters that you want to be stripped.
 *   With .. you can specify a range of characters.
 * Returns.
 *  Thr processed string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_trim</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Start the trim process */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>SyString</name></type> <name>sStr</name></decl>;</decl_stmt>
		<comment type="block">/* Remove white spaces and NUL bytes */</comment>
		<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sStr</name></expr></argument>, <argument><expr><name>zString</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyStringFullTrimSafe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>sStr</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sStr</name><operator>.</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Char list */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zList</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nListlen</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>zList</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nListlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nListlen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Return the string unchanged */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zString</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name> <init>= <expr><name>zString</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
			<comment type="block">/* Left trim */</comment>
			<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <name>zCur</name></expr>;</expr_stmt>
				<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nListlen</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
					<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>zList</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>zCur</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>==</operator> <name>zPtr</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* No match, break immediately */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<comment type="block">/* Right trim */</comment>
			<expr_stmt><expr><name>zEnd</name><operator>--</operator></expr>;</expr_stmt>
			<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&lt;=</operator> <name>zCur</name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <name>zEnd</name></expr>;</expr_stmt>
				<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nListlen</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
					<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&gt;</operator> <name>zCur</name> <operator>&amp;&amp;</operator> <name><name>zEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>zList</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>zEnd</name><operator>--</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>==</operator> <name>zPtr</name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Return the empty string */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>zEnd</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string rtrim(string $str[, string $charlist ])
 *  Strip whitespace (or other characters) from the end of a string.
 * Parameters
 *  $str
 *   The string that will be trimmed.
 * $charlist
 *   Optionally, the stripped characters can also be specified using the charlist parameter.
 *   Simply list all characters that you want to be stripped.
 *   With .. you can specify a range of characters.
 * Returns.
 *  Thr processed string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_rtrim</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Start the trim process */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>SyString</name></type> <name>sStr</name></decl>;</decl_stmt>
		<comment type="block">/* Remove white spaces and NUL bytes*/</comment>
		<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sStr</name></expr></argument>, <argument><expr><name>zString</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyStringRightTrimSafe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>sStr</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sStr</name><operator>.</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Char list */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zList</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nListlen</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>zList</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nListlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nListlen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Return the string unchanged */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zString</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nLen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name> <init>= <expr><name>zString</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
			<comment type="block">/* Right trim */</comment>
			<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&lt;=</operator> <name>zCur</name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <name>zEnd</name></expr>;</expr_stmt>
				<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nListlen</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
					<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&gt;</operator> <name>zCur</name> <operator>&amp;&amp;</operator> <name><name>zEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>zList</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>zEnd</name><operator>--</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>==</operator> <name>zPtr</name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&lt;=</operator> <name>zCur</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Return the empty string */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>zEnd</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string ltrim(string $str[, string $charlist ])
 *  Strip whitespace (or other characters) from the beginning and end of a string.
 * Parameters
 *  $str
 *   The string that will be trimmed.
 * $charlist
 *   Optionally, the stripped characters can also be specified using the charlist parameter.
 *   Simply list all characters that you want to be stripped.
 *   With .. you can specify a range of characters.
 * Returns.
 *  The processed string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ltrim</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Start the trim process */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>SyString</name></type> <name>sStr</name></decl>;</decl_stmt>
		<comment type="block">/* Remove white spaces and NUL byte */</comment>
		<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sStr</name></expr></argument>, <argument><expr><name>zString</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyStringLeftTrimSafe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>sStr</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sStr</name><operator>.</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Char list */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zList</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nListlen</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>zList</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nListlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nListlen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Return the string unchanged */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zString</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name> <init>= <expr><name>zString</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
			<comment type="block">/* Left trim */</comment>
			<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <name>zCur</name></expr>;</expr_stmt>
				<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nListlen</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
					<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>zList</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>zCur</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>==</operator> <name>zPtr</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* No match, break immediately */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Return the empty string */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string strtolower(string $str)
 *  Make a string lowercase.
 * Parameters
 *  $str
 *   The input string.
 * Returns.
 *  The lowercased string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strtolower</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zString</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input, break immediately */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* UTF-8 stream, output verbatim */</comment>
			<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zString</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
			<while>while<condition>( <expr><name>zString</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block>{<block_content>
				<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<comment type="block">/* Append UTF-8 stream */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zString</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>( <expr><call><name>SyisUpper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>SyToLower</name><argument_list>(<argument><expr><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Append character */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Advance the cursor */</comment>
			<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string strtolower(string $str)
 *  Make a string uppercase.
 * Parameters
 *  $str
 *   The input string.
 * Returns.
 *  The uppercased string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strtoupper</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zString</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input, break immediately */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* UTF-8 stream, output verbatim */</comment>
			<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zString</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
			<while>while<condition>( <expr><name>zString</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block>{<block_content>
				<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<comment type="block">/* Append UTF-8 stream */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zString</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>( <expr><call><name>SyisLower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>SyToUpper</name><argument_list>(<argument><expr><name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Append character */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Advance the cursor */</comment>
			<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int ord(string $string)
 *  Returns the ASCII value of the first character of string.
 * Parameters
 *  $str
 *   The input string.
 * Returns.
 *  The ASCII value as an integer.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ord</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return -1 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return -1 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the ASCII value of the first character */</comment>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Return that value */</comment>
	<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string chr(int $ascii)
 *  Returns a one-character string containing the character specified by ascii.
 * Parameters
 *  $ascii
 *   The ascii code.
 * Returns.
 *  The specified character.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_chr</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the ASCII value */</comment>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Return the specified character */</comment>
	<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Binary to hex consumer callback.
 * This callback is the default consumer used by the hash functions
 * [i.e: bin2hex(), md5(), sha1(), md5_file() ... ] defined below.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>HashConsumer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Append hex chunk verbatim */</comment>
	<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><operator>(</operator><name>jx9_context</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string bin2hex(string $str)
 *  Convert binary data into hexadecimal representation.
 * Parameters
 *  $str
 *   The input string.
 * Returns.
 *  Returns the hexadecimal representation of the given string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_bin2hex</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><call><name>SyBinToHexConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zString</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>HashConsumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Search callback signature */</comment>
<typedef>typedef <function_decl><type><name>sxi32</name></type> (<modifier>*</modifier><name>ProcStringMatch</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sxu32</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sxu32</name></type></decl></parameter>, <parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<comment type="block">/*
 * Case-insensitive pattern match.
 * Brute force is the default search method used here.
 * This is due to the fact that brute-forcing works quite
 * well for short/medium texts on modern hardware.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>iPatternMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pText</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pPattern</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>iPatLen</name></decl></parameter>, <parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pOfft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zpIn</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pPattern</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pText</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zpEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zpIn</name><index>[<expr><name>iPatLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPtr2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>iPatLen</name> <operator>&gt;</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother processing */</comment>
		<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>SyToLower</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>SyToLower</name><argument_list>(<argument><expr><name><name>zpIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <name>d</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zPtr</name>   <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zPtr2</name>  <operator>=</operator> <operator>&amp;</operator><name><name>zpIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name>zPtr2</name> <operator>&gt;=</operator> <name>zpEnd</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* Pattern found */</comment>
					<if_stmt><if>if<condition>( <expr><name>pOfft</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pOfft</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pText</name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
					<return>return <expr><name>SXRET_OK</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if<condition>( <expr><name>zPtr</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>SyToLower</name><argument_list>(<argument><expr><name><name>zPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>SyToLower</name><argument_list>(<argument><expr><name><name>zPtr2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>c</name> <operator>!=</operator> <name>d</name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>zPtr</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zPtr2</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Pattern not found */</comment>
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string strstr(string $haystack, string $needle[, bool $before_needle = false ])
 *  Find the first occurrence of a string.
 * Parameters
 *  $haystack
 *   The input string.
 * $needle
 *   Search pattern (must be a string).
 * $before_needle
 *   If TRUE, strstr() returns the part of the haystack before the first occurrence 
 *   of the needle (excluding the needle).
 * Return
 *  Returns the portion of string, or FALSE if needle is not found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strstr</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProcStringMatch</name></type> <name>xPatternMatch</name> <init>= <expr><name>SyBlobSearch</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Case-sensitive pattern match */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBlob</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>nPatLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the needle and the haystack */</comment>
	<expr_stmt><expr><name>zBlob</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPatLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nPatLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>before</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Perform the lookup */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xPatternMatch</name><argument_list>(<argument><expr><name>zBlob</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nPatLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Pattern not found, return FALSE */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Return the portion of the string */</comment>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>before</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>before</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zBlob</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nOfft</name></expr>]</index></name><operator>-</operator><name>zBlob</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nOfft</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name></expr>]</index></name><operator>-</operator><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nOfft</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string stristr(string $haystack, string $needle[, bool $before_needle = false ])
 *  Case-insensitive strstr().
 * Parameters
 *  $haystack
 *   The input string.
 * $needle
 *   Search pattern (must be a string).
 * $before_needle
 *   If TRUE, strstr() returns the part of the haystack before the first occurrence 
 *   of the needle (excluding the needle).
 * Return
 *  Returns the portion of string, or FALSE if needle is not found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_stristr</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProcStringMatch</name></type> <name>xPatternMatch</name> <init>= <expr><name>iPatternMatch</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Case-insensitive pattern match */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBlob</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>nPatLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the needle and the haystack */</comment>
	<expr_stmt><expr><name>zBlob</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPatLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nPatLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>before</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Perform the lookup */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xPatternMatch</name><argument_list>(<argument><expr><name>zBlob</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nPatLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Pattern not found, return FALSE */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Return the portion of the string */</comment>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>before</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>before</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zBlob</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nOfft</name></expr>]</index></name><operator>-</operator><name>zBlob</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nOfft</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name></expr>]</index></name><operator>-</operator><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nOfft</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strpos(string $haystack, string $needle [, int $offset = 0 ] )
 *  Returns the numeric position of the first occurrence of needle in the haystack string.
 * Parameters
 *  $haystack
 *   The input string.
 * $needle
 *   Search pattern (must be a string).
 * $offset
 *   This optional offset parameter allows you to specify which character in haystack
 *   to start searching. The position returned is still relative to the beginning
 *   of haystack.
 * Return
 *  Returns the position as an integer.If needle is not found, strpos() will return FALSE.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strpos</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProcStringMatch</name></type> <name>xPatternMatch</name> <init>= <expr><name>SyBlobSearch</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Case-sensitive pattern match */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBlob</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>nPatLen</name></decl>, <decl><type ref="prev"/><name>nStart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the needle and the haystack */</comment>
	<expr_stmt><expr><name>zBlob</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPatLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<expr_stmt><expr><name>nStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Peek the starting offset if available */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nStart</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nStart</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nStart</name> <operator>=</operator> <operator>-</operator><name>nStart</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nStart</name> <operator>&gt;=</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid offset */</comment>
			<expr_stmt><expr><name>nStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name>zBlob</name> <operator>+=</operator> <name>nStart</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nLen</name> <operator>-=</operator> <name>nStart</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nPatLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Perform the lookup */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xPatternMatch</name><argument_list>(<argument><expr><name>zBlob</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nPatLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Pattern not found, return FALSE */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Return the pattern position */</comment>
		<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>jx9_int64</name><operator>)</operator><operator>(</operator><name>nOfft</name><operator>+</operator><name>nStart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int stripos(string $haystack, string $needle [, int $offset = 0 ] )
 *  Case-insensitive strpos.
 * Parameters
 *  $haystack
 *   The input string.
 * $needle
 *   Search pattern (must be a string).
 * $offset
 *   This optional offset parameter allows you to specify which character in haystack
 *   to start searching. The position returned is still relative to the beginning
 *   of haystack.
 * Return
 *  Returns the position as an integer.If needle is not found, strpos() will return FALSE.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_stripos</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProcStringMatch</name></type> <name>xPatternMatch</name> <init>= <expr><name>iPatternMatch</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Case-insensitive pattern match */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBlob</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>nPatLen</name></decl>, <decl><type ref="prev"/><name>nStart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the needle and the haystack */</comment>
	<expr_stmt><expr><name>zBlob</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPatLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<expr_stmt><expr><name>nStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Peek the starting offset if available */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nStart</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nStart</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nStart</name> <operator>=</operator> <operator>-</operator><name>nStart</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nStart</name> <operator>&gt;=</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid offset */</comment>
			<expr_stmt><expr><name>nStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name>zBlob</name> <operator>+=</operator> <name>nStart</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nLen</name> <operator>-=</operator> <name>nStart</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nPatLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Perform the lookup */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xPatternMatch</name><argument_list>(<argument><expr><name>zBlob</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nPatLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Pattern not found, return FALSE */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Return the pattern position */</comment>
		<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>jx9_int64</name><operator>)</operator><operator>(</operator><name>nOfft</name><operator>+</operator><name>nStart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strrpos(string $haystack, string $needle [, int $offset = 0 ] )
 *  Find the numeric position of the last occurrence of needle in the haystack string.
 * Parameters
 *  $haystack
 *   The input string.
 * $needle
 *   Search pattern (must be a string).
 * $offset
 *   If specified, search will start this number of characters counted from the beginning
 *   of the string. If the value is negative, search will instead start from that many 
 *   characters from the end of the string, searching backwards.
 * Return
 *  Returns the position as an integer.If needle is not found, strrpos() will return FALSE.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strrpos</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zBlob</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPattern</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPtr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcStringMatch</name></type> <name>xPatternMatch</name> <init>= <expr><name>SyBlobSearch</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Case-sensitive pattern match */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>nPatLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the needle and the haystack */</comment>
	<expr_stmt><expr><name>zBlob</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPatLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Point to the end of the pattern */</comment>
	<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Save the starting posistion */</comment>
	<expr_stmt><expr><name>zStart</name> <operator>=</operator> <name>zBlob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<comment type="block">/* Peek the starting offset if available */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>nStart</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>nStart</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nStart</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nStart</name> <operator>=</operator> <operator>-</operator><name>nStart</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>nStart</name> <operator>&gt;=</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Invalid offset */</comment>
				<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>nLen</name> <operator>-=</operator> <name>nStart</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>nStart</name> <operator>&gt;=</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Invalid offset */</comment>
				<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>zBlob</name> <operator>+=</operator> <name>nStart</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nLen</name> <operator>-=</operator> <name>nStart</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nPatLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Perform the lookup */</comment>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>zBlob</name> <operator>&gt;=</operator> <name>zPtr</name></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xPatternMatch</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zPtr</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPattern</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nPatLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Pattern found, return it's position */</comment>
				<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>jx9_int64</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zPtr</name><index>[<expr><name>nOfft</name></expr>]</index></name> <operator>-</operator> <name>zStart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>zPtr</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* Pattern not found, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strripos(string $haystack, string $needle [, int $offset = 0 ] )
 *  Case-insensitive strrpos.
 * Parameters
 *  $haystack
 *   The input string.
 * $needle
 *   Search pattern (must be a string).
 * $offset
 *   If specified, search will start this number of characters counted from the beginning
 *   of the string. If the value is negative, search will instead start from that many 
 *   characters from the end of the string, searching backwards.
 * Return
 *  Returns the position as an integer.If needle is not found, strrpos() will return FALSE.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strripos</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zBlob</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPattern</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPtr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcStringMatch</name></type> <name>xPatternMatch</name> <init>= <expr><name>iPatternMatch</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Case-insensitive pattern match */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>nPatLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the needle and the haystack */</comment>
	<expr_stmt><expr><name>zBlob</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPatLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Point to the end of the pattern */</comment>
	<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Save the starting posistion */</comment>
	<expr_stmt><expr><name>zStart</name> <operator>=</operator> <name>zBlob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<comment type="block">/* Peek the starting offset if available */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>nStart</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>nStart</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nStart</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nStart</name> <operator>=</operator> <operator>-</operator><name>nStart</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>nStart</name> <operator>&gt;=</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Invalid offset */</comment>
				<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>nLen</name> <operator>-=</operator> <name>nStart</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>nStart</name> <operator>&gt;=</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Invalid offset */</comment>
				<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>zBlob</name> <operator>+=</operator> <name>nStart</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nLen</name> <operator>-=</operator> <name>nStart</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nPatLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Perform the lookup */</comment>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>zBlob</name> <operator>&gt;=</operator> <name>zPtr</name></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xPatternMatch</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zPtr</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zPattern</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nPatLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Pattern found, return it's position */</comment>
				<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>jx9_int64</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zPtr</name><index>[<expr><name>nOfft</name></expr>]</index></name> <operator>-</operator> <name>zStart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>zPtr</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* Pattern not found, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strrchr(string $haystack, mixed $needle)
 *  Find the last occurrence of a character in a string.
 * Parameters
 *  $haystack
 *   The input string.
 * $needle
 *  If needle contains more than one character, only the first is used.
 *  This behavior is different from that of strstr().
 *  If needle is not a string, it is converted to an integer and applied
 *  as the ordinal value of a character.
 * Return
 *  This function returns the portion of string, or FALSE if needle is not found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strrchr</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBlob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the haystack */</comment>
	<expr_stmt><expr><name>zBlob</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Never fail, so there is no need to check
														 * for NULL pointer.
														 */</comment>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zPattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Int cast */</comment>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Perform the lookup */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyByteFind2</name><argument_list>(<argument><expr><name>zBlob</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No such entry, return FALSE */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Return the string portion */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nOfft</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nLen</name></expr>]</index></name><operator>-</operator><operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name>nOfft</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string strrev(string $string)
 *  Reverse a string.
 * Parameters
 *  $string
 *   String to be reversed.
 * Return
 *  The reversed string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strrev</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string Return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Append current character */</comment>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>zEnd</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string str_repeat(string $input, int $multiplier)
 *  Returns input repeated multiplier times.
 * Parameters
 *  $string
 *   String to be repeated.
 * $multiplier
 *  Number of time the input string should be repeated.
 *  multiplier has to be greater than or equal to 0. If the multiplier is set
 *  to 0, the function will return an empty string.
 * Return
 *  The repeated string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_str_repeat</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>nMul</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string.Return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the multiplier */</comment>
	<expr_stmt><expr><name>nMul</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nMul</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>nMul</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Append the copy */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>JX9_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Out of memory, break immediately */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nMul</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string nl2br(string $string[, bool $is_xhtml = true ])
 *  Inserts HTML line breaks before all newlines in a string.
 * Parameters
 *  $string
 *   The input string.
 * $is_xhtml
 *   Whenever to use XHTML compatible line breaks or not.
 * Return
 *  The processed string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_nl2br</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>is_xhtml</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>is_xhtml</name> <operator>=</operator> <call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		<comment type="block">/* Delimit the string */</comment>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal><operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\r'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Output chunk verbatim */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Output the HTML line break */</comment>
		<if_stmt><if>if<condition>( <expr><name>is_xhtml</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&lt;br&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&lt;br&gt;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"&lt;br/&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"&lt;br/&gt;"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		<comment type="block">/* Append trailing line */</comment>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal>  <operator>||</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Output chunk verbatim */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Format a given string and invoke the given callback on each processed chunk.
 *  According to the JX9 reference manual.
 * The format string is composed of zero or more directives: ordinary characters
 * (excluding %) that are copied directly to the result, and conversion 
 * specifications, each of which results in fetching its own parameter.
 * This applies to both sprintf() and printf().
 * Each conversion specification consists of a percent sign (%), followed by one
 * or more of these elements, in order:
 *   An optional sign specifier that forces a sign (- or +) to be used on a number.
 *   By default, only the - sign is used on a number if it's negative. This specifier forces
 *   positive numbers to have the + sign attached as well.
 *   An optional padding specifier that says what character will be used for padding
 *   the results to the right string size. This may be a space character or a 0 (zero character).
 *   The default is to pad with spaces. An alternate padding character can be specified by prefixing
 *   it with a single quote ('). See the examples below.
 *   An optional alignment specifier that says if the result should be left-justified or right-justified.
 *   The default is right-justified; a - character here will make it left-justified.
 *   An optional number, a width specifier that says how many characters (minimum) this conversion
 *   should result in.
 *   An optional precision specifier in the form of a period (`.') followed by an optional decimal
 *   digit string that says how many decimal digits should be displayed for floating-point numbers.
 *   When using this specifier on a string, it acts as a cutoff point, setting a maximum character
 *   limit to the string.
 *  A type specifier that says what type the argument data should be treated as. Possible types:
 *       % - a literal percent character. No argument is required.
 *       b - the argument is treated as an integer, and presented as a binary number.
 *       c - the argument is treated as an integer, and presented as the character with that ASCII value.
 *       d - the argument is treated as an integer, and presented as a (signed) decimal number.
 *       e - the argument is treated as scientific notation (e.g. 1.2e+2). The precision specifier stands 
 * 	     for the number of digits after the decimal point.
 *       E - like %e but uses uppercase letter (e.g. 1.2E+2).
 *       u - the argument is treated as an integer, and presented as an unsigned decimal number.
 *       f - the argument is treated as a float, and presented as a floating-point number (locale aware).
 *       F - the argument is treated as a float, and presented as a floating-point number (non-locale aware).
 *       g - shorter of %e and %f.
 *       G - shorter of %E and %f.
 *       o - the argument is treated as an integer, and presented as an octal number.
 *       s - the argument is treated as and presented as a string.
 *       x - the argument is treated as an integer and presented as a hexadecimal number (with lowercase letters).
 *       X - the argument is treated as an integer and presented as a hexadecimal number (with uppercase letters).
 */</comment>
<comment type="block">/*
 * This implementation is based on the one found in the SQLite3 source tree.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_BUFSIZ</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define> <comment type="block">/* Conversion buffer size */</comment>
<comment type="block">/*
** Conversion types fall into various categories as defined by the
** following enumeration.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_RADIX</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define> <comment type="block">/* Integer types.%d, %x, %o, and so forth */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_FLOAT</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define> <comment type="block">/* Floating point.%f */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_EXP</name></cpp:macro>         <cpp:value>3</cpp:value></cpp:define> <comment type="block">/* Exponentional notation.%e and %E */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_GENERIC</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define> <comment type="block">/* Floating or exponential, depending on exponent.%g */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_SIZE</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define> <comment type="block">/* Total number of characters processed so far.%n */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_STRING</name></cpp:macro>      <cpp:value>6</cpp:value></cpp:define> <comment type="block">/* Strings.%s */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_PERCENT</name></cpp:macro>     <cpp:value>7</cpp:value></cpp:define> <comment type="block">/* Percent symbol.%% */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_CHARX</name></cpp:macro>       <cpp:value>8</cpp:value></cpp:define> <comment type="block">/* Characters.%c */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_ERROR</name></cpp:macro>       <cpp:value>9</cpp:value></cpp:define> <comment type="block">/* Used to indicate no such conversion type */</comment>
<comment type="block">/*
** Allowed values for jx9_fmt_info.flags
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_FLAG_SIGNED</name></cpp:macro>	  <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JX9_FMT_FLAG_UNSIGNED</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<comment type="block">/*
** Each builtin conversion character (ex: the 'd' in "%d") is described
** by an instance of the following structure
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>jx9_fmt_info</name></name></type> <name>jx9_fmt_info</name>;</typedef>
<struct>struct <name>jx9_fmt_info</name>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name>fmttype</name></decl>;</decl_stmt>  <comment type="block">/* The format field code letter [i.e: 'd', 's', 'x'] */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>base</name></decl>;</decl_stmt>     <comment type="block">/* The base for radix conversion */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>    <comment type="block">/* One or more of JX9_FMT_FLAG_ constants below */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>type</name></decl>;</decl_stmt>     <comment type="block">/* Conversion paradigm */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>charset</name></decl>;</decl_stmt> <comment type="block">/* The character set for conversion */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>  <comment type="block">/* Prefix on non-zero values in alt format */</comment>
}</block>;</struct>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/*
** "*val" is a double such that 0.1 &lt;= *val &lt; 10.0
** Return the ascii code for the leading digit of *val, then
** multiply "*val" by 10.0 to renormalize.
**
** Example:
**     input:     *val = 3.14159
**     output:    *val = 1.4159    function return = '3'
**
** The counter *cnt is incremented each time.  After counter exceeds
** 16 (the number of significant digits in a 64-bit float) '0' is
** always returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vxGetdigit</name><parameter_list>(<parameter><decl><type><name>sxlongreal</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sxlongreal</name></type> <name>d</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>digit</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>cnt</name><operator>)</operator><operator>++</operator> <operator>&gt;=</operator> <literal type="number">16</literal></expr> )</condition><block>{<block_content>
	  <return>return <expr><literal type="char">'0'</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>digit</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>val</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name> <operator>=</operator> <name>digit</name></expr>;</expr_stmt>
   <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>val</name> <operator>-</operator> <name>d</name><operator>)</operator><operator>*</operator><literal type="number">10.0</literal></expr>;</expr_stmt>
  <return>return <expr><name>digit</name> <operator>+</operator> <literal type="char">'0'</literal></expr> ;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_OMIT_FLOATING_POINT */</comment>
<comment type="block">/*
 * The following table is searched linearly, so it is good to put the most frequently
 * used conversion types first.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>jx9_fmt_info</name></type> <name><name>aFmt</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{  <expr><literal type="char">'d'</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>JX9_FMT_FLAG_SIGNED</name></expr>, <expr><name>JX9_FMT_RADIX</name></expr>, <expr><literal type="string">"0123456789"</literal></expr>, <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'s'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_STRING</name></expr>,     <expr><literal type="number">0</literal></expr>,                  <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'c'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_CHARX</name></expr>,      <expr><literal type="number">0</literal></expr>,                  <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'x'</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_RADIX</name></expr>,      <expr><literal type="string">"0123456789abcdef"</literal></expr>, <expr><literal type="string">"x0"</literal></expr> }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'X'</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_RADIX</name></expr>,      <expr><literal type="string">"0123456789ABCDEF"</literal></expr>, <expr><literal type="string">"X0"</literal></expr> }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'b'</literal></expr>,  <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_RADIX</name></expr>,      <expr><literal type="string">"01"</literal></expr>,                <expr><literal type="string">"b0"</literal></expr>}</block></expr>, 
  <expr><block>{  <expr><literal type="char">'o'</literal></expr>,  <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_RADIX</name></expr>,      <expr><literal type="string">"01234567"</literal></expr>,         <expr><literal type="string">"0"</literal></expr>  }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'u'</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_RADIX</name></expr>,      <expr><literal type="string">"0123456789"</literal></expr>,       <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'f'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_FLAG_SIGNED</name></expr>, <expr><name>JX9_FMT_FLOAT</name></expr>,        <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'F'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_FLAG_SIGNED</name></expr>, <expr><name>JX9_FMT_FLOAT</name></expr>,        <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'e'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_FLAG_SIGNED</name></expr>, <expr><name>JX9_FMT_EXP</name></expr>,        <expr><literal type="string">"e"</literal></expr>,    <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'E'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_FLAG_SIGNED</name></expr>, <expr><name>JX9_FMT_EXP</name></expr>,        <expr><literal type="string">"E"</literal></expr>,    <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'g'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_FLAG_SIGNED</name></expr>, <expr><name>JX9_FMT_GENERIC</name></expr>,    <expr><literal type="string">"e"</literal></expr>,    <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'G'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_FLAG_SIGNED</name></expr>, <expr><name>JX9_FMT_GENERIC</name></expr>,    <expr><literal type="string">"E"</literal></expr>,    <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'%'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>JX9_FMT_PERCENT</name></expr>,    <expr><literal type="number">0</literal></expr>,                  <expr><literal type="number">0</literal></expr>    }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Format a given string.
 * The root program.  All variations call this core.
 * INPUTS:
 *   xConsumer   This is a pointer to a function taking four arguments
 *            1. A pointer to the call context.
 *            2. A pointer to the list of characters to be output
 *               (Note, this list is NOT null terminated.)
 *            3. An integer number of characters to be output.
 *               (Note: This number might be zero.)
 *            4. Upper layer private data.
 *   zIn       This is the format string, as in the usual print.
 *   apArg     This is a pointer to a list of arguments.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9InputFormat</name><parameter_list>(
	<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xConsumer</name>)<parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Format consumer */</comment>
	<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,  <comment type="block">/* call context */</comment>
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>,    <comment type="block">/* Format string */</comment>
	<parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,          <comment type="block">/* Format string length */</comment>
	<parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,           <comment type="block">/* Total argument of the given arguments */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>,  <comment type="block">/* User arguments */</comment>
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>,    <comment type="block">/* Last argument to xConsumer() */</comment>
	<parameter><decl><type><name>int</name></type> <name>vf</name></decl></parameter>              <comment type="block">/* TRUE if called from vfprintf, vsprintf context */</comment> 
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>spaces</name><index>[]</index></name> <init>= <expr><literal type="string">"                                                  "</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etSPACESIZE</name></cpp:macro> <cpp:value>((int)sizeof(spaces)-1)</cpp:value></cpp:define>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>, <decl><type ref="prev"/><name><name>zWorker</name><index>[<expr><name>JX9_FMT_BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* Working buffer */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>jx9_fmt_info</name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>  <comment type="block">/* Pointer to the appropriate info structure */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>flag_alternateform</name></decl>;</decl_stmt> <comment type="block">/* True if "#" flag is present */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>flag_leftjustify</name></decl>;</decl_stmt>   <comment type="block">/* True if "-" flag is present */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>flag_blanksign</name></decl>;</decl_stmt>     <comment type="block">/* True if " " flag is present */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>flag_plussign</name></decl>;</decl_stmt>      <comment type="block">/* True if "+" flag is present */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>flag_zeropad</name></decl>;</decl_stmt>       <comment type="block">/* True if field width constant starts with zero */</comment>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArg</name></decl>;</decl_stmt>         <comment type="block">/* Current processed argument */</comment>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>iVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>precision</name></decl>;</decl_stmt>           <comment type="block">/* Precision of the current field */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExtra</name></decl>;</decl_stmt>  
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>              <comment type="block">/* Length of the field */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>prefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu8</name></type> <name>xtype</name></decl>;</decl_stmt>              <comment type="block">/* Conversion paradigm */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>               <comment type="block">/* Width of the current field */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>vf</name> <operator>==</operator> <name>TRUE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_ARG</name></cpp:macro>	<cpp:value>( n &lt; nArg ? apArg[n++] : 0 )</cpp:value></cpp:define>
	<comment type="block">/* Start the format process */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Consume chunk verbatim */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Callback request an operation abort */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process, break immediately */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Find out what flags are present */</comment>
		<expr_stmt><expr><name>flag_leftjustify</name> <operator>=</operator> <name>flag_plussign</name> <operator>=</operator> <name>flag_blanksign</name> <operator>=</operator> 
			<name>flag_alternateform</name> <operator>=</operator> <name>flag_zeropad</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the precent sign */</comment>
		<do>do<block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<switch>switch<condition>( <expr><name>c</name></expr> )</condition><block>{<block_content>
			<case>case <expr><literal type="char">'-'</literal></expr>:</case>   <expr_stmt><expr><name>flag_leftjustify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>     <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <break>break;</break>
			<case>case <expr><literal type="char">'+'</literal></expr>:</case>   <expr_stmt><expr><name>flag_plussign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <break>break;</break>
			<case>case <expr><literal type="char">' '</literal></expr>:</case>   <expr_stmt><expr><name>flag_blanksign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>       <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <break>break;</break>
			<case>case <expr><literal type="char">'#'</literal></expr>:</case>   <expr_stmt><expr><name>flag_alternateform</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <break>break;</break>
			<case>case <expr><literal type="char">'0'</literal></expr>:</case>   <expr_stmt><expr><name>flag_zeropad</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>         <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <break>break;</break>
			<case>case <expr><literal type="char">'\''</literal></expr>:</case>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* An alternate padding character can be specified by prefixing it with a single quote (') */</comment>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
					<for>for<control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>etSPACESIZE</name></expr> ;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr> )</control><block>{<block_content>
						<expr_stmt><expr><name><name>spaces</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>                                       <break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>while<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>zIn</name><operator>++</operator> <operator>&lt;</operator> <name>zEnd</name><operator>)</operator></expr> )</condition>;</do>
		<comment type="block">/* Get the field width */</comment>
		<expr_stmt><expr><name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>width</name> <operator>=</operator> <name>width</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Position specifer */</comment>
			<if_stmt><if>if<condition>( <expr><name>width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>n</name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>vf</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> 
					<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>flag_zeropad</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>width</name> <operator>=</operator> <name>width</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>width</name> <operator>&gt;</operator> <name>JX9_FMT_BUFSIZ</name><operator>-</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>width</name> <operator>=</operator> <name>JX9_FMT_BUFSIZ</name><operator>-</operator><literal type="number">10</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Get the precision */</comment>
		<expr_stmt><expr><name>precision</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>precision</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Fetch the info entry for the field */</comment>
		<expr_stmt><expr><name>pInfo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>JX9_FMT_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the format specifer */</comment>
		<for>for<control>(<init><expr><name>idx</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name><operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>aFmt</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name><name>aFmt</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>fmttype</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>pInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>aFmt</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>xtype</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>zBuf</name> <operator>=</operator> <name>zWorker</name></expr>;</expr_stmt> <comment type="block">/* Point to the working buffer */</comment>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>zExtra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		 <comment type="block">/*
		  ** At this point, variables are initialized as follows:
		  **
		  **   flag_alternateform          TRUE if a '#' is present.
		  **   flag_plussign               TRUE if a '+' is present.
		  **   flag_leftjustify            TRUE if a '-' is present or if the
		  **                               field width was negative.
		  **   flag_zeropad                TRUE if the width began with 0.
		  **                               the conversion character.
		  **   flag_blanksign              TRUE if a ' ' is present.
		  **   width                       The specified field width.  This is
		  **                               always non-negative.  Zero is the default.
		  **   precision                   The specified precision.  The default
		  **                               is -1.
		  */</comment>
		<switch>switch<condition>(<expr><name>xtype</name></expr>)</condition><block>{<block_content>
		<case>case <expr><name>JX9_FMT_PERCENT</name></expr>:</case>
			<comment type="block">/* A literal percent character */</comment>
			<expr_stmt><expr><name><name>zWorker</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'%'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JX9_FMT_CHARX</name></expr>:</case>
			<comment type="block">/* The argument is treated as an integer, and presented as the character
			 * with that ASCII value
			 */</comment>
			<expr_stmt><expr><name>pArg</name> <operator>=</operator> <name>NEXT_ARG</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pArg</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* NUL byte is an acceptable value */</comment>
			<expr_stmt><expr><name><name>zWorker</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JX9_FMT_STRING</name></expr>:</case>
			<comment type="block">/* the argument is treated as and presented as a string */</comment>
			<expr_stmt><expr><name>pArg</name> <operator>=</operator> <name>NEXT_ARG</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pArg</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>zBuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>length</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>zBuf</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>precision</name><operator>&lt;</operator><name>length</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>length</name> <operator>=</operator> <name>precision</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>flag_zeropad</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* zero-padding works on strings too */</comment>
				<for>for<control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>etSPACESIZE</name></expr> ;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr> )</control><block>{<block_content>
					<expr_stmt><expr><name><name>spaces</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JX9_FMT_RADIX</name></expr>:</case>
			<expr_stmt><expr><name>pArg</name> <operator>=</operator> <name>NEXT_ARG</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pArg</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>iVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* Limit the precision to prevent overflowing buf[] during conversion */</comment>
			<if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;</operator><name>JX9_FMT_BUFSIZ</name><operator>-</operator><literal type="number">40</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>JX9_FMT_BUFSIZ</name><operator>-</operator><literal type="number">40</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
        <comment type="block">/* For the format %#x, the value zero is printed "0" not "0x0".
        ** I think this is stupid.*/</comment>
        <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flag_alternateform</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* More sensible: turn off the prefix for octal (to prevent "00"), 
        ** but leave the prefix for hex.*/</comment>
        <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>base</name></name><operator>==</operator><literal type="number">8</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flag_alternateform</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JX9_FMT_FLAG_SIGNED</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> 
            <expr_stmt><expr><name>iVal</name> <operator>=</operator> <operator>-</operator><name>iVal</name></expr>;</expr_stmt>
			<comment type="block">/* Ticket 1433-003 */</comment>
			<if_stmt><if>if<condition>( <expr><name>iVal</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Overflow */</comment>
				<expr_stmt><expr><name>iVal</name><operator>=</operator> <literal type="number">0x7FFFFFFFFFFFFFFF</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flag_plussign</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></if>
          <if type="elseif">else if<condition>( <expr><name>flag_blanksign</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>                       <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>iVal</name> <operator>=</operator> <operator>-</operator><name>iVal</name></expr>;</expr_stmt>
				<comment type="block">/* Ticket 1433-003 */</comment>
				<if_stmt><if>if<condition>( <expr><name>iVal</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<comment type="block">/* Overflow */</comment>
					<expr_stmt><expr><name>iVal</name><operator>=</operator> <literal type="number">0x7FFFFFFFFFFFFFFF</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>flag_zeropad</name> <operator>&amp;&amp;</operator> <name>precision</name><operator>&lt;</operator><name>width</name><operator>-</operator><operator>(</operator><name>prefix</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>width</name><operator>-</operator><operator>(</operator><name>prefix</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <operator>&amp;</operator><name><name>zWorker</name><index>[<expr><name>JX9_FMT_BUFSIZ</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <block>{<block_content>
          <decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type><name>cset</name></decl>;</decl_stmt>      <comment type="block">/* Use registers for speed */</comment>
          <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>base</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>cset</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>charset</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
          <do>do<block>{<block_content>                                           <comment type="block">/* Convert to ascii */</comment>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>zBuf</name><operator>)</operator> <operator>=</operator> <name><name>cset</name><index>[<expr><name>iVal</name><operator>%</operator><name>base</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>iVal</name> <operator>=</operator> <name>iVal</name><operator>/</operator><name>base</name></expr>;</expr_stmt>
          </block_content>}</block>while<condition>( <expr><name>iVal</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>
        </block_content>}</block>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>&amp;</operator><name><name>zWorker</name><index>[<expr><name>JX9_FMT_BUFSIZ</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-</operator><name>zBuf</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>idx</name><operator>=</operator><name>precision</name><operator>-</operator><name>length</name></expr>;</init> <condition><expr><name>idx</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>idx</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>zBuf</name><operator>)</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>                             <comment type="block">/* Zero pad */</comment>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>prefix</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>zBuf</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>prefix</name></expr>;</expr_stmt></block_content></block></if></if_stmt>               <comment type="block">/* Add sign */</comment>
        <if_stmt><if>if<condition>( <expr><name>flag_alternateform</name> <operator>&amp;&amp;</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>prefix</name></name></expr> )</condition><block>{<block_content>      <comment type="block">/* Add "0" or "0x" */</comment>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pre</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>pre</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>prefix</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zBuf</name><operator>!=</operator><name><name>pre</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
            <for>for<control>(<init><expr><name>pre</name><operator>=</operator><name><name>pInfo</name><operator>-&gt;</operator><name>prefix</name></name></expr>;</init> <condition><expr><operator>(</operator><name>x</name><operator>=</operator><operator>(</operator><operator>*</operator><name>pre</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>pre</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>zBuf</name><operator>)</operator> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></for>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>&amp;</operator><name><name>zWorker</name><index>[<expr><name>JX9_FMT_BUFSIZ</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-</operator><name>zBuf</name></expr>;</expr_stmt>
		<break>break;</break>
		<case>case <expr><name>JX9_FMT_FLOAT</name></expr>:</case>
		<case>case <expr><name>JX9_FMT_EXP</name></expr>:</case>
		<case>case <expr><name>JX9_FMT_GENERIC</name></expr>:</case><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_OMIT_FLOATING_POINT</name></cpp:ifndef>
		<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>realvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>  <name>exp</name></decl>;</decl_stmt>                <comment type="block">/* exponent of real numbers */</comment>
		<decl_stmt><decl><type><name>double</name></type> <name>rounder</name></decl>;</decl_stmt>          <comment type="block">/* Used for rounding floating point values */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>flag_dp</name></decl>;</decl_stmt>            <comment type="block">/* True if decimal point should be shown */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>flag_rtz</name></decl>;</decl_stmt>           <comment type="block">/* True if trailing zeros should be removed */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>flag_exp</name></decl>;</decl_stmt>           <comment type="block">/* True to force display of the exponent */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>nsd</name></decl>;</decl_stmt>                 <comment type="block">/* Number of significant digits returned */</comment>
		<expr_stmt><expr><name>pArg</name> <operator>=</operator> <name>NEXT_ARG</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pArg</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>realvalue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name>realvalue</name> <operator>=</operator> <call><name>jx9_value_to_double</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>         <comment type="block">/* Set default precision */</comment>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;</operator><name>JX9_FMT_BUFSIZ</name><operator>-</operator><literal type="number">40</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>JX9_FMT_BUFSIZ</name><operator>-</operator><literal type="number">40</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>realvalue</name><operator>&lt;</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>realvalue</name> <operator>=</operator> <operator>-</operator><name>realvalue</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>flag_plussign</name></expr> )</condition><block type="pseudo"><block_content>          <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></if>
          <if type="elseif">else if<condition>( <expr><name>flag_blanksign</name></expr> )</condition><block type="pseudo"><block_content>    <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>                         <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>JX9_FMT_GENERIC</name> <operator>&amp;&amp;</operator> <name>precision</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rounder</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        <comment type="block">/* Rounding works like BSD when the constant 0.4999 is used.Wierd! */</comment>
        for(idx=precision, rounder=0.4999; idx&gt;0; idx--, rounder*=0.1);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* It makes more sense to use 0.5 */</comment>
        <for>for<control>(<init><expr><name>idx</name><operator>=</operator><name>precision</name></expr><operator>,</operator> <expr><name>rounder</name><operator>=</operator><literal type="number">0.5</literal></expr>;</init> <condition><expr><name>idx</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>idx</name><operator>--</operator></expr><operator>,</operator> <expr><name>rounder</name><operator>*=</operator><literal type="number">0.1</literal></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>JX9_FMT_FLOAT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>realvalue</name> <operator>+=</operator> <name>rounder</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Normalize realvalue to within 10.0 &gt; realvalue &gt;= 1.0 */</comment>
        <expr_stmt><expr><name>exp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>realvalue</name><operator>&gt;</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
          <while>while<condition>( <expr><name>realvalue</name><operator>&gt;=</operator><literal type="number">1e8</literal> <operator>&amp;&amp;</operator> <name>exp</name><operator>&lt;=</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">1e-8</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>+=</operator><literal type="number">8</literal></expr>;</expr_stmt> </block_content>}</block></while>
          <while>while<condition>( <expr><name>realvalue</name><operator>&gt;=</operator><literal type="number">10.0</literal> <operator>&amp;&amp;</operator> <name>exp</name><operator>&lt;=</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">0.1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
          <while>while<condition>( <expr><name>realvalue</name><operator>&lt;</operator><literal type="number">1e-8</literal> <operator>&amp;&amp;</operator> <name>exp</name><operator>&gt;=</operator><operator>-</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">1e8</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>-=</operator><literal type="number">8</literal></expr>;</expr_stmt> </block_content>}</block></while>
          <while>while<condition>( <expr><name>realvalue</name><operator>&lt;</operator><literal type="number">1.0</literal> <operator>&amp;&amp;</operator> <name>exp</name><operator>&gt;=</operator><operator>-</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
          <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&gt;</operator><literal type="number">350</literal> <operator>||</operator> <name>exp</name><operator>&lt;</operator><operator>-</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <literal type="string">"NaN"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <name>zWorker</name></expr>;</expr_stmt>
        <comment type="block">/*
        ** If the field type is etGENERIC, then convert to either etEXP
        ** or etFLOAT, as appropriate.
        */</comment>
        <expr_stmt><expr><name>flag_exp</name> <operator>=</operator> <name>xtype</name><operator>==</operator><name>JX9_FMT_EXP</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>!=</operator><name>JX9_FMT_FLOAT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>realvalue</name> <operator>+=</operator> <name>rounder</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>realvalue</name><operator>&gt;=</operator><literal type="number">10.0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">0.1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>==</operator><name>JX9_FMT_GENERIC</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>flag_rtz</name> <operator>=</operator> <operator>!</operator><name>flag_alternateform</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>exp</name><argument_list type="generic">&lt;<argument><expr><operator>-</operator><literal type="number">4</literal> <operator>||</operator> <name>exp</name></expr></argument>&gt;</argument_list></name><name>precision</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>JX9_FMT_EXP</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>precision</name> <operator>-</operator> <name>exp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>JX9_FMT_FLOAT</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>flag_rtz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/*
        ** The "exp+precision" test causes output to be of type etEXP if
        ** the precision is too large to fit in buf[].
        */</comment>
        <expr_stmt><expr><name>nsd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>==</operator><name>JX9_FMT_FLOAT</name> <operator>&amp;&amp;</operator> <name>exp</name><operator>+</operator><name>precision</name><operator>&lt;</operator><name>JX9_FMT_BUFSIZ</name><operator>-</operator><literal type="number">30</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>flag_dp</name> <operator>=</operator> <operator>(</operator><name>precision</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>flag_alternateform</name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>prefix</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>prefix</name></expr>;</expr_stmt></block_content></block></if></if_stmt>         <comment type="block">/* Sign */</comment>
          <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>            <comment type="block">/* Digits before "." */</comment>
          <else>else<block type="pseudo"><block_content> <for>for<control>(<init>;</init> <condition><expr><name>exp</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>exp</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>vxGetdigit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>flag_dp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>           <comment type="block">/* The decimal point */</comment>
          <for>for<control>(<init><expr><name>exp</name><operator>++</operator></expr>;</init> <condition><expr><name><name>exp</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>precision</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr>;</condition> <incr><expr><name>precision</name><operator>--</operator></expr><operator>,</operator> <expr><name>exp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
          </block_content>}</block></for>
          <while>while<condition>( <expr><operator>(</operator><name>precision</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>vxGetdigit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>--</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                           <comment type="block">/* Null terminate */</comment>
          <if_stmt><if>if<condition>( <expr><name>flag_rtz</name> <operator>&amp;&amp;</operator> <name>flag_dp</name></expr> )</condition><block>{<block_content>     <comment type="block">/* Remove trailing zeros and "." */</comment>
            <while>while<condition>( <expr><name>zBuf</name><operator>&gt;=</operator><name>zWorker</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>zBuf</name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>--</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
            <if_stmt><if>if<condition>( <expr><name>zBuf</name><operator>&gt;=</operator><name>zWorker</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>zBuf</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>--</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>zBuf</name><operator>++</operator></expr>;</expr_stmt>                            <comment type="block">/* point to next free slot */</comment>
        </block_content>}</block></if><else>else<block>{<block_content>    <comment type="block">/* etEXP or etGENERIC */</comment>
          <expr_stmt><expr><name>flag_dp</name> <operator>=</operator> <operator>(</operator><name>precision</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>flag_alternateform</name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>prefix</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>prefix</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* Sign */</comment>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>vxGetdigit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* First digit */</comment>
          <if_stmt><if>if<condition>( <expr><name>flag_dp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>     <comment type="block">/* Decimal point */</comment>
          <while>while<condition>( <expr><operator>(</operator><name>precision</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>vxGetdigit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><name>zBuf</name><operator>--</operator></expr>;</expr_stmt>                            <comment type="block">/* point to last digit */</comment>
          <if_stmt><if>if<condition>( <expr><name>flag_rtz</name> <operator>&amp;&amp;</operator> <name>flag_dp</name></expr> )</condition><block>{<block_content>          <comment type="block">/* Remove tail zeros */</comment>
            <while>while<condition>( <expr><name>zBuf</name><operator>&gt;=</operator><name>zWorker</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>zBuf</name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>--</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
            <if_stmt><if>if<condition>( <expr><name>zBuf</name><operator>&gt;=</operator><name>zWorker</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>zBuf</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>--</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>zBuf</name><operator>++</operator></expr>;</expr_stmt>                            <comment type="block">/* point to next free slot */</comment>
          <if_stmt><if>if<condition>( <expr><name>exp</name> <operator>||</operator> <name>flag_exp</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>charset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name> <operator>=</operator> <operator>-</operator><name>exp</name></expr>;</expr_stmt> </block_content>}</block></if> <comment type="block">/* sign of exp */</comment>
            <else>else       <block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&gt;=</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>exp</name><operator>/</operator><literal type="number">100</literal><operator>)</operator><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>                <comment type="block">/* 100's digit */</comment>
              <expr_stmt><expr><name>exp</name> <operator>%=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>exp</name><operator>/</operator><literal type="number">10</literal><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>                     <comment type="block">/* 10's digit */</comment>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>exp</name><operator>%</operator><literal type="number">10</literal><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>                     <comment type="block">/* 1's digit */</comment>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* The converted number is in buf[] and zero terminated.Output it.
        ** Note that the number is in the usual order, not reversed as with
        ** integer conversions.*/</comment>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zBuf</name><operator>-</operator><name>zWorker</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <name>zWorker</name></expr>;</expr_stmt>
        <comment type="block">/* Special case:  Add leading zeros if the flag_zeropad flag is
        ** set and we are not left justified */</comment>
        <if_stmt><if>if<condition>( <expr><name>flag_zeropad</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>flag_leftjustify</name> <operator>&amp;&amp;</operator> <name>length</name> <operator>&lt;</operator> <name>width</name></expr>)</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nPad</name> <init>= <expr><name>width</name> <operator>-</operator> <name>length</name></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>width</name></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><name>nPad</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zBuf</name><index>[<expr><name>i</name><operator>-</operator><name>nPad</name></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><name>i</name> <operator>=</operator> <name>prefix</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
          <while>while<condition>( <expr><name>nPad</name><operator>--</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><name>length</name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
         <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
		 <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_OMIT_FLOATING_POINT */</comment>
		 <break>break;</break>
							 </block_content>}</block>
		<default>default:</default>
			<comment type="block">/* Invalid format specifer */</comment>
			<expr_stmt><expr><name><name>zWorker</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>
		 <comment type="block">/*
		 ** The text of the conversion is pointed to by "zBuf" and is
		 ** "length" characters long.The field width is "width".Do
		 ** the output.
		 */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>flag_leftjustify</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>nspace</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>nspace</name> <operator>=</operator> <name>width</name><operator>-</operator><name>length</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nspace</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name>nspace</name><operator>&gt;=</operator><name>etSPACESIZE</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>spaces</name></expr></argument>, <argument><expr><name>etSPACESIZE</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>nspace</name> <operator>-=</operator> <name>etSPACESIZE</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>nspace</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>spaces</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>nspace</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>length</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>length</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		  <return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
		</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>flag_leftjustify</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>nspace</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>nspace</name> <operator>=</operator> <name>width</name><operator>-</operator><name>length</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nspace</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name>nspace</name><operator>&gt;=</operator><name>etSPACESIZE</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>spaces</name></expr></argument>, <argument><expr><name>etSPACESIZE</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>nspace</name> <operator>-=</operator> <name>etSPACESIZE</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>nspace</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>spaces</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>nspace</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
 </block_content>}</block></for><comment type="block">/* for(;;) */</comment>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Callback [i.e: Formatted input consumer] of the sprintf function.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sprintfConsumer</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Consume directly */</comment>
	<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string sprintf(string $format[, mixed $args [, mixed $... ]])
 *  Return a formatted string.
 * Parameters
 *  $format 
 *    The format string (see block comment above)
 * Return
 *  A string produced according to the formatting string format. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_sprintf</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the string format */</comment>
	<expr_stmt><expr><name>zFormat</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Format the string */</comment>
	<expr_stmt><expr><call><name>jx9InputFormat</name><argument_list>(<argument><expr><name>sprintfConsumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apArg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Callback [i.e: Formatted input consumer] of the printf function.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>printfConsumer</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_int64</name> <modifier>*</modifier></type><name>pCounter</name> <init>= <expr><operator>(</operator><name>jx9_int64</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Call the VM output consumer directly */</comment>
	<expr_stmt><expr><call><name>jx9_context_output</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Increment counter */</comment>
	<expr_stmt><expr><operator>*</operator><name>pCounter</name> <operator>+=</operator> <name>nLen</name></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int64 printf(string $format[, mixed $args[, mixed $... ]])
 *  Output a formatted string.
 * Parameters
 *  $format
 *   See sprintf() for a description of format.
 * Return
 *  The length of the outputted string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_printf</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>nCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the string format */</comment>
	<expr_stmt><expr><name>zFormat</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Format the string */</comment>
	<expr_stmt><expr><call><name>jx9InputFormat</name><argument_list>(<argument><expr><name>printfConsumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apArg</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nCounter</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Return the length of the outputted string */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nCounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int vprintf(string $format, array $args)
 *  Output a formatted string.
 * Parameters
 *  $format
 *   See sprintf() for a description of format.
 * Return
 *  The length of the outputted string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_vprintf</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>nCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SySet</name></type> <name>sArg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the string format */</comment>
	<expr_stmt><expr><name>zFormat</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<comment type="block">/* Extract arguments from the hashmap */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>jx9HashmapValuesToSet</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Format the string */</comment>
	<expr_stmt><expr><call><name>jx9InputFormat</name><argument_list>(<argument><expr><name>printfConsumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>jx9_value</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SySetBasePtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sArg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nCounter</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Return the length of the outputted string */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nCounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Release the container */</comment>
	<expr_stmt><expr><call><name>SySetRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int vsprintf(string $format, array $args)
 *  Output a formatted string.
 * Parameters
 *  $format
 *   See sprintf() for a description of format.
 * Return
 *  A string produced according to the formatting string format.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_vsprintf</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SySet</name></type> <name>sArg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the string format */</comment>
	<expr_stmt><expr><name>zFormat</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<comment type="block">/* Extract arguments from the hashmap */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>jx9HashmapValuesToSet</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Format the string */</comment>
	<expr_stmt><expr><call><name>jx9InputFormat</name><argument_list>(<argument><expr><name>sprintfConsumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>jx9_value</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SySetBasePtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sArg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Release the container */</comment>
	<expr_stmt><expr><call><name>SySetRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string size_format(int64 $size)
 *  Return a smart string represenation of the given size [i.e: 64-bit integer]
 *  Example:
 *    print size_format(1*1024*1024*1024);// 1GB
 *    print size_format(512*1024*1024); // 512 MB
 *    print size_format(file_size(/path/to/my/file_8192)); //8KB
 * Parameter
 *  $size
 *    Entity size in bytes.
 * Return
 *   Formatted string representation of the given size.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_size_format</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*Kilo*/</comment> <comment type="block">/*Mega*/</comment> <comment type="block">/*Giga*/</comment> <comment type="block">/*Tera*/</comment> <comment type="block">/*Peta*/</comment> <comment type="block">/*Exa*/</comment> <comment type="block">/*Zeta*/</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zUnit</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"KMGTPEZ"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>nRest</name></decl>, <decl><type ref="prev"/><name>i_32</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>iSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* index in zUnit[] */</comment>

	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the given size */</comment>
	<expr_stmt><expr><name>iSize</name> <operator>=</operator> <call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iSize</name> <operator>&lt;</operator> <literal type="number">100</literal></expr> <comment type="block">/* Bytes */</comment> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother formatting, return immediately */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"0.1 KB"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"0.1 KB"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<expr_stmt><expr><name>nRest</name> <operator>=</operator> <operator>(</operator><name>sxi32</name><operator>)</operator><operator>(</operator><name>iSize</name> <operator>&amp;</operator> <literal type="number">0x3FF</literal><operator>)</operator></expr>;</expr_stmt> 
		<expr_stmt><expr><name>iSize</name> <operator>&gt;&gt;=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name>iSize</name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><literal type="number">0</literal> <operator>^</operator> <literal type="number">1023</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>nRest</name> <operator>/=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nRest</name> <operator>&gt;</operator> <literal type="number">9</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nRest</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>iSize</name> <operator>&gt;</operator> <literal type="number">999</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nRest</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>iSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>i_32</name> <operator>=</operator> <operator>(</operator><name>sxi32</name><operator>)</operator><name>iSize</name></expr>;</expr_stmt>
	<comment type="block">/* Format */</comment>
	<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d.%d %cB"</literal></expr></argument>, <argument><expr><name>i_32</name></expr></argument>, <argument><expr><name>nRest</name></expr></argument>, <argument><expr><name><name>zUnit</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JX9_DISABLE_HASH_FUNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * string md5(string $str[, bool $raw_output = false])
 *   Calculate the md5 hash of a string.
 * Parameter
 *  $str
 *   Input string
 * $raw_output
 *   If the optional raw_output is set to TRUE, then the md5 digest
 *   is instead returned in raw binary format with a length of 16.
 * Return
 *  MD5 Hash as a 32-character hexadecimal string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_md5</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zDigest</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>raw_output</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the input string */</comment>
	<expr_stmt><expr><name>pIn</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>jx9_value_is_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name>raw_output</name> <operator>=</operator> <call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Compute the MD5 digest */</comment>
	<expr_stmt><expr><call><name>SyMD5Compute</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>zDigest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>raw_output</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Output raw digest */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>zDigest</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zDigest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Perform a binary to hex conversion */</comment>
		<expr_stmt><expr><call><name>SyBinToHexConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zDigest</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zDigest</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>HashConsumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string sha1(string $str[, bool $raw_output = false])
 *   Calculate the sha1 hash of a string.
 * Parameter
 *  $str
 *   Input string
 * $raw_output
 *   If the optional raw_output is set to TRUE, then the md5 digest
 *   is instead returned in raw binary format with a length of 16.
 * Return
 *  SHA1 Hash as a 40-character hexadecimal string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_sha1</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zDigest</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>raw_output</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the input string */</comment>
	<expr_stmt><expr><name>pIn</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>jx9_value_is_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name>raw_output</name> <operator>=</operator> <call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Compute the SHA1 digest */</comment>
	<expr_stmt><expr><call><name>SySha1Compute</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>zDigest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>raw_output</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Output raw digest */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>zDigest</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zDigest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Perform a binary to hex conversion */</comment>
		<expr_stmt><expr><call><name>SyBinToHexConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zDigest</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zDigest</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>HashConsumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int64 crc32(string $str)
 *   Calculates the crc32 polynomial of a strin.
 * Parameter
 *  $str
 *   Input string
 * Return
 *  CRC32 checksum of the given input (64-bit integer).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_crc32</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nCRC</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the input string */</comment>
	<expr_stmt><expr><name>pIn</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Calculate the sum */</comment>
	<expr_stmt><expr><name>nCRC</name> <operator>=</operator> <call><name>SyCrc32</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Return the CRC32 as 64-bit integer */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>jx9_int64</name><operator>)</operator><name>nCRC</name><operator>^</operator> <literal type="number">0xFFFFFFFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_HASH_FUNC */</comment>
<comment type="block">/*
 * Parse a CSV string and invoke the supplied callback for each processed xhunk.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9ProcessCsv</name><parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>, <comment type="block">/* Raw input */</comment>
	<parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,  <comment type="block">/* Input length */</comment>
	<parameter><decl><type><name>int</name></type> <name>delim</name></decl></parameter>,  <comment type="block">/* Delimiter */</comment>
	<parameter><decl><type><name>int</name></type> <name>encl</name></decl></parameter>,   <comment type="block">/* Enclosure */</comment>
	<parameter><decl><type><name>int</name></type> <name>escape</name></decl></parameter>,  <comment type="block">/* Escape character */</comment>
	<parameter><function_decl><type><name>sxi32</name></type> (<modifier>*</modifier><name>xConsumer</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* User callback */</comment>
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter> <comment type="block">/* Last argument to xConsumer() */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zInput</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>zInput</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>isEnc</name></decl>;</decl_stmt>
	<comment type="block">/* Start processing */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>isEnc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		<comment type="block">/* Find the first delimiter */</comment>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>delim</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isEnc</name></expr>)</condition><block>{<block_content>
				<comment type="block">/* Delimiter found, break imediately */</comment>
				<break>break;</break>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>encl</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Inside enclosure? */</comment>
				<expr_stmt><expr><name>isEnc</name> <operator>=</operator> <operator>!</operator><name>isEnc</name></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>escape</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Escape sequence */</comment>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Advance the cursor */</comment>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;</operator> <name>zPtr</name></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zPtr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
			<comment type="block">/* Invoke the supllied callback */</comment>
			<if_stmt><if>if<condition>( <expr><name><name>zPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>encl</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>zPtr</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>nByte</name><operator>-=</operator><literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* User callback request an operation abort */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Ignore trailing delimiter */</comment>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>delim</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Default consumer callback for the CSV parsing routine defined above.
 * All the processed input is insereted into an array passed as the last
 * argument to this callback.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9CsvConsumer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zToken</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTokenLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name> <init>= <expr><operator>(</operator><name>jx9_value</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyString</name></type> <name>sToken</name></decl>;</decl_stmt>
	<comment type="block">/* Insert the token in the given array */</comment>
	<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nTokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Remove trailing and leading white spcaces and null bytes */</comment>
	<expr_stmt><expr><call><name>SyStringFullTrimSafe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>sToken</name><operator>.</operator><name>nByte</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInitFromString</name><argument_list>(<argument><expr><name><name>pArray</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array str_getcsv(string $input[, string $delimiter = ', '[, string $enclosure = '"' [, string $escape='\\']]])
 *  Parse a CSV string into an array.
 * Parameters
 *  $input
 *   The string to parse.
 *  $delimiter
 *   Set the field delimiter (one character only).
 *  $enclosure
 *   Set the field enclosure character (one character only).
 *  $escape
 *   Set the escape character (one character only). Defaults as a backslash (\)
 * Return
 *  An indexed array containing the CSV fields or NULL on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_str_getcsv</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>delim</name>  <init>= <expr><literal type="char">','</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Delimiter */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>encl</name>   <init>= <expr><literal type="char">'"'</literal></expr></init></decl> ;</decl_stmt>  <comment type="block">/* Enclosure */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>escape</name> <init>= <expr><literal type="char">'\\'</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Escape character */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the raw input */</comment>
	<expr_stmt><expr><name>zInput</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Extract the delimiter */</comment>
			<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>delim</name> <operator>=</operator> <name><name>zPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<comment type="block">/* Extract the enclosure */</comment>
				<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>encl</name> <operator>=</operator> <name><name>zPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
					<comment type="block">/* Extract the escape character */</comment>
					<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>escape</name> <operator>=</operator> <name><name>zPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create our array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_context_throw_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>JX9_CTX_ERR</name></expr></argument>, <argument><expr><literal type="string">"JX9 is running out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Parse the raw input */</comment>
	<expr_stmt><expr><call><name>jx9ProcessCsv</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>, <argument><expr><name>encl</name></expr></argument>, <argument><expr><name>escape</name></expr></argument>, <argument><expr><name>jx9CsvConsumer</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Return the freshly created array */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Extract a tag name from a raw HTML input and insert it in the given
 * container.
 * Refer to [strip_tags()].
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>AddTag</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zTag</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyString</name></type> <name>sEntry</name></decl>;</decl_stmt>
	<comment type="block">/* Strip tags */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<while>while<condition>( <expr><name>zTag</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>||</operator> <name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal>
			<operator>||</operator> <name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>zTag</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zTag</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <name>zTag</name></expr>;</expr_stmt>
		<comment type="block">/* Delimit the tag */</comment>
		<while>while<condition>(<expr><name>zTag</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* UTF-8 stream */</comment>
				<expr_stmt><expr><name>zTag</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SX_JMP_UTF8</name><argument_list>(<argument><expr><name>zTag</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>SyisAlphaNum</name><argument_list>(<argument><expr><name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>zTag</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zTag</name> <operator>&gt;</operator> <name>zPtr</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Perform the insertion */</comment>
			<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>, <argument><expr><name>zPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zTag</name><operator>-</operator><name>zPtr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyStringFullTrim</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SySetPut</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Jump the trailing '&gt;' */</comment>
		<expr_stmt><expr><name>zTag</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Check if the given HTML tag name is present in the given container.
 * Return SXRET_OK if present.SXERR_NOTFOUND otherwise.
 * Refer to [strip_tags()].
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>FindTag</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><call><name>SySetUsed</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zTag</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SyString</name></type> <name>sTag</name></decl>;</decl_stmt>
		<while>while<condition>( <expr><name>zTag</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator>  <operator>(</operator><name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>||</operator> <name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator>
			<operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zTag</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<comment type="block">/* Delimit the tag */</comment>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zTag</name></expr>;</expr_stmt>
		<while>while<condition>(<expr><name>zTag</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* UTF-8 stream */</comment>
				<expr_stmt><expr><name>zTag</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SX_JMP_UTF8</name><argument_list>(<argument><expr><name>zTag</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>SyisAlphaNum</name><argument_list>(<argument><expr><name><name>zTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>zTag</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTag</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><name>zTag</name><operator>-</operator><name>zCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Trim leading white spaces and null bytes */</comment>
		<expr_stmt><expr><call><name>SyStringLeftTrimSafe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>sTag</name><operator>.</operator><name>nByte</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>aEntry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
			<comment type="block">/* Perform the lookup */</comment>
			<expr_stmt><expr><name>aEntry</name> <operator>=</operator> <operator>(</operator><name>SyString</name> <operator>*</operator><operator>)</operator><call><name>SySetBasePtr</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>SySetUsed</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
				<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>aEntry</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
				<comment type="block">/* Do the comparison */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyStringCmp</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTag</name></expr></argument>, <argument><expr><name>SyStrnicmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><operator>!</operator><name>rc</name></expr> )</condition><block>{<block_content>
					<return>return <expr><name>SXRET_OK</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* No such tag */</comment>
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * This function tries to return a string [i.e: in the call context result buffer]
 * with all NUL bytes, HTML and JX9 tags stripped from a given string.
 * Refer to [strip_tags()].
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9StripTagsFromString</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTaglist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTaglen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zTag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SySet</name></type> <name>sSet</name></decl>;</decl_stmt>
	<comment type="block">/* initialize the set of allowed tags */</comment>
	<expr_stmt><expr><call><name>SySetInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSet</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyString</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nTaglen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Set of allowed tags */</comment>
		<expr_stmt><expr><call><name>AddTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSet</name></expr></argument>, <argument><expr><name>zTaglist</name></expr></argument>, <argument><expr><name>nTaglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Set the empty string */</comment>
	<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Start processing */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr>)</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		<comment type="block">/* Find a tag */</comment>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr> <comment type="block">/* NUL byte */</comment> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;</operator> <name>zPtr</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Consume raw input */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zPtr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Ignore trailing null bytes */</comment>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>(<expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr>)</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>zTag</name> <operator>=</operator> <name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* Delimit the tag */</comment>
			<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Ignore the trailing closing tag */</comment>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Query the set */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>FindTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSet</name></expr></argument>, <argument><expr><name>zTag</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zTag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Keep the tag */</comment>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zTag</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zTag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Cleanup */</comment>
	<expr_stmt><expr><call><name>SySetRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string strip_tags(string $str[, string $allowable_tags])
 *   Strip HTML and JX9 tags from a string.
 * Parameters
 *  $str
 *  The input string.
 * $allowable_tags
 *  You can use the optional second parameter to specify tags which should not be stripped. 
 * Return
 *  Returns the stripped string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strip_tags</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTaglist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nTaglen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the raw string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Allowed tag */</comment>
		<expr_stmt><expr><name>zTaglist</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTaglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Process input */</comment>
	<expr_stmt><expr><call><name>jx9StripTagsFromString</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zString</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><name>zTaglist</name></expr></argument>, <argument><expr><name>nTaglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array str_split(string $string[, int $split_length = 1 ])
 *  Convert a string to an array.
 * Parameters
 * $str
 *  The input string.
 * $split_length
 *  Maximum length of the chunk.
 * Return
 *  If the optional split_length parameter is specified, the returned array
 *  will be broken down into chunks with each being split_length in length, otherwise
 *  each chunk will be one character in length. FALSE is returned if split_length is less than 1.
 *  If the split_length length exceeds the length of string, the entire string is returned 
 *  as the first (and only) array element.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_str_split</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>split_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the target string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to process, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>split_len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Split length */</comment>
		<expr_stmt><expr><name>split_len</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>split_len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid length, return FALSE */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>split_len</name> <operator>&gt;</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>split_len</name> <operator>=</operator> <name>nLen</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create the array and the scalar value */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*Chunk value */</comment>
	<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>jx9_context_new_scalar</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pValue</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the end of the string */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>nMax</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>zString</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nMax</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zString</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nMax</name> <operator>&lt;</operator> <name>split_len</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>split_len</name> <operator>=</operator> <name>nMax</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Copy the current chunk */</comment>
		<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name>zString</name></expr></argument>, <argument><expr><name>split_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Insert it */</comment>
		<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Will make it's own copy */</comment>
		<comment type="block">/* reset the string cursor */</comment>
		<expr_stmt><expr><call><name>jx9_value_reset_string_cursor</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Update position */</comment>
		<expr_stmt><expr><name>zString</name> <operator>+=</operator> <name>split_len</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* 
	 * Return the array.
	 * Don't worry about freeing memory, everything will be automatically released
	 * upon we return from this function.
	 */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Tokenize a raw string and extract the first non-space token.
 * Refer to [strspn()].
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ExtractNonSpaceToken</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl></parameter>, <parameter><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>*</operator><name>pzIn</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>;</decl_stmt>
	<comment type="block">/* Ignore leading white spaces */</comment>
	<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* End of input */</comment>
		<return>return <expr><name>SXERR_EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
	<comment type="block">/* Extract the token */</comment>
	<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>zPtr</name></expr></argument>, <argument><expr><name>zIn</name><operator>-</operator><name>zPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Synchronize pointers */</comment>
	<expr_stmt><expr><operator>*</operator><name>pzIn</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
	<comment type="block">/* Return to the caller */</comment>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Check if the given string contains only characters from the given mask.
 * return the longest match.
 * Refer to [strspn()].
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>LongestStringMask</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMaskLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>zString</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zString</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract current character */</comment>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Perform the lookup */</comment>
		<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nMaskLen</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <name><name>zMask</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Character found */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>( <expr><name>i</name> <operator>&gt;=</operator> <name>nMaskLen</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Character not in the current mask, break immediately */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Advance cursor */</comment>
		<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Longest match */</comment>
	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zString</name><operator>-</operator><name>zIn</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Do the reverse operation of the previous function [i.e: LongestStringMask()].
 * Refer to [strcspn()].
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>LongestStringMask2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMaskLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>zString</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zString</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract current character */</comment>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Perform the lookup */</comment>
		<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nMaskLen</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <name><name>zMask</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>( <expr><name>i</name> <operator>&lt;</operator> <name>nMaskLen</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Character in the current mask, break immediately */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Advance cursor */</comment>
		<expr_stmt><expr><name>zString</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Longest match */</comment>
	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zString</name><operator>-</operator><name>zIn</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strspn(string $str, string $mask[, int $start[, int $length]])
 *  Finds the length of the initial segment of a string consisting entirely
 *  of characters contained within a given mask.
 * Parameters
 * $str
 *  The input string.
 * $mask
 *  The list of allowable characters.
 * $start
 *  The position in subject to start searching.
 *  If start is given and is non-negative, then strspn() will begin examining 
 *  subject at the start'th position. For instance, in the string 'abcdef', the character
 *  at position 0 is 'a', the character at position 2 is 'c', and so forth.
 *  If start is given and is negative, then strspn() will begin examining subject at the
 *  start'th position from the end of subject.
 * $length
 *  The length of the segment from subject to examine.
 *  If length is given and is non-negative, then subject will be examined for length
 *  characters after the starting position.
 *  If lengthis given and is negative, then subject will be examined from the starting
 *  position up to length characters from the end of subject.
 * Return
 * Returns the length of the initial segment of subject which consists entirely of characters
 * in mask.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strspn</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zMask</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iMasklen</name></decl>, <decl><type ref="prev"/><name>iLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyString</name></type> <name>sToken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing agruments, return zero */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Extract the mask */</comment>
	<expr_stmt><expr><name>zMask</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iMasklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iLen</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>iMasklen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to process, return zero */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>nOfft</name></decl>;</decl_stmt>
		<comment type="block">/* Extract the offset */</comment>
		<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nOfft</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBase</name> <init>= <expr><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>iLen</name> <operator>+</operator> <name>nOfft</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>( <expr><name>zBase</name> <operator>&gt;</operator> <name>zString</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>iLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>iLen</name></expr>]</index></name><operator>-</operator><name>zBase</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>zString</name> <operator>=</operator> <name>zBase</name></expr>;</expr_stmt>	
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Invalid offset */</comment>
				<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>nOfft</name> <operator>&gt;=</operator> <name>iLen</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Invalid offset */</comment>
				<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Update offset */</comment>
				<expr_stmt><expr><name>zString</name> <operator>+=</operator> <name>nOfft</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>iLen</name> <operator>-=</operator> <name>nOfft</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>iUserlen</name></decl>;</decl_stmt>
			<comment type="block">/* Extract the desired length */</comment>
			<expr_stmt><expr><name>iUserlen</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>iUserlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iUserlen</name> <operator>&lt;</operator> <name>iLen</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>iLen</name> <operator>=</operator> <name>iUserlen</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the end of the string */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zString</name><index>[<expr><name>iLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Extract the first non-space token */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExtractNonSpaceToken</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zString</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name> <operator>&amp;&amp;</operator> <name><name>sToken</name><operator>.</operator><name>nByte</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Compare against the current mask */</comment>
		<expr_stmt><expr><name>iCount</name> <operator>=</operator> <call><name>LongestStringMask</name><argument_list>(<argument><expr><name><name>sToken</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sToken</name><operator>.</operator><name>nByte</name></name></expr></argument>, <argument><expr><name>zMask</name></expr></argument>, <argument><expr><name>iMasklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Longest match */</comment>
	<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int strcspn(string $str, string $mask[, int $start[, int $length]])
 *  Find length of initial segment not matching mask.
 * Parameters
 * $str
 *  The input string.
 * $mask
 *  The list of not allowed characters.
 * $start
 *  The position in subject to start searching.
 *  If start is given and is non-negative, then strspn() will begin examining 
 *  subject at the start'th position. For instance, in the string 'abcdef', the character
 *  at position 0 is 'a', the character at position 2 is 'c', and so forth.
 *  If start is given and is negative, then strspn() will begin examining subject at the
 *  start'th position from the end of subject.
 * $length
 *  The length of the segment from subject to examine.
 *  If length is given and is non-negative, then subject will be examined for length
 *  characters after the starting position.
 *  If lengthis given and is negative, then subject will be examined from the starting
 *  position up to length characters from the end of subject.
 * Return
 *  Returns the length of the segment as an integer.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strcspn</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zMask</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iMasklen</name></decl>, <decl><type ref="prev"/><name>iLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyString</name></type> <name>sToken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing agruments, return zero */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Extract the mask */</comment>
	<expr_stmt><expr><name>zMask</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iMasklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to process, return zero */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>iMasklen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* No given mask, return the string length */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>nOfft</name></decl>;</decl_stmt>
		<comment type="block">/* Extract the offset */</comment>
		<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nOfft</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBase</name> <init>= <expr><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>iLen</name> <operator>+</operator> <name>nOfft</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>( <expr><name>zBase</name> <operator>&gt;</operator> <name>zString</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>iLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>iLen</name></expr>]</index></name><operator>-</operator><name>zBase</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>zString</name> <operator>=</operator> <name>zBase</name></expr>;</expr_stmt>	
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Invalid offset */</comment>
				<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>nOfft</name> <operator>&gt;=</operator> <name>iLen</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Invalid offset */</comment>
				<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Update offset */</comment>
				<expr_stmt><expr><name>zString</name> <operator>+=</operator> <name>nOfft</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>iLen</name> <operator>-=</operator> <name>nOfft</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>iUserlen</name></decl>;</decl_stmt>
			<comment type="block">/* Extract the desired length */</comment>
			<expr_stmt><expr><name>iUserlen</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>iUserlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iUserlen</name> <operator>&lt;</operator> <name>iLen</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>iLen</name> <operator>=</operator> <name>iUserlen</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the end of the string */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zString</name><index>[<expr><name>iLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Extract the first non-space token */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExtractNonSpaceToken</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zString</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name> <operator>&amp;&amp;</operator> <name><name>sToken</name><operator>.</operator><name>nByte</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Compare against the current mask */</comment>
		<expr_stmt><expr><name>iCount</name> <operator>=</operator> <call><name>LongestStringMask2</name><argument_list>(<argument><expr><name><name>sToken</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sToken</name><operator>.</operator><name>nByte</name></name></expr></argument>, <argument><expr><name>zMask</name></expr></argument>, <argument><expr><name>iMasklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Longest match */</comment>
	<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string strpbrk(string $haystack, string $char_list)
 *  Search a string for any of a set of characters.
 * Parameters
 *  $haystack
 *   The string where char_list is looked for.
 *  $char_list
 *   This parameter is case sensitive.
 * Return
 *  Returns a string starting from the character found, or FALSE if it is not found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strpbrk</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zList</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iLen</name></decl>, <decl><type ref="prev"/><name>iListLen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>, <decl><type ref="prev"/><name>nMax</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the haystack and the char list */</comment>
	<expr_stmt><expr><name>zString</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zList</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iListLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to process, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the end of the string */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zString</name><index>[<expr><name>iLen</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <name>nMax</name> <operator>=</operator> <name>SXU32_HIGH</name></expr>;</expr_stmt>
	<comment type="block">/* perform the requested operation */</comment>
	<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iListLen</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zList</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyByteFind</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>iLen</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>nMax</name> <operator>&lt;</operator> <name>nOfft</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <name>nMax</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name>nOfft</name> <operator>==</operator> <name>SXU32_HIGH</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* No such substring, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Return the substring */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nOfft</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><operator>&amp;</operator><name><name>zString</name><index>[<expr><name>nOfft</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string soundex(string $str)
 *  Calculate the soundex key of a string.
 * Parameters
 *  $str
 *   The input string.
 * Return
 *  Returns the soundex key as a string.
 * Note:
 *  This implementation is based on the one found in the SQLite3
 * source tree.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_soundex</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>zResult</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>iCode</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, 
		<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, 
		<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 
	}</block></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SyisAlpha</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
	<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>prevcode</name> <init>= <expr><name><name>iCode</name><index>[<expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>zResult</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>SyToUpper</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><name><name>iCode</name><index>[<expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>( <expr><name>code</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name>code</name><operator>!=</operator><name>prevcode</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>prevcode</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>code</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>zResult</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>code</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>prevcode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<while>while<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>zResult</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zResult</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
	  <expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"?000"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string wordwrap(string $str[, int $width = 75[, string $break = "\n"]])
 *  Wraps a string to a given number of characters.
 * Parameters
 *  $str
 *   The input string.
 * $width
 *  The column width.
 * $break
 *  The line is broken using the optional break parameter.
 * Return
 *  Returns the given string wrapped at the specified column. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_wordwrap</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zBreak</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>iLen</name></decl>, <decl><type ref="prev"/><name>iBreaklen</name></decl>, <decl><type ref="prev"/><name>iChunk</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the input string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to process, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Chunk length */</comment>
	<expr_stmt><expr><name>iChunk</name> <operator>=</operator> <literal type="number">75</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>iBreaklen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>zBreak</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>iChunk</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iChunk</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iChunk</name> <operator>=</operator> <literal type="number">75</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zBreak</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBreaklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>iBreaklen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Set a default column break */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
		<expr_stmt><expr><name>zBreak</name> <operator>=</operator> <literal type="string">"\r\n"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>iBreaklen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>zBreak</name> <operator>=</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>iBreaklen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>iLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>nMax</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nMax</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zIn</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iChunk</name> <operator>&gt;</operator> <name>nMax</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iChunk</name> <operator>=</operator> <name>nMax</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Append the column first */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>iChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Will make it's own copy */</comment>
		<comment type="block">/* Advance the cursor */</comment>
		<expr_stmt><expr><name>zIn</name> <operator>+=</operator> <name>iChunk</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Append the line break */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zBreak</name></expr></argument>, <argument><expr><name>iBreaklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Check if the given character is a member of the given mask.
 * Return TRUE on success. FALSE otherwise.
 * Refer to [strtok()].
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>CheckMask</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMasklen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOfft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nMasklen</name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr> )</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <name><name>zMask</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>pOfft</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>pOfft</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>TRUE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Extract a single token from the input stream.
 * Refer to [strtok()].
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ExtractToken</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMasklen</name></decl></parameter>, <parameter><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>*</operator><name>pzIn</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>;</decl_stmt>
	<comment type="block">/* Ignore leading delimiter */</comment>
	<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>CheckMask</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zMask</name></expr></argument>, <argument><expr><name>nMasklen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* End of input */</comment>
		<return>return <expr><name>SXERR_EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zPtr</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
	<comment type="block">/* Extract the token */</comment>
	<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* UTF-8 stream */</comment>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SX_JMP_UTF8</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><call><name>CheckMask</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zMask</name></expr></argument>, <argument><expr><name>nMasklen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>zPtr</name></expr></argument>, <argument><expr><name>zIn</name><operator>-</operator><name>zPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Update the cursor */</comment>
	<expr_stmt><expr><operator>*</operator><name>pzIn</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
	<comment type="block">/* Return to the caller */</comment>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* strtok auxiliary private data */</comment>
<typedef>typedef <type><name><name>struct</name> <name>strtok_aux_data</name></name></type> <name>strtok_aux_data</name>;</typedef>
<struct>struct <name>strtok_aux_data</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDup</name></decl>;</decl_stmt>  <comment type="block">/* Complete duplicate of the input */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>   <comment type="block">/* Current input stream */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>  <comment type="block">/* End of input */</comment>
}</block>;</struct>
<comment type="block">/*
 * string strtok(string $str, string $token)
 * string strtok(string $token)
 *  strtok() splits a string (str) into smaller strings (tokens), with each token
 *  being delimited by any character from token. That is, if you have a string like
 *  "This is an example string" you could tokenize this string into its individual
 *  words by using the space character as the token.
 *  Note that only the first call to strtok uses the string argument. Every subsequent
 *  call to strtok only needs the token to use, as it keeps track of where it is in 
 *  the current string. To start over, or to tokenize a new string you simply call strtok
 *  with the string argument again to initialize it. Note that you may put multiple tokens
 *  in the token parameter. The string will be tokenized when any one of the characters in 
 *  the argument are found. 
 * Parameters
 *  $str
 *  The string being split up into smaller strings (tokens).
 * $token
 *  The delimiter used when splitting up str.
 * Return
 *   Current token or FALSE on EOF.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strtok</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>strtok_aux_data</name> <modifier>*</modifier></type><name>pAux</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyString</name></type> <name>sToken</name></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>int</name></type> <name>nMasklen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Extract top aux data */</comment>
		<expr_stmt><expr><name>pAux</name> <operator>=</operator> <operator>(</operator><name>strtok_aux_data</name> <operator>*</operator><operator>)</operator><call><name>jx9_context_peek_aux_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pAux</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* No aux data, return FALSE */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nMasklen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>zMask</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Extract the mask */</comment>
			<expr_stmt><expr><name>zMask</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nMasklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nMasklen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Invalid mask, return FALSE */</comment>
			<expr_stmt><expr><call><name>jx9_context_free_chunk</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pAux</name><operator>-&gt;</operator><name>zDup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_context_free_chunk</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>jx9_context_pop_aux_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract the token */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExtractToken</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAux</name><operator>-&gt;</operator><name>zIn</name></name></expr></argument>, <argument><expr><name><name>pAux</name><operator>-&gt;</operator><name>zEnd</name></name></expr></argument>, <argument><expr><name>zMask</name></expr></argument>, <argument><expr><name>nMasklen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* EOF , discard the aux data */</comment>
			<expr_stmt><expr><call><name>jx9_context_free_chunk</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pAux</name><operator>-&gt;</operator><name>zDup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_context_free_chunk</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>jx9_context_pop_aux_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Return the extracted token */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>sToken</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sToken</name><operator>.</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zCur</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
		<comment type="block">/* Extract the raw input */</comment>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zInput</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Empty input, return FALSE */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract the mask */</comment>
		<expr_stmt><expr><name>zMask</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nMasklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nMasklen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Set a default mask */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOK_MASK</name></cpp:macro> <cpp:value>" \n\t\r\f"</cpp:value></cpp:define> 
			<expr_stmt><expr><name>zMask</name> <operator>=</operator> <name>TOK_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nMasklen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TOK_MASK</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TOK_MASK</name></cpp:undef>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract a single token */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExtractToken</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zInput</name><index>[<expr><name>nLen</name></expr>]</index></name></expr></argument>, <argument><expr><name>zMask</name></expr></argument>, <argument><expr><name>nMasklen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Empty input */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Return the extracted token */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>sToken</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sToken</name><operator>.</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Create our auxilliary data and copy the input */</comment>
		<expr_stmt><expr><name>pAux</name> <operator>=</operator> <operator>(</operator><name>strtok_aux_data</name> <operator>*</operator><operator>)</operator><call><name>jx9_context_alloc_chunk</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>strtok_aux_data</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pAux</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nLen</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zInput</name><operator>-</operator><name>zCur</name><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>jx9_context_free_chunk</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Duplicate input */</comment>
			<expr_stmt><expr><name>zDup</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_context_alloc_chunk</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>nLen</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>zDup</name></expr>  )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>zDup</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Register the aux data */</comment>
				<expr_stmt><expr><name><name>pAux</name><operator>-&gt;</operator><name>zDup</name></name> <operator>=</operator> <name><name>pAux</name><operator>-&gt;</operator><name>zIn</name></name> <operator>=</operator> <name>zDup</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pAux</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>zDup</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>jx9_context_push_aux_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string str_pad(string $input, int $pad_length[, string $pad_string = " " [, int $pad_type = STR_PAD_RIGHT]])
 *  Pad a string to a certain length with another string
 * Parameters
 *  $input
 *   The input string.
 * $pad_length
 *   If the value of pad_length is negative, less than, or equal to the length of the input 
 *   string, no padding takes place.
 * $pad_string
 *   Note:
 *    The pad_string WIIL NOT BE truncated if the required number of padding characters can't be evenly
 *    divided by the pad_string's length.
 * $pad_type
 *    Optional argument pad_type can be STR_PAD_RIGHT, STR_PAD_LEFT, or STR_PAD_BOTH. If pad_type
 *    is not specified it is assumed to be STR_PAD_RIGHT.
 * Return
 *  The padded string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_str_pad</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>iLen</name></decl>, <decl><type ref="prev"/><name>iPadlen</name></decl>, <decl><type ref="prev"/><name>iType</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>iDiv</name></decl>, <decl><type ref="prev"/><name>iStrpad</name></decl>, <decl><type ref="prev"/><name>iRealPad</name></decl>, <decl><type ref="prev"/><name>jPad</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPad</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Padding length */</comment>
	<expr_stmt><expr><name>iRealPad</name> <operator>=</operator> <name>iPadlen</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iPadlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>iPadlen</name> <operator>-=</operator> <name>iLen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>iPadlen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>  )</condition><block>{<block_content>
		<comment type="block">/* Return the string verbatim */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zPad</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt> <comment type="block">/* Whitespace padding */</comment>
	<expr_stmt><expr><name>iStrpad</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>iType</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt> <comment type="block">/* STR_PAD_RIGHT */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Padding string */</comment>
		<expr_stmt><expr><name>zPad</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iStrpad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iStrpad</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Empty string */</comment>
			<expr_stmt><expr><name>zPad</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt> <comment type="block">/* Whitespace padding */</comment>
			<expr_stmt><expr><name>iStrpad</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Padd type */</comment>
			<expr_stmt><expr><name>iType</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>iType</name> <operator>!=</operator> <literal type="number">0</literal> <comment type="block">/* STR_PAD_LEFT */</comment> <operator>&amp;&amp;</operator> <name>iType</name> <operator>!=</operator> <literal type="number">2</literal></expr> <comment type="block">/* STR_PAD_BOTH */</comment> )</condition><block>{<block_content>
				<expr_stmt><expr><name>iType</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</expr_stmt> <comment type="block">/* STR_PAD_RIGHT */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iDiv</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iType</name> <operator>==</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>iDiv</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* STR_PAD_BOTH */</comment>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<if_stmt><if>if<condition>( <expr><name>iType</name> <operator>==</operator> <literal type="number">0</literal> <comment type="block">/* STR_PAD_LEFT */</comment> <operator>||</operator> <name>iType</name> <operator>==</operator> <literal type="number">2</literal></expr> <comment type="block">/* STR_PAD_BOTH */</comment> )</condition><block>{<block_content>
		<expr_stmt><expr><name>jPad</name> <operator>=</operator> <name>iStrpad</name></expr>;</expr_stmt>
		<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iPadlen</name><operator>/</operator><name>iDiv</name></expr> ;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>jPad</name></expr></incr> )</control><block>{<block_content>
			<comment type="block">/* Padding */</comment>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>jx9_context_result_buf_length</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>iLen</name> <operator>+</operator> <name>jPad</name> <operator>&gt;=</operator> <name>iRealPad</name></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zPad</name></expr></argument>, <argument><expr><name>jPad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>( <expr><name>iType</name> <operator>==</operator> <literal type="number">0</literal></expr> <comment type="block">/* STR_PAD_LEFT */</comment> )</condition><block>{<block_content>
			<while>while<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>jx9_context_result_buf_length</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>iLen</name> <operator>&lt;</operator> <name>iRealPad</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>jPad</name> <operator>=</operator> <name>iRealPad</name> <operator>-</operator> <operator>(</operator><name>iLen</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>jx9_context_result_buf_length</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call> <operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>jPad</name> <operator>&gt;</operator> <name>iStrpad</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>jPad</name> <operator>=</operator> <name>iStrpad</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if<condition>( <expr><name>jPad</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zPad</name></expr></argument>, <argument><expr><name>jPad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>iLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Append the input string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>iType</name> <operator>==</operator> <literal type="number">1</literal> <comment type="block">/* STR_PAD_RIGHT */</comment> <operator>||</operator> <name>iType</name> <operator>==</operator> <literal type="number">2</literal></expr> <comment type="block">/* STR_PAD_BOTH */</comment> )</condition><block>{<block_content>
		<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iPadlen</name><operator>/</operator><name>iDiv</name></expr> ;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>iStrpad</name></expr></incr> )</control><block>{<block_content>
			<comment type="block">/* Padding */</comment>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>jx9_context_result_buf_length</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>iStrpad</name> <operator>&gt;=</operator> <name>iRealPad</name></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zPad</name></expr></argument>, <argument><expr><name>iStrpad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<while>while<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>jx9_context_result_buf_length</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>iRealPad</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>jPad</name> <operator>=</operator> <name>iRealPad</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>jx9_context_result_buf_length</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>jPad</name> <operator>&gt;</operator> <name>iStrpad</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>jPad</name> <operator>=</operator> <name>iStrpad</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>jPad</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zPad</name></expr></argument>, <argument><expr><name>jPad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * String replacement private data.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>str_replace_data</name></name></type> <name>str_replace_data</name>;</typedef>
<struct>struct <name>str_replace_data</name>
<block>{
	<comment type="block">/* The following two fields are only used by the strtr function */</comment>
	<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt>         <comment type="block">/* Working buffer */</comment>
	<decl_stmt><decl><type><name>ProcStringMatch</name></type> <name>xMatch</name></decl>;</decl_stmt>  <comment type="block">/* Pattern match routine */</comment>
	<comment type="block">/* The following two fields are only used by the str_replace function */</comment>
	<decl_stmt><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pCollector</name></decl>;</decl_stmt>  <comment type="block">/* Argument collector*/</comment>
	<decl_stmt><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>  <comment type="block">/* Call context */</comment>
}</block>;</struct>
<comment type="block">/*
 * Remove a substring.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRDEL</name><parameter_list>(<parameter><type><name>SRC</name></type></parameter>, <parameter><type><name>SLEN</name></type></parameter>, <parameter><type><name>OFFT</name></type></parameter>, <parameter><type><name>ILEN</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{\
	for(;;){\
		if( OFFT + ILEN &gt;= SLEN ) break; SRC[OFFT] = SRC[OFFT+ILEN]; ++OFFT;\
	}\
}</cpp:value></cpp:define>
<comment type="block">/*
 * Shift right and insert algorithm.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHIFTRANDINSERT</name><parameter_list>(<parameter><type><name>SRC</name></type></parameter>, <parameter><type><name>LEN</name></type></parameter>, <parameter><type><name>OFFT</name></type></parameter>, <parameter><type><name>ENTRY</name></type></parameter>, <parameter><type><name>ELEN</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{\
	sxu32 INLEN = LEN - OFFT;\
	for(;;){\
	  if( LEN &gt; 0 ){ LEN--; } if(INLEN &lt; 1 ) break; SRC[LEN + ELEN] = SRC[LEN] ; --INLEN; \
	}\
	for(;;){\
		if(ELEN &lt; 1)break; SRC[OFFT] = ENTRY[0]; OFFT++; ENTRY++; --ELEN;\
	}\
}</cpp:value></cpp:define> 
<comment type="block">/*
 * Replace all occurrences of the search string at offset (nOfft) with the given 
 * replacement string [i.e: zReplace].
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>StringReplace</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pWorker</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nOfft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zReplace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReplen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zInput</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>m</name> <operator>=</operator> <name>nOfft</name></expr>;</expr_stmt>
	<comment type="block">/* Delete the old entry */</comment>
	<expr_stmt><expr><call><name>STRDEL</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call> <operator>-=</operator> <name>nLen</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nReplen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>sxi32</name></type> <name>iRep</name> <init>= <expr><name>nReplen</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
		<comment type="block">/*
		 * Make sure the working buffer is big enough to hold the replacement
		 * string.
		 */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Grow without an append operation*/</comment>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nReplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Simply ignore any memory failure problem */</comment>
			<return>return <expr><name>SXRET_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Perform the insertion now */</comment>
		<expr_stmt><expr><name>zInput</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHIFTRANDINSERT</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>nOfft</name></expr></argument>, <argument><expr><name>zReplace</name></expr></argument>, <argument><expr><name>iRep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>nReplen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * String replacement walker callback.
 * The following callback is invoked for each array entry that hold
 * the replace string.
 * Refer to the strtr() implementation for more information.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>StringReplaceWalker</name><parameter_list>(<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>str_replace_data</name> <modifier>*</modifier></type><name>pRepData</name> <init>= <expr><operator>(</operator><name>str_replace_data</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTarget</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zReplace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tLen</name></decl>, <decl><type ref="prev"/><name>nLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Point to the working buffer */</comment>
	<expr_stmt><expr><name>pWorker</name> <operator>=</operator> <name><name>pRepData</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Target and replace must be a string */</comment>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target and the replace */</comment>
	<expr_stmt><expr><name>zTarget</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>tLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty target, return immediately */</comment>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform a pattern search */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pRepData</name><operator>-&gt;</operator><name>xMatch</name></name><argument_list>(<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zTarget</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>tLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Pattern not found */</comment>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the replace string */</comment>
	<expr_stmt><expr><name>zReplace</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the replace process */</comment>
	<expr_stmt><expr><call><name>StringReplace</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name>nOfft</name></expr></argument>, <argument><expr><name>tLen</name></expr></argument>, <argument><expr><name>zReplace</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * The following walker callback is invoked by the str_rplace() function inorder
 * to collect search/replace string.
 * This callback is invoked only if the given argument is of type array.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>StrReplaceWalker</name><parameter_list>(<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>str_replace_data</name> <modifier>*</modifier></type><name>pRep</name> <init>= <expr><operator>(</operator><name>str_replace_data</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyString</name></type> <name>sWorker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
	<comment type="block">/* Extract a string representation of the given argument */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDup</name></decl>;</decl_stmt>
		<comment type="block">/* Duplicate the chunk */</comment>
		<expr_stmt><expr><name>zDup</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_context_alloc_chunk</name><argument_list>(<argument><expr><name><name>pRep</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>nByte</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, 
			<argument><expr><name>TRUE</name></expr></argument> <comment type="block">/* Release the chunk automatically, upon this context is destroyd */</comment>
			)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zDup</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Ignore any memory failure problem */</comment>
			<expr_stmt><expr><call><name>jx9_context_throw_error</name><argument_list>(<argument><expr><name><name>pRep</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>JX9_CTX_ERR</name></expr></argument>, <argument><expr><literal type="string">"JX9 is running out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zDup</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Save the chunk */</comment>
		<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>, <argument><expr><name>zDup</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Save for later processing */</comment>
	<expr_stmt><expr><call><name>SySetPut</name><argument_list>(<argument><expr><name><name>pRep</name><operator>-&gt;</operator><name>pCollector</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * mixed str_replace(mixed $search, mixed $replace, mixed $subject[, int &amp;$count ])
 * mixed str_ireplace(mixed $search, mixed $replace, mixed $subject[, int &amp;$count ])
 *  Replace all occurrences of the search string with the replacement string.
 * Parameters
 *  If search and replace are arrays, then str_replace() takes a value from each
 *  array and uses them to search and replace on subject. If replace has fewer values
 *  than search, then an empty string is used for the rest of replacement values.
 *  If search is an array and replace is a string, then this replacement string is used
 *  for every value of search. The converse would not make sense, though.
 *  If search or replace are arrays, their elements are processed first to last.
 * $search
 *  The value being searched for, otherwise known as the needle. An array may be used
 *  to designate multiple needles.
 * $replace
 *  The replacement value that replaces found search values. An array may be used
 *  to designate multiple replacements.
 * $subject
 *  The string or array being searched and replaced on, otherwise known as the haystack.
 *  If subject is an array, then the search and replace is performed with every entry 
 *  of subject, and the return value is an array as well.
 * $count (Not used)
 *  If passed, this will be set to the number of replacements performed.
 * Return
 * This function returns a string or an array with the replaced values.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_str_replace</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyString</name></type> <name>sTemp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pSearch</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pReplace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcStringMatch</name></type> <name>xMatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zFunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>str_replace_data</name></type> <name>sRep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyBlob</name></type> <name>sWorker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SySet</name></type> <name>sReplace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SySet</name></type> <name>sSearch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rep_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Initialize fields */</comment>
	<expr_stmt><expr><call><name>SySetInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSearch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyString</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SySetInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sReplace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyString</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBlobInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str_replace_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sRep</name><operator>.</operator><name>pCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sRep</name><operator>.</operator><name>pCollector</name></name> <operator>=</operator> <operator>&amp;</operator><name>sSearch</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rep_str</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Extract the subject */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to replace, return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Copy the subject */</comment>
	<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Search string */</comment>
	<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Collect search string */</comment>
		<expr_stmt><expr><call><name>jx9_array_walk</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>StrReplaceWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sRep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Single pattern */</comment>
		<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Return the subject untouched since no search string is available */</comment>
			<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument><comment type="block">/* Subject as thrird argument*/</comment>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTemp</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Save for later processing */</comment>
		<expr_stmt><expr><call><name>SySetPut</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSearch</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Replace string */</comment>
	<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Collect replace string */</comment>
		<expr_stmt><expr><name><name>sRep</name><operator>.</operator><name>pCollector</name></name> <operator>=</operator> <operator>&amp;</operator><name>sReplace</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_array_walk</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>StrReplaceWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sRep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Single needle */</comment>
		<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rep_str</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTemp</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Save for later processing */</comment>
		<expr_stmt><expr><call><name>SySetPut</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sReplace</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Reset loop cursors */</comment>
	<expr_stmt><expr><call><name>SySetResetCursor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSearch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SySetResetCursor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pReplace</name> <operator>=</operator> <name>pSearch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTemp</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Extract function name */</comment>
	<expr_stmt><expr><name>zFunc</name> <operator>=</operator> <call><name>jx9_function_name</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Set the default pattern match routine */</comment>
	<expr_stmt><expr><name>xMatch</name> <operator>=</operator> <name>SyBlobSearch</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>SyStrncmp</name><argument_list>(<argument><expr><name>zFunc</name></expr></argument>, <argument><expr><literal type="string">"str_ireplace"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"str_ireplace"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator>  <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Case insensitive pattern match */</comment>
		<expr_stmt><expr><name>xMatch</name> <operator>=</operator> <name>iPatternMatch</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Start the replace process */</comment>
	<while>while<condition>( <expr><name>SXRET_OK</name> <operator>==</operator> <call><name>SySetGetNextEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSearch</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pSearch</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nCount</name></decl>, <decl><type ref="prev"/><name>nOfft</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pSearch</name><operator>-&gt;</operator><name>nByte</name></name> <operator>&lt;</operator>  <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Empty string, ignore */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract the replace string */</comment>
		<if_stmt><if>if<condition>( <expr><name>rep_str</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>pReplace</name> <operator>=</operator> <operator>(</operator><name>SyString</name> <operator>*</operator><operator>)</operator><call><name>SySetPeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>!=</operator> <call><name>SySetGetNextEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sReplace</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pReplace</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<comment type="block">/* Sepecial case when 'replace set' has fewer values than the search set.
				 * An empty string is used for the rest of replacement values
				 */</comment>
				<expr_stmt><expr><name>pReplace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>pReplace</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Use an empty string instead */</comment>
			<expr_stmt><expr><name>pReplace</name> <operator>=</operator> <operator>&amp;</operator><name>sTemp</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <name>nCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>nCount</name> <operator>&gt;=</operator> <call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Perform a pattern lookup */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xMatch</name><argument_list>(<argument><expr><call><name>SyBlobDataAt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>, <argument><expr><name>nCount</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nCount</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name><name>pSearch</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>, 
				<argument><expr><name><name>pSearch</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Pattern not found */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Perform the replace operation */</comment>
			<expr_stmt><expr><call><name>StringReplace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>, <argument><expr><name>nCount</name><operator>+</operator><name>nOfft</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pSearch</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>, <argument><expr><name><name>pReplace</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pReplace</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Increment offset counter */</comment>
			<expr_stmt><expr><name>nCount</name> <operator>+=</operator> <name>nOfft</name> <operator>+</operator> <name><name>pReplace</name><operator>-&gt;</operator><name>nByte</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>
	<comment type="block">/* All done, clean-up the mess left behind */</comment>
	<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SySetRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSearch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SySetRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string strtr(string $str, string $from, string $to)
 * string strtr(string $str, array $replace_pairs)
 *  Translate characters or replace substrings.
 * Parameters
 *  $str
 *  The string being translated.
 * $from
 *  The string being translated to to.
 * $to
 *  The string replacing from.
 * $replace_pairs
 *  The replace_pairs parameter may be used instead of to and 
 *  from, in which case it's an array in the form array('from' =&gt; 'to', ...).
 * Return
 *  The translated string.
 *  If replace_pairs contains a key which is an empty string (""), FALSE will be returned.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strtr</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to replace, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid arguments */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>str_replace_data</name></type> <name>sRepData</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SyBlob</name></type> <name>sWorker</name></decl>;</decl_stmt>
		<comment type="block">/* Initilaize the working buffer */</comment>
		<expr_stmt><expr><call><name>SyBlobInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Copy raw string */</comment>
		<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Init our replace data instance */</comment>
		<expr_stmt><expr><name><name>sRepData</name><operator>.</operator><name>pWorker</name></name> <operator>=</operator> <operator>&amp;</operator><name>sWorker</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sRepData</name><operator>.</operator><name>xMatch</name></name> <operator>=</operator> <name>SyBlobSearch</name></expr>;</expr_stmt>
		<comment type="block">/* Iterate throw array entries and perform the replace operation.*/</comment>
		<expr_stmt><expr><call><name>jx9_array_walk</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>StringReplaceWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sRepData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* All done, return the result string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr></argument>, 
			<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Will make it's own copy */</comment>
		<comment type="block">/* Clean-up */</comment>
		<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>flen</name></decl>, <decl><type ref="prev"/><name>tlen</name></decl>, <decl><type ref="prev"/><name>c</name></decl>, <decl><type ref="prev"/><name>iOfft</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zTo</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Nothing to replace */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract given arguments */</comment>
		<expr_stmt><expr><name>zFrom</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>zTo</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>flen</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>tlen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Nothing to replace */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Start the replace process */</comment>
		<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLen</name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr> )</control><block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><call><name>CheckMask</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>flen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iOfft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<if_stmt><if>if <condition>( <expr><name>iOfft</name> <operator>&lt;</operator> <name>tlen</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zTo</name><index>[<expr><name>iOfft</name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Parse an INI string.
 * According to wikipedia
 *  The INI file format is an informal standard for configuration files for some platforms or software.
 *  INI files are simple text files with a basic structure composed of "sections" and "properties".
 *  Format
*    Properties
*     The basic element contained in an INI file is the property. Every property has a name and a value
*     delimited by an equals sign (=). The name appears to the left of the equals sign.
*     Example:
*      name=value
*    Sections
*     Properties may be grouped into arbitrarily named sections. The section name appears on a line by itself
*     in square brackets ([ and ]). All properties after the section declaration are associated with that section.
*     There is no explicit "end of section" delimiter; sections end at the next section declaration
*     or the end of the file. Sections may not be nested.
*     Example:
*      [section]
*   Comments
*    Semicolons (;) at the beginning of the line indicate a comment. Comment lines are ignored.
* This function return an array holding parsed values on success.FALSE otherwise.
*/</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9ParseIniString</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bProcessSection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pArray</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pSection</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pWorker</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyString</name></type> <name>sEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyHash</name></type> <name>sHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<comment type="block">/* Create an empty array and worker variables */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pWorker</name> <operator>=</operator> <call><name>jx9_context_new_scalar</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>jx9_context_new_scalar</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pWorker</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pValue</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
		<comment type="block">/* Out of memory */</comment>
		<expr_stmt><expr><call><name>jx9_context_throw_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>JX9_CTX_ERR</name></expr></argument>, <argument><expr><literal type="string">"JX9 is running out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyHashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pCur</name> <operator>=</operator> <name>pArray</name></expr>;</expr_stmt>
	<comment type="block">/* Start the parse process */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<comment type="block">/* Ignore leading white spaces */</comment>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal> <operator>||</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Comment til the end of line */</comment>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			<while>while<condition>(<expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Reset the string cursor of the working variable */</comment>
		<expr_stmt><expr><call><name>jx9_value_reset_string_cursor</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Section: Extract the section name */</comment>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
			<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">']'</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;</operator> <name>zCur</name> <operator>&amp;&amp;</operator> <name>bProcessSection</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Save the section name */</comment>
				<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SyStringFullTrim</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name><name>sEntry</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sEntry</name><operator>.</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name><name>sEntry</name><operator>.</operator><name>nByte</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<comment type="block">/* Associate an array with the section */</comment>
					<expr_stmt><expr><name>pSection</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>pSection</name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument><comment type="block">/*Section name*/</comment>, <argument><expr><name>pSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>pCur</name> <operator>=</operator> <name>pSection</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Trailing square brackets ']' */</comment>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pOldCur</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>is_array</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>iLen</name></decl>;</decl_stmt>
			<comment type="block">/* Properties */</comment>
			<expr_stmt><expr><name>is_array</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>iLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
			<expr_stmt><expr><name>pOldCur</name> <operator>=</operator> <name>pCur</name></expr>;</expr_stmt>
			<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'='</literal></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_array</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* Array */</comment>
					<expr_stmt><expr><name>iLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>is_array</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>iLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
						<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pvArr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc warning */</comment>
						<comment type="block">/* Query the hashtable */</comment>
						<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>SyStringFullTrim</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>SyHashGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sHash</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name><name>sEntry</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><name><name>sEntry</name><operator>.</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if<condition>( <expr><name>pEntry</name></expr> )</condition><block>{<block_content>
							<expr_stmt><expr><name>pvArr</name> <operator>=</operator> <operator>(</operator><name>jx9_value</name> <operator>*</operator><operator>)</operator><call><name>SyHashEntryGetUserData</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if><else>else<block>{<block_content>
							<comment type="block">/* Create an empty array */</comment>
							<expr_stmt><expr><name>pvArr</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if<condition>( <expr><name>pvArr</name></expr> )</condition><block>{<block_content>
								<comment type="block">/* Save the entry */</comment>
								<expr_stmt><expr><call><name>SyHashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sHash</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name><name>sEntry</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><name><name>sEntry</name><operator>.</operator><name>nByte</name></name></expr></argument>, <argument><expr><name>pvArr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<comment type="block">/* Insert the entry */</comment>
								<expr_stmt><expr><call><name>jx9_value_reset_string_cursor</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name><name>sEntry</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sEntry</name><operator>.</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name>pvArr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>jx9_value_reset_string_cursor</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></else></if_stmt>
						<if_stmt><if>if<condition>( <expr><name>pvArr</name></expr> )</condition><block>{<block_content>
							<expr_stmt><expr><name>pCur</name> <operator>=</operator> <name>pvArr</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<while>while <condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">']'</literal></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></while>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if<condition>( <expr><operator>!</operator><name>is_array</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>iLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Trim the key */</comment>
			<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyStringFullTrim</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>sEntry</name><operator>.</operator><name>nByte</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><operator>!</operator><name>is_array</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* Save the key name */</comment>
					<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name><name>sEntry</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sEntry</name><operator>.</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* extract key value */</comment>
				<expr_stmt><expr><call><name>jx9_value_reset_string_cursor</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* '=' */</comment>
				<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
				<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
						<comment type="block">/* Delimit the value */</comment>
						<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
							<if_stmt><if>if <condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block></while>
						<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
							<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if><else>else<block>{<block_content>
						<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
							<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
								<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
									<break>break;</break>
								</block_content>}</block></if></if_stmt>
							</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal> <operator>||</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr> )</condition><block>{<block_content>
								<comment type="block">/* Inline comments */</comment>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block></while>
					</block_content>}</block></else></if_stmt>
					<comment type="block">/* Trim the value */</comment>
					<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SyStringFullTrim</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><call><name>SyStringTrimLeadingChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>SyStringTrimTrailingChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if<condition>( <expr><name><name>sEntry</name><operator>.</operator><name>nByte</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sEntry</name><operator>.</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sEntry</name><operator>.</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Insert the key and it's value */</comment>
					<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><ternary><condition><expr><name>is_array</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> <comment type="block">/*Automatic index assign */</comment></then><else>: <expr><name>pWorker</name></expr></else></ternary></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <operator>(</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>)</operator></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>pCur</name> <operator>=</operator> <name>pOldCur</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>SyHashRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Return the parse of the INI string */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array parse_ini_string(string $ini[, bool $process_sections = false[, int $scanner_mode = INI_SCANNER_NORMAL ]])
 *  Parse a configuration string.
 * Parameters
 *  $ini
 *   The contents of the ini file being parsed.
 *  $process_sections
 *   By setting the process_sections parameter to TRUE, you get a multidimensional array, with the section names
 *   and settings included. The default for process_sections is FALSE.
 *  $scanner_mode (Not used)
 *   Can either be INI_SCANNER_NORMAL (default) or INI_SCANNER_RAW. If INI_SCANNER_RAW is supplied
 *   then option values will not be parsed.
 * Return
 *  The settings are returned as an associative array on success, and FALSE on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_parse_ini_string</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIni</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return FALSE*/</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the raw INI buffer */</comment>
	<expr_stmt><expr><name>zIni</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Process the INI buffer*/</comment>
	<expr_stmt><expr><call><name>jx9ParseIniString</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zIni</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nByte</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Ctype Functions.
 * Authors:
 *    Symisc Systems, devel@symisc.net.
 *    Copyright (C) Symisc Systems, http://jx9.symisc.net
 * Status:
 *    Stable.
 */</comment>
<comment type="block">/*
 * bool ctype_alnum(string $text)
 *  Checks if all of the characters in the provided string, text, are alphanumeric.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *   TRUE if every character in text is either a letter or a digit, FALSE otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_alnum</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisAlphaNum</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool ctype_alpha(string $text)
 *  Checks if all of the characters in the provided string, text, are alphabetic.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *  TRUE if every character in text is a letter from the current locale, FALSE otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_alpha</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisAlpha</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool ctype_cntrl(string $text)
 *  Checks if all of the characters in the provided string, text, are control characters.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *  TRUE if every character in text is a control characters, FALSE otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_cntrl</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* UTF-8 stream  */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisCtrl</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool ctype_digit(string $text)
 *  Checks if all of the characters in the provided string, text, are numerical.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *  TRUE if every character in the string text is a decimal digit, FALSE otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_digit</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* UTF-8 stream  */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool ctype_xdigit(string $text)
 *  Check for character(s) representing a hexadecimal digit.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *  Returns TRUE if every character in text is a hexadecimal 'digit', that is
 * a decimal digit or a character from [A-Fa-f] , FALSE otherwise. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_xdigit</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* UTF-8 stream  */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisHex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool ctype_graph(string $text)
 *  Checks if all of the characters in the provided string, text, creates visible output.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *  Returns TRUE if every character in text is printable and actually creates visible output
 * (no white space), FALSE otherwise. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_graph</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* UTF-8 stream  */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisGraph</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool ctype_print(string $text)
 *  Checks if all of the characters in the provided string, text, are printable.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *  Returns TRUE if every character in text will actually create output (including blanks).
 *  Returns FALSE if text contains control characters or characters that do not have any output
 *  or control function at all. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_print</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* UTF-8 stream  */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisPrint</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool ctype_punct(string $text)
 *  Checks if all of the characters in the provided string, text, are punctuation character.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *  Returns TRUE if every character in text is printable, but neither letter
 *  digit or blank, FALSE otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_punct</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* UTF-8 stream  */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisPunct</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool ctype_space(string $text)
 *  Checks if all of the characters in the provided string, text, creates whitespace.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *  Returns TRUE if every character in text creates some sort of white space, FALSE otherwise.
 *  Besides the blank character this also includes tab, vertical tab, line feed, carriage return
 *  and form feed characters. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_space</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* UTF-8 stream  */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool ctype_lower(string $text)
 *  Checks if all of the characters in the provided string, text, are lowercase letters.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *  Returns TRUE if every character in text is a lowercase letter in the current locale. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_lower</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisLower</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool ctype_upper(string $text)
 *  Checks if all of the characters in the provided string, text, are uppercase letters.
 * Parameters
 *  $text
 *   The tested string.
 * Return
 *  Returns TRUE if every character in text is a uppercase letter in the current locale. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_ctype_upper</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the target string */</comment>
	<expr_stmt><expr><name>zIn</name>  <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty string, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* If we reach the end of the string, then the test succeeded. */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>SyisUpper</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The test failed, return FALSE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Date/Time functions
 * Authors:
 *    Symisc Systems, devel@symisc.net.
 *    Copyright (C) Symisc Systems, http://jx9.symisc.net
 * Status:
 *    Devel.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
<comment type="block">/* GetSystemTime() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Windows.h&gt;</cpp:file></cpp:include> 
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32_WCE</name></cpp:ifdef>
<comment type="block">/*
** WindowsCE does not have a localtime() function.  So create a
** substitute.
** Taken from the SQLite3 source tree.
** Status: Public domain
*/</comment>
<function><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier><name>__cdecl</name></type> <name>localtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name></type> <name>y</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILETIME</name></type> <name>uTm</name></decl>, <decl><type ref="prev"/><name>lTm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>pTm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jx9_int64</name></type> <name>t64</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>t64</name> <operator>=</operator> <operator>*</operator><name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>t64</name> <operator>=</operator> <operator>(</operator><name>t64</name> <operator>+</operator> <literal type="number">11644473600</literal><operator>)</operator><operator>*</operator><literal type="number">10000000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>uTm</name><operator>.</operator><name>dwLowDateTime</name></name> <operator>=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><name>t64</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>uTm</name><operator>.</operator><name>dwHighDateTime</name></name><operator>=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><name>t64</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>FileTimeToLocalFileTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>FileTimeToSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wYear</name></name> <operator>-</operator> <literal type="number">1900</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wMonth</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_wday</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wDayOfWeek</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wDay</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wHour</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_min</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wMinute</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wSecond</name></name></expr>;</expr_stmt>
  <return>return <expr><operator>&amp;</operator><name>y</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*_WIN32_WCE */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__UNIXES__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __WINNT__*/</comment>
 <comment type="block">/*
  * int64 time(void)
  *  Current Unix timestamp
  * Parameters
  *  None.
  * Return
  *  Returns the current time measured in the number of seconds
  *  since the Unix Epoch (January 1 1970 00:00:00 GMT).
  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_time</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Extract the current time */</comment>
	<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Return as 64-bit integer */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>jx9_int64</name><operator>)</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return  <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
  * string/float microtime([ bool $get_as_float = false ])
  *  microtime() returns the current Unix timestamp with microseconds.
  * Parameters
  *  $get_as_float
  *   If used and set to TRUE, microtime() will return a float instead of a string
  *   as described in the return values section below.
  * Return
  *  By default, microtime() returns a string in the form "msec sec", where sec 
  *  is the current time measured in the number of seconds since the Unix 
  *  epoch (0:00:00 January 1, 1970 GMT), and msec is the number of microseconds
  *  that have elapsed since sec expressed in seconds.
  *  If get_as_float is set to TRUE, then microtime() returns a float, which represents
  *  the current time in seconds since the Unix epoch accurate to the nearest microsecond. 
  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_microtime</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>bFloat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sytime</name></type> <name>sTime</name></decl>;</decl_stmt>	
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__UNIXES__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sTime</name><operator>.</operator><name>tm_sec</name></name>  <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sTime</name><operator>.</operator><name>tm_usec</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sTime</name><operator>.</operator><name>tm_sec</name></name>  <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>tt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sTime</name><operator>.</operator><name>tm_usec</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>tt</name><operator>%</operator><name>SX_USEC_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __UNIXES__ */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>bFloat</name> <operator>=</operator> <call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>bFloat</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return as float */</comment>
		<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name><name>sTime</name><operator>.</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Return as string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%ld %ld"</literal></expr></argument>, <argument><expr><name><name>sTime</name><operator>.</operator><name>tm_usec</name></name></expr></argument>, <argument><expr><name><name>sTime</name><operator>.</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array getdate ([ int $timestamp = time() ])
 *  Get date/time information.
 * Parameter
 *  $timestamp: The optional timestamp parameter is an integer Unix timestamp
 *     that defaults to the current local time if a timestamp is not given.
 *     In other words, it defaults to the value of time().
 * Returns
 *  Returns an associative array of information related to the timestamp.
 *  Elements from the returned associative array are as follows: 
 *   KEY                                                         VALUE
 * ---------                                                    -------
 * "seconds" 	Numeric representation of seconds 	            0 to 59
 * "minutes" 	Numeric representation of minutes 	            0 to 59
 * "hours" 	    Numeric representation of hours 	            0 to 23
 * "mday" 	    Numeric representation of the day of the month 	1 to 31
 * "wday" 	    Numeric representation of the day of the week 	0 (for Sunday) through 6 (for Saturday)
 * "mon" 	    Numeric representation of a month 	            1 through 12
 * "year" 	    A full numeric representation of a year,        4 digits 	Examples: 1999 or 2003
 * "yday" 	    Numeric representation of the day of the year   0 through 365
 * "weekday" 	A full textual representation of the day of the week 	Sunday through Saturday
 * "month" 	    A full textual representation of a month, such as January or March 	January through December
 * 0 	        Seconds since the Unix Epoch, similar to the values returned by time() and used by date(). 
 * NOTE:
 *   NULL is returned on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_getdate</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sytm</name></type> <name>sTm</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
		<decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>sOS</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SYSTEMTIME_TO_SYTM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Use the given timestamp */</comment>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal></expr></cpp:if> <comment type="block">/* Visual Studio 2005 and up */</comment>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4996</name><name>)</name></cpp:pragma> <comment type="block">/* _CRT_SECURE...*/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pTm</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Element value */</comment>
	<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>jx9_context_new_scalar</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pValue</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create a new array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fill the array */</comment>
	<comment type="block">/* Seconds */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"seconds"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Minutes */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"minutes"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Hours */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_hour</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"hours"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* mday */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"mday"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* wday */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_wday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"wday"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* mon */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_mon</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"mon"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* year */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"year"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* yday */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_yday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"yday"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Weekday */</comment>
	<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><call><name>SyTimeGetDay</name><argument_list>(<argument><expr><name><name>sTm</name><operator>.</operator><name>tm_wday</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"weekday"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Month */</comment>
	<expr_stmt><expr><call><name>jx9_value_reset_string_cursor</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><call><name>SyTimeGetMonth</name><argument_list>(<argument><expr><name><name>sTm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"month"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Seconds since the epoch */</comment>
	<expr_stmt><expr><call><name>jx9_value_int64</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><operator>(</operator><name>jx9_int64</name><operator>)</operator><call><name>time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* Index zero */</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Return the freshly created array */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * mixed gettimeofday([ bool $return_float = false ] )
 *   Returns an associative array containing the data returned from the system call.
 * Parameters
 *  $return_float
 *   When set to TRUE, a float instead of an array is returned.
 * Return
 *   By default an array is returned. If return_float is set, then
 *   a float is returned. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_gettimeofday</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>bFloat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sytime</name></type> <name>sTime</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__UNIXES__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sTime</name><operator>.</operator><name>tm_sec</name></name>  <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sTime</name><operator>.</operator><name>tm_usec</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sTime</name><operator>.</operator><name>tm_sec</name></name>  <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>tt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sTime</name><operator>.</operator><name>tm_usec</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>tt</name><operator>%</operator><name>SX_USEC_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __UNIXES__ */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>bFloat</name> <operator>=</operator> <call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>bFloat</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return as float */</comment>
		<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name><name>sTime</name><operator>.</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Return an associative array */</comment>
		<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
		<comment type="block">/* Create a new array */</comment>
		<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Element value */</comment>
		<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>jx9_context_new_scalar</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pValue</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Return NULL */</comment>
			<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Fill the array */</comment>
		<comment type="block">/* sec */</comment>
		<expr_stmt><expr><call><name>jx9_value_int64</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTime</name><operator>.</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"sec"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* usec */</comment>
		<expr_stmt><expr><call><name>jx9_value_int64</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTime</name><operator>.</operator><name>tm_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"usec"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Return the array */</comment>
		<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Check if the given year is leap or not */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LEAP_YEAR</name><parameter_list>(<parameter><type><name>YEAR</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(YEAR % 400 ? ( YEAR % 100 ? ( YEAR % 4 ? 0 : 1 ) : 0 ) : 1)</cpp:value></cpp:define>
<comment type="block">/* ISO-8601 numeric representation of the day of the week */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>aISO8601</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">7</literal></expr> <comment type="block">/* Sunday */</comment>, <expr><literal type="number">1</literal></expr> <comment type="block">/* Monday */</comment>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Format a given date string.
 * Supported format: (Taken from JX9 online docs)
 * character 	Description
 * d          Day of the month 
 * D          A textual representation of a days
 * j          Day of the month without leading zeros
 * l          A full textual representation of the day of the week 	
 * N          ISO-8601 numeric representation of the day of the week 
 * w          Numeric representation of the day of the week
 * z          The day of the year (starting from 0) 	
 * F          A full textual representation of a month, such as January or March
 * m          Numeric representation of a month, with leading zeros 	01 through 12
 * M          A short textual representation of a month, three letters 	Jan through Dec
 * n          Numeric representation of a month, without leading zeros 	1 through 12
 * t          Number of days in the given month 	28 through 31
 * L          Whether it's a leap year 	1 if it is a leap year, 0 otherwise.
 * o          ISO-8601 year number. This has the same value as Y, except that if the ISO week number
 *            (W) belongs to the previous or next year, that year is used instead. (added in JX9 5.1.0) Examples: 1999 or 2003
 * Y          A full numeric representation of a year, 4 digits 	Examples: 1999 or 2003
 * y          A two digit representation of a year 	Examples: 99 or 03
 * a          Lowercase Ante meridiem and Post meridiem 	am or pm
 * A          Uppercase Ante meridiem and Post meridiem 	AM or PM
 * g          12-hour format of an hour without leading zeros 	1 through 12
 * G          24-hour format of an hour without leading zeros 	0 through 23
 * h          12-hour format of an hour with leading zeros 	01 through 12
 * H          24-hour format of an hour with leading zeros 	00 through 23
 * i          Minutes with leading zeros 	00 to 59
 * s          Seconds, with leading zeros 	00 through 59
 * u          Microseconds Example: 654321
 * e          Timezone identifier 	Examples: UTC, GMT, Atlantic/Azores
 * I          (capital i) Whether or not the date is in daylight saving time 	1 if Daylight Saving Time, 0 otherwise.
 * r          RFC 2822 formatted date 	Example: Thu, 21 Dec 2000 16:01:07 +0200
 * U          Seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)
 * S          English ordinal suffix for the day of the month, 2 characters
 * O          Difference to Greenwich time (GMT) in hours
 * Z          Timezone offset in seconds. The offset for timezones west of UTC is always negative, and for those
 *            east of UTC is always positive.
 * c         ISO 8601 date
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>DateFormat</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>Sytm</name> <modifier>*</modifier></type><name>pTm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>;</decl_stmt>
	<comment type="block">/* Start the format process */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<switch>switch<condition>(<expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block>{<block_content>
		<case>case <expr><literal type="char">'d'</literal></expr>:</case>
			<comment type="block">/* Day of the month, 2 digits with leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'D'</literal></expr>:</case>
			<comment type="block">/*A textual representation of a day, three letters*/</comment>
			<expr_stmt><expr><name>zCur</name> <operator>=</operator> <call><name>SyTimeGetDay</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'j'</literal></expr>:</case>
			<comment type="block">/*	Day of the month without leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'l'</literal></expr>:</case>
			<comment type="block">/* A full textual representation of the day of the week */</comment>
			<expr_stmt><expr><name>zCur</name> <operator>=</operator> <call><name>SyTimeGetDay</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument><comment type="block">/*Compute length automatically*/</comment>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'N'</literal></expr>:</case><block>{<block_content>
			<comment type="block">/* ISO-8601 numeric representation of the day of the week */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>aISO8601</name><index>[<expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>%</operator> <literal type="number">7</literal></expr> ]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
				 </block_content>}</block>
		<case>case <expr><literal type="char">'w'</literal></expr>:</case>
			<comment type="block">/*Numeric representation of the day of the week*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'z'</literal></expr>:</case>
			<comment type="block">/*The day of the year*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_yday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'F'</literal></expr>:</case>
			<comment type="block">/*A full textual representation of a month, such as January or March*/</comment>
			<expr_stmt><expr><name>zCur</name> <operator>=</operator> <call><name>SyTimeGetMonth</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument><comment type="block">/*Compute length automatically*/</comment>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'m'</literal></expr>:</case>
			<comment type="block">/*Numeric representation of a month, with leading zeros*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'M'</literal></expr>:</case>
			<comment type="block">/*A short textual representation of a month, three letters*/</comment>
			<expr_stmt><expr><name>zCur</name> <operator>=</operator> <call><name>SyTimeGetMonth</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'n'</literal></expr>:</case>
			<comment type="block">/*Numeric representation of a month, without leading zeros*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'t'</literal></expr>:</case><block>{<block_content>
			<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>aMonDays</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">31</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>nDays</name> <init>= <expr><name><name>aMonDays</name><index>[<expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>%</operator> <literal type="number">12</literal></expr> ]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>==</operator> <literal type="number">1</literal> <comment type="block">/* 'February' */</comment> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_LEAP_YEAR</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>nDays</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/*Number of days in the given month*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>nDays</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
				 </block_content>}</block>
		<case>case <expr><literal type="char">'L'</literal></expr>:</case><block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>isLeap</name> <init>= <expr><call><name>IS_LEAP_YEAR</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Whether it's a leap year */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>isLeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
				 </block_content>}</block>
		<case>case <expr><literal type="char">'o'</literal></expr>:</case>
			<comment type="block">/* ISO-8601 year number.*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%4d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
			<comment type="block">/*	A full numeric representation of a year, 4 digits */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%4d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'y'</literal></expr>:</case>
			<comment type="block">/*A two digit representation of a year*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name><operator>%</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'a'</literal></expr>:</case>
			<comment type="block">/*	Lowercase Ante meridiem and Post meridiem */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <literal type="number">12</literal></expr> ?</condition><then> <expr><literal type="string">"pm"</literal></expr> </then><else>: <expr><literal type="string">"am"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'A'</literal></expr>:</case>
			<comment type="block">/*	Uppercase Ante meridiem and Post meridiem */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <literal type="number">12</literal></expr> ?</condition><then> <expr><literal type="string">"PM"</literal></expr> </then><else>: <expr><literal type="string">"AM"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'g'</literal></expr>:</case>
			<comment type="block">/*	12-hour format of an hour without leading zeros*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><operator>(</operator><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>%</operator><literal type="number">12</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'G'</literal></expr>:</case>
			<comment type="block">/* 24-hour format of an hour without leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'h'</literal></expr>:</case>
			<comment type="block">/* 12-hour format of an hour with leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><operator>(</operator><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>%</operator><literal type="number">12</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'H'</literal></expr>:</case>
			<comment type="block">/*	24-hour format of an hour with leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'i'</literal></expr>:</case>
			<comment type="block">/* 	Minutes with leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'s'</literal></expr>:</case>
			<comment type="block">/* 	second with leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'u'</literal></expr>:</case>
			<comment type="block">/* 	Microseconds */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <name>SX_USEC_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'S'</literal></expr>:</case><block>{<block_content>
			<comment type="block">/* English ordinal suffix for the day of the month, 2 characters */</comment>
			<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zSuffix</name><index>[]</index></name> <init>= <expr><literal type="string">"thstndrdthththththth"</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zSuffix</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>v</name> <operator>/</operator> <literal type="number">10</literal> <operator>%</operator> <literal type="number">10</literal> <operator>!=</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>v</name> <operator>%</operator> <literal type="number">10</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
				 </block_content>}</block>
		<case>case <expr><literal type="char">'e'</literal></expr>:</case>
			<comment type="block">/* 	Timezone identifier */</comment>
			<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name><name>pTm</name><operator>-&gt;</operator><name>tm_zone</name></name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Assume GMT */</comment>
				<expr_stmt><expr><name>zCur</name> <operator>=</operator> <literal type="string">"GMT"</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'I'</literal></expr>:</case>
			<comment type="block">/* Whether or not the date is in daylight saving time */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32_WCE</name></cpp:ifndef>
			<expr_stmt><expr><call><name>_get_daylight</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTm</name><operator>-&gt;</operator><name>tm_isdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'r'</literal></expr>:</case>
			<comment type="block">/* RFC 2822 formatted date 	Example: Thu, 21 Dec 2000 16:01:07 */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%.3s, %02d %.3s %4d %02d:%02d:%02d"</literal></expr></argument>, 
				<argument><expr><call><name>SyTimeGetDay</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr></argument>)</argument_list></call></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, 
				<argument><expr><call><name>SyTimeGetMonth</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>)</argument_list></call></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'U'</literal></expr>:</case><block>{<block_content>
			<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name></decl>;</decl_stmt>
			<comment type="block">/* Seconds since the Unix Epoch */</comment>
			<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
				 </block_content>}</block>
		<case>case <expr><literal type="char">'O'</literal></expr>:</case>
		<case>case <expr><literal type="char">'P'</literal></expr>:</case>
			<comment type="block">/* Difference to Greenwich time (GMT) in hours */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%+05d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'Z'</literal></expr>:</case>
			<comment type="block">/* Timezone offset in seconds. The offset for timezones west of UTC
			 * is always negative, and for those east of UTC is always positive.
			 */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%+05d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'c'</literal></expr>:</case>
			<comment type="block">/* 	ISO 8601 date */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%4d-%02d-%02dT%02d:%02d:%02d%+05d"</literal></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* Expand verbatim */</comment>
			<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* Unknown format specifer, expand verbatim */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>
		<comment type="block">/* Point to the next character */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * JX9 implementation of the strftime() function.
 * The following formats are supported:
 * %a 	An abbreviated textual representation of the day
 * %A 	A full textual representation of the day
 * %d 	Two-digit day of the month (with leading zeros)
 * %e 	Day of the month, with a space preceding single digits.
 * %j 	Day of the year, 3 digits with leading zeros 
 * %u 	ISO-8601 numeric representation of the day of the week 	1 (for Monday) though 7 (for Sunday)
 * %w 	Numeric representation of the day of the week 0 (for Sunday) through 6 (for Saturday)
 * %U 	Week number of the given year, starting with the first Sunday as the first week
 * %V 	ISO-8601:1988 week number of the given year, starting with the first week of the year with at least
 *   4 weekdays, with Monday being the start of the week.
 * %W 	A numeric representation of the week of the year
 * %b 	Abbreviated month name, based on the locale
 * %B 	Full month name, based on the locale
 * %h 	Abbreviated month name, based on the locale (an alias of %b)
 * %m 	Two digit representation of the month
 * %C 	Two digit representation of the century (year divided by 100, truncated to an integer)
 * %g 	Two digit representation of the year going by ISO-8601:1988 standards (see %V)
 * %G 	The full four-digit version of %g
 * %y 	Two digit representation of the year
 * %Y 	Four digit representation for the year
 * %H 	Two digit representation of the hour in 24-hour format
 * %I 	Two digit representation of the hour in 12-hour format
 * %l (lower-case 'L') 	Hour in 12-hour format, with a space preceeding single digits
 * %M 	Two digit representation of the minute
 * %p 	UPPER-CASE 'AM' or 'PM' based on the given time
 * %P 	lower-case 'am' or 'pm' based on the given time
 * %r 	Same as "%I:%M:%S %p"
 * %R 	Same as "%H:%M"
 * %S 	Two digit representation of the second
 * %T 	Same as "%H:%M:%S"
 * %X 	Preferred time representation based on locale, without the date
 * %z 	Either the time zone offset from UTC or the abbreviation
 * %Z 	The time zone offset/abbreviation option NOT given by %z
 * %c 	Preferred date and time stamp based on local
 * %D 	Same as "%m/%d/%y"
 * %F 	Same as "%Y-%m-%d"
 * %s 	Unix Epoch Time timestamp (same as the time() function)
 * %x 	Preferred date representation based on locale, without the time
 * %n 	A newline character ("\n")
 * %t 	A Tab character ("\t")
 * %% 	A literal percentage character ("%")
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Strftime</name><parameter_list>(
	<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,  <comment type="block">/* Call context */</comment>
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>,    <comment type="block">/* Input string */</comment>
	<parameter><decl><type><name>int</name></type> <name>nLen</name></decl></parameter>,           <comment type="block">/* Input length */</comment>
	<parameter><decl><type><name>Sytm</name> <modifier>*</modifier></type><name>pTm</name></decl></parameter>           <comment type="block">/* Parse of the given time */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<comment type="block">/* Start the format process */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		<while>while<condition>(<expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;</operator> <name>zCur</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Consume input verbatim */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the percent sign */</comment>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more input to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Act according to the current specifer */</comment>
		<switch>switch<condition>(<expr><name>c</name></expr>)</condition><block>{<block_content>
		<case>case <expr><literal type="char">'%'</literal></expr>:</case>
			<comment type="block">/* A literal percentage character ("%") */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'t'</literal></expr>:</case>
			<comment type="block">/* A Tab character */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"\t"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'n'</literal></expr>:</case>
			<comment type="block">/* A newline character */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'a'</literal></expr>:</case>
			<comment type="block">/* An abbreviated textual representation of the day */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>SyTimeGetDay</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'A'</literal></expr>:</case>
			<comment type="block">/* A full textual representation of the day */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>SyTimeGetDay</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument><comment type="block">/*Compute length automatically*/</comment>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'e'</literal></expr>:</case>
			<comment type="block">/* Day of the month, 2 digits with leading space for single digit*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%2d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'d'</literal></expr>:</case>
			<comment type="block">/* Two-digit day of the month (with leading zeros) */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'j'</literal></expr>:</case>
			<comment type="block">/*The day of the year, 3 digits with leading zeros*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%03d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_yday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'u'</literal></expr>:</case>
			<comment type="block">/* ISO-8601 numeric representation of the day of the week */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>aISO8601</name><index>[<expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>%</operator> <literal type="number">7</literal></expr> ]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'w'</literal></expr>:</case>
			<comment type="block">/* Numeric representation of the day of the week */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'b'</literal></expr>:</case>
		<case>case <expr><literal type="char">'h'</literal></expr>:</case>
			<comment type="block">/*A short textual representation of a month, three letters (Not based on locale)*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>SyTimeGetMonth</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'B'</literal></expr>:</case>
			<comment type="block">/* Full month name (Not based on locale) */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>SyTimeGetMonth</name><argument_list>(<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument><comment type="block">/*Compute length automatically*/</comment>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'m'</literal></expr>:</case>
			<comment type="block">/*Numeric representation of a month, with leading zeros*/</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'C'</literal></expr>:</case>
			<comment type="block">/* Two digit representation of the century */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%2d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name><operator>/</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'y'</literal></expr>:</case>
		<case>case <expr><literal type="char">'g'</literal></expr>:</case>
			<comment type="block">/* Two digit representation of the year */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%2d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name><operator>%</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
		<case>case <expr><literal type="char">'G'</literal></expr>:</case>
			<comment type="block">/* Four digit representation of the year */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%4d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'I'</literal></expr>:</case>
			<comment type="block">/* 12-hour format of an hour with leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><operator>(</operator><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>%</operator><literal type="number">12</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'l'</literal></expr>:</case>
			<comment type="block">/* 12-hour format of an hour with leading space */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%2d"</literal></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><operator>(</operator><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>%</operator><literal type="number">12</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'H'</literal></expr>:</case>
			<comment type="block">/* 24-hour format of an hour with leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'M'</literal></expr>:</case>
			<comment type="block">/* Minutes with leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'S'</literal></expr>:</case>
			<comment type="block">/* Seconds with leading zeros */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'z'</literal></expr>:</case>
		<case>case <expr><literal type="char">'Z'</literal></expr>:</case>
			<comment type="block">/* 	Timezone identifier */</comment>
			<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name><name>pTm</name><operator>-&gt;</operator><name>tm_zone</name></name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Assume GMT */</comment>
				<expr_stmt><expr><name>zCur</name> <operator>=</operator> <literal type="string">"GMT"</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'T'</literal></expr>:</case>
		<case>case <expr><literal type="char">'X'</literal></expr>:</case>
			<comment type="block">/* Same as "%H:%M:%S" */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d:%02d:%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'R'</literal></expr>:</case>
			<comment type="block">/* Same as "%H:%M" */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d:%02d"</literal></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'P'</literal></expr>:</case>
			<comment type="block">/*	Lowercase Ante meridiem and Post meridiem */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <literal type="number">12</literal></expr> ?</condition><then> <expr><literal type="string">"pm"</literal></expr> </then><else>: <expr><literal type="string">"am"</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'p'</literal></expr>:</case>
			<comment type="block">/*	Uppercase Ante meridiem and Post meridiem */</comment>
			<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <literal type="number">12</literal></expr> ?</condition><then> <expr><literal type="string">"PM"</literal></expr> </then><else>: <expr><literal type="string">"AM"</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'r'</literal></expr>:</case>
			<comment type="block">/* Same as "%I:%M:%S %p" */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d:%02d:%02d %s"</literal></expr></argument>, 
				<argument><expr><literal type="number">1</literal><operator>+</operator><operator>(</operator><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>%</operator><literal type="number">12</literal><operator>)</operator></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>, 
				<argument><expr><ternary><condition><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <literal type="number">12</literal></expr> ?</condition><then> <expr><literal type="string">"PM"</literal></expr> </then><else>: <expr><literal type="string">"AM"</literal></expr></else></ternary></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'D'</literal></expr>:</case>
		<case>case <expr><literal type="char">'x'</literal></expr>:</case>
			<comment type="block">/* Same as "%m/%d/%y" */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%02d/%02d/%02d"</literal></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name><operator>%</operator><literal type="number">100</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'F'</literal></expr>:</case>
			<comment type="block">/* Same as "%Y-%m-%d" */</comment>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d-%02d-%02d"</literal></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'c'</literal></expr>:</case>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%d-%02d-%02d %02d:%02d:%02d"</literal></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, 
				<argument><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'s'</literal></expr>:</case><block>{<block_content>
			<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name></decl>;</decl_stmt>
			<comment type="block">/* Seconds since the Unix Epoch */</comment>
			<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9_result_string_format</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
				 </block_content>}</block>
		<default>default:</default>
			<comment type="block">/* unknown specifer, simply ignore*/</comment>
			<break>break;</break>
		</block_content>}</block></switch>
		<comment type="block">/* Advance the cursor */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string date(string $format [, int $timestamp = time() ] )
 *  Returns a string formatted according to the given format string using
 *  the given integer timestamp or the current time if no timestamp is given.
 *  In other words, timestamp is optional and defaults to the value of time(). 
 * Parameters
 *  $format
 *   The format of the outputted date string (See code above)
 * $timestamp
 *   The optional timestamp parameter is an integer Unix timestamp
 *   that defaults to the current local time if a timestamp is not given.
 *   In other words, it defaults to the value of time(). 
 * Return
 *  A formatted date string. If a non-numeric value is used for timestamp, FALSE is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_date</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sytm</name></type> <name>sTm</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zFormat</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother processing return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
		<decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>sOS</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SYSTEMTIME_TO_SYTM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Use the given timestamp */</comment>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pTm</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Format the given string */</comment>
	<expr_stmt><expr><call><name>DateFormat</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string strftime(string $format [, int $timestamp = time() ] )
 *  Format a local time/date (PLATFORM INDEPENDANT IMPLEENTATION NOT BASED ON LOCALE)
 * Parameters
 *  $format
 *   The format of the outputted date string (See code above)
 * $timestamp
 *   The optional timestamp parameter is an integer Unix timestamp
 *   that defaults to the current local time if a timestamp is not given.
 *   In other words, it defaults to the value of time(). 
 * Return
 * Returns a string formatted according format using the given timestamp
 * or the current local time if no timestamp is given.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_strftime</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sytm</name></type> <name>sTm</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zFormat</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother processing return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
		<decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>sOS</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SYSTEMTIME_TO_SYTM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Use the given timestamp */</comment>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pTm</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Format the given string */</comment>
	<expr_stmt><expr><call><name>jx9Strftime</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>jx9_context_result_buf_length</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing was formatted, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string gmdate(string $format [, int $timestamp = time() ] )
 *  Identical to the date() function except that the time returned
 *  is Greenwich Mean Time (GMT).
 * Parameters
 *  $format
 *  The format of the outputted date string (See code above)
 *  $timestamp
 *   The optional timestamp parameter is an integer Unix timestamp
 *   that defaults to the current local time if a timestamp is not given.
 *   In other words, it defaults to the value of time(). 
 * Return
 *  A formatted date string. If a non-numeric value is used for timestamp, FALSE is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_gmdate</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sytm</name></type> <name>sTm</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zFormat</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother processing return the empty string */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
		<decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>sOS</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SYSTEMTIME_TO_SYTM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Use the given timestamp */</comment>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pTm</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Format the given string */</comment>
	<expr_stmt><expr><call><name>DateFormat</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array localtime([ int $timestamp = time() [, bool $is_associative = false ]])
 *  Return the local time.
 * Parameter
 *  $timestamp: The optional timestamp parameter is an integer Unix timestamp
 *     that defaults to the current local time if a timestamp is not given.
 *     In other words, it defaults to the value of time().
 * $is_associative
 *   If set to FALSE or not supplied then the array is returned as a regular, numerically
 *   indexed array. If the argument is set to TRUE then localtime() returns an associative
 *   array containing all the different elements of the structure returned by the C function
 *   call to localtime. The names of the different keys of the associative array are as follows:
 *      "tm_sec" - seconds, 0 to 59
 *      "tm_min" - minutes, 0 to 59
 *      "tm_hour" - hours, 0 to 23
 *      "tm_mday" - day of the month, 1 to 31
 *      "tm_mon" - month of the year, 0 (Jan) to 11 (Dec)
 *      "tm_year" - years since 1900
 *      "tm_wday" - day of the week, 0 (Sun) to 6 (Sat)
 *      "tm_yday" - day of the year, 0 to 365
 *      "tm_isdst" - is daylight savings time in effect? Positive if yes, 0 if not, negative if unknown.
 * Returns
 *  An associative array of information related to the timestamp.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_localtime</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>isAssoc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sytm</name></type> <name>sTm</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
		<decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>sOS</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* TODO(chems): GMT not local */</comment>
		<expr_stmt><expr><call><name>SYSTEMTIME_TO_SYTM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Use the given timestamp */</comment>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pTm</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Element value */</comment>
	<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>jx9_context_new_scalar</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pValue</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create a new array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>isAssoc</name> <operator>=</operator> <call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fill the array */</comment>
	<comment type="block">/* Seconds */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>isAssoc</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"tm_sec"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index */</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Minutes */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>isAssoc</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"tm_min"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index */</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Hours */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_hour</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>isAssoc</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"tm_hour"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index */</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* mday */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>isAssoc</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"tm_mday"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index */</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* mon */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>isAssoc</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"tm_mon"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index */</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* year since 1900 */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_year</name></name><operator>-</operator><literal type="number">1900</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>isAssoc</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"tm_year"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index */</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* wday */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_wday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>isAssoc</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"tm_wday"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index */</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* yday */</comment>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_yday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>isAssoc</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"tm_yday"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index */</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* isdst */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32_WCE</name></cpp:ifndef>
			<expr_stmt><expr><call><name>_get_daylight</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sTm</name><operator>.</operator><name>tm_isdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>jx9_value_int</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name><name>sTm</name><operator>.</operator><name>tm_isdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>isAssoc</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"tm_isdst"</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index */</comment>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Return the array */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int idate(string $format [, int $timestamp = time() ])
 *  Returns a number formatted according to the given format string
 *  using the given integer timestamp or the current local time if 
 *  no timestamp is given. In other words, timestamp is optional and defaults
 *  to the value of time().
 *  Unlike the function date(), idate() accepts just one char in the format
 *  parameter.
 * $Parameters
 *  Supported format
 *   d 	Day of the month
 *   h 	Hour (12 hour format)
 *   H 	Hour (24 hour format)
 *   i 	Minutes
 *   I (uppercase i)1 if DST is activated, 0 otherwise
 *   L (uppercase l) returns 1 for leap year, 0 otherwise
 *   m 	Month number
 *   s 	Seconds
 *   t 	Days in current month
 *   U 	Seconds since the Unix Epoch - January 1 1970 00:00:00 UTC - this is the same as time()
 *   w 	Day of the week (0 on Sunday)
 *   W 	ISO-8601 week number of year, weeks starting on Monday
 *   y 	Year (1 or 2 digits - check note below)
 *   Y 	Year (4 digits)
 *   z 	Day of the year
 *   Z 	Timezone offset in seconds
 * $timestamp
 *  The optional timestamp parameter is an integer Unix timestamp that defaults
 *  to the current local time if a timestamp is not given. In other words, it defaults
 *  to the value of time(). 
 * Return
 *  An integer. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_idate</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sytm</name></type> <name>sTm</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid argument, return -1 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zFormat</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother processing return -1*/</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
		<decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>sOS</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SYSTEMTIME_TO_SYTM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sOS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Use the given timestamp */</comment>
		<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>jx9_value_to_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pTm</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<switch>switch<condition>(<expr><name><name>zFormat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block>{<block_content>
	<case>case <expr><literal type="char">'d'</literal></expr>:</case>
		<comment type="block">/* Day of the month */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_mday</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'h'</literal></expr>:</case>
		<comment type="block">/*	Hour (12 hour format)*/</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name><name>sTm</name><operator>.</operator><name>tm_hour</name></name> <operator>%</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'H'</literal></expr>:</case>
		<comment type="block">/* Hour (24 hour format)*/</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_hour</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'i'</literal></expr>:</case>
		<comment type="block">/*Minutes*/</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_min</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'I'</literal></expr>:</case>
		<comment type="block">/*	returns 1 if DST is activated, 0 otherwise */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32_WCE</name></cpp:ifndef>
			<expr_stmt><expr><call><name>_get_daylight</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sTm</name><operator>.</operator><name>tm_isdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_isdst</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'L'</literal></expr>:</case>
		<comment type="block">/* 	returns 1 for leap year, 0 otherwise */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>IS_LEAP_YEAR</name><argument_list>(<argument><expr><name><name>sTm</name><operator>.</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'m'</literal></expr>:</case>
		<comment type="block">/* Month number*/</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_mon</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'s'</literal></expr>:</case>
		<comment type="block">/*Seconds*/</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_sec</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'t'</literal></expr>:</case><block>{<block_content>
		<comment type="block">/*Days in current month*/</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>aMonDays</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">31</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nDays</name> <init>= <expr><name><name>aMonDays</name><index>[<expr><name><name>sTm</name><operator>.</operator><name>tm_mon</name></name> <operator>%</operator> <literal type="number">12</literal></expr> ]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>sTm</name><operator>.</operator><name>tm_mon</name></name> <operator>==</operator> <literal type="number">1</literal> <comment type="block">/* 'February' */</comment> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_LEAP_YEAR</name><argument_list>(<argument><expr><name><name>sTm</name><operator>.</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nDays</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name>nDays</name></expr>;</expr_stmt>
		<break>break;</break>
			 </block_content>}</block>
	<case>case <expr><literal type="char">'U'</literal></expr>:</case>
		<comment type="block">/*Seconds since the Unix Epoch*/</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <operator>(</operator><name>jx9_int64</name><operator>)</operator><call><name>time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'w'</literal></expr>:</case>
		<comment type="block">/*	Day of the week (0 on Sunday) */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_wday</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'W'</literal></expr>:</case> <block>{<block_content>
		<comment type="block">/* ISO-8601 week number of year, weeks starting on Monday */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>aISO8601</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">7</literal></expr> <comment type="block">/* Sunday */</comment>, <expr><literal type="number">1</literal></expr> <comment type="block">/* Monday */</comment>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>aISO8601</name><index>[<expr><name><name>sTm</name><operator>.</operator><name>tm_wday</name></name> <operator>%</operator> <literal type="number">7</literal></expr> ]</index></name></expr>;</expr_stmt>
		<break>break;</break>
			  </block_content>}</block>
	<case>case <expr><literal type="char">'y'</literal></expr>:</case>
		<comment type="block">/* Year (2 digits) */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_year</name></name> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
		<comment type="block">/* Year (4 digits) */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_year</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'z'</literal></expr>:</case>
		<comment type="block">/* Day of the year */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_yday</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><literal type="char">'Z'</literal></expr>:</case>
		<comment type="block">/*Timezone offset in seconds*/</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <name><name>sTm</name><operator>.</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<comment type="block">/* unknown format, throw a warning */</comment>
		<expr_stmt><expr><call><name>jx9_context_throw_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>JX9_CTX_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Unknown date format token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></switch>
	<comment type="block">/* Return the time value */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int mktime/gmmktime([ int $hour = date("H") [, int $minute = date("i") [, int $second = date("s") 
 *  [, int $month = date("n") [, int $day = date("j") [, int $year = date("Y") [, int $is_dst = -1 ]]]]]]] )
 *  Returns the Unix timestamp corresponding to the arguments given. This timestamp is a 64bit integer 
 *  containing the number of seconds between the Unix Epoch (January 1 1970 00:00:00 GMT) and the time
 *  specified.
 *  Arguments may be left out in order from right to left; any arguments thus omitted will be set to
 *  the current value according to the local date and time.
 * Parameters
 * $hour
 *  The number of the hour relevant to the start of the day determined by month, day and year.
 *  Negative values reference the hour before midnight of the day in question. Values greater
 *  than 23 reference the appropriate hour in the following day(s).
 * $minute
 *  The number of the minute relevant to the start of the hour. Negative values reference
 *  the minute in the previous hour. Values greater than 59 reference the appropriate minute
 *  in the following hour(s).
 * $second
 *  The number of seconds relevant to the start of the minute. Negative values reference 
 *  the second in the previous minute. Values greater than 59 reference the appropriate 
 * second in the following minute(s).
 * $month
 *  The number of the month relevant to the end of the previous year. Values 1 to 12 reference
 *  the normal calendar months of the year in question. Values less than 1 (including negative values)
 *  reference the months in the previous year in reverse order, so 0 is December, -1 is November)...
 * $day
 *  The number of the day relevant to the end of the previous month. Values 1 to 28, 29, 30 or 31 
 *  (depending upon the month) reference the normal days in the relevant month. Values less than 1
 *  (including negative values) reference the days in the previous month, so 0 is the last day 
 *  of the previous month, -1 is the day before that, etc. Values greater than the number of days
 *  in the relevant month reference the appropriate day in the following month(s).
 * $year
 *  The number of the year, may be a two or four digit value, with values between 0-69 mapping
 *  to 2000-2069 and 70-100 to 1970-2000. On systems where time_t is a 32bit signed integer, as 
 *  most common today, the valid range for year is somewhere between 1901 and 2038.
 * $is_dst
 *  This parameter can be set to 1 if the time is during daylight savings time (DST), 0 if it is not, 
 *  or -1 (the default) if it is unknown whether the time is within daylight savings time or not. 
 * Return
 *   mktime() returns the Unix timestamp of the arguments given. 
 *   If the arguments are invalid, the function returns FALSE
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_mktime</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_int64</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
	<comment type="block">/* Extract function name */</comment>
	<expr_stmt><expr><name>zFunction</name> <operator>=</operator> <call><name>jx9_function_name</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Get the current time */</comment>
	<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>zFunction</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'g'</literal></expr> <comment type="block">/* gmmktime */</comment> )</condition><block>{<block_content>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* localtime */</comment>
		<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>iVal</name></decl>;</decl_stmt>
		<comment type="block">/* Hour */</comment>
		<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Minutes */</comment>
			<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Seconds */</comment>
				<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
					<comment type="block">/* Month */</comment>
					<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name>iVal</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">4</literal></expr> )</condition><block>{<block_content>
						<comment type="block">/* mday */</comment>
						<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
						<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">5</literal></expr> )</condition><block>{<block_content>
							<comment type="block">/* Year */</comment>
							<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if<condition>( <expr><name>iVal</name> <operator>&gt;</operator> <literal type="number">1900</literal></expr> )</condition><block>{<block_content>
								<expr_stmt><expr><name>iVal</name> <operator>-=</operator> <literal type="number">1900</literal></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
							<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">6</literal></expr> )</condition><block>{<block_content>
								<comment type="block">/* is_dst */</comment>
								<expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>pTm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make the time */</comment>
	<expr_stmt><expr><name>iVal</name> <operator>=</operator> <operator>(</operator><name>jx9_int64</name><operator>)</operator><call><name>mktime</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Return the timesatmp as a 64bit integer */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Section:
 *    URL handling Functions.
 * Authors:
 *    Symisc Systems, devel@symisc.net.
 *    Copyright (C) Symisc Systems, http://jx9.symisc.net
 * Status:
 *    Stable.
 */</comment>
<comment type="block">/*
 * Output consumer callback for the standard Symisc routines.
 * [i.e: SyBase64Encode(), SyBase64Decode(), SyUriEncode(), ...].
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>Consumer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Store in the call context result buffer */</comment>
	<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><operator>(</operator><name>jx9_context</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string base64_encode(string $data)
 * string convert_uuencode(string $data)  
 *  Encodes data with MIME base64
 * Parameter
 *  $data
 *    Data to encode
 * Return
 *  Encoded data or FALSE on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_base64_encode</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the input string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to process, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the BASE64 encoding */</comment>
	<expr_stmt><expr><call><name>SyBase64Encode</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>Consumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string base64_decode(string $data)
 * string convert_uudecode(string $data)
 *  Decodes data encoded with MIME base64
 * Parameter
 *  $data
 *    Encoded data.
 * Return
 *  Returns the original data or FALSE on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_base64_decode</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the input string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to process, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the BASE64 decoding */</comment>
	<expr_stmt><expr><call><name>SyBase64Decode</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>Consumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string urlencode(string $str)
 *  URL encoding
 * Parameter
 *  $data
 *   Input string.
 * Return
 *  Returns a string in which all non-alphanumeric characters except -_. have
 *  been replaced with a percent (%) sign followed by two hex digits and spaces
 *  encoded as plus (+) signs.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_urlencode</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the input string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to process, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the URL encoding */</comment>
	<expr_stmt><expr><call><name>SyUriEncode</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>Consumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * string urldecode(string $str)
 *  Decodes any %## encoding in the given string.
 *  Plus symbols ('+') are decoded to a space character. 
 * Parameter
 *  $data
 *    Input string.
 * Return
 *  Decoded URL or FALSE on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9Builtin_urldecode</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nLen</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract the input string */</comment>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to process, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the URL decoding */</comment>
	<expr_stmt><expr><call><name>SyUriDecode</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>, <argument><expr><name>Consumer</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
<comment type="block">/* Table of the built-in functions */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>jx9_builtin_func</name></type> <name><name>aBuiltInFunc</name><index>[]</index></name> <init>= <expr><block>{
	   <comment type="block">/* Variable handling functions */</comment>
	<expr><block>{ <expr><literal type="string">"is_bool"</literal></expr>    , <expr><name>jx9Builtin_is_bool</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_float"</literal></expr>   , <expr><name>jx9Builtin_is_float</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_real"</literal></expr>    , <expr><name>jx9Builtin_is_float</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_double"</literal></expr>  , <expr><name>jx9Builtin_is_float</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_int"</literal></expr>     , <expr><name>jx9Builtin_is_int</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_integer"</literal></expr> , <expr><name>jx9Builtin_is_int</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_long"</literal></expr>    , <expr><name>jx9Builtin_is_int</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_string"</literal></expr>  , <expr><name>jx9Builtin_is_string</name></expr>   }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_null"</literal></expr>    , <expr><name>jx9Builtin_is_null</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_numeric"</literal></expr> , <expr><name>jx9Builtin_is_numeric</name></expr>  }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_scalar"</literal></expr>  , <expr><name>jx9Builtin_is_scalar</name></expr>   }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_array"</literal></expr>   , <expr><name>jx9Builtin_is_array</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_object"</literal></expr>  , <expr><name>jx9Builtin_is_object</name></expr>   }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"is_resource"</literal></expr>, <expr><name>jx9Builtin_is_resource</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"douleval"</literal></expr>   , <expr><name>jx9Builtin_floatval</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"floatval"</literal></expr>   , <expr><name>jx9Builtin_floatval</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"intval"</literal></expr>     , <expr><name>jx9Builtin_intval</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strval"</literal></expr>     , <expr><name>jx9Builtin_strval</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"empty"</literal></expr>      , <expr><name>jx9Builtin_empty</name></expr>       }</block></expr>, 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JX9_ENABLE_MATH_FUNC</name></cpp:ifdef>
	   <comment type="block">/* Math functions */</comment>
	<expr><block>{ <expr><literal type="string">"abs"</literal></expr>  ,    <expr><name>jx9Builtin_abs</name></expr>          }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"sqrt"</literal></expr> ,    <expr><name>jx9Builtin_sqrt</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"exp"</literal></expr>  ,    <expr><name>jx9Builtin_exp</name></expr>          }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"floor"</literal></expr>,    <expr><name>jx9Builtin_floor</name></expr>        }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"cos"</literal></expr>  ,    <expr><name>jx9Builtin_cos</name></expr>          }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"sin"</literal></expr>  ,    <expr><name>jx9Builtin_sin</name></expr>          }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"acos"</literal></expr> ,    <expr><name>jx9Builtin_acos</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"asin"</literal></expr> ,    <expr><name>jx9Builtin_asin</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"cosh"</literal></expr> ,    <expr><name>jx9Builtin_cosh</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"sinh"</literal></expr> ,    <expr><name>jx9Builtin_sinh</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ceil"</literal></expr> ,    <expr><name>jx9Builtin_ceil</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"tan"</literal></expr>  ,    <expr><name>jx9Builtin_tan</name></expr>          }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"tanh"</literal></expr> ,    <expr><name>jx9Builtin_tanh</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"atan"</literal></expr> ,    <expr><name>jx9Builtin_atan</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"atan2"</literal></expr>,    <expr><name>jx9Builtin_atan2</name></expr>        }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"log"</literal></expr>  ,    <expr><name>jx9Builtin_log</name></expr>          }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"log10"</literal></expr> ,   <expr><name>jx9Builtin_log10</name></expr>        }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"pow"</literal></expr>  ,    <expr><name>jx9Builtin_pow</name></expr>          }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"pi"</literal></expr>,       <expr><name>jx9Builtin_pi</name></expr>           }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"fmod"</literal></expr>,     <expr><name>jx9Builtin_fmod</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"hypot"</literal></expr>,    <expr><name>jx9Builtin_hypot</name></expr>        }</block></expr>, 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_ENABLE_MATH_FUNC */</comment>
	<expr><block>{ <expr><literal type="string">"round"</literal></expr>,    <expr><name>jx9Builtin_round</name></expr>        }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"dechex"</literal></expr>, <expr><name>jx9Builtin_dechex</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"decoct"</literal></expr>, <expr><name>jx9Builtin_decoct</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"decbin"</literal></expr>, <expr><name>jx9Builtin_decbin</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"hexdec"</literal></expr>, <expr><name>jx9Builtin_hexdec</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"bindec"</literal></expr>, <expr><name>jx9Builtin_bindec</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"octdec"</literal></expr>, <expr><name>jx9Builtin_octdec</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"base_convert"</literal></expr>, <expr><name>jx9Builtin_base_convert</name></expr> }</block></expr>, 
	   <comment type="block">/* String handling functions */</comment>
	<expr><block>{ <expr><literal type="string">"substr"</literal></expr>,          <expr><name>jx9Builtin_substr</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"substr_compare"</literal></expr>,  <expr><name>jx9Builtin_substr_compare</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"substr_count"</literal></expr>,    <expr><name>jx9Builtin_substr_count</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"chunk_split"</literal></expr>,     <expr><name>jx9Builtin_chunk_split</name></expr>}</block></expr>, 
	<expr><block>{ <expr><literal type="string">"htmlspecialchars"</literal></expr>, <expr><name>jx9Builtin_htmlspecialchars</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"htmlspecialchars_decode"</literal></expr>, <expr><name>jx9Builtin_htmlspecialchars_decode</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"get_html_translation_table"</literal></expr>, <expr><name>jx9Builtin_get_html_translation_table</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"htmlentities"</literal></expr>, <expr><name>jx9Builtin_htmlentities</name></expr>}</block></expr>, 
	<expr><block>{ <expr><literal type="string">"html_entity_decode"</literal></expr>, <expr><name>jx9Builtin_html_entity_decode</name></expr>}</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strlen"</literal></expr>     , <expr><name>jx9Builtin_strlen</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strcmp"</literal></expr>     , <expr><name>jx9Builtin_strcmp</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strcoll"</literal></expr>    , <expr><name>jx9Builtin_strcmp</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strncmp"</literal></expr>    , <expr><name>jx9Builtin_strncmp</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strcasecmp"</literal></expr> , <expr><name>jx9Builtin_strcasecmp</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strncasecmp"</literal></expr>, <expr><name>jx9Builtin_strncasecmp</name></expr>}</block></expr>, 
	<expr><block>{ <expr><literal type="string">"implode"</literal></expr>    , <expr><name>jx9Builtin_implode</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"join"</literal></expr>       , <expr><name>jx9Builtin_implode</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"implode_recursive"</literal></expr> , <expr><name>jx9Builtin_implode_recursive</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"join_recursive"</literal></expr>    , <expr><name>jx9Builtin_implode_recursive</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"explode"</literal></expr>     , <expr><name>jx9Builtin_explode</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"trim"</literal></expr>        , <expr><name>jx9Builtin_trim</name></expr>       }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"rtrim"</literal></expr>       , <expr><name>jx9Builtin_rtrim</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"chop"</literal></expr>        , <expr><name>jx9Builtin_rtrim</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ltrim"</literal></expr>       , <expr><name>jx9Builtin_ltrim</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strtolower"</literal></expr>,   <expr><name>jx9Builtin_strtolower</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"mb_strtolower"</literal></expr>, <expr><name>jx9Builtin_strtolower</name></expr> }</block></expr>, <comment type="block">/* Only UTF-8 encoding is supported */</comment>
	<expr><block>{ <expr><literal type="string">"strtoupper"</literal></expr>,   <expr><name>jx9Builtin_strtoupper</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"mb_strtoupper"</literal></expr>, <expr><name>jx9Builtin_strtoupper</name></expr> }</block></expr>, <comment type="block">/* Only UTF-8 encoding is supported */</comment>
	<expr><block>{ <expr><literal type="string">"ord"</literal></expr>,          <expr><name>jx9Builtin_ord</name></expr>        }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"chr"</literal></expr>,          <expr><name>jx9Builtin_chr</name></expr>        }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"bin2hex"</literal></expr>,      <expr><name>jx9Builtin_bin2hex</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strstr"</literal></expr>,       <expr><name>jx9Builtin_strstr</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"stristr"</literal></expr>,      <expr><name>jx9Builtin_stristr</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strchr"</literal></expr>,       <expr><name>jx9Builtin_strstr</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strpos"</literal></expr>,       <expr><name>jx9Builtin_strpos</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"stripos"</literal></expr>,      <expr><name>jx9Builtin_stripos</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strrpos"</literal></expr>,      <expr><name>jx9Builtin_strrpos</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strripos"</literal></expr>,     <expr><name>jx9Builtin_strripos</name></expr>   }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strrchr"</literal></expr>,      <expr><name>jx9Builtin_strrchr</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strrev"</literal></expr>,       <expr><name>jx9Builtin_strrev</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"str_repeat"</literal></expr>,   <expr><name>jx9Builtin_str_repeat</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"nl2br"</literal></expr>,        <expr><name>jx9Builtin_nl2br</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"sprintf"</literal></expr>,      <expr><name>jx9Builtin_sprintf</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"printf"</literal></expr>,       <expr><name>jx9Builtin_printf</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"vprintf"</literal></expr>,      <expr><name>jx9Builtin_vprintf</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"vsprintf"</literal></expr>,     <expr><name>jx9Builtin_vsprintf</name></expr>   }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"size_format"</literal></expr>,  <expr><name>jx9Builtin_size_format</name></expr>}</block></expr>, 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JX9_DISABLE_HASH_FUNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr><block>{ <expr><literal type="string">"md5"</literal></expr>,          <expr><name>jx9Builtin_md5</name></expr>       }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"sha1"</literal></expr>,         <expr><name>jx9Builtin_sha1</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"crc32"</literal></expr>,        <expr><name>jx9Builtin_crc32</name></expr>     }</block></expr>, 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_HASH_FUNC */</comment>
	<expr><block>{ <expr><literal type="string">"str_getcsv"</literal></expr>,   <expr><name>jx9Builtin_str_getcsv</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strip_tags"</literal></expr>,   <expr><name>jx9Builtin_strip_tags</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"str_split"</literal></expr>,    <expr><name>jx9Builtin_str_split</name></expr>  }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strspn"</literal></expr>,       <expr><name>jx9Builtin_strspn</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strcspn"</literal></expr>,      <expr><name>jx9Builtin_strcspn</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strpbrk"</literal></expr>,      <expr><name>jx9Builtin_strpbrk</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"soundex"</literal></expr>,      <expr><name>jx9Builtin_soundex</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"wordwrap"</literal></expr>,     <expr><name>jx9Builtin_wordwrap</name></expr>   }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strtok"</literal></expr>,       <expr><name>jx9Builtin_strtok</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"str_pad"</literal></expr>,      <expr><name>jx9Builtin_str_pad</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"str_replace"</literal></expr>,  <expr><name>jx9Builtin_str_replace</name></expr>}</block></expr>, 
	<expr><block>{ <expr><literal type="string">"str_ireplace"</literal></expr>, <expr><name>jx9Builtin_str_replace</name></expr>}</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strtr"</literal></expr>,        <expr><name>jx9Builtin_strtr</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"parse_ini_string"</literal></expr>, <expr><name>jx9Builtin_parse_ini_string</name></expr>}</block></expr>, 
	         <comment type="block">/* Ctype functions */</comment>
	<expr><block>{ <expr><literal type="string">"ctype_alnum"</literal></expr>, <expr><name>jx9Builtin_ctype_alnum</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ctype_alpha"</literal></expr>, <expr><name>jx9Builtin_ctype_alpha</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ctype_cntrl"</literal></expr>, <expr><name>jx9Builtin_ctype_cntrl</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ctype_digit"</literal></expr>, <expr><name>jx9Builtin_ctype_digit</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ctype_xdigit"</literal></expr>, <expr><name>jx9Builtin_ctype_xdigit</name></expr>}</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ctype_graph"</literal></expr>, <expr><name>jx9Builtin_ctype_graph</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ctype_print"</literal></expr>, <expr><name>jx9Builtin_ctype_print</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ctype_punct"</literal></expr>, <expr><name>jx9Builtin_ctype_punct</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ctype_space"</literal></expr>, <expr><name>jx9Builtin_ctype_space</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ctype_lower"</literal></expr>, <expr><name>jx9Builtin_ctype_lower</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"ctype_upper"</literal></expr>, <expr><name>jx9Builtin_ctype_upper</name></expr> }</block></expr>, 
	         <comment type="block">/* Time functions */</comment>
	<expr><block>{ <expr><literal type="string">"time"</literal></expr>    ,    <expr><name>jx9Builtin_time</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"microtime"</literal></expr>,   <expr><name>jx9Builtin_microtime</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"getdate"</literal></expr> ,    <expr><name>jx9Builtin_getdate</name></expr>      }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"gettimeofday"</literal></expr>, <expr><name>jx9Builtin_gettimeofday</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"date"</literal></expr>,        <expr><name>jx9Builtin_date</name></expr>         }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"strftime"</literal></expr>,    <expr><name>jx9Builtin_strftime</name></expr>     }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"idate"</literal></expr>,       <expr><name>jx9Builtin_idate</name></expr>        }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"gmdate"</literal></expr>,      <expr><name>jx9Builtin_gmdate</name></expr>       }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"localtime"</literal></expr>,   <expr><name>jx9Builtin_localtime</name></expr>    }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"mktime"</literal></expr>,      <expr><name>jx9Builtin_mktime</name></expr>       }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"gmmktime"</literal></expr>,    <expr><name>jx9Builtin_mktime</name></expr>       }</block></expr>, 
	        <comment type="block">/* URL functions */</comment>
	<expr><block>{ <expr><literal type="string">"base64_encode"</literal></expr>, <expr><name>jx9Builtin_base64_encode</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"base64_decode"</literal></expr>, <expr><name>jx9Builtin_base64_decode</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"convert_uuencode"</literal></expr>, <expr><name>jx9Builtin_base64_encode</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"convert_uudecode"</literal></expr>, <expr><name>jx9Builtin_base64_decode</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"urlencode"</literal></expr>,    <expr><name>jx9Builtin_urlencode</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"urldecode"</literal></expr>,    <expr><name>jx9Builtin_urldecode</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"rawurlencode"</literal></expr>, <expr><name>jx9Builtin_urlencode</name></expr> }</block></expr>, 
	<expr><block>{ <expr><literal type="string">"rawurldecode"</literal></expr>, <expr><name>jx9Builtin_urldecode</name></expr> }</block></expr>, 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Register the built-in functions defined above, the array functions 
 * defined in hashmap.c and the IO functions defined in vfs.c.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>jx9RegisterBuiltInFunction</name><parameter_list>(<parameter><decl><type><name>jx9_vm</name> <modifier>*</modifier></type><name>pVm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>aBuiltInFunc</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_create_function</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVm</name><operator>)</operator></expr></argument>, <argument><expr><name><name>aBuiltInFunc</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aBuiltInFunc</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>xFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Register hashmap functions [i.e: sort(), count(), array_diff(), ...] */</comment>
	<expr_stmt><expr><call><name>jx9RegisterHashmapFunctions</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVm</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Register IO functions [i.e: fread(), fwrite(), chdir(), mkdir(), file(), ...] */</comment>
	<expr_stmt><expr><call><name>jx9RegisterIORoutine</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVm</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
