<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/src/jx9_json.c"><comment type="block">/*
 * Symisc JX9: A Highly Efficient Embeddable Scripting Engine Based on JSON.
 * Copyright (C) 2012-2013, Symisc Systems http://jx9.symisc.net/
 * Version 1.7.2
 * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES
 * please contact Symisc Systems via:
 *       legal@symisc.net
 *       licensing@symisc.net
 *       contact@symisc.net
 * or visit:
 *      http://jx9.symisc.net/
 */</comment>
 <comment type="block">/* $SymiscID: json.c v1.0 FreeBSD 2012-12-16 00:28 stable &lt;chm@symisc.net&gt; $ */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_AMALGAMATION</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jx9Int.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* This file deals with JSON serialization, decoding and stuff like that. */</comment>
<comment type="block">/*
 * Section: 
 *  JSON encoding/decoding routines.
 * Authors:
 *  Symisc Systems, devel@symisc.net.
 *  Copyright (C) Symisc Systems, http://jx9.symisc.net
 * Status:
 *    Devel.
 */</comment>
<comment type="block">/* Forward reference */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>VmJsonArrayEncode</name><parameter_list>(<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>VmJsonObjectEncode</name><parameter_list>(<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* 
 * JSON encoder state is stored in an instance 
 * of the following structure.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>json_private_data</name></name></type> <name>json_private_data</name>;</typedef>
<struct>struct <name>json_private_data</name>
<block>{
	<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>      <comment type="block">/* Output consumer buffer */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>isFirst</name></decl>;</decl_stmt>       <comment type="block">/* True if first encoded entry */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>iFlags</name></decl>;</decl_stmt>        <comment type="block">/* JSON encoding flags */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nRecCount</name></decl>;</decl_stmt>     <comment type="block">/* Recursion count */</comment>
}</block>;</struct>
<comment type="block">/*
 * Returns the JSON representation of a value.In other word perform a JSON encoding operation.
 * According to wikipedia
 * JSON's basic types are:
 *   Number (double precision floating-point format in JavaScript, generally depends on implementation)
 *   String (double-quoted Unicode, with backslash escaping)
 *   Boolean (true or false)
 *   Array (an ordered sequence of values, comma-separated and enclosed in square brackets; the values
 *    do not need to be of the same type)
 *   Object (an unordered collection of key:value pairs with the ':' character separating the key 
 *     and the value, comma-separated and enclosed in curly braces; the keys must be strings and should
 *     be distinct from each other)
 *   null (empty)
 * Non-significant white space may be added freely around the "structural characters"
 * (i.e. the brackets "[{]}", colon ":" and comma ",").
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>VmJsonEncode</name><parameter_list>(
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,          <comment type="block">/* Encode this value */</comment>
	<parameter><decl><type><name>json_private_data</name> <modifier>*</modifier></type><name>pData</name></decl></parameter> <comment type="block">/* Context data */</comment>
	)</parameter_list><block>{<block_content>
		<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name><name>pData</name><operator>-&gt;</operator><name>pOut</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_null</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>jx9_value_is_resource</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
			<comment type="block">/* null */</comment>
			<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>jx9_value_is_bool</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>iBool</name> <init>= <expr><call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>sxu32</name></type> <name>iLen</name></decl>;</decl_stmt>
			<comment type="block">/* true/false */</comment>
			<expr_stmt><expr><name>iLen</name> <operator>=</operator> <ternary><condition><expr><name>iBool</name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><ternary><condition><expr><name>iBool</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>iLen</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>(  <expr><call><name>jx9_value_is_numeric</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNum</name></decl>;</decl_stmt>
			<comment type="block">/* Get a string representation of the number */</comment>
			<expr_stmt><expr><name>zNum</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><name>zNum</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>jx9_value_is_string</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
				<comment type="block">/* Encode the string */</comment>
				<expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nByte</name></expr>]</index></name></expr>;</expr_stmt>
				<comment type="block">/* Append the double quote */</comment>
				<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
					<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
						<comment type="block">/* No more input to process */</comment>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
					<comment type="block">/* Advance the stream cursor */</comment>
					<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
						<comment type="block">/* Unescape the character */</comment>
						<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="string">"\\"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Append character verbatim */</comment>
					<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<comment type="block">/* Append the double quote */</comment>
				<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="string">"\""</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Encode the array/object */</comment>
			<expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>isFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_json_object</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<comment type="block">/* Encode the object instance */</comment>
				<expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>isFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* Append the curly braces */</comment>
				<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Iterate throw object attribute */</comment>
				<expr_stmt><expr><call><name>jx9_array_walk</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>,<argument><expr><name>VmJsonObjectEncode</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Append the closing curly braces  */</comment>
				<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Append the square bracket or curly braces */</comment>
				<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="string">"["</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Iterate throw array entries */</comment>
				<expr_stmt><expr><call><name>jx9_array_walk</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>VmJsonArrayEncode</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Append the closing square bracket or curly braces */</comment>
				<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="string">"]"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Can't happen */</comment>
			<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>,<argument><expr><literal type="string">"null"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* All done */</comment>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * The following walker callback is invoked each time we need
 * to encode an array to JSON.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>VmJsonArrayEncode</name><parameter_list>(<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>json_private_data</name> <modifier>*</modifier></type><name>pJson</name> <init>= <expr><operator>(</operator><name>json_private_data</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pJson</name><operator>-&gt;</operator><name>nRecCount</name></name> <operator>&gt;</operator> <literal type="number">31</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Recursion limit reached, return immediately */</comment>
		<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pJson</name><operator>-&gt;</operator><name>isFirst</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Append the colon first */</comment>
		<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name><name>pJson</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>,<argument><expr><literal type="string">","</literal></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Encode the value */</comment>
	<expr_stmt><expr><name><name>pJson</name><operator>-&gt;</operator><name>nRecCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VmJsonEncode</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name>pJson</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pJson</name><operator>-&gt;</operator><name>nRecCount</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pJson</name><operator>-&gt;</operator><name>isFirst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * The following walker callback is invoked each time we need to encode
 * a object instance [i.e: Object in the JX9 jargon] to JSON.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>VmJsonObjectEncode</name><parameter_list>(<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>json_private_data</name> <modifier>*</modifier></type><name>pJson</name> <init>= <expr><operator>(</operator><name>json_private_data</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pJson</name><operator>-&gt;</operator><name>nRecCount</name></name> <operator>&gt;</operator> <literal type="number">31</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Recursion limit reached, return immediately */</comment>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pJson</name><operator>-&gt;</operator><name>isFirst</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Append the colon first */</comment>
		<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name><name>pJson</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>,<argument><expr><literal type="string">","</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract a string representation of the key */</comment>
	<expr_stmt><expr><name>zKey</name> <operator>=</operator> <call><name>jx9_value_to_string</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Append the key and the double colon */</comment>
	<if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name><name>pJson</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>,<argument><expr><literal type="string">"\""</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name><name>pJson</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>,<argument><expr><name>zKey</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name><name>pJson</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>,<argument><expr><literal type="string">"\""</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Can't happen */</comment>
		<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name><name>pJson</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>,<argument><expr><literal type="string">"null"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><name><name>pJson</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>,<argument><expr><literal type="string">":"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Encode the value */</comment>
	<expr_stmt><expr><name><name>pJson</name><operator>-&gt;</operator><name>nRecCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VmJsonEncode</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name>pJson</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pJson</name><operator>-&gt;</operator><name>nRecCount</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pJson</name><operator>-&gt;</operator><name>isFirst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 *  Returns a string containing the JSON representation of value. 
 *  In other words, perform the serialization of the given JSON object.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>int</name></type> <name>jx9JsonSerialize</name><parameter_list>(<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>,<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>json_private_data</name></type> <name>sJson</name></decl>;</decl_stmt>
	<comment type="block">/* Prepare the JSON data */</comment>
	<expr_stmt><expr><name><name>sJson</name><operator>.</operator><name>nRecCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sJson</name><operator>.</operator><name>pOut</name></name> <operator>=</operator> <name>pOut</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sJson</name><operator>.</operator><name>isFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sJson</name><operator>.</operator><name>iFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Perform the encoding operation */</comment>
	<expr_stmt><expr><call><name>VmJsonEncode</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sJson</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Possible tokens from the JSON tokenization process */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_TRUE</name></cpp:macro>    <cpp:value>0x001</cpp:value></cpp:define> <comment type="block">/* Boolean true */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_FALSE</name></cpp:macro>   <cpp:value>0x002</cpp:value></cpp:define> <comment type="block">/* Boolean false */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_STR</name></cpp:macro>     <cpp:value>0x004</cpp:value></cpp:define> <comment type="block">/* String enclosed in double quotes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_NULL</name></cpp:macro>    <cpp:value>0x008</cpp:value></cpp:define> <comment type="block">/* null */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_NUM</name></cpp:macro>     <cpp:value>0x010</cpp:value></cpp:define> <comment type="block">/* Numeric */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_OCB</name></cpp:macro>     <cpp:value>0x020</cpp:value></cpp:define> <comment type="block">/* Open curly braces '{' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_CCB</name></cpp:macro>     <cpp:value>0x040</cpp:value></cpp:define> <comment type="block">/* Closing curly braces '}' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_OSB</name></cpp:macro>     <cpp:value>0x080</cpp:value></cpp:define> <comment type="block">/* Open square bracke '[' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_CSB</name></cpp:macro>     <cpp:value>0x100</cpp:value></cpp:define> <comment type="block">/* Closing square bracket ']' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_COLON</name></cpp:macro>   <cpp:value>0x200</cpp:value></cpp:define> <comment type="block">/* Single colon ':' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_COMMA</name></cpp:macro>   <cpp:value>0x400</cpp:value></cpp:define> <comment type="block">/* Single comma ',' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_ID</name></cpp:macro>      <cpp:value>0x800</cpp:value></cpp:define> <comment type="block">/* ID */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TK_INVALID</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define> <comment type="block">/* Unexpected token */</comment>
<comment type="block">/* 
 * Tokenize an entire JSON input.
 * Get a single low-level token from the input file.
 * Update the stream pointer so that it points to the first
 * character beyond the extracted token.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>VmJsonTokenize</name><parameter_list>(<parameter><decl><type><name>SyStream</name> <modifier>*</modifier></type><name>pStream</name></decl></parameter>, <parameter><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtxData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pJsonErr</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<comment type="block">/* Ignore leading white spaces */</comment>
	<while>while<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>&amp;&amp;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Advance the stream cursor */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Update line counter */</comment>
			<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>nLine</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&gt;=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* End of input reached */</comment>
		<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pCtxData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
		<return>return <expr><name>SXERR_EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Record token starting position and line */</comment>
	<expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nLine</name></name> <operator>=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>nLine</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>pStr</name> <operator>=</operator> <operator>&amp;</operator><name><name>pToken</name><operator>-&gt;</operator><name>sData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal> <operator>||</operator> <call><name>SyisAlpha</name><argument_list>(<argument><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* The following code fragment is taken verbatim from the xPP source tree.
		 * xPP is a modern embeddable macro processor with advanced features useful for
		 * application seeking for a production quality, ready to use macro processor.
		 * xPP is a widely used library developed and maintened by Symisc Systems.
		 * You can reach the xPP home page by following this link:
		 * http://xpp.symisc.net/
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
		<comment type="block">/* Isolate UTF-8 or alphanumeric stream */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<expr_stmt><expr><name>zIn</name> <operator>=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* UTF-8 stream */</comment>
				<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal><operator>)</operator></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Skip alphanumeric stream */</comment>
			<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>SyisAlphaNum</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>==</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Not an UTF-8 or alphanumeric stream */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Synchronize pointers */</comment>
			<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* Record token length */</comment>
		<expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>-</operator><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* A simple identifier */</comment>
		<expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_ID</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* boolean true */</comment>
			<expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_TRUE</name></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>,<argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* boolean false */</comment>
			<expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_FALSE</name></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>SyStrnicmp</name><argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>,<argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* NULL */</comment>
			<expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal> <operator>||</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'}'</literal> <operator>||</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">']'</literal>
		<operator>||</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Single character */</comment>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<comment type="block">/* Set token type */</comment>
			<switch>switch<condition>(<expr><name>c</name></expr>)</condition><block>{<block_content>
			<case>case <expr><literal type="char">'['</literal></expr>:</case> <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_OSB</name></expr>;</expr_stmt>   <break>break;</break>
			<case>case <expr><literal type="char">'{'</literal></expr>:</case> <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_OCB</name></expr>;</expr_stmt>   <break>break;</break>
			<case>case <expr><literal type="char">'}'</literal></expr>:</case> <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_CCB</name></expr>;</expr_stmt>   <break>break;</break>
			<case>case <expr><literal type="char">']'</literal></expr>:</case> <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_CSB</name></expr>;</expr_stmt>   <break>break;</break>
			<case>case <expr><literal type="char">':'</literal></expr>:</case> <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_COLON</name></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><literal type="char">','</literal></expr>:</case> <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_COMMA</name></expr>;</expr_stmt> <break>break;</break>
			<default>default:</default>
				<break>break;</break>
			</block_content>}</block></switch>
			<comment type="block">/* Advance the stream cursor */</comment>
			<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* JSON string */</comment>
		<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* Delimit the string */</comment>
		<while>while<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Update line counter */</comment>
				<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>nLine</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&gt;=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Missing closing '"' */</comment>
			<expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_INVALID</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>pJsonErr</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_STR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the closing double quotes */</comment>
		</block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator>
          <operator>||</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Number */</comment>
		<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_NUM</name></expr>;</expr_stmt>
		<while>while<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>&amp;&amp;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
					<comment type="block">/* Real number */</comment>
					<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
					<while>while<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>&amp;&amp;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></while>
					<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
						<if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
							<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
							<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name></expr> )</condition><block>{<block_content>
								<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
								<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator><literal type="char">'+'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
									<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
								</block_content>}</block></if></if_stmt>
								<while>while<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>&amp;&amp;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
									<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
								</block_content>}</block></while>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>					
				</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
					<comment type="block">/* Real number */</comment>
					<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
						<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator><literal type="char">'+'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
							<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<while>while<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&lt;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>&amp;&amp;</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
							<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block></while>
					</block_content>}</block></if></if_stmt>					
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Unexpected token */</comment>
		<expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>JSON_TK_INVALID</name></expr>;</expr_stmt>
		<comment type="block">/* Advance the stream cursor */</comment>
		<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pJsonErr</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
		<comment type="block">/* Abort processing immediatley */</comment>
		<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* record token length */</comment>
	<expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name><operator>-</operator><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pToken</name><operator>-&gt;</operator><name>nType</name></name> <operator>==</operator> <name>JSON_TK_STR</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Return to the lexer */</comment>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * JSON decoded input consumer callback signature.
 */</comment>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>ProcJSONConsumer</name>)<parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef> 
<comment type="block">/* 
 * JSON decoder state is kept in the following structure.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>json_decoder</name></name></type> <name>json_decoder</name>;</typedef>
<struct>struct <name>json_decoder</name>
<block>{
	<decl_stmt><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt> <comment type="block">/* Call context */</comment>
	<decl_stmt><decl><type><name>ProcJSONConsumer</name></type> <name>xConsumer</name></decl>;</decl_stmt> <comment type="block">/* Consumer callback */</comment> 
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl>;</decl_stmt>   <comment type="block">/* Last argument to xConsumer() */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>iFlags</name></decl>;</decl_stmt>        <comment type="block">/* Configuration flags */</comment>
	<decl_stmt><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>      <comment type="block">/* Token stream */</comment>
	<decl_stmt><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>     <comment type="block">/* End of the token stream */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rec_count</name></decl>;</decl_stmt>     <comment type="block">/* Current nesting level */</comment>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pErr</name></decl>;</decl_stmt>         <comment type="block">/* JSON decoding error if any */</comment>
}</block>;</struct>
<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>VmJsonArrayDecoder</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pWorker</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * Dequote [i.e: Resolve all backslash escapes ] a JSON string and store
 * the result in the given jx9_value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>VmJsonDequoteString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SyString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pWorker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pStr</name><operator>-&gt;</operator><name>zString</name><index>[<expr><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<comment type="block">/* Mark the value as a string */</comment>
	<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Empty string */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
		<while>while<condition>( <expr><name>zIn</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;</operator> <name>zCur</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Append chunk verbatim */</comment>
			<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name>zCur</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zIn</name><operator>-</operator><name>zCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* End of the input reached */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Unescape the character */</comment>
		<switch>switch<condition>(<expr><name>c</name></expr>)</condition><block>{<block_content>
		<case>case <expr><literal type="char">'"'</literal></expr>:</case>  <expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		<case>case <expr><literal type="char">'\\'</literal></expr>:</case> <expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		<case>case <expr><literal type="char">'n'</literal></expr>:</case>  <expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		<case>case <expr><literal type="char">'r'</literal></expr>:</case>  <expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><literal type="string">"\r"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		<case>case <expr><literal type="char">'t'</literal></expr>:</case>  <expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><literal type="string">"\t"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		<case>case <expr><literal type="char">'f'</literal></expr>:</case>  <expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><literal type="string">"\f"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>
		<comment type="block">/* Advance the stream cursor */</comment>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<comment type="block">/*
 * Returns a jx9_value holding the image of a JSON string. In other word perform a JSON decoding operation.
 * According to wikipedia
 * JSON's basic types are:
 *   Number (double precision floating-point format in JavaScript, generally depends on implementation)
 *   String (double-quoted Unicode, with backslash escaping)
 *   Boolean (true or false)
 *   Array (an ordered sequence of values, comma-separated and enclosed in square brackets; the values
 *    do not need to be of the same type)
 *   Object (an unordered collection of key:value pairs with the ':' character separating the key 
 *     and the value, comma-separated and enclosed in curly braces; the keys must be strings and should
 *     be distinct from each other)
 *   null (empty)
 * Non-significant white space may be added freely around the "structural characters" (i.e. the brackets "[{]}", colon ":" and comma ", ").
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>VmJsonDecode</name><parameter_list>(
	<parameter><decl><type><name>json_decoder</name> <modifier>*</modifier></type><name>pDecoder</name></decl></parameter>, <comment type="block">/* JSON decoder */</comment>      
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArrayKey</name></decl></parameter>    <comment type="block">/* Key for the decoded array */</comment>
	)</parameter_list><block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt> <comment type="block">/* Worker variable */</comment>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Check if we do not nest to much */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>rec_count</name></name> <operator>&gt;</operator> <literal type="number">31</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nesting limit reached, abort decoding immediately */</comment>
		<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JSON_TK_STR</name><operator>|</operator><name>JSON_TK_ID</name><operator>|</operator><name>JSON_TK_TRUE</name><operator>|</operator><name>JSON_TK_FALSE</name><operator>|</operator><name>JSON_TK_NULL</name><operator>|</operator><name>JSON_TK_NUM</name><operator>)</operator></expr> )</condition><block>{<block_content>
		<comment type="block">/* Scalar value */</comment>
		<expr_stmt><expr><name>pWorker</name> <operator>=</operator> <call><name>jx9_context_new_scalar</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pWorker</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9_context_throw_error</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>JX9_CTX_ERR</name></expr></argument>, <argument><expr><literal type="string">"JX9 is running out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Abort the decoding operation immediately */</comment>
			<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Reflect the JSON image */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_NULL</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Nullify the value.*/</comment>
			<expr_stmt><expr><call><name>jx9_value_null</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JSON_TK_TRUE</name><operator>|</operator><name>JSON_TK_FALSE</name><operator>)</operator></expr> )</condition><block>{<block_content>
			<comment type="block">/* Boolean value */</comment>
			<expr_stmt><expr><call><name>jx9_value_bool</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_TRUE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_NUM</name></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pStr</name> <init>= <expr><operator>&amp;</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>sData</name></name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* 
			 * Numeric value.
			 * Get a string representation first then try to get a numeric
			 * value.
			 */</comment>
			<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Obtain a numeric representation */</comment>
			<expr_stmt><expr><call><name>jx9MemObjToNumeric</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_ID</name></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pStr</name> <init>= <expr><operator>&amp;</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>sData</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Dequote the string */</comment>
			<expr_stmt><expr><call><name>VmJsonDequoteString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>sData</name></name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Invoke the consumer callback */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pDecoder</name><operator>-&gt;</operator><name>xConsumer</name></name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>pArrayKey</name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* All done, advance the stream cursor */</comment>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_OSB</name></expr> <comment type="block">/*'[' */</comment>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>ProcJSONConsumer</name></type> <name>xOld</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>
		<comment type="block">/* Array representation*/</comment>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* Create a working array */</comment>
		<expr_stmt><expr><name>pWorker</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pWorker</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9_context_throw_error</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>JX9_CTX_ERR</name></expr></argument>, <argument><expr><literal type="string">"JX9 is running out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Abort the decoding operation immediately */</comment>
			<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Save the old consumer */</comment>
		<expr_stmt><expr><name>xOld</name> <operator>=</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>xConsumer</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pOld</name> <operator>=</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>pUserData</name></name></expr>;</expr_stmt>
		<comment type="block">/* Set the new consumer */</comment>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>xConsumer</name></name> <operator>=</operator> <name>VmJsonArrayDecoder</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pWorker</name></expr>;</expr_stmt>
		<comment type="block">/* Decode the array */</comment>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<comment type="block">/* Jump trailing comma. Note that the standard JX9 engine will not let you
			 * do this.
			 */</comment>
			<while>while<condition>( <expr><operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name> <operator>&lt;</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>pEnd</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_COMMA</name><operator>)</operator></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name> <operator>&gt;=</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>pEnd</name></name> <operator>||</operator> <operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_CSB</name><operator>)</operator></expr> <comment type="block">/*']'*/</comment> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name> <operator>&lt;</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>pEnd</name></name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the trailing ']' */</comment>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Recurse and decode the entry */</comment>
			<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>rec_count</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>VmJsonDecode</name><argument_list>(<argument><expr><name>pDecoder</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>rec_count</name></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Abort processing immediately */</comment>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/*The cursor is automatically advanced by the VmJsonDecode() function */</comment>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name> <operator>&lt;</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>pEnd</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JSON_TK_CSB</name><comment type="block">/*']'*/</comment><operator>|</operator><name>JSON_TK_COMMA</name><comment type="block">/*','*/</comment><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
					<comment type="block">/* Unexpected token, abort immediatley */</comment>
					<expr_stmt><expr><operator>*</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pErr</name></name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
					<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<comment type="block">/* Restore the old consumer */</comment>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>xConsumer</name></name> <operator>=</operator> <name>xOld</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pOld</name></expr>;</expr_stmt>
		<comment type="block">/* Invoke the old consumer on the decoded array */</comment>
		<expr_stmt><expr><call><name>xOld</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>pArrayKey</name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_OCB</name></expr> <comment type="block">/*'{' */</comment>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>ProcJSONConsumer</name></type> <name>xOld</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>
		<comment type="block">/* Object representation*/</comment>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* Create a working array */</comment>
		<expr_stmt><expr><name>pWorker</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>jx9_context_new_scalar</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pWorker</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pKey</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9_context_throw_error</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>JX9_CTX_ERR</name></expr></argument>, <argument><expr><literal type="string">"JX9 is running out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Abort the decoding operation immediately */</comment>
			<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Save the old consumer */</comment>
		<expr_stmt><expr><name>xOld</name> <operator>=</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>xConsumer</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pOld</name> <operator>=</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>pUserData</name></name></expr>;</expr_stmt>
		<comment type="block">/* Set the new consumer */</comment>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>xConsumer</name></name> <operator>=</operator> <name>VmJsonArrayDecoder</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pWorker</name></expr>;</expr_stmt>
		<comment type="block">/* Decode the object */</comment>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<comment type="block">/* Jump trailing comma. Note that the standard JX9 engine will not let you
			 * do this.
			 */</comment>
			<while>while<condition>( <expr><operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name> <operator>&lt;</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>pEnd</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_COMMA</name><operator>)</operator></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name> <operator>&gt;=</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>pEnd</name></name> <operator>||</operator> <operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_CCB</name><operator>)</operator></expr> <comment type="block">/*'}'*/</comment> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name> <operator>&lt;</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>pEnd</name></name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the trailing ']' */</comment>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JSON_TK_ID</name><operator>|</operator><name>JSON_TK_STR</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>&amp;</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <name><name>pDecoder</name><operator>-&gt;</operator><name>pEnd</name></name>
				<operator>||</operator> <operator>(</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nType</name> <operator>&amp;</operator> <name>JSON_TK_COLON</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
					<comment type="block">/* Syntax error, return immediately */</comment>
					<expr_stmt><expr><operator>*</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pErr</name></name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
					<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JSON_TK_ID</name></expr> )</condition><block>{<block_content>
				<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pStr</name> <init>= <expr><operator>&amp;</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>sData</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>jx9_value_string</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Dequote the key */</comment>
				<expr_stmt><expr><call><name>VmJsonDequoteString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>sData</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* Jump the key and the colon */</comment>
			<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pIn</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
			<comment type="block">/* Recurse and decode the value */</comment>
			<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>rec_count</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>VmJsonDecode</name><argument_list>(<argument><expr><name>pDecoder</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>rec_count</name></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Abort processing immediately */</comment>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Reset the internal buffer of the key */</comment>
			<expr_stmt><expr><call><name>jx9_value_reset_string_cursor</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*The cursor is automatically advanced by the VmJsonDecode() function */</comment>
		</block_content>}</block></for>
		<comment type="block">/* Restore the old consumer */</comment>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>xConsumer</name></name> <operator>=</operator> <name>xOld</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pOld</name></expr>;</expr_stmt>
		<comment type="block">/* Invoke the old consumer on the decoded object*/</comment>
		<expr_stmt><expr><call><name>xOld</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>pArrayKey</name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Release the key */</comment>
		<expr_stmt><expr><call><name>jx9_context_release_value</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Unexpected token */</comment>
		<return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Abort immediately */</comment>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Release the worker variable */</comment>
	<expr_stmt><expr><call><name>jx9_context_release_value</name><argument_list>(<argument><expr><name><name>pDecoder</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * The following JSON decoder callback is invoked each time
 * a JSON array representation [i.e: [15, "hello", FALSE] ]
 * is being decoded.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>VmJsonArrayDecoder</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pWorker</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name> <init>= <expr><operator>(</operator><name>jx9_value</name> <operator>*</operator><operator>)</operator><name>pUserData</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Insert the entry */</comment>
	<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Will make it's own copy */</comment>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Standard JSON decoder callback.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>VmJsonDefaultDecoder</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pWorker</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Return the value directly */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Will make it's own copy */</comment>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Exported JSON decoding interface
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>int</name></type> <name>jx9JsonDecode</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zJSON</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_vm</name> <modifier>*</modifier></type><name>pVm</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVm</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>json_decoder</name></type> <name>sDecoder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SySet</name></type> <name>sToken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyLex</name></type> <name>sLex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Tokenize the input */</comment>
	<expr_stmt><expr><call><name>SySetInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyToken</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXRET_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyLexInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sLex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>, <argument><expr><name>VmJsonTokenize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyLexTokenizeInput</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sLex</name></expr></argument>,<argument><expr><name>zJSON</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nByte</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Something goes wrong while tokenizing input. [i.e: Unexpected token] */</comment>
		<expr_stmt><expr><call><name>SyLexRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sLex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SySetRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fill the decoder */</comment>
	<expr_stmt><expr><name><name>sDecoder</name><operator>.</operator><name>pCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sDecoder</name><operator>.</operator><name>pErr</name></name> <operator>=</operator> <operator>&amp;</operator><name>rc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sDecoder</name><operator>.</operator><name>pIn</name></name> <operator>=</operator> <operator>(</operator><name>SyToken</name> <operator>*</operator><operator>)</operator><call><name>SySetBasePtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sDecoder</name><operator>.</operator><name>pEnd</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>sDecoder</name><operator>.</operator><name>pIn</name><index>[<expr><call><name>SySetUsed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sDecoder</name><operator>.</operator><name>iFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sDecoder</name><operator>.</operator><name>rec_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Set a default consumer */</comment>
	<expr_stmt><expr><name><name>sDecoder</name><operator>.</operator><name>xConsumer</name></name> <operator>=</operator> <name>VmJsonDefaultDecoder</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sDecoder</name><operator>.</operator><name>pUserData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Decode the raw JSON input */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>VmJsonDecode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sDecoder</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* 
		 * Something goes wrong while decoding JSON input.Return NULL.
		 */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Clean-up the mess left behind */</comment>
	<expr_stmt><expr><call><name>SyLexRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sLex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SySetRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
