<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/src/jx9_hashmap.c"><comment type="block">/*
 * Symisc JX9: A Highly Efficient Embeddable Scripting Engine Based on JSON.
 * Copyright (C) 2012-2013, Symisc Systems http://jx9.symisc.net/
 * Version 1.7.2
 * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES
 * please contact Symisc Systems via:
 *       legal@symisc.net
 *       licensing@symisc.net
 *       contact@symisc.net
 * or visit:
 *      http://jx9.symisc.net/
 */</comment>
 <comment type="block">/* $SymiscID: hashmap.c v2.6 Win7 2012-12-11 00:50 stable &lt;chm@symisc.net&gt; $ */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_AMALGAMATION</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jx9Int.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* This file implement generic hashmaps used to represent JSON arrays and objects */</comment>
<comment type="block">/* Allowed node types */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHMAP_INT_NODE</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>  <comment type="block">/* Node with an int [i.e: 64-bit integer] key */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHMAP_BLOB_NODE</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>  <comment type="block">/* Node with a string/BLOB key */</comment>
<comment type="block">/*
 * Default hash function for int [i.e; 64-bit integer] keys.
 */</comment>
<function><type><specifier>static</specifier> <name>sxu32</name></type> <name>IntHash</name><parameter_list>(<parameter><decl><type><name>sxi64</name></type> <name>iKey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>iKey</name> <operator>^</operator> <operator>(</operator><name>iKey</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>iKey</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Default hash function for string/BLOB keys.
 */</comment>
<function><type><specifier>static</specifier> <name>sxu32</name></type> <name>BinHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pSrc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nH</name> <init>= <expr><literal type="number">5381</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>	
	<return>return <expr><name>nH</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Return the total number of entries in a given hashmap.
 * If bRecurisve is set to TRUE then recurse on hashmap entries.
 * If the nesting limit is reached, this function abort immediately. 
 */</comment>
<function><type><specifier>static</specifier> <name>sxi64</name></type> <name>HashmapCount</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bRecursive</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iRecCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>iCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><name>bRecursive</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>iCount</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Recursive hashmap walk */</comment>
		<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>pLast</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pElem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Point to the element value */</comment>
			<expr_stmt><expr><name>pElem</name> <operator>=</operator> <operator>(</operator><name>jx9_value</name> <operator>*</operator><operator>)</operator><call><name>SySetAt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>aMemObj</name></name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nValIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pElem</name></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name><name>pElem</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_HASHMAP</name></expr> )</condition><block>{<block_content>
					<if_stmt><if>if<condition>( <expr><name>iRecCount</name> <operator>&gt;</operator> <literal type="number">31</literal></expr> )</condition><block>{<block_content>
						<comment type="block">/* Nesting limit reached */</comment>
						<return>return <expr><name>iCount</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Recurse */</comment>
					<expr_stmt><expr><name>iRecCount</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>iCount</name> <operator>+=</operator> <call><name>HashmapCount</name><argument_list>(<argument><expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>pElem</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pOther</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>iRecCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>iRecCount</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Point to the next entry */</comment>
			<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>n</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* Update count */</comment>
		<expr_stmt><expr><name>iCount</name> <operator>+=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>iCount</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Allocate a new hashmap node with a 64-bit integer key.
 * If something goes wrong [i.e: out of memory], this function return NULL.
 * Otherwise a fresh [jx9_hashmap_node] instance is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>jx9_hashmap_node</name> <modifier>*</modifier></type> <name>HashmapNewIntNode</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>sxi64</name></type> <name>iKey</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nHash</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nValIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
	<comment type="block">/* Allocate a new node */</comment>
	<expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap_node</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jx9_hashmap_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNode</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the stucture */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jx9_hashmap_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pMap</name></name>  <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iType</name></name> <operator>=</operator> <name>HASHMAP_INT_NODE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <name>nHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>nValIdx</name></name>  <operator>=</operator> <name>nValIdx</name></expr>;</expr_stmt>
	<return>return <expr><name>pNode</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Allocate a new hashmap node with a BLOB key.
 * If something goes wrong [i.e: out of memory], this function return NULL.
 * Otherwise a fresh [jx9_hashmap_node] instance is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>jx9_hashmap_node</name> <modifier>*</modifier></type> <name>HashmapNewBlobNode</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nHash</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nValIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
	<comment type="block">/* Allocate a new node */</comment>
	<expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap_node</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jx9_hashmap_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNode</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the stucture */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jx9_hashmap_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pMap</name></name>  <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iType</name></name> <operator>=</operator> <name>HASHMAP_BLOB_NODE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <name>nHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBlobInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>nValIdx</name></name> <operator>=</operator> <name>nValIdx</name></expr>;</expr_stmt>
	<return>return <expr><name>pNode</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * link a hashmap node to the given bucket index (last argument to this function).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HashmapNodeLink</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nBucketIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Link */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucketIdx</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucketIdx</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucketIdx</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCollide</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucketIdx</name></expr>]</index></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
	<comment type="block">/* Link to the map list */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pLast</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
		<comment type="block">/* Point to the first inserted node */</comment>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>MACRO_LD_PUSH</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pLast</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><operator>++</operator><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Unlink a node from the hashmap.
 * If the node count reaches zero then release the whole hash-bucket.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jx9HashmapUnlinkNode</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name> <init>= <expr><name><name>pNode</name><operator>-&gt;</operator><name>pMap</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_vm</name> <modifier>*</modifier></type><name>pVm</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Unlink from the corresponding bucket */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pPrevCollide</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pPrevCollide</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pNextCollide</name><operator>-&gt;</operator><name>pPrevCollide</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pPrevCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>==</operator> <name>pNode</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>==</operator> <name>pNode</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Advance the node cursor */</comment>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pCur</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Unlink from the map list */</comment>
	<expr_stmt><expr><call><name>MACRO_LD_REMOVE</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pLast</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Restore to the free list */</comment>
	<expr_stmt><expr><call><name>jx9VmUnsetMemObj</name><argument_list>(<argument><expr><name>pVm</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>nValIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_BLOB_NODE</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name><operator>--</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Free the hash-bucket */</comment>
		<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pLast</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHMAP_FILL_FACTOR</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<comment type="block">/*
 * Grow the hash-table and rehash all entries.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapGrowBucket</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&gt;=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>*</operator> <name>HASHMAP_FILL_FACTOR</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>apOld</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nNew</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nBucket</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>nNew</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nNew</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Allocate a new bucket */</comment>
		<expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap_node</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>nNew</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>jx9_hashmap_node</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>apNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_MEM</name></expr>;</return> <comment type="block">/* Fatal */</comment>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Not so fatal here, simply a performance hit */</comment>
			<return>return <expr><name>SXRET_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Zero the table */</comment>
		<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>apNew</name></expr></argument>, <argument><expr><name>nNew</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>jx9_hashmap_node</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Reflect the change */</comment>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>apOld</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* First allocated table [i.e: no entry], return immediately */</comment>
			<return>return <expr><name>SXRET_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Rehash old entries */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for<control>( <init>;</init><condition>;</condition> <incr/>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Clear the old collision link */</comment>
			<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCollide</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<comment type="block">/* Link to the new bucket */</comment>
			<expr_stmt><expr><name>nBucket</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name>nNew</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucket</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucket</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCollide</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucket</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
			<comment type="block">/* Point to the next entry */</comment>
			<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
			<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* Free the old table */</comment>
		<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>apOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Insert a 64-bit integer key and it's associated value (if any) in the given
 * hashmap.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapInsertIntKey</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>,<parameter><decl><type><name>sxi64</name></type> <name>iKey</name></decl></parameter>,<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Reserve a jx9_value for the value */</comment>
	<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>jx9VmReserveMemObj</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pObj</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pValue</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Duplicate the value */</comment>
		<expr_stmt><expr><call><name>jx9MemObjStore</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	
	<comment type="block">/* Hash the key */</comment>
	<expr_stmt><expr><name>nHash</name> <operator>=</operator> <call><name><name>pMap</name><operator>-&gt;</operator><name>xIntHash</name></name><argument_list>(<argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Allocate a new int node */</comment>
	<expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>HashmapNewIntNode</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>nHash</name></expr></argument>, <argument><expr><name>nIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNode</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure the bucket is big enough to hold the new entry */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapGrowBucket</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the insertion */</comment>
	<expr_stmt><expr><call><name>HashmapNodeLink</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Insert a BLOB key and it's associated value (if any) in the given
 * hashmap.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapInsertBlobKey</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>,<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Reserve a jx9_value for the value */</comment>
	<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>jx9VmReserveMemObj</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pObj</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pValue</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Duplicate the value */</comment>
		<expr_stmt><expr><call><name>jx9MemObjStore</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Hash the key */</comment>
	<expr_stmt><expr><name>nHash</name> <operator>=</operator> <call><name><name>pMap</name><operator>-&gt;</operator><name>xBlobHash</name></name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Allocate a new blob node */</comment>
	<expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>HashmapNewBlobNode</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKeyLen</name></expr></argument>, <argument><expr><name>nHash</name></expr></argument>, <argument><expr><name>nIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNode</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure the bucket is big enough to hold the new entry */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapGrowBucket</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the insertion */</comment>
	<expr_stmt><expr><call><name>HashmapNodeLink</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Check if a given 64-bit integer key exists in the given hashmap.
 * Write a pointer to the target node on success. Otherwise
 * SXERR_NOTFOUND is returned on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapLookupIntKey</name><parameter_list>(
	<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>,         <comment type="block">/* Target hashmap */</comment>
	<parameter><decl><type><name>sxi64</name></type> <name>iKey</name></decl></parameter>,                <comment type="block">/* lookup key */</comment>
	<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNode</name></decl></parameter>  <comment type="block">/* OUT: target node on success */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother hashing, there is no entry anyway */</comment>
		<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Hash the key first */</comment>
	<expr_stmt><expr><name>nHash</name> <operator>=</operator> <call><name><name>pMap</name><operator>-&gt;</operator><name>xIntHash</name></name><argument_list>(<argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Point to the appropriate bucket */</comment>
	<expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Perform the lookup */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pNode</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_INT_NODE</name>
			<operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>nHash</name></name> <operator>==</operator> <name>nHash</name>
			<operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name> <operator>==</operator> <name>iKey</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Node found */</comment>
				<if_stmt><if>if<condition>( <expr><name>ppNode</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>SXRET_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Follow the collision link */</comment>
		<expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* No such entry */</comment>
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Check if a given BLOB key exists in the given hashmap.
 * Write a pointer to the target node on success. Otherwise
 * SXERR_NOTFOUND is returned on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapLookupBlobKey</name><parameter_list>(
	<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>,          <comment type="block">/* Target hashmap */</comment>
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,           <comment type="block">/* Lookup key */</comment>
	<parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>,              <comment type="block">/* Key length in bytes */</comment>
	<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNode</name></decl></parameter>   <comment type="block">/* OUT: target node on success */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother hashing, there is no entry anyway */</comment>
		<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Hash the key first */</comment>
	<expr_stmt><expr><name>nHash</name> <operator>=</operator> <call><name><name>pMap</name><operator>-&gt;</operator><name>xBlobHash</name></name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Point to the appropriate bucket */</comment>
	<expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Perform the lookup */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pNode</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_BLOB_NODE</name> 
			<operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>nHash</name></name> <operator>==</operator> <name>nHash</name>
			<operator>&amp;&amp;</operator> <call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nKeyLen</name> 
			<operator>&amp;&amp;</operator> <call><name>SyMemcmp</name><argument_list>(<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Node found */</comment>
				<if_stmt><if>if<condition>( <expr><name>ppNode</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>SXRET_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Follow the collision link */</comment>
		<expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* No such entry */</comment>
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Check if the given BLOB key looks like a decimal number. 
 * Retrurn TRUE on success.FALSE otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>HashmapIsIntKey</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name>  <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zIn</name><index>[<expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Octal not decimal number */</comment>
		<return>return <expr><name>FALSE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>TRUE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal> <comment type="block">/* UTF-8 stream */</comment>  <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Key does not look like a decimal number */</comment>
	<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Check if a given key exists in the given hashmap.
 * Write a pointer to the target node on success.
 * Otherwise SXERR_NOTFOUND is returned on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapLookup</name><parameter_list>(
	<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>,          <comment type="block">/* Target hashmap */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,            <comment type="block">/* Lookup key */</comment>
	<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNode</name></decl></parameter>   <comment type="block">/* OUT: target node on success */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc -O6 warning */</comment>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pKey</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEMOBJ_STRING</name><operator>|</operator><name>MEMOBJ_HASHMAP</name><operator>|</operator><name>MEMOBJ_RES</name><operator>)</operator></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Force a string cast */</comment>
			<expr_stmt><expr><call><name>jx9MemObjToString</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pKey</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Perform a blob lookup */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapLookupBlobKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>result</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform an int lookup */</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_INT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Force an integer cast */</comment>
		<expr_stmt><expr><call><name>jx9MemObjToInteger</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform an int lookup */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapLookupIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>iVal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>result</name>:</label>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Node found */</comment>
		<if_stmt><if>if<condition>( <expr><name>ppNode</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* No such entry */</comment>
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Insert a given key and it's associated value (if any) in the given
 * hashmap.
 * If a node with the given key already exists in the database
 * then this function overwrite the old value.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapInsert</name><parameter_list>(
	<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <comment type="block">/* Target hashmap */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,   <comment type="block">/* Lookup key  */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>    <comment type="block">/* Node value */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name> <init>= <expr><name>SXRET_OK</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>pKey</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name><operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>|=</operator> <name>HASHMAP_JSON_OBJECT</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pKey</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEMOBJ_STRING</name><operator>|</operator><name>MEMOBJ_HASHMAP</name><operator>|</operator><name>MEMOBJ_RES</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Force a string cast */</comment>
			<expr_stmt><expr><call><name>jx9MemObjToString</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pKey</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>HashmapIsIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>(<expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
				<comment type="block">/* Automatic index assign */</comment>
				<expr_stmt><expr><name>pKey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<goto>goto <name>IntKey</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>==</operator> <call><name>HashmapLookupBlobKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, 
			<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<comment type="block">/* Overwrite the old value */</comment>
				<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pElem</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>pElem</name> <operator>=</operator> <operator>(</operator><name>jx9_value</name> <operator>*</operator><operator>)</operator><call><name>SySetAt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>aMemObj</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>nValIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>pElem</name></expr> )</condition><block>{<block_content>
					<if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><call><name>jx9MemObjStore</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if><else>else<block>{<block_content>
						<comment type="block">/* Nullify the entry */</comment>
						<expr_stmt><expr><call><name>jx9MemObjToNull</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>SXRET_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Perform a blob-key insertion */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsertBlobKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>,<argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVal</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<label><name>IntKey</name>:</label>
	<if_stmt><if>if<condition>( <expr><name>pKey</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>pKey</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_INT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Force an integer cast */</comment>
			<expr_stmt><expr><call><name>jx9MemObjToInteger</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>==</operator> <call><name>HashmapLookupIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>iVal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Overwrite the old value */</comment>
			<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pElem</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>pElem</name> <operator>=</operator> <operator>(</operator><name>jx9_value</name> <operator>*</operator><operator>)</operator><call><name>SySetAt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>aMemObj</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>nValIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pElem</name></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><call><name>jx9MemObjStore</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if><else>else<block>{<block_content>
					<comment type="block">/* Nullify the entry */</comment>
					<expr_stmt><expr><call><name>jx9MemObjToNull</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>SXRET_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Perform a 64-bit-int-key insertion */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsertIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>iVal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVal</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>pKey</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>iVal</name></name> <operator>&gt;=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Increment the automatic index */</comment> 
				<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name> <operator>=</operator> <name><name>pKey</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>iVal</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* Make sure the automatic index is not reserved */</comment>
				<while>while<condition>( <expr><name>SXRET_OK</name> <operator>==</operator> <call><name>HashmapLookupIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Assign an automatic index */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsertIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>,<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVal</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>++</operator><name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Insertion result */</comment>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Extract node value.
 */</comment>
<function><type><specifier>static</specifier> <name>jx9_value</name> <modifier>*</modifier></type> <name>HashmapExtractNodeValue</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Point to the desired object */</comment>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pObj</name> <operator>=</operator> <operator>(</operator><name>jx9_value</name> <operator>*</operator><operator>)</operator><call><name>SySetAt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>aMemObj</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>nValIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>pObj</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Insert a node in the given hashmap.
 * If a node with the given key already exists in the database
 * then this function overwrite the old value.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapInsertNode</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bPreserve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Extract the node value */</comment>
	<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pNode</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pObj</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Preserve key */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_INT_NODE</name></expr>)</condition><block>{<block_content>
		<comment type="block">/* Int64 key */</comment>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name>bPreserve</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Assign an automatic index */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsertIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name></expr></argument>, <argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Blob key */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsertBlobKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>, 
			<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Compare two node values.
 * Return 0 if the node values are equals, &gt; 0 if pLeft is greater than pRight
 * or &lt; 0 if pRight is greater than pLeft.
 * For a full description on jx9_values comparison, refer to the implementation
 * of the [jx9MemObjCmp()] function defined in memobj.c or the official
 * documenation.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapNodeCmp</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bStrict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sObj1</name></decl>, <decl><type ref="prev"/><name>sObj2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pLeft</name> <operator>==</operator> <name>pRight</name></expr> )</condition><block>{<block_content>
		<comment type="block">/*
		 * Same node.Refer to the sort() implementation defined
		 * below for more information on this sceanario.
		 */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Do the comparison */</comment>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sObj1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sObj2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sObj1</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sObj2</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9MemObjCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sObj1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sObj2</name></expr></argument>, <argument><expr><name>bStrict</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sObj1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sObj2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Rehash a node with a 64-bit integer key.
 * Refer to [merge_sort(), array_shift()] implementations for more information.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HashmapRehashIntNode</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name> <init>= <expr><name><name>pEntry</name><operator>-&gt;</operator><name>pMap</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nBucket</name></decl>;</decl_stmt>
	<comment type="block">/* Remove old collision links */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCollide</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCollide</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name><operator>-&gt;</operator><name>pPrevCollide</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCollide</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Compute the new hash */</comment>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <call><name><name>pMap</name><operator>-&gt;</operator><name>xIntHash</name></name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nBucket</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* Link to the new bucket */</comment>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucket</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucket</name></expr>]</index></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCollide</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucket</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nBucket</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
	<comment type="block">/* Increment the automatic index */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Perform a linear search on a given hashmap.
 * Write a pointer to the target node on success.
 * Otherwise SXERR_NOTFOUND is returned on failure.
 * Refer to [array_intersect(), array_diff(), in_array(), ...] implementations 
 * for more information.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>HashmapFindValue</name><parameter_list>(
	<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>,   <comment type="block">/* Target hashmap */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pNeedle</name></decl></parameter>,  <comment type="block">/* Lookup key */</comment>
	<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNode</name></decl></parameter>, <comment type="block">/* OUT: target node on success  */</comment>
	<parameter><decl><type><name>int</name></type> <name>bStrict</name></decl></parameter>      <comment type="block">/* TRUE for strict comparison */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sVal</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sNeedle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<comment type="block">/* Perform a linear search since we cannot sort the hashmap based on values */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sNeedle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract node value */</comment>
		<expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pVal</name><operator>-&gt;</operator><name>iFlags</name></name><operator>|</operator><name><name>pNeedle</name><operator>-&gt;</operator><name>iFlags</name></name><operator>)</operator> <operator>&amp;</operator> <name>MEMOBJ_NULL</name></expr> )</condition><block>{<block_content>
				<decl_stmt><decl><type><name>sxi32</name></type> <name>iF1</name> <init>= <expr><name><name>pVal</name><operator>-&gt;</operator><name>iFlags</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>sxi32</name></type> <name>iF2</name> <init>= <expr><name><name>pNeedle</name><operator>-&gt;</operator><name>iFlags</name></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if<condition>( <expr><name>iF1</name> <operator>==</operator> <name>iF2</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* NULL values are equals */</comment>
					<if_stmt><if>if<condition>( <expr><name>ppNode</name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<return>return <expr><name>SXRET_OK</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Duplicate value */</comment>
				<expr_stmt><expr><call><name>jx9MemObjLoad</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>jx9MemObjLoad</name><argument_list>(<argument><expr><name>pNeedle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sNeedle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9MemObjCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNeedle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sVal</name></expr></argument>, <argument><expr><name>bStrict</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNeedle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<if_stmt><if>if<condition>( <expr><name>ppNode</name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Match found*/</comment>
					<return>return <expr><name>SXRET_OK</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
		<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* No such entry */</comment>
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Compare two hashmaps.
 * Return 0 if the hashmaps are equals.Any other value indicates inequality.
 * Note on array comparison operators.
 *  According to the JX9 language reference manual.
 *  Array Operators Example 	Name 	Result
 *  $a + $b 	Union 	Union of $a and $b.
 *  $a == $b 	Equality 	TRUE if $a and $b have the same key/value pairs.
 *  $a === $b 	Identity 	TRUE if $a and $b have the same key/value pairs in the same 
 *                          order and of the same types.
 *  $a != $b 	Inequality 	TRUE if $a is not equal to $b.
 *  $a &lt;&gt; $b 	Inequality 	TRUE if $a is not equal to $b.
 *  $a !== $b 	Non-identity 	TRUE if $a is not identical to $b.
 * The + operator returns the right-hand array appended to the left-hand array;
 * For keys that exist in both arrays, the elements from the left-hand array will be used
 * and the matching elements from the right-hand array will be ignored.
 * &lt;?jx9
 * $a = array("a" =&gt; "apple", "b" =&gt; "banana");
 * $b = array("a" =&gt; "pear", "b" =&gt; "strawberry", "c" =&gt; "cherry");
 * $c = $a + $b; // Union of $a and $b
 * print "Union of \$a and \$b: \n";
 * dump($c);
 * $c = $b + $a; // Union of $b and $a
 * print "Union of \$b and \$a: \n";
 * dump($c);
 * ?&gt;
 * When executed, this script will print the following:
 * Union of $a and $b:
 * array(3) {
 *  ["a"]=&gt;
 *  string(5) "apple"
 *  ["b"]=&gt;
 * string(6) "banana"
 *  ["c"]=&gt;
 * string(6) "cherry"
 * }
 * Union of $b and $a:
 * array(3) {
 * ["a"]=&gt;
 * string(4) "pear"
 * ["b"]=&gt;
 * string(10) "strawberry"
 * ["c"]=&gt;
 * string(6) "cherry"
 * }
 * Elements of arrays are equal for the comparison if they have the same key and value.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9HashmapCmp</name><parameter_list>(
	<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,  <comment type="block">/* Left hashmap */</comment>
	<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <comment type="block">/* Right hashmap */</comment>
	<parameter><decl><type><name>int</name></type> <name>bStrict</name></decl></parameter>          <comment type="block">/* TRUE for strict comparison */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pLe</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pRe</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pLeft</name> <operator>==</operator> <name>pRight</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Same hashmap instance. This can easily happen since hashmaps are passed by reference.
		 * Unlike the  engine.
		 */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>!=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>nEntry</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Must have the same number of entries */</comment>
		<return>return <expr><ternary><condition><expr><name><name>pLeft</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&gt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the first inserted entry of the left hashmap */</comment>
	<expr_stmt><expr><name>pLe</name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pRe</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc warning */</comment>
	<comment type="block">/* Perform the comparison */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pLe</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_INT_NODE</name></expr>)</condition><block>{<block_content>
			<comment type="block">/* Int key */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapLookupIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pRight</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pLe</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pKey</name> <init>= <expr><operator>&amp;</operator><name><name>pLe</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Blob key */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapLookupBlobKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pRight</name><operator>)</operator></expr></argument>, <argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No such entry in the right side */</comment>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>bStrict</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Make sure, the keys are of the same type */</comment>
			<if_stmt><if>if<condition>( <expr><name><name>pLe</name><operator>-&gt;</operator><name>iType</name></name> <operator>!=</operator> <name><name>pRe</name><operator>-&gt;</operator><name>iType</name></name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name>rc</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Compare nodes */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapNodeCmp</name><argument_list>(<argument><expr><name>pLe</name></expr></argument>, <argument><expr><name>pRe</name></expr></argument>, <argument><expr><name>bStrict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Nodes key/value differ */</comment>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pLe</name> <operator>=</operator> <name><name>pLe</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
		<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Hashmaps are equals */</comment>
</block_content>}</block></function>
<comment type="block">/*
 * Merge two hashmaps.
 * Note on the merge process
 * According to the JX9 language reference manual.
 *  Merges the elements of two arrays together so that the values of one are appended
 *  to the end of the previous one. It returns the resulting array (pDest).
 *  If the input arrays have the same string keys, then the later value for that key
 *  will overwrite the previous one. If, however, the arrays contain numeric keys
 *  the later value will not overwrite the original value, but will be appended.
 *  Values in the input array with numeric keys will be renumbered with incrementing
 *  keys starting from zero in the result array. 
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapMerge</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sKey</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pSrc</name> <operator>==</operator> <name>pDest</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Same map. This can easily happen since hashmaps are passed by reference.
		 * Unlike the  engine.
		 */</comment>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the first inserted entry in the source */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<comment type="block">/* Perform the merge */</comment>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
		<comment type="block">/* Extract the node value */</comment>
		<expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_BLOB_NODE</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Blob key insertion */</comment>
			<expr_stmt><expr><call><name>jx9MemObjInitFromString</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9MemObjStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9HashmapInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pDest</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pDest</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index assign */</comment>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Duplicate the contents of a hashmap. Store the copy in pDest.
 * Refer to the [array_pad(), array_copy(), ...] implementation for more information.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9HashmapDup</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sKey</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pSrc</name> <operator>==</operator> <name>pDest</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Same map. This can easily happen since hashmaps are passed by reference.
		 * Unlike the  engine.
		 */</comment>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the first inserted entry in the source */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<comment type="block">/* Perform the duplication */</comment>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
		<comment type="block">/* Extract the node value */</comment>
		<expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_BLOB_NODE</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Blob key insertion */</comment>
			<expr_stmt><expr><call><name>jx9MemObjInitFromString</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9MemObjStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9HashmapInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pDest</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Int key insertion */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsertIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pDest</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Perform the union of two hashmaps.
 * This operation is performed only if the user uses the '+' operator
 * with a variable holding an array as follows:
 * &lt;?jx9
 * $a = array("a" =&gt; "apple", "b" =&gt; "banana");
 * $b = array("a" =&gt; "pear", "b" =&gt; "strawberry", "c" =&gt; "cherry");
 * $c = $a + $b; // Union of $a and $b
 * print "Union of \$a and \$b: \n";
 * dump($c);
 * $c = $b + $a; // Union of $b and $a
 * print "Union of \$b and \$a: \n";
 * dump($c);
 * ?&gt;
 * When executed, this script will print the following:
 * Union of $a and $b:
 * array(3) {
 *  ["a"]=&gt;
 *  string(5) "apple"
 *  ["b"]=&gt;
 * string(6) "banana"
 *  ["c"]=&gt;
 * string(6) "cherry"
 * }
 * Union of $b and $a:
 * array(3) {
 * ["a"]=&gt;
 * string(4) "pear"
 * ["b"]=&gt;
 * string(10) "strawberry"
 * ["c"]=&gt;
 * string(6) "cherry"
 * }
 * The + operator returns the right-hand array appended to the left-hand array;
 * For keys that exist in both arrays, the elements from the left-hand array will be used
 * and the matching elements from the right-hand array will be ignored.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9HashmapUnion</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name> <init>= <expr><name>SXRET_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pLeft</name> <operator>==</operator> <name>pRight</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Same map. This can easily happen since hashmaps are passed by reference.
		 * Unlike the  engine.
		 */</comment>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the union */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<for>for<control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
		<comment type="block">/* Make sure the given key does not exists in the left array */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_BLOB_NODE</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* BLOB key */</comment>
			<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>!=</operator> 
				<call><name>HashmapLookupBlobKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pLeft</name><operator>)</operator></expr></argument>, <argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>pObj</name></expr> )</condition><block>{<block_content>
						<comment type="block">/* Perform the insertion */</comment>
						<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsertBlobKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pLeft</name><operator>)</operator></expr></argument>, <argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
							<return>return <expr><name>rc</name></expr>;</return>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* INT key */</comment>
			<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>!=</operator> <call><name>HashmapLookupIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pLeft</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>pObj</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* Perform the insertion */</comment>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsertIntKey</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pLeft</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name></expr></argument>, <argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
						<return>return <expr><name>rc</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Allocate a new hashmap.
 * Return a pointer to the freshly allocated hashmap on success.NULL otherwise.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>jx9_hashmap</name> <modifier>*</modifier></type> <name>jx9NewHashmap</name><parameter_list>(
	<parameter><decl><type><name>jx9_vm</name> <modifier>*</modifier></type><name>pVm</name></decl></parameter>,              <comment type="block">/* VM that trigger the hashmap creation */</comment>
	<parameter><function_decl><type><name>sxu32</name></type> (<modifier>*</modifier><name>xIntHash</name>)<parameter_list>(<parameter><decl><type><name>sxi64</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Hash function for int keys.NULL otherwise*/</comment>
	<parameter><function_decl><type><name>sxu32</name></type> (<modifier>*</modifier><name>xBlobHash</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sxu32</name></type></decl></parameter>)</parameter_list></function_decl></parameter> <comment type="block">/* Hash function for BLOB keys.NULL otherwise */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<comment type="block">/* Allocate a new instance */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jx9_hashmap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pMap</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the structure */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jx9_hashmap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVm</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* pMap-&gt;iFlags = 0; */</comment>
	<comment type="block">/* Default hash functions */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>xIntHash</name></name>  <operator>=</operator> <ternary><condition><expr><name>xIntHash</name></expr> ?</condition><then> <expr><name>xIntHash</name></expr> </then><else>: <expr><name>IntHash</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>xBlobHash</name></name> <operator>=</operator> <ternary><condition><expr><name>xBlobHash</name></expr> ?</condition><then> <expr><name>xBlobHash</name></expr> </then><else>: <expr><name>BinHash</name></expr></else></ternary></expr>;</expr_stmt>
	<return>return <expr><name>pMap</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Install superglobals in the given virtual machine.
 * Note on superglobals.
 *  According to the JX9 language reference manual.
 *  Superglobals are built-in variables that are always available in all scopes.
*   Description
*   All predefined variables in JX9 are "superglobals", which means they
*   are available in all scopes throughout a script.
*   These variables are:
*    $_SERVER
*    $_GET
*    $_POST
*    $_FILES
*    $_REQUEST
*    $_ENV
*/</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9HashmapLoadBuiltin</name><parameter_list>(<parameter><decl><type><name>jx9_vm</name> <modifier>*</modifier></type><name>pVm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name><name>azSuper</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"_SERVER"</literal></expr>,   <comment type="block">/* $_SERVER */</comment>
		<expr><literal type="string">"_GET"</literal></expr>,      <comment type="block">/* $_GET */</comment>
		<expr><literal type="string">"_POST"</literal></expr>,     <comment type="block">/* $_POST */</comment>
		<expr><literal type="string">"_FILES"</literal></expr>,    <comment type="block">/* $_FILES */</comment>
		<expr><literal type="string">"_REQUEST"</literal></expr>,  <comment type="block">/* $_REQUEST */</comment>
		<expr><literal type="string">"_COOKIE"</literal></expr>,   <comment type="block">/* $_COOKIE */</comment>
		<expr><literal type="string">"_ENV"</literal></expr>,      <comment type="block">/* $_ENV */</comment>
		<expr><literal type="string">"_HEADER"</literal></expr>,   <comment type="block">/* $_HEADER */</comment>
		<expr><literal type="string">"argv"</literal></expr>       <comment type="block">/* $argv */</comment>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<comment type="block">/* Install globals variable now */</comment>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator>  <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>azSuper</name></expr></argument>)</argument_list></call></expr>  ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pSuper</name></decl>;</decl_stmt>
		<comment type="block">/* Request an empty array */</comment>
		<expr_stmt><expr><name>pSuper</name> <operator>=</operator> <call><name>jx9_new_array</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVm</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pSuper</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><name>SXERR_MEM</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Install */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9_vm_config</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVm</name><operator>)</operator></expr></argument>,<argument><expr><name>JX9_VM_CONFIG_CREATE_VAR</name></expr></argument>, <argument><expr><name><name>azSuper</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument><comment type="block">/* Super-global name*/</comment>, <argument><expr><name>pSuper</name></expr></argument><comment type="block">/* Super-global value */</comment>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Release the value now it have been installed */</comment>
		<expr_stmt><expr><call><name>jx9_release_value</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVm</name><operator>)</operator></expr></argument>, <argument><expr><name>pSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Set some $_SERVER entries */</comment>
	<expr_stmt><expr><name>pFile</name> <operator>=</operator> <operator>(</operator><name>SyString</name> <operator>*</operator><operator>)</operator><call><name>SySetPeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>aFiles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * 'SCRIPT_FILENAME'
	 * The absolute pathname of the currently executing script.
	 */</comment>
	<expr_stmt><expr><call><name>jx9_vm_config</name><argument_list>(<argument><expr><name>pVm</name></expr></argument>, <argument><expr><name>JX9_VM_CONFIG_SERVER_ATTR</name></expr></argument>, 
		<argument><expr><literal type="string">"SCRIPT_FILENAME"</literal></expr></argument>, 
		<argument><expr><ternary><condition><expr><name>pFile</name></expr> ?</condition><then> <expr><name><name>pFile</name><operator>-&gt;</operator><name>zString</name></name></expr> </then><else>: <expr><literal type="string">":Memory:"</literal></expr></else></ternary></expr></argument>, 
		<argument><expr><ternary><condition><expr><name>pFile</name></expr> ?</condition><then> <expr><name><name>pFile</name><operator>-&gt;</operator><name>nByte</name></name></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">":Memory:"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done, all global variables are installed now */</comment>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Release a hashmap.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9HashmapRelease</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>FreeDS</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_vm</name> <modifier>*</modifier></type><name>pVm</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<comment type="block">/* Start the release process */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
		<comment type="block">/* Restore the jx9_value to the free list */</comment>
		<expr_stmt><expr><call><name>jx9VmUnsetMemObj</name><argument_list>(<argument><expr><name>pVm</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nValIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Release the node */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_BLOB_NODE</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Release the hash bucket */</comment>
		<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>FreeDS</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Free the whole instance */</comment>
		<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Keep the instance but reset it's fields */</comment>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>apBucket</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pLast</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Decrement the reference count of a given hashmap.
 * If the count reaches zero which mean no more variables
 * are pointing to this hashmap, then release the whole instance.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type>  <name>jx9HashmapUnref</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iRef</name></name><operator>--</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>iRef</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9HashmapRelease</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Check if a given key exists in the given hashmap.
 * Write a pointer to the target node on success.
 * Otherwise SXERR_NOTFOUND is returned on failure.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9HashmapLookup</name><parameter_list>(
	<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>,        <comment type="block">/* Target hashmap */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,          <comment type="block">/* Lookup key */</comment>
	<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNode</name></decl></parameter> <comment type="block">/* OUT: Target node on success */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* TICKET 1433-25: Don't bother hashing, the hashmap is empty anyway.
		 */</comment>
		<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pKey</name><operator>)</operator></expr></argument>, <argument><expr><name>ppNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Insert a given key and it's associated value (if any) in the given
 * hashmap.
 * If a node with the given key already exists in the database
 * then this function overwrite the old value.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9HashmapInsert</name><parameter_list>(
	<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <comment type="block">/* Target hashmap */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,   <comment type="block">/* Lookup key */</comment>
	<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>    <comment type="block">/* Node value.NULL otherwise */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pMap</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pKey</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVal</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Reset the node cursor of a given hashmap.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>jx9HashmapResetLoopCursor</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Reset the loop cursor */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Return a pointer to the node currently pointed by the node cursor.
 * If the cursor reaches the end of the list, then this function
 * return NULL.
 * Note that the node cursor is automatically advanced by this function.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>jx9_hashmap_node</name> <modifier>*</modifier></type> <name>jx9HashmapGetNextEntry</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* End of the list, return null */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Advance the node cursor */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	<return>return <expr><name>pCur</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Extract a node value.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>jx9_value</name> <modifier>*</modifier></type> <name>jx9HashmapGetNodeValue</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>pValue</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Extract a node value (Second).
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>jx9HashmapExtractNodeValue</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bStore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pEntry</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>bStore</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9MemObjStore</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>jx9MemObjLoad</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Extract a node key.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>jx9HashmapExtractNodeKey</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Fill with the current key */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_INT_NODE</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pKey</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>iVal</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemObjSetType</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>MEMOBJ_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>SyBlobReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pKey</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>, <argument><expr><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemObjSetType</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>MEMOBJ_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<comment type="block">/*
 * Store the address of nodes value in the given container.
 * Refer to the [vfprintf(), vprintf(), vsprintf()] implementations
 * defined in 'builtin.c' for more information.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>int</name></type> <name>jx9HashmapValuesToSet</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<comment type="block">/* Initialize the container */</comment>
	<expr_stmt><expr><call><name>SySetInit</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jx9_value</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<comment type="block">/* Extract node value */</comment>
		<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pValue</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>SySetPut</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<comment type="block">/* Total inserted entries */</comment>
	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>SySetUsed</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
<comment type="block">/*
 * Merge sort.
 * The merge sort implementation is based on the one found in the SQLite3 source tree.
 * Status: Public domain
 */</comment>
<comment type="block">/* Node comparison callback signature */</comment>
<typedef>typedef <function_decl><type><name>sxi32</name></type> (<modifier>*</modifier><name>ProcNodeCmp</name>)<parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<comment type="block">/*
** Inputs:
**   a:       A sorted, null-terminated linked list.  (May be null).
**   b:       A sorted, null-terminated linked list.  (May be null).
**   cmp:     A pointer to the comparison function.
**
** Return Value:
**   A pointer to the head of a sorted list containing the elements
**   of both a and b.
**
** Side effects:
**   The "next", "prev" pointers for elements in the lists a and b are
**   changed.
*/</comment>
<function><type><specifier>static</specifier> <name>jx9_hashmap_node</name> <modifier>*</modifier></type> <name>HashmapNodeMerge</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>, <parameter><decl><type><name>ProcNodeCmp</name></type> <name>xCmp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCmpData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name></type> <name>result</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pTail</name></decl>;</decl_stmt>
    <comment type="block">/* Prevent compiler warning */</comment>
	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>pPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>pTail</name> <operator>=</operator> <operator>&amp;</operator><name>result</name></expr>;</expr_stmt>
	<while>while<condition>( <expr><name>pA</name> <operator>&amp;&amp;</operator> <name>pB</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><call><name>xCmp</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>pCmpData</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pB</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>pA</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pB</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name><name>result</name><operator>.</operator><name>pPrev</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Inputs:
**   Map:       Input hashmap
**   cmp:       A comparison function.
**
** Return Value:
**   Sorted hashmap.
**
** Side effects:
**   The "next" pointers for elements in list are changed.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_SORT_BUCKET</name></cpp:macro>  <cpp:value>32</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapMergeSort</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>ProcNodeCmp</name></type> <name>xCmp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCmpData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name><name>a</name><index>[<expr><name>N_SORT_BUCKET</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Point to the first inserted entry */</comment>
	<expr_stmt><expr><name>pIn</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<while>while<condition>( <expr><name>pIn</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pIn</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N_SORT_BUCKET</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>HashmapNodeMerge</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xCmp</name></expr></argument>, <argument><expr><name>pCmpData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>N_SORT_BUCKET</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* To get here, there need to be 2^(N_SORT_BUCKET) elements in he input list.
			 * But that is impossible.
			 */</comment>
			<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>HashmapNodeMerge</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xCmp</name></expr></argument>, <argument><expr><name>pCmpData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N_SORT_BUCKET</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>HashmapNodeMerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>xCmp</name></expr></argument>, <argument><expr><name>pCmpData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Reflect the change */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<comment type="block">/* Reset the loop cursor */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Node comparison callback.
 * used-by: [sort(), asort(), ...]
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapCmpCallback1</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCmpData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sA</name></decl>, <decl><type ref="prev"/><name>sB</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>iFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCmpData</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Perform a standard comparison */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapNodeCmp</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iFlags</name> <operator>=</operator> <call><name>SX_PTR_TO_INT</name><argument_list>(<argument><expr><name>pCmpData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Duplicate node values */</comment>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iFlags</name> <operator>==</operator> <literal type="number">5</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* String cast */</comment>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>sA</name><operator>.</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9MemObjToString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>sB</name><operator>.</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9MemObjToString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Numeric cast */</comment>
		<expr_stmt><expr><call><name>jx9MemObjToNumeric</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9MemObjToNumeric</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Perform the comparison */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9MemObjCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Node comparison callback.
 * Used by: [rsort(), arsort()];
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapCmpCallback3</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCmpData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sA</name></decl>, <decl><type ref="prev"/><name>sB</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>iFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCmpData</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Perform a standard comparison */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapNodeCmp</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iFlags</name> <operator>=</operator> <call><name>SX_PTR_TO_INT</name><argument_list>(<argument><expr><name>pCmpData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Duplicate node values */</comment>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iFlags</name> <operator>==</operator> <literal type="number">5</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* String cast */</comment>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>sA</name><operator>.</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9MemObjToString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>sB</name><operator>.</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>jx9MemObjToString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Numeric cast */</comment>
		<expr_stmt><expr><call><name>jx9MemObjToNumeric</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9MemObjToNumeric</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Perform the comparison */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9MemObjCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Node comparison callback: Invoke an user-defined callback for the purpose of node comparison.
 * used-by: [usort(), uasort()]
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapCmpCallback4</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCmpData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sResult</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pCallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pV1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pV2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Callback arguments */</comment>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Point to the desired callback */</comment>
	<expr_stmt><expr><name>pCallback</name> <operator>=</operator> <operator>(</operator><name>jx9_value</name> <operator>*</operator><operator>)</operator><name>pCmpData</name></expr>;</expr_stmt>
	<comment type="block">/* initialize the result value */</comment>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Extract nodes values */</comment>
	<expr_stmt><expr><name>pV1</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pV2</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pV1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>pV2</name></expr>;</expr_stmt>
	<comment type="block">/* Invoke the callback */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9VmCallUserFunction</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><name>pCallback</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>apArg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* An error occured while calling user defined function [i.e: not defined] */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Set a dummy result */</comment>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Extract callback result */</comment>
		<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>sResult</name><operator>.</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_INT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Perform an int cast */</comment>
			<expr_stmt><expr><call><name>jx9MemObjToInteger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>sxi32</name><operator>)</operator><name><name>sResult</name><operator>.</operator><name>x</name><operator>.</operator><name>iVal</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Callback result */</comment>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Rehash all nodes keys after a merge-sort have been applied.
 * Used by [sort(), usort() and rsort()].
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>HashmapSortRehash</name><parameter_list>(<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>i</name></decl>;</decl_stmt>
	<comment type="block">/* Rehash all entries */</comment>
	<expr_stmt><expr><name>pLast</name> <operator>=</operator> <name>p</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Reset the automatic index */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for<control>( <init>;</init><condition>;</condition> <incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>i</name> <operator>&gt;=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pLast</name></name> <operator>=</operator> <name>pLast</name></expr>;</expr_stmt> <comment type="block">/* Fix the last link broken by the merge-sort */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_BLOB_NODE</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Do not maintain index association as requested by the JX9 specification */</comment>
			<expr_stmt><expr><call><name>SyBlobRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Change key type */</comment>
			<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iType</name></name> <operator>=</operator> <name>HASHMAP_INT_NODE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>HashmapRehashIntNode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>pLast</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
</block_content>}</block></function>
<comment type="block">/*
 * Array functions implementation.
 * Authors:
 *  Symisc Systems, devel@symisc.net.
 *  Copyright (C) Symisc Systems, http://jx9.symisc.net
 * Status:
 *  Stable.
 */</comment>
<comment type="block">/*
 * bool sort(array &amp;$array[, int $sort_flags = SORT_REGULAR ] )
 * Sort an array.
 * Parameters
 *  $array
 *   The input array.
 * $sort_flags
 *  The optional second parameter sort_flags may be used to modify the sorting behavior using these values:
 *  Sorting type flags:
 *   SORT_REGULAR - compare items normally (don't change types)
 *   SORT_NUMERIC - compare items numerically
 *   SORT_STRING - compare items as strings
 * Return
 *  TRUE on success or FALSE on failure.
 * 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_sort</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the input hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>sxi32</name></type> <name>iCmpFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Extract comparison flags */</comment>
			<expr_stmt><expr><name>iCmpFlags</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>iCmpFlags</name> <operator>==</operator> <literal type="number">3</literal></expr> <comment type="block">/* SORT_REGULAR */</comment> )</condition><block>{<block_content>
				<expr_stmt><expr><name>iCmpFlags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Standard comparison */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Do the merge sort */</comment>
		<expr_stmt><expr><call><name>HashmapMergeSort</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><name>HashmapCmpCallback1</name></expr></argument>, <argument><expr><call><name>SX_INT_TO_PTR</name><argument_list>(<argument><expr><name>iCmpFlags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Rehash [Do not maintain index association as requested by the JX9 specification] */</comment>
		<expr_stmt><expr><call><name>HashmapSortRehash</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* All done, return TRUE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool rsort(array &amp;$array[, int $sort_flags = SORT_REGULAR ] )
 * Sort an array in reverse order.
 * Parameters
 *  $array
 *   The input array.
 * $sort_flags
 *  The optional second parameter sort_flags may be used to modify the sorting behavior using these values:
 *  Sorting type flags:
 *   SORT_REGULAR - compare items normally (don't change types)
 *   SORT_NUMERIC - compare items numerically
 *   SORT_STRING - compare items as strings
 * Return
 *  TRUE on success or FALSE on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_rsort</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the input hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>sxi32</name></type> <name>iCmpFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Extract comparison flags */</comment>
			<expr_stmt><expr><name>iCmpFlags</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>iCmpFlags</name> <operator>==</operator> <literal type="number">3</literal></expr> <comment type="block">/* SORT_REGULAR */</comment> )</condition><block>{<block_content>
				<expr_stmt><expr><name>iCmpFlags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Standard comparison */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Do the merge sort */</comment>
		<expr_stmt><expr><call><name>HashmapMergeSort</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><name>HashmapCmpCallback3</name></expr></argument>, <argument><expr><call><name>SX_INT_TO_PTR</name><argument_list>(<argument><expr><name>iCmpFlags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Rehash [Do not maintain index association as requested by the JX9 specification] */</comment>
		<expr_stmt><expr><call><name>HashmapSortRehash</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* All done, return TRUE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool usort(array &amp;$array, callable $cmp_function)
 *  Sort an array by values using a user-defined comparison function.
 * Parameters
 *  $array
 *   The input array.
 * $cmp_function
 *  The comparison function must return an integer less than, equal to, or greater
 *  than zero if the first argument is considered to be respectively less than, equal
 *  to, or greater than the second.
 *    int callback ( mixed $a, mixed $b )
 * Return
 *  TRUE on success or FALSE on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_usort</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing/Invalid arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the input hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pCallback</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ProcNodeCmp</name></type> <name>xCmp</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>xCmp</name> <operator>=</operator> <name>HashmapCmpCallback4</name></expr>;</expr_stmt> <comment type="block">/* User-defined function as the comparison callback */</comment>
		<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>jx9_value_is_callable</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Point to the desired callback */</comment>
			<expr_stmt><expr><name>pCallback</name> <operator>=</operator> <name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Use the default comparison function */</comment>
			<expr_stmt><expr><name>xCmp</name> <operator>=</operator> <name>HashmapCmpCallback1</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Do the merge sort */</comment>
		<expr_stmt><expr><call><name>HashmapMergeSort</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><name>xCmp</name></expr></argument>, <argument><expr><name>pCallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Rehash [Do not maintain index association as requested by the JX9 specification] */</comment>
		<expr_stmt><expr><call><name>HashmapSortRehash</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* All done, return TRUE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int count(array $var [, int $mode = COUNT_NORMAL ])
 *   Count all elements in an array, or something in an object.
 * Parameters
 *  $var
 *   The array or the object.
 * $mode
 *  If the optional mode parameter is set to COUNT_RECURSIVE (or 1), count()
 *  will recursively count the array. This is particularly useful for counting 
 *  all the elements of a multidimensional array. count() does not detect infinite
 *  recursion.
 * Return
 *  Returns the number of elements in the array.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_count</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>bRecursive</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>iCount</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* TICKET 1433-19: Handle objects */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><operator>!</operator><call><name>jx9_value_is_null</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Recursive count? */</comment>
		<expr_stmt><expr><name>bRecursive</name> <operator>=</operator> <call><name>jx9_value_to_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr> <comment type="block">/* COUNT_RECURSIVE */</comment>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Count */</comment>
	<expr_stmt><expr><name>iCount</name> <operator>=</operator> <call><name>HashmapCount</name><argument_list>(<argument><expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr></argument>, <argument><expr><name>bRecursive</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>iCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool array_key_exists(value $key, array $search)
 *  Checks if the given key or index exists in the array.
 * Parameters
 * $key
 *   Value to check.
 * $search
 *  An array with keys to check.
 * Return
 *  TRUE on success or FALSE on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_key_exists</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the lookup */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9HashmapLookup</name><argument_list>(<argument><expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr></argument>, <argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* lookup result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><ternary><condition><expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * value array_pop(array $array)
 *   POP the last inserted element from the array.
 * Parameter
 *  The array to get the value from.
 * Return
 *  Poped value or NULL on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_pop</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Noting to pop, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pLast</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>pLast</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pObj</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Node value */</comment>
			<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unlink the node */</comment>
			<expr_stmt><expr><call><name>jx9HashmapUnlinkNode</name><argument_list>(<argument><expr><name>pLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Reset the cursor */</comment>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * int array_push($array, $var, ...)
 *   Push one or more elements onto the end of array. (Stack insertion)
 * Parameters
 *  array
 *    The input array.
 *  var
 *   On or more value to push.
 * Return
 *  New array count (including old items).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_push</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the input hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<comment type="block">/* Start pushing given values */</comment>
	<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nArg</name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9HashmapInsert</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Return the new count */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>sxi64</name><operator>)</operator><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * value array_shift(array $array)
 *   Shift an element off the beginning of array.
 * Parameter
 *  The array to get the value from.
 * Return
 *  Shifted value or NULL on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_shift</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return null */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty hashmap, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pObj</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Node value */</comment>
			<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unlink the first node */</comment>
			<expr_stmt><expr><call><name>jx9HashmapUnlinkNode</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Rehash all int keys */</comment>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>iNextIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Reset the automatic index */</comment>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_INT_NODE</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>HashmapRehashIntNode</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Point to the next entry */</comment>
			<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
			<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* Reset the cursor */</comment>
		<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Extract the node cursor value.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashmapCurrentValue</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDirection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Cursor does not point to anything, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>iDirection</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>iDirection</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Point to the next entry */</comment>
			<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
			<expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Point to the previous entry */</comment>
			<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
			<expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* End of input reached, return FALSE */</comment>
			<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>JX9_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>		
	<comment type="block">/* Point to the desired element */</comment>
	<expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * value current(array $array)
 *  Return the current element in an array.
 * Parameter
 *  $input: The input array.
 * Return
 *  The current() function simply returns the value of the array element that's currently
 *  being pointed to by the internal pointer. It does not move the pointer in any way.
 *  If the internal pointer points beyond the end of the elements list or the array 
 *  is empty, current() returns FALSE. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_current</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>HashmapCurrentValue</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pCtx</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * value next(array $input)
 *  Advance the internal array pointer of an array.
 * Parameter
 *  $input: The input array.
 * Return
 *  next() behaves like current(), with one difference. It advances the internal array 
 *  pointer one place forward before returning the element value. That means it returns 
 *  the next array value and advances the internal array pointer by one. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_next</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>HashmapCurrentValue</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pCtx</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * value prev(array $input)
 *  Rewind the internal array pointer.
 * Parameter
 *  $input: The input array.
 * Return
 *  Returns the array value in the previous place that's pointed
 *  to by the internal array pointer, or FALSE if there are no more
 *  elements. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_prev</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>HashmapCurrentValue</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pCtx</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * value end(array $input)
 *  Set the internal pointer of an array to its last element.
 * Parameter
 *  $input: The input array.
 * Return
 *  Returns the value of the last element or FALSE for empty array. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_end</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the input hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<comment type="block">/* Point to the last node */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pLast</name></name></expr>;</expr_stmt>
	<comment type="block">/* Return the last node value */</comment>
	<expr_stmt><expr><call><name>HashmapCurrentValue</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pCtx</name><operator>)</operator></expr></argument>, <argument><expr><name>pMap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * value reset(array $array )
 *  Set the internal pointer of an array to its first element.
 * Parameter
 *  $input: The input array.
 * Return
 *  Returns the value of the first array element, or FALSE if the array is empty. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_reset</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the input hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<comment type="block">/* Point to the first node */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<comment type="block">/* Return the last node value if available */</comment>
	<expr_stmt><expr><call><name>HashmapCurrentValue</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pCtx</name><operator>)</operator></expr></argument>, <argument><expr><name>pMap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * value key(array $array)
 *   Fetch a key from an array
 * Parameter
 *  $input
 *   The input array.
 * Return
 *  The key() function simply returns the key of the array element that's currently
 *  being pointed to by the internal pointer. It does not move the pointer in any way.
 *  If the internal pointer points beyond the end of the elements list or the array 
 *  is empty, key() returns NULL. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_simple_key</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Cursor does not point to anything, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_INT_NODE</name></expr>)</condition><block>{<block_content>
		<comment type="block">/* Key is integer */</comment>
		<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Key is blob */</comment>
		<expr_stmt><expr><call><name>jx9_result_string</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, 
			<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array each(array $input)
 *  Return the current key and value pair from an array and advance the array cursor.
 * Parameter
 *  $input
 *    The input array.
 * Return
 *  Returns the current key and value pair from the array array. This pair is returned 
 *  in a four-element array, with the keys 0, 1, key, and value. Elements 0 and key 
 *  contain the key name of the array element, and 1 and value contain the data.
 *  If the internal pointer for the array points past the end of the array contents
 *  each() returns FALSE. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_each</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sKey</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation that describe the input hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Cursor does not point to anything, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name></expr>;</expr_stmt>
	<comment type="block">/* Create a new array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Insert the current value */</comment>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Make the key */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iType</name></name> <operator>==</operator> <name>HASHMAP_INT_NODE</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9MemObjInitFromInt</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>iKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>jx9MemObjInitFromString</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9MemObjStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>xKey</name><operator>.</operator><name>sKey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Insert the current key */</comment>
	<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9_array_add_strkey_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Advance the cursor */</comment>
	<expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>pCur</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	<comment type="block">/* Return the current entry */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array array_values(array $input)
 *   Returns all the values from the input array and indexes numerically the array.
 * Parameters
 *   input: The input array.
 * Return
 *  An indexed array of values or NULL on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_values</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation that describe the input hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<comment type="block">/* Create a new array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pObj</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* perform the insertion */</comment>
			<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index assign */</comment>, <argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<comment type="block">/* return the new array */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool array_same(array $arr1, array $arr2)
 *  Return TRUE if the given arrays are the same instance.
 *  This function is useful under JX9 since arrays and objects
 *  are passed by reference.
 * Parameters
 *  $arr1
 *   First array
 *  $arr2
 *   Second array
 * Return
 *  TRUE if the arrays are the same instance. FALSE otherwise.
 * Note
 *  This function is a symisc eXtension.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_same</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>p1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing or invalid arguments, return FALSE*/</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the hashmaps */</comment>
	<expr_stmt><expr><name>p1</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p2</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>p1</name> <operator>==</operator> <name>p2</name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* Same instance? */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array array_merge(array $array1, ...)
 *  Merge one or more arrays.
 * Parameters
 *  $array1
 *    Initial array to merge.
 *  ...
 *   More array to merge.
 * Return
 *  The resulting array.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_merge</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create a new array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>pArray</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<comment type="block">/* Start merging */</comment>
	<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nArg</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<comment type="block">/* Insert scalar value */</comment>
			<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name>pSrc</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
			<comment type="block">/* Merge the two hashmaps */</comment>
			<expr_stmt><expr><call><name>HashmapMerge</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Return the freshly created array */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool in_array(value $needle, array $haystack[, bool $strict = FALSE ])
 *  Checks if a value exists in an array.
 * Parameters
 *  $needle
 *   The searched value.
 *   Note:
 *    If needle is a string, the comparison is done in a case-sensitive manner.
 * $haystack
 *  The target array.
 * $strict
 *  If the third parameter strict is set to TRUE then the in_array() function
 *  will also check the types of the needle in the haystack.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_in_array</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pNeedle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bStrict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing argument, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pNeedle</name> <operator>=</operator> <name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bStrict</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>bStrict</name> <operator>=</operator> <call><name>jx9_value_to_bool</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* haystack must be an array, perform a standard comparison */</comment> 
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9_value_compare</name><argument_list>(<argument><expr><name>pNeedle</name></expr></argument>, <argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>bStrict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Set the comparison result */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the lookup */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapFindValue</name><argument_list>(<argument><expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr></argument>, <argument><expr><name>pNeedle</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bStrict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Lookup result */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array array_copy(array $source)
 *  Make a blind copy of the target array.
 * Parameters
 *  $source
 *   Target array
 * Return
 *  Copy of the target array on success. NULL otherwise.
 * Note
 *  This function is a symisc eXtension.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_copy</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create a new array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>pArray</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
		<comment type="block">/* Point to the internal representation of the source */</comment>
		<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Perform the copy */</comment>
		<expr_stmt><expr><call><name>jx9HashmapDup</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Simple insertion */</comment>
		<expr_stmt><expr><call><name>jx9HashmapInsert</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument><comment type="block">/* Automatic index assign*/</comment>, <argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Return the duplicated array */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool array_erase(array $source)
 *  Remove all elements from a given array.
 * Parameters
 *  $source
 *   Target array
 * Return
 *  TRUE on success. FALSE otherwise.
 * Note
 *  This function is a symisc eXtension.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_erase</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the target hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<comment type="block">/* Erase */</comment>
	<expr_stmt><expr><call><name>jx9HashmapRelease</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array array_diff(array $array1, array $array2, ...)
 *  Computes the difference of arrays.
 * Parameters
 *  $array1
 *    The array to compare from
 *  $array2
 *    An array to compare against 
 *  $...
 *   More arrays to compare against
 * Return
 *  Returns an array containing all the entries from array1 that
 *  are not present in any of the other arrays.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_diff</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pSrc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>==</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return the first array since we cannot perform a diff */</comment>
		<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create a new array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the source hashmap */</comment>
	<expr_stmt><expr><name>pSrc</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<comment type="block">/* Perform the diff */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract the node value */</comment>
		<expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
			<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nArg</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<comment type="block">/* ignore */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Point to the internal representation of the hashmap */</comment>
				<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
				<comment type="block">/* Perform the lookup */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapFindValue</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* Value exist */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if<condition>( <expr><name>i</name> <operator>&gt;=</operator> <name>nArg</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Perform the insertion */</comment>
				<expr_stmt><expr><call><name>HashmapInsertNode</name><argument_list>(<argument><expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>pArray</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pOther</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
		<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Return the freshly created array */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array array_intersect(array $array1 , array $array2, ...)
 *  Computes the intersection of arrays.
 * Parameters
 *  $array1
 *    The array to compare from
 *  $array2
 *    An array to compare against 
 *  $...
 *   More arrays to compare against
 * Return
 *  Returns an array containing all of the values in array1 whose values exist
 *  in all of the parameters. .
 * Note that NULL is returned on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_intersect</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pSrc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>==</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Return the first array since we cannot perform a diff */</comment>
		<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create a new array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the source hashmap */</comment>
	<expr_stmt><expr><name>pSrc</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<comment type="block">/* Perform the intersection */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract the node value */</comment>
		<expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
			<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nArg</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<comment type="block">/* ignore */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Point to the internal representation of the hashmap */</comment>
				<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
				<comment type="block">/* Perform the lookup */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashmapFindValue</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* Value does not exist */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if<condition>( <expr><name>i</name> <operator>&gt;=</operator> <name>nArg</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Perform the insertion */</comment>
				<expr_stmt><expr><call><name>HashmapInsertNode</name><argument_list>(<argument><expr><operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>pArray</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pOther</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
		<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Return the freshly created array */</comment>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * number array_sum(array $array )
 *  Calculate the sum of values in an array.
 * Parameters
 *  $array: The input array.
 * Return
 *  Returns the sum of values as an integer or float.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>DoubleSum</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>dSum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pObj</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEMOBJ_NULL</name><operator>|</operator><name>MEMOBJ_HASHMAP</name><operator>|</operator><name>MEMOBJ_RES</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_REAL</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>dSum</name> <operator>+=</operator> <name><name>pObj</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rVal</name></name></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEMOBJ_INT</name><operator>|</operator><name>MEMOBJ_BOOL</name><operator>)</operator></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>dSum</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>pObj</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>iVal</name></name></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type> <name>dv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>SyStrToReal</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dSum</name> <operator>+=</operator> <name>dv</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<comment type="block">/* Return sum */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>dSum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>Int64Sum</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>nSum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pObj</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEMOBJ_NULL</name><operator>|</operator><name>MEMOBJ_HASHMAP</name><operator>|</operator><name>MEMOBJ_RES</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_REAL</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>nSum</name> <operator>+=</operator> <operator>(</operator><name>sxi64</name><operator>)</operator><name><name>pObj</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rVal</name></name></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEMOBJ_INT</name><operator>|</operator><name>MEMOBJ_BOOL</name><operator>)</operator></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>nSum</name> <operator>+=</operator> <name><name>pObj</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>iVal</name></name></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<decl_stmt><decl><type><name>sxi64</name></type> <name>nv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>SyStrToInt64</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>nSum</name> <operator>+=</operator> <name>nv</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<comment type="block">/* Return sum */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nSum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* number array_sum(array $array ) 
 * (See block-coment above)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_sum</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to compute, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* If the first element is of type float, then perform floating
	 * point computaion.Otherwise switch to int64 computaion.
	 */</comment>
	<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pObj</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_REAL</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>DoubleSum</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>Int64Sum</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * number array_product(array $array )
 *  Calculate the product of values in an array.
 * Parameters
 *  $array: The input array.
 * Return
 *  Returns the product of values as an integer or float.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>DoubleProd</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>dProd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dProd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pObj</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEMOBJ_NULL</name><operator>|</operator><name>MEMOBJ_HASHMAP</name><operator>|</operator><name>MEMOBJ_RES</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_REAL</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>dProd</name> <operator>*=</operator> <name><name>pObj</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rVal</name></name></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEMOBJ_INT</name><operator>|</operator><name>MEMOBJ_BOOL</name><operator>)</operator></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>dProd</name> <operator>*=</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>pObj</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>iVal</name></name></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type> <name>dv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>SyStrToReal</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dProd</name> <operator>*=</operator> <name>dv</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<comment type="block">/* Return product */</comment>
	<expr_stmt><expr><call><name>jx9_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>dProd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>Int64Prod</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>nProd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nProd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pObj</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEMOBJ_NULL</name><operator>|</operator><name>MEMOBJ_HASHMAP</name><operator>|</operator><name>MEMOBJ_RES</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_REAL</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>nProd</name> <operator>*=</operator> <operator>(</operator><name>sxi64</name><operator>)</operator><name><name>pObj</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rVal</name></name></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEMOBJ_INT</name><operator>|</operator><name>MEMOBJ_BOOL</name><operator>)</operator></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>nProd</name> <operator>*=</operator> <name><name>pObj</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>iVal</name></name></expr>;</expr_stmt>
			</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_STRING</name></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<decl_stmt><decl><type><name>sxi64</name></type> <name>nv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>SyStrToInt64</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyBlobData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pObj</name><operator>-&gt;</operator><name>sBlob</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>nProd</name> <operator>*=</operator> <name>nv</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<comment type="block">/* Return product */</comment>
	<expr_stmt><expr><call><name>jx9_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nProd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* number array_product(array $array )
 * (See block-block comment above)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_product</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pObj</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Missing arguments, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid hashmap */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid argument, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Nothing to compute, return 0 */</comment>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* If the first element is of type float, then perform floating
	 * point computaion.Otherwise switch to int64 computaion.
	 */</comment>
	<expr_stmt><expr><name>pObj</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pObj</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pObj</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>MEMOBJ_REAL</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>DoubleProd</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>Int64Prod</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * array array_map(callback $callback, array $arr1)
 *  Applies the callback to the elements of the given arrays.
 * Parameters
 *  $callback
 *   Callback function to run for each element in each array.
 * $arr1
 *   An array to run through the callback function.
 * Return
 *  Returns an array containing all the elements of arr1 after applying
 *  the callback function to each one. 
 * NOTE:
 *  array_map() passes only a single value to the callback. 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_map</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pArray</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pValue</name></decl>, <decl><type ref="prev"/><name>sKey</name></decl>, <decl><type ref="prev"/><name>sResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid arguments, return NULL */</comment>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create a new array */</comment>
	<expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>jx9_context_new_array</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pArray</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the internal representation of the input hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the requested operation */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<comment type="block">/* Extrcat the node value */</comment>
		<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pValue</name></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
			<comment type="block">/* Invoke the supplied callback */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9VmCallUserFunction</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Extract the node key */</comment>
			<expr_stmt><expr><call><name>jx9HashmapExtractNodeKey</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* An error occured while invoking the supplied callback [i.e: not defined] */</comment>
				<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Keep the same value */</comment>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Insert the callback return value */</comment>
				<expr_stmt><expr><call><name>jx9_array_add_elem</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>jx9_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * bool array_walk(array &amp;$array, callback $funcname [, value $userdata ] )
 *  Apply a user function to every member of an array.
 * Parameters
 *  $array
 *   The input array.
 * $funcname
 *  Typically, funcname takes on two parameters.The array parameter's value being
 *  the first, and the key/index second.
 * Note:
 *  If funcname needs to be working with the actual values of the array, specify the first
 *  parameter of funcname as a reference. Then, any changes made to those elements will 
 *  be made in the original array itself.
 * $userdata
 *  If the optional userdata parameter is supplied, it will be passed as the third parameter
 *  to the callback funcname.
 * Return
 *  Returns TRUE on success or FALSE on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jx9_hashmap_walk</name><parameter_list>(<parameter><decl><type><name>jx9_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_value</name> <modifier>*</modifier></type><name>pValue</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pUserData</name></decl>, <decl><type ref="prev"/><name>sKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><call><name>jx9_value_is_json_array</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Invalid/Missing arguments, return FALSE */</comment>
		<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>JX9_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pUserData</name> <operator>=</operator> <ternary><condition><expr><name>nArg</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>apArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<comment type="block">/* Point to the internal representation of the input hashmap */</comment>
	<expr_stmt><expr><name>pMap</name> <operator>=</operator> <operator>(</operator><name>jx9_hashmap</name> <operator>*</operator><operator>)</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>x</name><operator>.</operator><name>pOther</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the desired operation */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<comment type="block">/* Extract the node value */</comment>
		<expr_stmt><expr><name>pValue</name> <operator>=</operator> <call><name>HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pValue</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Extract the entry key */</comment>
			<expr_stmt><expr><call><name>jx9HashmapExtractNodeKey</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Invoke the supplied callback */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9VmCallUserFunctionAp</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* An error occured while invoking the supplied callback [i.e: not defined] */</comment>
				<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* return FALSE */</comment>
				<return>return <expr><name>JX9_OK</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
	</block_content>}</block></for>
	<comment type="block">/* All done, return TRUE */</comment>
	<expr_stmt><expr><call><name>jx9_result_bool</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>JX9_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Table of built-in hashmap functions.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>jx9_builtin_func</name></type> <name><name>aHashmapFunc</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"count"</literal></expr>,             <expr><name>jx9_hashmap_count</name></expr> }</block></expr>, 
	<expr><block>{<expr><literal type="string">"sizeof"</literal></expr>,            <expr><name>jx9_hashmap_count</name></expr> }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_key_exists"</literal></expr>,  <expr><name>jx9_hashmap_key_exists</name></expr> }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_pop"</literal></expr>,         <expr><name>jx9_hashmap_pop</name></expr>     }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_push"</literal></expr>,        <expr><name>jx9_hashmap_push</name></expr>    }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_shift"</literal></expr>,       <expr><name>jx9_hashmap_shift</name></expr>   }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_product"</literal></expr>,     <expr><name>jx9_hashmap_product</name></expr> }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_sum"</literal></expr>,         <expr><name>jx9_hashmap_sum</name></expr>     }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_values"</literal></expr>,      <expr><name>jx9_hashmap_values</name></expr>  }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_same"</literal></expr>,        <expr><name>jx9_hashmap_same</name></expr>    }</block></expr>,
	<expr><block>{<expr><literal type="string">"array_merge"</literal></expr>,       <expr><name>jx9_hashmap_merge</name></expr>   }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_diff"</literal></expr>,        <expr><name>jx9_hashmap_diff</name></expr>    }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_intersect"</literal></expr>,   <expr><name>jx9_hashmap_intersect</name></expr>}</block></expr>, 
	<expr><block>{<expr><literal type="string">"in_array"</literal></expr>,          <expr><name>jx9_hashmap_in_array</name></expr> }</block></expr>,
	<expr><block>{<expr><literal type="string">"array_copy"</literal></expr>,        <expr><name>jx9_hashmap_copy</name></expr>    }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_erase"</literal></expr>,       <expr><name>jx9_hashmap_erase</name></expr>   }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_map"</literal></expr>,         <expr><name>jx9_hashmap_map</name></expr>     }</block></expr>, 
	<expr><block>{<expr><literal type="string">"array_walk"</literal></expr>,        <expr><name>jx9_hashmap_walk</name></expr>    }</block></expr>, 
	<expr><block>{<expr><literal type="string">"sort"</literal></expr>,              <expr><name>jx9_hashmap_sort</name></expr>    }</block></expr>, 
	<expr><block>{<expr><literal type="string">"rsort"</literal></expr>,             <expr><name>jx9_hashmap_rsort</name></expr>   }</block></expr>, 
	<expr><block>{<expr><literal type="string">"usort"</literal></expr>,             <expr><name>jx9_hashmap_usort</name></expr>   }</block></expr>, 
	<expr><block>{<expr><literal type="string">"current"</literal></expr>,           <expr><name>jx9_hashmap_current</name></expr> }</block></expr>, 
	<expr><block>{<expr><literal type="string">"each"</literal></expr>,              <expr><name>jx9_hashmap_each</name></expr>    }</block></expr>, 
	<expr><block>{<expr><literal type="string">"pos"</literal></expr>,               <expr><name>jx9_hashmap_current</name></expr> }</block></expr>, 
	<expr><block>{<expr><literal type="string">"next"</literal></expr>,              <expr><name>jx9_hashmap_next</name></expr>    }</block></expr>, 
	<expr><block>{<expr><literal type="string">"prev"</literal></expr>,              <expr><name>jx9_hashmap_prev</name></expr>    }</block></expr>, 
	<expr><block>{<expr><literal type="string">"end"</literal></expr>,               <expr><name>jx9_hashmap_end</name></expr>     }</block></expr>, 
	<expr><block>{<expr><literal type="string">"reset"</literal></expr>,             <expr><name>jx9_hashmap_reset</name></expr>   }</block></expr>, 
	<expr><block>{<expr><literal type="string">"key"</literal></expr>,               <expr><name>jx9_hashmap_simple_key</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Register the built-in hashmap functions defined above.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>jx9RegisterHashmapFunctions</name><parameter_list>(<parameter><decl><type><name>jx9_vm</name> <modifier>*</modifier></type><name>pVm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>aHashmapFunc</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><call><name>jx9_create_function</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pVm</name><operator>)</operator></expr></argument>, <argument><expr><name><name>aHashmapFunc</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aHashmapFunc</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>xFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<comment type="block">/*
 * Iterate throw hashmap entries and invoke the given callback [i.e: xWalk()] for each 
 * retrieved entry.
 * Note that argument are passed to the callback by copy. That is, any modification to 
 * the entry value in the callback body will not alter the real value.
 * If the callback wishes to abort processing [i.e: it's invocation] it must return
 * a value different from JX9_OK.
 * Refer to [jx9_array_walk()] for more information.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9HashmapWalk</name><parameter_list>(
	<parameter><decl><type><name>jx9_hashmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <comment type="block">/* Target hashmap */</comment>
	<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xWalk</name>)<parameter_list>(<parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>jx9_value</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Walker callback */</comment>
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter> <comment type="block">/* Last argument to xWalk() */</comment>
	)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_hashmap_node</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_value</name></type> <name>sKey</name></decl>, <decl><type ref="prev"/><name>sValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<comment type="block">/* Initialize walker parameter */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXRET_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jx9MemObjInit</name><argument_list>(<argument><expr><name><name>pMap</name><operator>-&gt;</operator><name>pVm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pMap</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
	<comment type="block">/* Start the iteration process */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract a copy of the key and a copy the current value */</comment>
		<expr_stmt><expr><call><name>jx9HashmapExtractNodeKey</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9HashmapExtractNodeValue</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sValue</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Invoke the user callback */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xWalk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sValue</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Release the copy of the key and the value */</comment>
		<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9MemObjRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>JX9_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Callback request an operation abort */</comment>
			<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
		<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
