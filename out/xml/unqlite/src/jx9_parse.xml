<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/src/jx9_parse.c"><comment type="block">/*
 * Symisc JX9: A Highly Efficient Embeddable Scripting Engine Based on JSON.
 * Copyright (C) 2012-2013, Symisc Systems http://jx9.symisc.net/
 * Version 1.7.2
 * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES
 * please contact Symisc Systems via:
 *       legal@symisc.net
 *       licensing@symisc.net
 *       contact@symisc.net
 * or visit:
 *      http://jx9.symisc.net/
 */</comment>
 <comment type="block">/* $SymiscID: parse.c v1.2 FreeBSD 2012-12-11 00:46 stable &lt;chm@symisc.net&gt; $ */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_AMALGAMATION</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jx9Int.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* Expression parser for the Jx9 programming language */</comment>
<comment type="block">/* Operators associativity */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPR_OP_ASSOC_LEFT</name></cpp:macro>   <cpp:value>0x01</cpp:value></cpp:define> <comment type="block">/* Left associative operator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPR_OP_ASSOC_RIGHT</name></cpp:macro>  <cpp:value>0x02</cpp:value></cpp:define> <comment type="block">/* Right associative operator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPR_OP_NON_ASSOC</name></cpp:macro>    <cpp:value>0x04</cpp:value></cpp:define> <comment type="block">/* Non-associative operator */</comment>
<comment type="block">/* 
 * Operators table
 * This table is sorted by operators priority (highest to lowest) according
 * the JX9 language reference manual.
 * JX9 implements all the 60 JX9 operators and have introduced the eq and ne operators.
 * The operators precedence table have been improved dramatically so that you can do same
 * amazing things now such as array dereferencing, on the fly function call, anonymous function
 * as array values, object member access on instantiation and so on.
 * Refer to the following page for a full discussion on these improvements:
 * http://jx9.symisc.net/features.html
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>jx9_expr_op</name></type> <name><name>aOpTable</name><index>[]</index></name> <init>= <expr><block>{
	                              <comment type="block">/* Postfix operators */</comment>
	<comment type="block">/* Precedence 2(Highest), left-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"."</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_DOT</name></expr>,     <expr><literal type="number">2</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr> ,   <expr><name>JX9_OP_MEMBER</name></expr> }</block></expr>,
	<expr><block>{ <expr><block>{<expr><literal type="string">"["</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_SUBSCRIPT</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr> , <expr><name>JX9_OP_LOAD_IDX</name></expr>}</block></expr>, 
	<comment type="block">/* Precedence 3, non-associative  */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"++"</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><name>EXPR_OP_INCR</name></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr> , <expr><name>JX9_OP_INCR</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"--"</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><name>EXPR_OP_DECR</name></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr> , <expr><name>JX9_OP_DECR</name></expr>}</block></expr>, 
	                              <comment type="block">/* Unary operators */</comment>
	<comment type="block">/* Precedence 4, right-associative  */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"-"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>,                 <expr><name>EXPR_OP_UMINUS</name></expr>,    <expr><literal type="number">4</literal></expr>, <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_UMINUS</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"+"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>,                 <expr><name>EXPR_OP_UPLUS</name></expr>,     <expr><literal type="number">4</literal></expr>, <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_UPLUS</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"~"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>,                 <expr><name>EXPR_OP_BITNOT</name></expr>,    <expr><literal type="number">4</literal></expr>, <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_BITNOT</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"!"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>,                 <expr><name>EXPR_OP_LOGNOT</name></expr>,    <expr><literal type="number">4</literal></expr>, <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_LNOT</name></expr> }</block></expr>, 
	                             <comment type="block">/* Cast operators */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"(int)"</literal></expr>,    <expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"(int)"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>   }</block></expr>, <expr><name>EXPR_OP_TYPECAST</name></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_CVT_INT</name></expr>  }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"(bool)"</literal></expr>,   <expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"(bool)"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>  }</block></expr>, <expr><name>EXPR_OP_TYPECAST</name></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_CVT_BOOL</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"(string)"</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"(string)"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>, <expr><name>EXPR_OP_TYPECAST</name></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_CVT_STR</name></expr>  }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"(float)"</literal></expr>,  <expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"(float)"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>, <expr><name>EXPR_OP_TYPECAST</name></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_CVT_REAL</name></expr> }</block></expr>,
	<expr><block>{ <expr><block>{<expr><literal type="string">"(array)"</literal></expr>,  <expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"(array)"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>, <expr><name>EXPR_OP_TYPECAST</name></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_CVT_ARRAY</name></expr> }</block></expr>,   <comment type="block">/* Not used, but reserved for future use */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"(object)"</literal></expr>,  <expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"(object)"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>, <expr><name>EXPR_OP_TYPECAST</name></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_CVT_ARRAY</name></expr> }</block></expr>, <comment type="block">/* Not used, but reserved for future use */</comment>
	                           <comment type="block">/* Binary operators */</comment>
	<comment type="block">/* Precedence 7, left-associative */</comment> 
	<expr><block>{ <expr><block>{<expr><literal type="string">"*"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_MUL</name></expr>, <expr><literal type="number">7</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr> , <expr><name>JX9_OP_MUL</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"/"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_DIV</name></expr>, <expr><literal type="number">7</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr> , <expr><name>JX9_OP_DIV</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"%"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_MOD</name></expr>, <expr><literal type="number">7</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr> , <expr><name>JX9_OP_MOD</name></expr>}</block></expr>, 
	<comment type="block">/* Precedence 8, left-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"+"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_ADD</name></expr>, <expr><literal type="number">8</literal></expr>,  <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><name>JX9_OP_ADD</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"-"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_SUB</name></expr>, <expr><literal type="number">8</literal></expr>,  <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><name>JX9_OP_SUB</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">".."</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,<expr><name>EXPR_OP_DDOT</name></expr>, <expr><literal type="number">8</literal></expr>,  <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><name>JX9_OP_CAT</name></expr>}</block></expr>, 
	<comment type="block">/* Precedence 9, left-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"&lt;&lt;"</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><name>EXPR_OP_SHL</name></expr>, <expr><literal type="number">9</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><name>JX9_OP_SHL</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"&gt;&gt;"</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><name>EXPR_OP_SHR</name></expr>, <expr><literal type="number">9</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><name>JX9_OP_SHR</name></expr>}</block></expr>, 
	<comment type="block">/* Precedence 10, non-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"&lt;"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>,    <expr><name>EXPR_OP_LT</name></expr>,  <expr><literal type="number">10</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr>, <expr><name>JX9_OP_LT</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"&gt;"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>,    <expr><name>EXPR_OP_GT</name></expr>,  <expr><literal type="number">10</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr>, <expr><name>JX9_OP_GT</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"&lt;="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><name>EXPR_OP_LE</name></expr>,  <expr><literal type="number">10</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr>, <expr><name>JX9_OP_LE</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"&gt;="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><name>EXPR_OP_GE</name></expr>,  <expr><literal type="number">10</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr>, <expr><name>JX9_OP_GE</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"&lt;&gt;"</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><name>EXPR_OP_NE</name></expr>,  <expr><literal type="number">10</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr>, <expr><name>JX9_OP_NEQ</name></expr>}</block></expr>, 
	<comment type="block">/* Precedence 11, non-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"=="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_EQ</name></expr>,  <expr><literal type="number">11</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr>, <expr><name>JX9_OP_EQ</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"!="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_NE</name></expr>,  <expr><literal type="number">11</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr>, <expr><name>JX9_OP_NEQ</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"==="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">3</literal></expr>}</block></expr>, <expr><name>EXPR_OP_TEQ</name></expr>, <expr><literal type="number">11</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr>, <expr><name>JX9_OP_TEQ</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"!=="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">3</literal></expr>}</block></expr>, <expr><name>EXPR_OP_TNE</name></expr>, <expr><literal type="number">11</literal></expr>, <expr><name>EXPR_OP_NON_ASSOC</name></expr>, <expr><name>JX9_OP_TNE</name></expr>}</block></expr>, 
		<comment type="block">/* Precedence 12, left-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"&amp;"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_BAND</name></expr>, <expr><literal type="number">12</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>,   <expr><name>JX9_OP_BAND</name></expr>}</block></expr>, 
	                         <comment type="block">/* Binary operators */</comment>
	<comment type="block">/* Precedence 13, left-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"^"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_XOR</name></expr>, <expr><literal type="number">13</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><name>JX9_OP_BXOR</name></expr>}</block></expr>, 
	<comment type="block">/* Precedence 14, left-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"|"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_BOR</name></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><name>JX9_OP_BOR</name></expr>}</block></expr>, 
	<comment type="block">/* Precedence 15, left-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"&amp;&amp;"</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><name>EXPR_OP_LAND</name></expr>, <expr><literal type="number">15</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><name>JX9_OP_LAND</name></expr>}</block></expr>, 
	<comment type="block">/* Precedence 16, left-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"||"</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><name>EXPR_OP_LOR</name></expr>, <expr><literal type="number">16</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><name>JX9_OP_LOR</name></expr>}</block></expr>, 
	                      <comment type="block">/* Ternary operator */</comment>
	<comment type="block">/* Precedence 17, left-associative */</comment>
    <expr><block>{ <expr><block>{<expr><literal type="string">"?"</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_QUESTY</name></expr>, <expr><literal type="number">17</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>, 
	                     <comment type="block">/* Combined binary operators */</comment>
	<comment type="block">/* Precedence 18, right-associative */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">"="</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>,     <expr><name>EXPR_OP_ASSIGN</name></expr>,     <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_STORE</name></expr>}</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"+="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_ADD_ASSIGN</name></expr>, <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_ADD_STORE</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"-="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_SUB_ASSIGN</name></expr>, <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_SUB_STORE</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">".="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_DOT_ASSIGN</name></expr>, <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_CAT_STORE</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"*="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_MUL_ASSIGN</name></expr>, <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_MUL_STORE</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"/="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_DIV_ASSIGN</name></expr>, <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_DIV_STORE</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"%="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_MOD_ASSIGN</name></expr>, <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_MOD_STORE</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"&amp;="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_AND_ASSIGN</name></expr>, <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_BAND_STORE</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"|="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_OR_ASSIGN</name></expr>,  <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_BOR_STORE</name></expr>  }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"^="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>}</block></expr>,  <expr><name>EXPR_OP_XOR_ASSIGN</name></expr>, <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_BXOR_STORE</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"&lt;&lt;="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">3</literal></expr>}</block></expr>, <expr><name>EXPR_OP_SHL_ASSIGN</name></expr>, <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_SHL_STORE</name></expr> }</block></expr>, 
	<expr><block>{ <expr><block>{<expr><literal type="string">"&gt;&gt;="</literal></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">3</literal></expr>}</block></expr>, <expr><name>EXPR_OP_SHR_ASSIGN</name></expr>, <expr><literal type="number">18</literal></expr>,  <expr><name>EXPR_OP_ASSOC_RIGHT</name></expr>, <expr><name>JX9_OP_SHR_STORE</name></expr> }</block></expr>,
		<comment type="block">/* Precedence 22, left-associative [Lowest operator] */</comment>
	<expr><block>{ <expr><block>{<expr><literal type="string">","</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>,  <expr><name>EXPR_OP_COMMA</name></expr>, <expr><literal type="number">22</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>, <comment type="block">/* IMP-0139-COMMA: Symisc eXtension */</comment>
}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* Function call operator need special handling */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>jx9_expr_op</name></type> <name>sFCallOp</name> <init>= <expr><block>{<expr><block>{<expr><literal type="string">"("</literal></expr>, <expr>sizeof<operator>(</operator><name>char</name><operator>)</operator></expr>}</block></expr>, <expr><name>EXPR_OP_FUNC_CALL</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>EXPR_OP_ASSOC_LEFT</name></expr> , <expr><name>JX9_OP_CALL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Check if the given token is a potential operator or not.
 * This function is called by the lexer each time it extract a token that may 
 * look like an operator.
 * Return a structure [i.e: jx9_expr_op instnace ] that describe the operator on success.
 * Otherwise NULL.
 * Note that the function take care of handling ambiguity [i.e: whether we are dealing with
 * a binary minus or unary minus.]
 */</comment>
<function><type><name>JX9_PRIVATE</name> <specifier>const</specifier> <name>jx9_expr_op</name> <modifier>*</modifier></type>  <name>jx9ExprExtractOperator</name><parameter_list>(<parameter><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>, <parameter><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pLast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Do a linear lookup on the operators table */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;=</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>aOpTable</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyStringCmp</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aOpTable</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sOp</name></expr></argument>, <argument><expr><name>SyMemcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>aOpTable</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>sOp</name><operator>.</operator><name>nByte</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <operator>(</operator><name><name>aOpTable</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>iOp</name> <operator>!=</operator> <name>EXPR_OP_UMINUS</name> <operator>&amp;&amp;</operator> <name><name>aOpTable</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>iOp</name> <operator>!=</operator> <name>EXPR_OP_UPLUS</name><operator>)</operator> <operator>||</operator> <name>pLast</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name><name>aOpTable</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>iOp</name> <operator>==</operator> <name>EXPR_OP_SUBSCRIPT</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pLast</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pLast</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_ID</name><operator>|</operator><name>JX9_TK_CSB</name><comment type="block">/*]*/</comment><operator>|</operator><name>JX9_TK_RPAREN</name><comment type="block">/*)*/</comment><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
					<comment type="block">/* JSON Array not subscripting, return NULL  */</comment>
					<return>return <expr><literal type="number">0</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* There is no ambiguity here, simply return the first operator seen */</comment>
				<return>return <expr><operator>&amp;</operator><name><name>aOpTable</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Handle ambiguity */</comment>
			<if_stmt><if>if<condition>( <expr><name><name>pLast</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_LPAREN</name><comment type="block">/*'('*/</comment><operator>|</operator><name>JX9_TK_OCB</name><comment type="block">/*'{'*/</comment><operator>|</operator><name>JX9_TK_OSB</name><comment type="block">/*'['*/</comment><operator>|</operator><name>JX9_TK_COLON</name><comment type="block">/*:*/</comment><operator>|</operator><name>JX9_TK_COMMA</name><comment type="block">/*, '*/</comment><operator>)</operator></expr> )</condition><block>{<block_content>
				<comment type="block">/* Unary opertors have prcedence here over binary operators */</comment>
				<return>return <expr><operator>&amp;</operator><name><name>aOpTable</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pLast</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OP</name></expr> )</condition><block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>jx9_expr_op</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>jx9_expr_op</name> <operator>*</operator><operator>)</operator><name><name>pLast</name><operator>-&gt;</operator><name>pUserData</name></name></expr></init></decl>;</decl_stmt>
				<comment type="block">/* Ticket 1433-31: Handle the '++', '--' operators case */</comment>
				<if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>!=</operator> <name>EXPR_OP_INCR</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>!=</operator> <name>EXPR_OP_DECR</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* Unary opertors have prcedence here over binary operators */</comment>
					<return>return <expr><operator>&amp;</operator><name><name>aOpTable</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>++</operator><name>n</name></expr>;</expr_stmt> <comment type="block">/* Next operator in the table */</comment>
	</block_content>}</block></for>
	<comment type="block">/* No such operator */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Delimit a set of token stream.
 * This function take care of handling the nesting level and stops when it hit
 * the end of the input or the ending token is found and the nesting level is zero.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>jx9DelimitNestedTokens</name><parameter_list>(<parameter><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,<parameter><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nTokStart</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nTokEnd</name></decl></parameter>,<parameter><decl><type><name>SyToken</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><name>pIn</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>iNest</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>&gt;=</operator> <name>pEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>nTokStart</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Increment nesting level */</comment>
			<expr_stmt><expr><name>iNest</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>nTokEnd</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Decrement nesting level */</comment>
			<expr_stmt><expr><name>iNest</name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>iNest</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Advance cursor */</comment>
		<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Point to the end of the chunk */</comment>
	<expr_stmt><expr><operator>*</operator><name>ppEnd</name> <operator>=</operator> <name>pCur</name></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Retrun TRUE if the given ID represent a language construct [i.e: print, print..]. FALSE otherwise.
 * Note on reserved keywords.
 *  According to the JX9 language reference manual:
 *   These words have special meaning in JX9. Some of them represent things which look like 
 *   functions, some look like constants, and so on--but they're not, really: they are language
 *   constructs. You cannot use any of the following words as constants, object names, function
 *   or method names. Using them as variable names is generally OK, but could lead to confusion.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>int</name></type> <name>jx9IsLangConstruct</name><parameter_list>(<parameter><decl><type><name>sxu32</name></type> <name>nKeyID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>nKeyID</name> <operator>==</operator> <name>JX9_TKWRD_PRINT</name> <operator>||</operator> <name>nKeyID</name> <operator>==</operator> <name>JX9_TKWRD_EXIT</name> <operator>||</operator> <name>nKeyID</name> <operator>==</operator> <name>JX9_TKWRD_DIE</name>
		<operator>||</operator> <name>nKeyID</name> <operator>==</operator> <name>JX9_TKWRD_INCLUDE</name><operator>||</operator> <name>nKeyID</name> <operator>==</operator> <name>JX9_TKWRD_IMPORT</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>TRUE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Not a language construct */</comment>
	<return>return <expr><name>FALSE</name></expr>;</return> 
</block_content>}</block></function>
<comment type="block">/*
 * Point to the next expression that should be evaluated shortly.
 * The cursor stops when it hit a comma ', ' or a semi-colon and the nesting
 * level is zero.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9GetNextExpr</name><parameter_list>(<parameter><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pStart</name></decl></parameter>,<parameter><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>,<parameter><decl><type><name>SyToken</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><name>pStart</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>iNest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>&gt;=</operator> <name>pEnd</name> <operator>||</operator> <operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_SEMI</name><comment type="block">/*';'*/</comment><operator>)</operator></expr> )</condition><block>{<block_content>
		<comment type="block">/* Last expression */</comment>
		<return>return <expr><name>SXERR_EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<while>while<condition>( <expr><name>pCur</name> <operator>&lt;</operator> <name>pEnd</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_COMMA</name><comment type="block">/*','*/</comment><operator>|</operator><name>JX9_TK_SEMI</name><comment type="block">/*';'*/</comment><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <name>iNest</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_LPAREN</name><comment type="block">/*'('*/</comment><operator>|</operator><name>JX9_TK_OSB</name><comment type="block">/*'['*/</comment><operator>|</operator><name>JX9_TK_OCB</name><comment type="block">/*'{'*/</comment><operator>)</operator></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iNest</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_RPAREN</name><comment type="block">/*')'*/</comment><operator>|</operator><name>JX9_TK_CSB</name><comment type="block">/*']'*/</comment><operator>|</operator><name>JX9_TK_CCB</name><comment type="block">/*'}*/</comment><operator>)</operator></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iNest</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>ppNext</name> <operator>=</operator> <name>pCur</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Collect and assemble tokens holding annonymous functions/closure body.
 * When errors, JX9 take care of generating the appropriate error message.
 * Note on annonymous functions.
 *  According to the JX9 language reference manual:
 *  Anonymous functions, also known as closures, allow the creation of functions
 *  which have no specified name. They are most useful as the value of callback
 *  parameters, but they have many other uses. 
 *  Closures may also inherit variables from the parent scope. Any such variables
 *  must be declared in the function header. Inheriting variables from the parent
 *  scope is not the same as using global variables. Global variables exist in the global scope
 *  which is the same no matter what function is executing. The parent scope of a closure is the 
 *  function in which the closure was declared (not necessarily the function it was called from).
 *
 * Some example:
 *  $greet = function($name)
 * {
 *   printf("Hello %s\r\n", $name);
 * };
 *  $greet('World');
 *  $greet('JX9');
 *
 * $double = function($a) {
 *   return $a * 2;
 * };
 * // This is our range of numbers
 * $numbers = range(1, 5);
 * // Use the Annonymous function as a callback here to 
 * // double the size of each element in our 
 * // range
 * $new_numbers = array_map($double, $numbers);
 * print implode(' ', $new_numbers);
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ExprAssembleAnnon</name><parameter_list>(<parameter><decl><type><name>jx9_gen_state</name> <modifier>*</modifier></type><name>pGen</name></decl></parameter>,<parameter><decl><type><name>SyToken</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCur</name></decl></parameter>, <parameter><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pIn</name> <init>= <expr><operator>*</operator><name>ppCur</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nLine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Jump the 'function' keyword */</comment>
	<expr_stmt><expr><name>nLine</name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>nLine</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pIn</name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pIn</name> <operator>&lt;</operator> <name>pEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_ID</name><operator>|</operator><name>JX9_TK_KEYWORD</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>pIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pIn</name> <operator>&gt;=</operator> <name>pEnd</name> <operator>||</operator> <operator>(</operator><name><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_LPAREN</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Syntax error */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name>nLine</name></expr></argument>, <argument><expr><literal type="string">"Missing opening parenthesis '(' while declaring annonymous function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<goto>goto <name>Synchronize</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pIn</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the leading parenthesis '(' */</comment>
	<expr_stmt><expr><call><name>jx9DelimitNestedTokens</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>, <argument><expr><name>JX9_TK_LPAREN</name></expr></argument><comment type="block">/*'('*/</comment>, <argument><expr><name>JX9_TK_RPAREN</name></expr></argument><comment type="block">/*')'*/</comment>, <argument><expr><operator>&amp;</operator><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pIn</name> <operator>&gt;=</operator> <name>pEnd</name> <operator>||</operator> <operator>&amp;</operator><name><name>pIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <name>pEnd</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Syntax error */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name>nLine</name></expr></argument>, <argument><expr><literal type="string">"Syntax error while declaring annonymous function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<goto>goto <name>Synchronize</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pIn</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the trailing parenthesis */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pIn</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OCB</name></expr> <comment type="block">/*'{'*/</comment> )</condition><block>{<block_content>
		<expr_stmt><expr><name>pIn</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the leading curly '{' */</comment>
		<expr_stmt><expr><call><name>jx9DelimitNestedTokens</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>, <argument><expr><name>JX9_TK_OCB</name></expr></argument><comment type="block">/*'{'*/</comment>, <argument><expr><name>JX9_TK_CCB</name></expr></argument><comment type="block">/*'}'*/</comment>, <argument><expr><operator>&amp;</operator><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pIn</name> <operator>&lt;</operator> <name>pEnd</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>pIn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Syntax error */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name>nLine</name></expr></argument>, <argument><expr><literal type="string">"Syntax error while declaring annonymous function, missing '{'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>			
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXRET_OK</name></expr>;</expr_stmt>
<label><name>Synchronize</name>:</label>
	<comment type="block">/* Synchronize pointers */</comment>
	<expr_stmt><expr><operator>*</operator><name>ppCur</name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Make sure we are dealing with a valid expression tree.
 * This function check for balanced parenthesis, braces, brackets and so on.
 * When errors, JX9 take care of generating the appropriate error message.
 * Return SXRET_OK on success. Any other return value indicates syntax error.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ExprVerifyNodes</name><parameter_list>(<parameter><decl><type><name>jx9_gen_state</name> <modifier>*</modifier></type><name>pGen</name></decl></parameter>, <parameter><decl><type><name>jx9_expr_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNode</name></decl></parameter>, <parameter><decl><type><name>sxi32</name></type> <name>nNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>iParen</name></decl>, <decl><type ref="prev"/><name>iSquare</name></decl>, <decl><type ref="prev"/><name>iBraces</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>

	<if_stmt><if>if<condition>( <expr><name>nNode</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>pOp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>==</operator> <name>EXPR_OP_ADD</name> <operator>||</operator> <name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>==</operator> <name>EXPR_OP_SUB</name><operator>)</operator></expr> )</condition><block>{<block_content>
		<comment type="block">/* Fix and mark as an unary not binary plus/minus operator */</comment>
		<expr_stmt><expr><name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>pOp</name> <operator>=</operator> <call><name>jx9ExprExtractOperator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>sData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>pOp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iParen</name> <operator>=</operator> <name>iSquare</name> <operator>=</operator> <name>iBraces</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nNode</name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr> )</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_LPAREN</name></expr> <comment type="block">/*'('*/</comment>)</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>apNode</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>xCode</name> <operator>==</operator> <name>jx9CompileVariable</name> <operator>||</operator> <name><name>apNode</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>xCode</name> <operator>==</operator> <name>jx9CompileLiteral</name> <operator>||</operator>
				<operator>(</operator><name><name>apNode</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_ID</name><operator>|</operator><name>JX9_TK_KEYWORD</name><operator>|</operator><name>JX9_TK_SSTR</name><operator>|</operator><name>JX9_TK_DSTR</name><operator>|</operator><name>JX9_TK_RPAREN</name><comment type="block">/*')'*/</comment><operator>|</operator><name>JX9_TK_CSB</name><comment type="block">/*]*/</comment><operator>)</operator><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
					<comment type="block">/* Ticket 1433-033: Take care to ignore alpha-stream [i.e: or, xor] operators followed by an opening parenthesis */</comment>
					<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>apNode</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
						<comment type="block">/* We are dealing with a postfix [i.e: function call]  operator
						 * not a simple left parenthesis. Mark the node.
						 */</comment>
						<expr_stmt><expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>|=</operator> <name>JX9_TK_OP</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sFCallOp</name></expr>;</expr_stmt> <comment type="block">/* Function call operator */</comment>
						<expr_stmt><expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name>sFCallOp</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>iParen</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_RPAREN</name></expr><comment type="block">/*')*/</comment>)</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>iParen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Syntax error: Unexpected token ')'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>iParen</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OSB</name> <comment type="block">/*'['*/</comment> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>xCode</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iSquare</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if <condition>(<expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_CSB</name></expr> <comment type="block">/*']'*/</comment>)</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>iSquare</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Syntax error: Unexpected token ']'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>iSquare</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OCB</name> <comment type="block">/*'{'*/</comment> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>xCode</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iBraces</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if <condition>(<expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_CCB</name></expr> <comment type="block">/*'}'*/</comment>)</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>iBraces</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Syntax error: Unexpected token '}'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>iBraces</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OP</name></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>jx9_expr_op</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>jx9_expr_op</name> <operator>*</operator><operator>)</operator><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pOp</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>( <expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>==</operator> <name>EXPR_OP_UMINUS</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>==</operator> <name>EXPR_OP_UPLUS</name><operator>)</operator></expr>)</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>xCode</name> <operator>==</operator> <name>jx9CompileVariable</name> <operator>||</operator> <name><name>apNode</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>xCode</name> <operator>==</operator> <name>jx9CompileLiteral</name></expr> )</condition><block>{<block_content>
					<decl_stmt><decl><type><name>sxi32</name></type> <name>iExprOp</name> <init>= <expr><name>EXPR_OP_SUB</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Binary minus */</comment>
					<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>==</operator> <name>EXPR_OP_UPLUS</name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>iExprOp</name> <operator>=</operator> <name>EXPR_OP_ADD</name></expr>;</expr_stmt> <comment type="block">/* Binary plus */</comment>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/*
					 * TICKET 1433-013: This is a fix around an obscure bug when the user uses
					 * a variable name which is an alpha-stream operator [i.e: $and, $xor, $eq..].
					 */</comment>
					<while>while<condition>( <expr><name>n</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>aOpTable</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aOpTable</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>iOp</name> <operator>!=</operator> <name>iExprOp</name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><operator>++</operator><name>n</name></expr>;</expr_stmt>
					</block_content>}</block></while>
					<expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOpTable</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
					<comment type="block">/* Mark as binary '+' or '-', not an unary */</comment>
					<expr_stmt><expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pOp</name> <operator>=</operator> <name>pOp</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>apNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pOp</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name>iParen</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>iSquare</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>iBraces</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Syntax error, mismatched '(', '[' or '{'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Extract a single expression node from the input.
 * On success store the freshly extractd node in ppNode.
 * When errors, JX9 take care of generating the appropriate error message.
 * An expression node can be a variable [i.e: $var], an operator [i.e: ++] 
 * an annonymous function [i.e: function(){ return "Hello"; }, a double/single
 * quoted string, a heredoc/nowdoc, a literal [i.e: JX9_EOL], a namespace path
 * [i.e: namespaces\path\to..], a array/list [i.e: array(4, 5, 6)] and so on.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ExprExtractNode</name><parameter_list>(<parameter><decl><type><name>jx9_gen_state</name> <modifier>*</modifier></type><name>pGen</name></decl></parameter>, <parameter><decl><type><name>jx9_expr_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_expr_node</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Allocate a new node */</comment>
	<expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>(</operator><name>jx9_expr_node</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pGen</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jx9_expr_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNode</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* If the supplied memory subsystem is so sick that we are unable to allocate
		 * a tiny chunk of memory, there is no much we can do here.
		 */</comment>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the structure */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jx9_expr_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SySetInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>aNodeArgs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pGen</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jx9_expr_node</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Point to the head of the token stream */</comment>
	<expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pStart</name></name> <operator>=</operator> <name><name>pGen</name><operator>-&gt;</operator><name>pIn</name></name></expr>;</expr_stmt>
	<comment type="block">/* Start collecting tokens */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OP</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Point to the instance that describe this operator */</comment>
		<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>jx9_expr_op</name> <operator>*</operator><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pUserData</name></name></expr>;</expr_stmt>
		<comment type="block">/* Advance the stream cursor */</comment>
		<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_DOLLAR</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Isolate variable */</comment>
		<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the dollar sign */</comment>
		<if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>&gt;=</operator> <name><name>pGen</name><operator>-&gt;</operator><name>pEnd</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Syntax error */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>,<argument><expr><literal type="string">"Invalid variable name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pGen</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Jump the variable name */</comment>
		<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>=</operator> <name>jx9CompileVariable</name></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OCB</name></expr> <comment type="block">/* '{' */</comment> )</condition><block>{<block_content>
		<comment type="block">/* JSON Object, assemble tokens */</comment>
		<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9DelimitNestedTokens</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pGen</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>, <argument><expr><name>JX9_TK_OCB</name></expr></argument> <comment type="block">/* '[' */</comment>, <argument><expr><name>JX9_TK_CCB</name></expr></argument> <comment type="block">/* ']' */</comment>, <argument><expr><operator>&amp;</operator><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>&lt;</operator> <name><name>pGen</name><operator>-&gt;</operator><name>pEnd</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Syntax error */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>,<argument><expr><literal type="string">"JSON Object: Missing closing braces '}'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pGen</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>=</operator> <name>jx9CompileJsonObject</name></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OSB</name> <comment type="block">/* '[' */</comment> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OP</name><operator>)</operator></expr> )</condition><block>{<block_content>
		<comment type="block">/* JSON Array, assemble tokens */</comment>
		<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>jx9DelimitNestedTokens</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pGen</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>, <argument><expr><name>JX9_TK_OSB</name></expr></argument> <comment type="block">/* '[' */</comment>, <argument><expr><name>JX9_TK_CSB</name></expr></argument> <comment type="block">/* ']' */</comment>, <argument><expr><operator>&amp;</operator><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>&lt;</operator> <name><name>pGen</name><operator>-&gt;</operator><name>pEnd</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Syntax error */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>,<argument><expr><literal type="string">"JSON Array: Missing closing square bracket ']'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pGen</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>=</operator> <name>jx9CompileJsonArray</name></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_KEYWORD</name></expr> )</condition><block>{<block_content>
		 <decl_stmt><decl><type><name>int</name></type> <name>nKeyword</name> <init>= <expr><call><name>SX_PTR_TO_INT</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		 <if_stmt><if>if<condition>( <expr><name>nKeyword</name> <operator>==</operator> <name>JX9_TKWRD_FUNCTION</name></expr> )</condition><block>{<block_content>
			 <comment type="block">/* Annonymous function */</comment>
			  <if_stmt><if>if<condition>( <expr><operator>&amp;</operator><name><name>pCur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <name><name>pGen</name><operator>-&gt;</operator><name>pEnd</name></name></expr> )</condition><block>{<block_content>
				 <comment type="block">/* Assume a literal */</comment>
				<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>=</operator> <name>jx9CompileLiteral</name></expr>;</expr_stmt>
			 </block_content>}</block></if><else>else<block>{<block_content>
				 <comment type="block">/* Assemble annonymous functions body */</comment>
				 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExprAssembleAnnon</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCur</name></expr></argument>, <argument><expr><name><name>pGen</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
					 <expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pGen</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					 <return>return <expr><name>rc</name></expr>;</return> 
				 </block_content>}</block></if></if_stmt>
				 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>=</operator> <name>jx9CompileAnnonFunc</name></expr>;</expr_stmt>
			  </block_content>}</block></else></if_stmt>
		 </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>jx9IsLangConstruct</name><argument_list>(<argument><expr><name>nKeyword</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>&amp;</operator><name><name>pCur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>pGen</name><operator>-&gt;</operator><name>pEnd</name></name></expr> )</condition><block>{<block_content>
			 <comment type="block">/* Language constructs [i.e: print,die...] require special handling */</comment>
			 <expr_stmt><expr><call><name>jx9DelimitNestedTokens</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pGen</name><operator>-&gt;</operator><name>pEnd</name></name></expr></argument>, <argument><expr><name>JX9_TK_LPAREN</name><operator>|</operator><name>JX9_TK_OCB</name><operator>|</operator><name>JX9_TK_OSB</name></expr></argument>, <argument><expr><name>JX9_TK_RPAREN</name><operator>|</operator><name>JX9_TK_CCB</name><operator>|</operator><name>JX9_TK_CSB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>=</operator> <name>jx9CompileLangConstruct</name></expr>;</expr_stmt>
		 </block_content>}</block></if><else>else<block>{<block_content>
			 <comment type="block">/* Assume a literal */</comment>
			 <expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
			 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>=</operator> <name>jx9CompileLiteral</name></expr>;</expr_stmt>
		 </block_content>}</block></else></if_stmt>
	 </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_ID</name><operator>)</operator></expr> )</condition><block>{<block_content>
		 <comment type="block">/* Constants, function name, namespace path, object name... */</comment>
		 <expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
		 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>=</operator> <name>jx9CompileLiteral</name></expr>;</expr_stmt>
	 </block_content>}</block></if><else>else<block>{<block_content>
		 <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_LPAREN</name><operator>|</operator><name>JX9_TK_RPAREN</name><operator>|</operator><name>JX9_TK_COMMA</name><operator>|</operator><name>JX9_TK_CSB</name><operator>|</operator><name>JX9_TK_OCB</name><operator>|</operator><name>JX9_TK_CCB</name><operator>|</operator><name>JX9_TK_COLON</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			 <comment type="block">/* Point to the code generator routine */</comment>
			 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>=</operator> <call><name>jx9GetNodeHandler</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Syntax error: Unexpected token '%z'"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>sData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				 </block_content>}</block></if></if_stmt>
				 <expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pGen</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 <return>return <expr><name>rc</name></expr>;</return>
			 </block_content>}</block></if></if_stmt>
		 </block_content>}</block></if></if_stmt>
		<comment type="block">/* Advance the stream cursor */</comment>
		<expr_stmt><expr><name>pCur</name><operator>++</operator></expr>;</expr_stmt>
	 </block_content>}</block></else></if_stmt>
	<comment type="block">/* Point to the end of the token stream */</comment>
	<expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pEnd</name></name> <operator>=</operator> <name>pCur</name></expr>;</expr_stmt>
	<comment type="block">/* Save the node for later processing */</comment>
	<expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
	<comment type="block">/* Synchronize cursors */</comment>
	<expr_stmt><expr><name><name>pGen</name><operator>-&gt;</operator><name>pIn</name></name> <operator>=</operator> <name>pCur</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Free an expression tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ExprFreeTree</name><parameter_list>(<parameter><decl><type><name>jx9_gen_state</name> <modifier>*</modifier></type><name>pGen</name></decl></parameter>, <parameter><decl><type><name>jx9_expr_node</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Release the left tree */</comment>
		<expr_stmt><expr><call><name>ExprFreeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Release the right tree */</comment>
		<expr_stmt><expr><call><name>ExprFreeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pCond</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Release the conditional tree used by the ternary operator */</comment>
		<expr_stmt><expr><call><name>ExprFreeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>SySetUsed</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>aNodeArgs</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>jx9_expr_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
		<comment type="block">/* Release node arguments */</comment>
		<expr_stmt><expr><name>apArg</name> <operator>=</operator> <operator>(</operator><name>jx9_expr_node</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SySetBasePtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>aNodeArgs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>SySetUsed</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>aNodeArgs</name></name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
			<expr_stmt><expr><call><name>ExprFreeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name><name>apArg</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>SySetRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>aNodeArgs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Finally, release this node */</comment>
	<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pGen</name><operator>-&gt;</operator><name>pVm</name><operator>-&gt;</operator><name>sAllocator</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Free an expression tree.
 * This function is a wrapper around ExprFreeTree() defined above.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9ExprFreeTree</name><parameter_list>(<parameter><decl><type><name>jx9_gen_state</name> <modifier>*</modifier></type><name>pGen</name></decl></parameter>, <parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pNodeSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_expr_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>apNode</name> <operator>=</operator> <operator>(</operator><name>jx9_expr_node</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SySetBasePtr</name><argument_list>(<argument><expr><name>pNodeSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>  ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>SySetUsed</name><argument_list>(<argument><expr><name>pNodeSet</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>n</name></expr>]</index></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>ExprFreeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name><name>apNode</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Check if the given node is a modifialbe l/r-value.
 * Return TRUE if modifiable.FALSE otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ExprIsModifiableValue</name><parameter_list>(<parameter><decl><type><name>jx9_expr_node</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>iExprOp</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><ternary><condition><expr><name><name>pNode</name><operator>-&gt;</operator><name>xCode</name></name> <operator>==</operator> <name>jx9CompileVariable</name></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iExprOp</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>iExprOp</name> <operator>==</operator> <name>EXPR_OP_DOT</name></expr> <comment type="block">/*'.' */</comment>  )</condition><block>{<block_content>
			<return>return <expr><name>TRUE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>iExprOp</name> <operator>==</operator> <name>EXPR_OP_SUBSCRIPT</name></expr><comment type="block">/*'[]'*/</comment> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pOp</name></name></expr> )</condition> <block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>!=</operator> <name>EXPR_OP_SUBSCRIPT</name> <comment type="block">/*'['*/</comment> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>!=</operator> <name>EXPR_OP_DOT</name></expr> <comment type="block">/*'.'*/</comment>)</condition><block>{<block_content>
				<return>return <expr><name>FALSE</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>xCode</name></name> <operator>!=</operator> <name>jx9CompileVariable</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>FALSE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>TRUE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Not a modifiable l or r-value */</comment>
	<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>sxi32</name></type> <name>ExprMakeTree</name><parameter_list>(<parameter><decl><type><name>jx9_gen_state</name> <modifier>*</modifier></type><name>pGen</name></decl></parameter>, <parameter><decl><type><name>jx9_expr_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNode</name></decl></parameter>, <parameter><decl><type><name>sxi32</name></type> <name>nToken</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* Macro to check if the given node is a terminal */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_ISTERM</name><parameter_list>(<parameter><type><name>NODE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(apNode[NODE] &amp;&amp; (!apNode[NODE]-&gt;pOp || apNode[NODE]-&gt;pLeft ))</cpp:value></cpp:define>
<comment type="block">/*
 * Buid an expression tree for each given function argument.
 * When errors, JX9 take care of generating the appropriate error message.
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ExprProcessFuncArguments</name><parameter_list>(<parameter><decl><type><name>jx9_gen_state</name> <modifier>*</modifier></type><name>pGen</name></decl></parameter>, <parameter><decl><type><name>jx9_expr_node</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>, <parameter><decl><type><name>jx9_expr_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNode</name></decl></parameter>, <parameter><decl><type><name>sxi32</name></type> <name>nToken</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>iNest</name></decl>, <decl><type ref="prev"/><name>iCur</name></decl>, <decl><type ref="prev"/><name>iNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Process function arguments from left to right */</comment>
	<expr_stmt><expr><name>iCur</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>iCur</name> <operator>&gt;=</operator> <name>nToken</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* No more arguments to process */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>iNode</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iNest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while<condition>( <expr><name>iCur</name> <operator>&lt;</operator> <name>nToken</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_COMMA</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name>pLeft</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iNest</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_LPAREN</name><operator>|</operator><name>JX9_TK_OSB</name><operator>|</operator><name>JX9_TK_OCB</name><operator>)</operator></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>iNest</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <operator>(</operator><name>JX9_TK_RPAREN</name><operator>|</operator><name>JX9_TK_CCB</name><operator>|</operator><name>JX9_TK_CSB</name><operator>)</operator></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>iNest</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>iCur</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>iCur</name> <operator>&gt;</operator> <name>iNode</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>ExprMakeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apNode</name><index>[<expr><name>iNode</name></expr>]</index></name></expr></argument>, <argument><expr><name>iCur</name><operator>-</operator><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iNode</name></expr>]</index></name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Put a pointer to the root of the tree in the arguments set */</comment>
				<expr_stmt><expr><call><name>SySetPut</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOp</name><operator>-&gt;</operator><name>aNodeArgs</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>apNode</name><index>[<expr><name>iNode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<comment type="block">/* Empty function argument */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Empty function argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Missing function argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Jump trailing comma */</comment>
		<if_stmt><if>if<condition>( <expr><name>iCur</name> <operator>&lt;</operator> <name>nToken</name> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_COMMA</name><operator>)</operator></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iCur</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>iCur</name> <operator>&gt;=</operator> <name>nToken</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* missing function argument */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Missing function argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
  * Create an expression tree from an array of tokens.
  * If successful, the root of the tree is stored in apNode[0].
  * When errors, JX9 take care of generating the appropriate error message.
  */</comment>
 <function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ExprMakeTree</name><parameter_list>(<parameter><decl><type><name>jx9_gen_state</name> <modifier>*</modifier></type><name>pGen</name></decl></parameter>, <parameter><decl><type><name>jx9_expr_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNode</name></decl></parameter>, <parameter><decl><type><name>sxi32</name></type> <name>nToken</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
	 <decl_stmt><decl><type><name>sxi32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>iLeft</name></decl>, <decl><type ref="prev"/><name>iRight</name></decl>;</decl_stmt>
	 <decl_stmt><decl><type><name>jx9_expr_node</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
	 <decl_stmt><decl><type><name>sxi32</name></type> <name>iCur</name></decl>;</decl_stmt>
	 <decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	 <if_stmt><if>if<condition>( <expr><name>nToken</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>nToken</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>xCode</name><operator>)</operator></expr> )</condition><block>{<block_content>
		 <comment type="block">/* TICKET 1433-17: self evaluating node */</comment>
		 <return>return <expr><name>SXRET_OK</name></expr>;</return>
	 </block_content>}</block></if></if_stmt>
	 <comment type="block">/* Process expressions enclosed in parenthesis first */</comment>
	 <for>for<control>( <init><expr><name>iCur</name> <operator>=</operator>  <literal type="number">0</literal></expr> ;</init> <condition><expr><name>iCur</name> <operator>&lt;</operator> <name>nToken</name></expr> ;</condition> <incr><expr><operator>++</operator><name>iCur</name></expr></incr> )</control><block>{<block_content>
		 <decl_stmt><decl><type><name>sxi32</name></type> <name>iNest</name></decl>;</decl_stmt>
		 <comment type="block">/* Note that, we use strict comparison here '!=' instead of the bitwise and '&amp;' operator
		  * since the LPAREN token can also be an operator [i.e: Function call].
		  */</comment>
		 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>!=</operator> <name>JX9_TK_LPAREN</name></expr> )</condition><block>{<block_content>
			 <continue>continue;</continue>
		 </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>iNest</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
		 <comment type="block">/* Find the closing parenthesis */</comment>
		 <expr_stmt><expr><name>iCur</name><operator>++</operator></expr>;</expr_stmt>
		 <while>while<condition>( <expr><name>iCur</name> <operator>&lt;</operator> <name>nToken</name></expr> )</condition><block>{<block_content>
			 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr> )</condition><block>{<block_content>
				 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_RPAREN</name></expr> <comment type="block">/* ')' */</comment>)</condition><block>{<block_content>
					 <comment type="block">/* Decrement nesting level */</comment>
					 <expr_stmt><expr><name>iNest</name><operator>--</operator></expr>;</expr_stmt>
					 <if_stmt><if>if<condition>( <expr><name>iNest</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
						 <break>break;</break>
					 </block_content>}</block></if></if_stmt>
				 </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_LPAREN</name></expr> <comment type="block">/* '(' */</comment> )</condition><block>{<block_content>
					 <comment type="block">/* Increment nesting level */</comment>
					 <expr_stmt><expr><name>iNest</name><operator>++</operator></expr>;</expr_stmt>
				 </block_content>}</block></if></if_stmt>
			 </block_content>}</block></if></if_stmt>
			 <expr_stmt><expr><name>iCur</name><operator>++</operator></expr>;</expr_stmt>
		 </block_content>}</block></while>
		 <if_stmt><if>if<condition>( <expr><name>iCur</name> <operator>-</operator> <name>iLeft</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			 <comment type="block">/* Recurse and process this expression */</comment>
			 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExprMakeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apNode</name><index>[<expr><name>iLeft</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iCur</name> <operator>-</operator> <name>iLeft</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				 <return>return <expr><name>rc</name></expr>;</return>
			 </block_content>}</block></if></if_stmt>
		 </block_content>}</block></if></if_stmt>
		 <comment type="block">/* Free the left and right nodes */</comment>
		 <expr_stmt><expr><call><name>ExprFreeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>ExprFreeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	 </block_content>}</block></for>
	 <comment type="block">/* Handle postfix [i.e: function call, member access] operators with precedence 2 */</comment>
	 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	 <for>for<control>( <init><expr><name>iCur</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>iCur</name> <operator>&lt;</operator> <name>nToken</name></expr> ;</condition> <incr><expr><operator>++</operator><name>iCur</name></expr></incr> )</control><block>{<block_content>
		 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			 <continue>continue;</continue>
		 </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr>;</expr_stmt>
		 <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>==</operator> <literal type="number">0</literal></expr>  )</condition><block>{<block_content>
			 <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>==</operator> <name>EXPR_OP_FUNC_CALL</name></expr> )</condition><block>{<block_content>
				 <comment type="block">/* Collect function arguments */</comment>
				 <decl_stmt><decl><type><name>sxi32</name></type> <name>iPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				 <decl_stmt><decl><type><name>sxi32</name></type> <name>nFuncTok</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				 <while>while<condition>( <expr><name>nFuncTok</name> <operator>+</operator> <name>iCur</name> <operator>&lt;</operator> <name>nToken</name></expr> )</condition><block>{<block_content>
					 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>nFuncTok</name><operator>+</operator><name>iCur</name></expr>]</index></name></expr> )</condition><block>{<block_content>
						 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>nFuncTok</name><operator>+</operator><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_LPAREN</name></expr> <comment type="block">/*'('*/</comment> )</condition><block>{<block_content>
							 <expr_stmt><expr><name>iPtr</name><operator>++</operator></expr>;</expr_stmt>
						 </block_content>}</block></if><if type="elseif">else if <condition>( <expr><name><name>apNode</name><index>[<expr><name>nFuncTok</name><operator>+</operator><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_RPAREN</name></expr> <comment type="block">/*')'*/</comment>)</condition><block>{<block_content>
							 <expr_stmt><expr><name>iPtr</name><operator>--</operator></expr>;</expr_stmt>
							 <if_stmt><if>if<condition>( <expr><name>iPtr</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
								 <break>break;</break>
							 </block_content>}</block></if></if_stmt>
						 </block_content>}</block></if></if_stmt>
					 </block_content>}</block></if></if_stmt>
					 <expr_stmt><expr><name>nFuncTok</name><operator>++</operator></expr>;</expr_stmt>
				 </block_content>}</block></while>
				 <if_stmt><if>if<condition>( <expr><name>nFuncTok</name> <operator>+</operator> <name>iCur</name> <operator>&gt;=</operator> <name>nToken</name></expr> )</condition><block>{<block_content>
					 <comment type="block">/* Syntax error */</comment>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Missing right parenthesis ')'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
						 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
					 </block_content>}</block></if></if_stmt>
					 <return>return <expr><name>rc</name></expr>;</return> 
				 </block_content>}</block></if></if_stmt>
				 <if_stmt><if>if<condition>(  <expr><name>iLeft</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>NODE_ISTERM</name><argument_list>(<argument><expr><name>iLeft</name></expr></argument>)</argument_list></call></expr> <comment type="block">/*|| ( apNode[iLeft]-&gt;pOp &amp;&amp; apNode[iLeft]-&gt;pOp-&gt;iPrec != 2)*/</comment> )</condition><block>{<block_content>
					 <comment type="block">/* Syntax error */</comment>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Invalid function name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
						 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
					 </block_content>}</block></if></if_stmt>
					 <return>return <expr><name>rc</name></expr>;</return>
				 </block_content>}</block></if></if_stmt>
				 <if_stmt><if>if<condition>( <expr><name>nFuncTok</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
					 <comment type="block">/* Process function arguments */</comment>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExprProcessFuncArguments</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apNode</name><index>[<expr><name>iCur</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nFuncTok</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
						 <return>return <expr><name>rc</name></expr>;</return>
					 </block_content>}</block></if></if_stmt>
				 </block_content>}</block></if></if_stmt>
				 <comment type="block">/* Link the node to the tree */</comment>
				 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
				 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				 <for>for<control>( <init><expr><name>iPtr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>iPtr</name> <operator>&lt;=</operator> <name>nFuncTok</name></expr> ;</condition> <incr><expr><name>iPtr</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
					 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iCur</name><operator>+</operator><name>iPtr</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				 </block_content>}</block></for>
			 </block_content>}</block></if><if type="elseif">else if <condition>(<expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>==</operator> <name>EXPR_OP_SUBSCRIPT</name></expr> )</condition><block>{<block_content>
				 <comment type="block">/* Subscripting */</comment>
				 <decl_stmt><decl><type><name>sxi32</name></type> <name>iArrTok</name> <init>= <expr><name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
				 <decl_stmt><decl><type><name>sxi32</name></type> <name>iNest</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
				 <if_stmt><if>if<condition>(  <expr><name>iLeft</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>-&gt;</operator><name>xCode</name> <operator>==</operator> <name>jx9CompileVariable</name> <operator>||</operator> <operator>(</operator><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>-&gt;</operator><name>pOp</name> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>-&gt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>==</operator> <literal type="number">2</literal> <comment type="block">/* postfix */</comment><operator>)</operator> <operator>)</operator></expr> )</condition><block>{<block_content>
					 <comment type="block">/* Collect index tokens */</comment>
				    <while>while<condition>( <expr><name>iArrTok</name> <operator>&lt;</operator> <name>nToken</name></expr> )</condition><block>{<block_content>
					 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iArrTok</name></expr>]</index></name></expr> )</condition><block>{<block_content>
						 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iArrTok</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_OSB</name></expr> <comment type="block">/*'['*/</comment>)</condition><block>{<block_content>
							 <comment type="block">/* Increment nesting level */</comment>
							 <expr_stmt><expr><name>iNest</name><operator>++</operator></expr>;</expr_stmt>
						 </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iArrTok</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_CSB</name></expr> <comment type="block">/*']'*/</comment>)</condition><block>{<block_content>
							 <comment type="block">/* Decrement nesting level */</comment>
							 <expr_stmt><expr><name>iNest</name><operator>--</operator></expr>;</expr_stmt>
							 <if_stmt><if>if<condition>( <expr><name>iNest</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
								 <break>break;</break>
							 </block_content>}</block></if></if_stmt>
						 </block_content>}</block></if></if_stmt>
					 </block_content>}</block></if></if_stmt>
					 <expr_stmt><expr><operator>++</operator><name>iArrTok</name></expr>;</expr_stmt>
				   </block_content>}</block></while>
				   <if_stmt><if>if<condition>( <expr><name>iArrTok</name> <operator>&gt;</operator> <name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
					 <comment type="block">/* Recurse and process this expression */</comment>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExprMakeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apNode</name><index>[<expr><name>iCur</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iArrTok</name> <operator>-</operator> <name>iCur</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
						 <return>return <expr><name>rc</name></expr>;</return>
					 </block_content>}</block></if></if_stmt>
					 <comment type="block">/* Link the node to it's index */</comment>
					 <expr_stmt><expr><call><name>SySetPut</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>aNodeArgs</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>apNode</name><index>[<expr><name>iCur</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				   </block_content>}</block></if></if_stmt>
				   <comment type="block">/* Link the node to the tree */</comment>
				   <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
				   <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				   <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				   <for>for<control>( <init><expr><name>iNest</name> <operator>=</operator> <name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr> ;</init> <condition><expr><name>iNest</name> <operator>&lt;=</operator> <name>iArrTok</name></expr> ;</condition> <incr><expr><operator>++</operator><name>iNest</name></expr></incr> )</control><block>{<block_content>
					 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iNest</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				  </block_content>}</block></for>
				 </block_content>}</block></if></if_stmt>
			 </block_content>}</block></if><else>else<block>{<block_content>
				 <comment type="block">/* Member access operators [i.e: '.' ] */</comment>
				 <expr_stmt><expr><name>iRight</name> <operator>=</operator> <name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				 <while>while<condition>( <expr><name>iRight</name> <operator>&lt;</operator> <name>nToken</name> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					 <expr_stmt><expr><name>iRight</name><operator>++</operator></expr>;</expr_stmt>
				 </block_content>}</block></while>
				 <if_stmt><if>if<condition>( <expr><name>iRight</name> <operator>&gt;=</operator> <name>nToken</name> <operator>||</operator> <name>iLeft</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>NODE_ISTERM</name><argument_list>(<argument><expr><name>iRight</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>NODE_ISTERM</name><argument_list>(<argument><expr><name>iLeft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
					 <comment type="block">/* Syntax error */</comment>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"'%z': Missing/Invalid member name"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
						 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
					 </block_content>}</block></if></if_stmt>
					 <return>return <expr><name>rc</name></expr>;</return>
				 </block_content>}</block></if></if_stmt>
				 <comment type="block">/* Link the node to the tree */</comment>
				 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
				 <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pOp</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>xCode</name></name> <operator>!=</operator> <name>jx9CompileVariable</name></expr> )</condition><block>{<block_content>
					 <comment type="block">/* Syntax error */</comment>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, 
						 <argument><expr><literal type="string">"'%z': Expecting a variable as left operand"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
						 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
					 </block_content>}</block></if></if_stmt>
					 <return>return <expr><name>rc</name></expr>;</return>
				 </block_content>}</block></if></if_stmt>
				 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>;</expr_stmt>
				 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			 </block_content>}</block></else></if_stmt>
		 </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
	 </block_content>}</block></for>
	  <comment type="block">/* Handle post/pre icrement/decrement [i.e: ++/--] operators with precedence 3 */</comment>
	 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	 <for>for<control>( <init><expr><name>iCur</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>iCur</name> <operator>&lt;</operator> <name>nToken</name></expr> ;</condition> <incr><expr><operator>++</operator><name>iCur</name></expr></incr> )</control><block>{<block_content>
		 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			 <continue>continue;</continue>
		 </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr>;</expr_stmt>
		 <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
			 <if_stmt><if>if<condition>( <expr><name>iLeft</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>-&gt;</operator><name>pOp</name> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>-&gt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>==</operator> <literal type="number">2</literal> <comment type="block">/* Postfix */</comment><operator>)</operator>
				 <operator>||</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>-&gt;</operator><name>xCode</name> <operator>==</operator> <name>jx9CompileVariable</name><operator>)</operator></expr> )</condition><block>{<block_content>
					 <comment type="block">/* Link the node to the tree */</comment>
					 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
					 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
			 </block_content>}</block></if></if_stmt>
		  </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
	  </block_content>}</block></for>
	 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	 <for>for<control>( <init><expr><name>iCur</name> <operator>=</operator> <name>nToken</name> <operator>-</operator>  <literal type="number">1</literal></expr> ;</init> <condition><expr><name>iCur</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>iCur</name><operator>--</operator></expr></incr> )</control><block>{<block_content>
		 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			 <continue>continue;</continue>
		 </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr>;</expr_stmt>
		 <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
			 <if_stmt><if>if<condition>( <expr><name>iLeft</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>-&gt;</operator><name>pOp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>-&gt;</operator><name>xCode</name> <operator>!=</operator> <name>jx9CompileVariable</name><operator>)</operator>
				 <operator>||</operator> <operator>(</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>-&gt;</operator><name>pOp</name> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name><operator>-&gt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>!=</operator> <literal type="number">2</literal> <comment type="block">/* Postfix */</comment><operator>)</operator></expr> )</condition><block>{<block_content>
					 <comment type="block">/* Syntax error */</comment>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"'%z' operator needs l-value"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
						 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
					 </block_content>}</block></if></if_stmt>
					 <return>return <expr><name>rc</name></expr>;</return>
			 </block_content>}</block></if></if_stmt>
			 <comment type="block">/* Link the node to the tree */</comment>
			 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
			 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			 <comment type="block">/* Mark as pre-increment/decrement node */</comment>
			 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>|=</operator> <name>EXPR_NODE_PRE_INCR</name></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
	 </block_content>}</block></for>
	 <comment type="block">/* Handle right associative unary and cast operators [i.e: !, (string), ~...]  with precedence 4 */</comment>
	  <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <for>for<control>( <init><expr><name>iCur</name> <operator>=</operator> <name>nToken</name> <operator>-</operator>  <literal type="number">1</literal></expr> ;</init> <condition><expr><name>iCur</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>iCur</name><operator>--</operator></expr></incr> )</control><block>{<block_content>
		  <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr> )</condition><block>{<block_content>
			  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr>;</expr_stmt>
			  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
				  <if_stmt><if>if<condition>( <expr><name>iLeft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					  <comment type="block">/* Link the node to the tree */</comment>
					  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
					  <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pOp</name></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>&gt;</operator> <literal type="number">4</literal></expr> )</condition><block>{<block_content>
						  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pRight</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
							   <comment type="block">/* Syntax error */</comment>
							  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"'%z': Missing operand"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
								  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
							  </block_content>}</block></if></if_stmt>
							  <return>return <expr><name>rc</name></expr>;</return>
						  </block_content>}</block></if></if_stmt>
					  </block_content>}</block></if></if_stmt>
				  </block_content>}</block></if><else>else<block>{<block_content>
					  <comment type="block">/* Syntax error */</comment>
					  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"'%z': Missing operand"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
						  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
					  </block_content>}</block></if></if_stmt>
					  <return>return <expr><name>rc</name></expr>;</return>
				  </block_content>}</block></else></if_stmt>
			  </block_content>}</block></if></if_stmt>
			  <comment type="block">/* Save terminal position */</comment>
			  <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>
	  </block_content>}</block></for>	 
	 <comment type="block">/* Process left and non-associative binary operators [i.e: *, /, &amp;&amp;, ||...]*/</comment>
	 <for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">7</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">17</literal></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		 <for>for<control>( <init><expr><name>iCur</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>iCur</name> <operator>&lt;</operator> <name>nToken</name></expr> ;</condition> <incr><expr><operator>++</operator><name>iCur</name></expr></incr> )</control><block>{<block_content>
			 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				 <continue>continue;</continue>
			 </block_content>}</block></if></if_stmt>
			 <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr>;</expr_stmt>
			 <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>==</operator> <name>i</name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				 <comment type="block">/* Get the right node */</comment>
				 <expr_stmt><expr><name>iRight</name> <operator>=</operator> <name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				 <while>while<condition>( <expr><name>iRight</name> <operator>&lt;</operator> <name>nToken</name> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					 <expr_stmt><expr><name>iRight</name><operator>++</operator></expr>;</expr_stmt>
				 </block_content>}</block></while>
				 <if_stmt><if>if<condition>( <expr><name>iRight</name> <operator>&gt;=</operator> <name>nToken</name> <operator>||</operator> <name>iLeft</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>NODE_ISTERM</name><argument_list>(<argument><expr><name>iRight</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>NODE_ISTERM</name><argument_list>(<argument><expr><name>iLeft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
					 <comment type="block">/* Syntax error */</comment>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"'%z': Missing/Invalid operand"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
						 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
					 </block_content>}</block></if></if_stmt>
					 <return>return <expr><name>rc</name></expr>;</return> 
				 </block_content>}</block></if></if_stmt>
				 <comment type="block">/* Link the node to the tree */</comment>
				 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
				 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>;</expr_stmt>
				 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			 </block_content>}</block></if></if_stmt>
			 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
		 </block_content>}</block></for>
	 </block_content>}</block></for>
	 <comment type="block">/* Handle the ternary operator. (expr1) ? (expr2) : (expr3) 
	  * Note that we do not need a precedence loop here since
	  * we are dealing with a single operator.
	  */</comment>
	  <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	  <for>for<control>( <init><expr><name>iCur</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>iCur</name> <operator>&lt;</operator> <name>nToken</name></expr> ;</condition> <incr><expr><operator>++</operator><name>iCur</name></expr></incr> )</control><block>{<block_content>
		  <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			  <continue>continue;</continue>
		  </block_content>}</block></if></if_stmt>
		  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr>;</expr_stmt>
		  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>==</operator> <name>EXPR_OP_QUESTY</name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			  <decl_stmt><decl><type><name>sxi32</name></type> <name>iNest</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			  <if_stmt><if>if<condition>( <expr><name>iLeft</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>NODE_ISTERM</name><argument_list>(<argument><expr><name>iLeft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				  <comment type="block">/* Missing condition */</comment>
				  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"'%z': Syntax error"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				  </block_content>}</block></if></if_stmt>
				  <return>return <expr><name>rc</name></expr>;</return>
			  </block_content>}</block></if></if_stmt>
			  <comment type="block">/* Get the right node */</comment>
			  <expr_stmt><expr><name>iRight</name> <operator>=</operator> <name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			  <while>while<condition>( <expr><name>iRight</name> <operator>&lt;</operator> <name>nToken</name></expr>  )</condition><block>{<block_content>
				  <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name></expr> )</condition><block>{<block_content>
					  <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name><operator>-&gt;</operator><name>pOp</name> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name><operator>-&gt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>iOp</name></name> <operator>==</operator> <name>EXPR_OP_QUESTY</name> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name><operator>-&gt;</operator><name>pCond</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
						  <comment type="block">/* Increment nesting level */</comment>
						  <expr_stmt><expr><operator>++</operator><name>iNest</name></expr>;</expr_stmt>
					  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nType</name></name> <operator>&amp;</operator> <name>JX9_TK_COLON</name></expr> <comment type="block">/*:*/</comment> )</condition><block>{<block_content>
						  <comment type="block">/* Decrement nesting level */</comment>
						  <expr_stmt><expr><operator>--</operator><name>iNest</name></expr>;</expr_stmt>
						  <if_stmt><if>if<condition>( <expr><name>iNest</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
							  <break>break;</break>
						  </block_content>}</block></if></if_stmt>
					  </block_content>}</block></if></if_stmt>
				  </block_content>}</block></if></if_stmt>
				  <expr_stmt><expr><name>iRight</name><operator>++</operator></expr>;</expr_stmt>
			  </block_content>}</block></while>
			  <if_stmt><if>if<condition>( <expr><name>iRight</name> <operator>&gt;</operator> <name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				  <comment type="block">/* Recurse and process the then expression */</comment>
				  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExprMakeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apNode</name><index>[<expr><name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iRight</name> <operator>-</operator> <name>iCur</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
					  <return>return <expr><name>rc</name></expr>;</return>
				  </block_content>}</block></if></if_stmt>
				  <comment type="block">/* Link the node to the tree */</comment>
				  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			  </block_content>}</block></if><else>else<block>{<block_content>
				  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"'%z': Missing 'then' expression"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				 </block_content>}</block></if></if_stmt>
				 <return>return <expr><name>rc</name></expr>;</return>
			  </block_content>}</block></else></if_stmt>
			  <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			  <if_stmt><if>if<condition>( <expr><name>iRight</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>nToken</name></expr> )</condition><block>{<block_content>
				  <comment type="block">/* Recurse and process the else expression */</comment>
				  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExprMakeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apNode</name><index>[<expr><name>iRight</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nToken</name> <operator>-</operator> <name>iRight</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
					  <return>return <expr><name>rc</name></expr>;</return>
				  </block_content>}</block></if></if_stmt>
				  <comment type="block">/* Link the node to the tree */</comment>
				  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iRight</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				  <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iRight</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>  <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			  </block_content>}</block></if><else>else<block>{<block_content>
				  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"'%z': Missing 'else' expression"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				 </block_content>}</block></if></if_stmt>
				 <return>return <expr><name>rc</name></expr>;</return>
			  </block_content>}</block></else></if_stmt>
			  <comment type="block">/* Point to the condition */</comment>
			  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pCond</name></name>  <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
			  <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			  <break>break;</break>
		  </block_content>}</block></if></if_stmt>
		  <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
	  </block_content>}</block></for>
	 <comment type="block">/* Process right associative binary operators [i.e: '=', '+=', '/='] 
	  * Note: All right associative binary operators have precedence 18
	  * so there is no need for a precedence loop here.
	  */</comment>
	 <expr_stmt><expr><name>iRight</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	 <for>for<control>( <init><expr><name>iCur</name> <operator>=</operator> <name>nToken</name> <operator>-</operator>  <literal type="number">1</literal></expr> ;</init> <condition><expr><name>iCur</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>iCur</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
		 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			 <continue>continue;</continue>
		 </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr>;</expr_stmt>
		 <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>==</operator> <literal type="number">18</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			 <comment type="block">/* Get the left node */</comment>
			 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <name>iCur</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			 <while>while<condition>( <expr><name>iLeft</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				 <expr_stmt><expr><name>iLeft</name><operator>--</operator></expr>;</expr_stmt>
			 </block_content>}</block></while>
			 <if_stmt><if>if<condition>( <expr><name>iLeft</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>iRight</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>NODE_ISTERM</name><argument_list>(<argument><expr><name>iRight</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>NODE_ISTERM</name><argument_list>(<argument><expr><name>iLeft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				 <comment type="block">/* Syntax error */</comment>
				 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"'%z': Missing/Invalid operand"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				 </block_content>}</block></if></if_stmt>
				 <return>return <expr><name>rc</name></expr>;</return>
			 </block_content>}</block></if></if_stmt>
			 <if_stmt><if>if<condition>( <expr><call><name>ExprIsModifiableValue</name><argument_list>(<argument><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr> )</condition><block>{<block_content>
				 <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iVmOp</name></name> <operator>!=</operator> <name>JX9_OP_STORE</name></expr>  )</condition><block>{<block_content>
					 <comment type="block">/* Left operand must be a modifiable l-value */</comment>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, 
						 <argument><expr><literal type="string">"'%z': Left operand must be a modifiable l-value"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
						 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
					 </block_content>}</block></if></if_stmt>
					 <return>return <expr><name>rc</name></expr>;</return> 
				 </block_content>}</block></if></if_stmt>
			 </block_content>}</block></if></if_stmt>
			 <comment type="block">/* Link the node to the tree (Reverse) */</comment>
			 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>;</expr_stmt>
			 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
			 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		 </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>iRight</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
	 </block_content>}</block></for>
	 <comment type="block">/* Process the lowest precedence operator (22, comma) */</comment>
	 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	 <for>for<control>( <init><expr><name>iCur</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>iCur</name> <operator>&lt;</operator> <name>nToken</name></expr> ;</condition> <incr><expr><operator>++</operator><name>iCur</name></expr></incr> )</control><block>{<block_content>
		 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			 <continue>continue;</continue>
		 </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr>;</expr_stmt>
		 <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name></name> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>iPrec</name></name> <operator>==</operator> <literal type="number">22</literal> <comment type="block">/* ',' */</comment> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			 <comment type="block">/* Get the right node */</comment>
			 <expr_stmt><expr><name>iRight</name> <operator>=</operator> <name>iCur</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			 <while>while<condition>( <expr><name>iRight</name> <operator>&lt;</operator> <name>nToken</name> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				 <expr_stmt><expr><name>iRight</name><operator>++</operator></expr>;</expr_stmt>
			 </block_content>}</block></while>
			 <if_stmt><if>if<condition>( <expr><name>iRight</name> <operator>&gt;=</operator> <name>nToken</name> <operator>||</operator> <name>iLeft</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>NODE_ISTERM</name><argument_list>(<argument><expr><name>iRight</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>NODE_ISTERM</name><argument_list>(<argument><expr><name>iLeft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				 <comment type="block">/* Syntax error */</comment>
				 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"'%z': Missing/Invalid operand"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOp</name><operator>-&gt;</operator><name>sOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				 <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				 </block_content>}</block></if></if_stmt>
				 <return>return <expr><name>rc</name></expr>;</return>
			 </block_content>}</block></if></if_stmt>
			 <comment type="block">/* Link the node to the tree */</comment>
			 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
			 <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>;</expr_stmt>
			 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iLeft</name></expr>]</index></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iRight</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		 </block_content>}</block></if></if_stmt>
		 <expr_stmt><expr><name>iLeft</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
	 </block_content>}</block></for>
	 <comment type="block">/* Point to the root of the expression tree */</comment>
	 <for>for<control>( <init><expr><name>iCur</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</init> <condition><expr><name>iCur</name> <operator>&lt;</operator> <name>nToken</name></expr> ;</condition> <incr><expr><operator>++</operator><name>iCur</name></expr></incr> )</control><block>{<block_content>
		 <if_stmt><if>if<condition>( <expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr> )</condition><block>{<block_content>
			 <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name>pOp</name> <operator>||</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name>xCode</name> <operator>)</operator> <operator>&amp;&amp;</operator> <name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
				 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>jx9GenCompileError</name><argument_list>(<argument><expr><name>pGen</name></expr></argument>, <argument><expr><name>E_ERROR</name></expr></argument>, <argument><expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><literal type="string">"Unexpected token '%z'"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name><operator>-&gt;</operator><name><name>pStart</name><operator>-&gt;</operator><name>sData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
					  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_SYNTAX</name></expr>;</expr_stmt>
				  </block_content>}</block></if></if_stmt>
				  <return>return <expr><name>rc</name></expr>;</return>  
			 </block_content>}</block></if></if_stmt>
			 <expr_stmt><expr><name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name></expr>;</expr_stmt>
			 <expr_stmt><expr><name><name>apNode</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		 </block_content>}</block></if></if_stmt>
	 </block_content>}</block></for>
	 <return>return <expr><name>SXRET_OK</name></expr>;</return>
 </block_content>}</block></function>
 <comment type="block">/*
  * Build an expression tree from the freshly extracted raw tokens.
  * If successful, the root of the tree is stored in ppRoot.
  * When errors, JX9 take care of generating the appropriate error message.
  * This is the public interface used by the most code generator routines.
  */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>jx9ExprMakeTree</name><parameter_list>(<parameter><decl><type><name>jx9_gen_state</name> <modifier>*</modifier></type><name>pGen</name></decl></parameter>, <parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pExprNode</name></decl></parameter>, <parameter><decl><type><name>jx9_expr_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRoot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>jx9_expr_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jx9_expr_node</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Reset node container */</comment>
	<expr_stmt><expr><call><name>SySetReset</name><argument_list>(<argument><expr><name>pExprNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pNode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Prevent compiler warning */</comment>
	<comment type="block">/* Extract nodes one after one until we hit the end of the input */</comment>
	<while>while<condition>( <expr><name><name>pGen</name><operator>-&gt;</operator><name>pIn</name></name> <operator>&lt;</operator> <name><name>pGen</name><operator>-&gt;</operator><name>pEnd</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExprExtractNode</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Save the extracted node */</comment>
		<expr_stmt><expr><call><name>SySetPut</name><argument_list>(<argument><expr><name>pExprNode</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><call><name>SySetUsed</name><argument_list>(<argument><expr><name>pExprNode</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Empty expression [i.e: A semi-colon;] */</comment>
		<expr_stmt><expr><operator>*</operator><name>ppRoot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>apNode</name> <operator>=</operator> <operator>(</operator><name>jx9_expr_node</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SySetBasePtr</name><argument_list>(<argument><expr><name>pExprNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Make sure we are dealing with valid nodes */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExprVerifyNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>apNode</name></expr></argument>, <argument><expr><operator>(</operator><name>sxi32</name><operator>)</operator><call><name>SySetUsed</name><argument_list>(<argument><expr><name>pExprNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't worry about freeing memory, upper layer will
		 * cleanup the mess left behind.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>ppRoot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Build the tree */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExprMakeTree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pGen</name><operator>)</operator></expr></argument>, <argument><expr><name>apNode</name></expr></argument>, <argument><expr><operator>(</operator><name>sxi32</name><operator>)</operator><call><name>SySetUsed</name><argument_list>(<argument><expr><name>pExprNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Something goes wrong [i.e: Syntax error] */</comment>
		<expr_stmt><expr><operator>*</operator><name>ppRoot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the root of the tree */</comment>
	<expr_stmt><expr><operator>*</operator><name>ppRoot</name> <operator>=</operator> <name><name>apNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
