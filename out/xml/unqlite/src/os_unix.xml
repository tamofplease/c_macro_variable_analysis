<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/src/os_unix.c"><comment type="block">/*
 * Symisc unQLite: An Embeddable NoSQL (Post Modern) Database Engine.
 * Copyright (C) 2012-2013, Symisc Systems http://unqlite.org/
 * Version 1.1.6
 * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES
 * please contact Symisc Systems via:
 *       legal@symisc.net
 *       licensing@symisc.net
 *       contact@symisc.net
 * or visit:
 *      http://unqlite.org/licensing.html
 */</comment>
 <comment type="block">/* $SymiscID: os_unix.c v1.3 FreeBSD 2013-04-05 01:10 devel &lt;chm@symisc.net&gt; $ */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unqliteInt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* 
 * Omit the whole layer from the build if compiling for platforms other than Unix (Linux, BSD, Solaris, OS X, etc.).
 * Note: Mostly SQLite3 source tree.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__UNIXES__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/** This file contains the VFS implementation for unix-like operating systems
** include Linux, MacOSX, *BSD, QNX, VxWorks, AIX, HPUX, and others.
**
** There are actually several different VFS implementations in this file.
** The differences are in the way that file locking is done.  The default
** implementation uses Posix Advisory Locks.  Alternative implementations
** use flock(), dot-files, various proprietary locking schemas, or simply
** skip locking all together.
**
** This source file is organized into divisions where the logic for various
** subfunctions is contained within the appropriate division.  PLEASE
** KEEP THE STRUCTURE OF THIS FILE INTACT.  New code should be placed
** in the correct division and should be clearly labeled.
**
*/</comment>
<comment type="block">/*
** standard include files.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/uio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if> 
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mount.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** Allowed values of unixFile.fsFlags
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNQLITE_FSFLAGS_IS_MSDOS</name></cpp:macro>     <cpp:value>0x1</cpp:value></cpp:define>

<comment type="block">/*
** Default permissions when creating a new file
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_DEFAULT_FILE_PERMISSIONS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UNQLITE_DEFAULT_FILE_PERMISSIONS</name></cpp:macro> <cpp:value>0644</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 ** Default permissions when creating auto proxy dir
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_DEFAULT_PROXYDIR_PERMISSIONS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UNQLITE_DEFAULT_PROXYDIR_PERMISSIONS</name></cpp:macro> <cpp:value>0755</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** Maximum supported path-length.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PATHNAME</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>
<comment type="block">/*
** Only set the lastErrno if the error code is a real error and not 
** a normal expected return code of UNQLITE_BUSY or UNQLITE_OK
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LOCK_ERROR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((x != UNQLITE_OK) &amp;&amp; (x != UNQLITE_BUSY))</cpp:value></cpp:define>
<comment type="block">/* Forward references */</comment>
<typedef>typedef <type><name><name>struct</name> <name>unixInodeInfo</name></name></type> <name>unixInodeInfo</name>;</typedef>   <comment type="block">/* An i-node */</comment>
<typedef>typedef <type><name><name>struct</name> <name>UnixUnusedFd</name></name></type> <name>UnixUnusedFd</name>;</typedef>     <comment type="block">/* An unused file descriptor */</comment>
<comment type="block">/*
** Sometimes, after a file handle is closed by SQLite, the file descriptor
** cannot be closed immediately. In these cases, instances of the following
** structure are used to store the file descriptor while waiting for an
** opportunity to either close or reuse it.
*/</comment>
<struct>struct <name>UnixUnusedFd</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>                   <comment type="block">/* File descriptor to close */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                <comment type="block">/* Flags this file descriptor was opened with */</comment>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>      <comment type="block">/* Next unused file descriptor on same file */</comment>
}</block>;</struct>
<comment type="block">/*
** The unixFile structure is subclass of unqlite3_file specific to the unix
** VFS implementations.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>unixFile</name></name></type> <name>unixFile</name>;</typedef>
<struct>struct <name>unixFile</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>unqlite_io_methods</name> <modifier>*</modifier></type><name>pMethod</name></decl>;</decl_stmt>  <comment type="block">/* Always the first entry */</comment>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name></decl>;</decl_stmt>              <comment type="block">/* Info about locks on this inode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>                              <comment type="block">/* The file descriptor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>dirfd</name></decl>;</decl_stmt>                          <comment type="block">/* File descriptor for the directory */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>eFileLock</name></decl>;</decl_stmt>            <comment type="block">/* The type of lock held on this fd */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>lastErrno</name></decl>;</decl_stmt>                      <comment type="block">/* The unix errno from last I/O error */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>lockingContext</name></decl>;</decl_stmt>               <comment type="block">/* Locking style specific state */</comment>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pUnused</name></decl>;</decl_stmt>              <comment type="block">/* Pre-allocated UnixUnusedFd */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>fileFlags</name></decl>;</decl_stmt>                      <comment type="block">/* Miscellanous flags */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>                  <comment type="block">/* Name of the file */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>fsFlags</name></decl>;</decl_stmt>                   <comment type="block">/* cached details from statfs() */</comment>
}</block>;</struct>
<comment type="block">/*
** The following macros define bits in unixFile.fileFlags
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNQLITE_WHOLE_FILE_LOCKING</name></cpp:macro>  <cpp:value>0x0001</cpp:value></cpp:define>   <comment type="block">/* Use whole-file locking */</comment>
<comment type="block">/*
** Define various macros that are missing from some systems.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_LARGEFILE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>O_LARGEFILE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_NOFOLLOW</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>O_NOFOLLOW</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_BINARY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>O_BINARY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** Helper functions to obtain and relinquish the global mutex. The
** global mutex is used to protect the unixInodeInfo and
** vxworksFileId objects used by this file, all of which may be 
** shared by multiple threads.
**
** Function unixMutexHeld() is used to assert() that the global mutex 
** is held when required. This function is only used as part of assert() 
** statements. e.g.
**
**   unixEnterMutex()
**     assert( unixMutexHeld() );
**   unixEnterLeave()
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixEnterMutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNQLITE_ENABLE_THREADS</name></cpp:ifdef>
	<decl_stmt><decl><type><specifier>const</specifier> <name>SyMutexMethods</name> <modifier>*</modifier></type><name>pMutexMethods</name> <init>= <expr><call><name>SyMutexExportMethods</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pMutexMethods</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name> <init>= <expr><call><name><name>pMutexMethods</name><operator>-&gt;</operator><name>xNew</name></name><argument_list>(<argument><expr><name>SXMUTEX_TYPE_STATIC_2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* pre-allocated, never fail */</comment>
		<expr_stmt><expr><call><name>SyMutexEnter</name><argument_list>(<argument><expr><name>pMutexMethods</name></expr></argument>,<argument><expr><name>pMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* UNQLITE_ENABLE_THREADS */</comment>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixLeaveMutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNQLITE_ENABLE_THREADS</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>SyMutexMethods</name> <modifier>*</modifier></type><name>pMutexMethods</name> <init>= <expr><call><name>SyMutexExportMethods</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pMutexMethods</name></expr> )</condition><block>{<block_content>
	 <decl_stmt><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name> <init>= <expr><call><name><name>pMutexMethods</name><operator>-&gt;</operator><name>xNew</name></name><argument_list>(<argument><expr><name>SXMUTEX_TYPE_STATIC_2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* pre-allocated, never fail */</comment>
	 <expr_stmt><expr><call><name>SyMutexLeave</name><argument_list>(<argument><expr><name>pMutexMethods</name></expr></argument>,<argument><expr><name>pMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* UNQLITE_ENABLE_THREADS */</comment>
</block_content>}</block></function>
<comment type="block">/*
** This routine translates a standard POSIX errno code into something
** useful to the clients of the unqlite3 functions.  Specifically, it is
** intended to translate a variety of "try again" errors into UNQLITE_BUSY
** and a variety of "please close the file descriptor NOW" errors into 
** UNQLITE_IOERR
** 
** Errors during initialization of locks, or file system support for locks,
** should handle ENOLCK, ENOTSUP, EOPNOTSUPP separately.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteErrorFromPosixError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>posixError</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unqliteIOErr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>posixError</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><literal type="number">0</literal></expr>:</case> 
    <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
    
  <case>case <expr><name>EAGAIN</name></expr>:</case>
  <case>case <expr><name>ETIMEDOUT</name></expr>:</case>
  <case>case <expr><name>EBUSY</name></expr>:</case>
  <case>case <expr><name>EINTR</name></expr>:</case>
  <case>case <expr><name>ENOLCK</name></expr>:</case>  
    <comment type="block">/* random NFS retry error, unless during file system support 
     * introspection, in which it actually means what it says */</comment>
    <return>return <expr><name>UNQLITE_BUSY</name></expr>;</return>
 
  <case>case <expr><name>EACCES</name></expr>:</case> 
    <comment type="block">/* EACCES is like EAGAIN during locking operations, but not any other time*/</comment>
      <return>return <expr><name>UNQLITE_BUSY</name></expr>;</return>
    
  <case>case <expr><name>EPERM</name></expr>:</case> 
    <return>return <expr><name>UNQLITE_PERM</name></expr>;</return>
    
  <case>case <expr><name>EDEADLK</name></expr>:</case>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EOPNOTSUPP</name><operator>!=</operator><name>ENOTSUP</name></expr></cpp:if>
  <case>case <expr><name>EOPNOTSUPP</name></expr>:</case> 
    <comment type="block">/* something went terribly awry, unless during file system support 
     * introspection, in which it actually means what it says */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENOTSUP</name></cpp:ifdef>
  <case>case <expr><name>ENOTSUP</name></expr>:</case> 
    <comment type="block">/* invalid fd, unless during file system support introspection, in which 
     * it actually means what it says */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <case>case <expr><name>EIO</name></expr>:</case>
  <case>case <expr><name>EBADF</name></expr>:</case>
  <case>case <expr><name>EINVAL</name></expr>:</case>
  <case>case <expr><name>ENOTCONN</name></expr>:</case>
  <case>case <expr><name>ENODEV</name></expr>:</case>
  <case>case <expr><name>ENXIO</name></expr>:</case>
  <case>case <expr><name>ENOENT</name></expr>:</case>
  <case>case <expr><name>ESTALE</name></expr>:</case>
  <case>case <expr><name>ENOSYS</name></expr>:</case>
    <comment type="block">/* these should force the client to close the file and reconnect */</comment>
    
  <default>default:</default> 
    <return>return <expr><name>unqliteIOErr</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>
<comment type="block" format="doxygen">/******************************************************************************
*************************** Posix Advisory Locking ****************************
**
** POSIX advisory locks are broken by design.  ANSI STD 1003.1 (1996)
** section 6.5.2.2 lines 483 through 490 specify that when a process
** sets or clears a lock, that operation overrides any prior locks set
** by the same process.  It does not explicitly say so, but this implies
** that it overrides locks set by the same process using a different
** file descriptor.  Consider this test case:
**
**       int fd1 = open("./file1", O_RDWR|O_CREAT, 0644);
**       int fd2 = open("./file2", O_RDWR|O_CREAT, 0644);
**
** Suppose ./file1 and ./file2 are really the same file (because
** one is a hard or symbolic link to the other) then if you set
** an exclusive lock on fd1, then try to get an exclusive lock
** on fd2, it works.  I would have expected the second lock to
** fail since there was already a lock on the file due to fd1.
** But not so.  Since both locks came from the same process, the
** second overrides the first, even though they were on different
** file descriptors opened on different file names.
**
** This means that we cannot use POSIX locks to synchronize file access
** among competing threads of the same process.  POSIX locks will work fine
** to synchronize access for threads in separate processes, but not
** threads within the same process.
**
** To work around the problem, SQLite has to manage file locks internally
** on its own.  Whenever a new database is opened, we have to find the
** specific inode of the database file (the inode is determined by the
** st_dev and st_ino fields of the stat structure that fstat() fills in)
** and check for locks already existing on that inode.  When locks are
** created or removed, we have to look at our own internal record of the
** locks to see if another thread has previously set a lock on that same
** inode.
**
** (Aside: The use of inode numbers as unique IDs does not work on VxWorks.
** For VxWorks, we have to use the alternative unique ID system based on
** canonical filename and implemented in the previous division.)
**
** There is one locking structure
** per inode, so if the same inode is opened twice, both unixFile structures
** point to the same locking structure.  The locking structure keeps
** a reference count (so we will know when to delete it) and a "cnt"
** field that tells us its internal lock status.  cnt==0 means the
** file is unlocked.  cnt==-1 means the file has an exclusive lock.
** cnt&gt;0 means there are cnt shared locks on the file.
**
** Any attempt to lock or unlock a file first checks the locking
** structure.  The fcntl() system call is only invoked to set a 
** POSIX lock if the internal lock structure transitions between
** a locked and an unlocked state.
**
** But wait:  there are yet more problems with POSIX advisory locks.
**
** If you close a file descriptor that points to a file that has locks,
** all locks on that file that are owned by the current process are
** released.  To work around this problem, each unixInodeInfo object
** maintains a count of the number of pending locks on that inode.
** When an attempt is made to close an unixFile, if there are
** other unixFile open on the same inode that are holding locks, the call
** to close() the file descriptor is deferred until all of the locks clear.
** The unixInodeInfo structure keeps a list of file descriptors that need to
** be closed and that list is walked (and cleared) when the last lock
** clears.
**
** Yet another problem:  LinuxThreads do not play well with posix locks.
**
** Many older versions of linux use the LinuxThreads library which is
** not posix compliant.  Under LinuxThreads, a lock created by thread
** A cannot be modified or overridden by a different thread B.
** Only thread A can modify the lock.  Locking behavior is correct
** if the appliation uses the newer Native Posix Thread Library (NPTL)
** on linux - with NPTL a lock created by thread A can override locks
** in thread B.  But there is no way to know at compile-time which
** threading library is being used.  So there is no way to know at
** compile-time whether or not thread A can override locks on thread B.
** One has to do a run-time check to discover the behavior of the
** current process.
**
*/</comment>

<comment type="block">/*
** An instance of the following structure serves as the key used
** to locate a particular unixInodeInfo object.
*/</comment>
<struct>struct <name>unixFileId</name> <block>{
  <decl_stmt><decl><type><name>dev_t</name></type> <name>dev</name></decl>;</decl_stmt>                  <comment type="block">/* Device number */</comment>
  <decl_stmt><decl><type><name>ino_t</name></type> <name>ino</name></decl>;</decl_stmt>                  <comment type="block">/* Inode number */</comment>
}</block>;</struct>
<comment type="block">/*
** An instance of the following structure is allocated for each open
** inode.  Or, on LinuxThreads, there is one of these structures for
** each inode opened by each thread.
**
** A single inode can have multiple file descriptors, so each unixFile
** structure contains a pointer to an instance of this object and this
** object keeps a count of the number of unixFile pointing to it.
*/</comment>
<struct>struct <name>unixInodeInfo</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>unixFileId</name></name></type> <name>fileId</name></decl>;</decl_stmt>       <comment type="block">/* The lookup key */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nShared</name></decl>;</decl_stmt>                    <comment type="block">/* Number of SHARED locks held */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eFileLock</name></decl>;</decl_stmt>                  <comment type="block">/* One of SHARED_LOCK, RESERVED_LOCK etc. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                       <comment type="block">/* Number of pointers to this structure */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLock</name></decl>;</decl_stmt>                      <comment type="block">/* Number of outstanding file locks */</comment>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pUnused</name></decl>;</decl_stmt>          <comment type="block">/* Unused file descriptors to close */</comment>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>           <comment type="block">/* List of all unixInodeInfo objects */</comment>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pPrev</name></decl>;</decl_stmt>           <comment type="block">/*    .... doubly linked */</comment>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>unixInodeInfo</name> <modifier>*</modifier></type><name>inodeList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Local memory allocation stuff.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type> <name>unqlite_malloc</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pAlloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pAlloc</name> <operator>=</operator> <operator>(</operator><name>SyMemBackend</name> <operator>*</operator><operator>)</operator><call><name>unqliteExportMemBackend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><name>pAlloc</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>unqlite_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pAlloc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pAlloc</name> <operator>=</operator> <operator>(</operator><name>SyMemBackend</name> <operator>*</operator><operator>)</operator><call><name>unqliteExportMemBackend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name>pAlloc</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
** Close all file descriptors accumuated in the unixInodeInfo-&gt;pUnused list.
** If all such file descriptors are closed without error, the list is
** cleared and UNQLITE_OK returned.
**
** Otherwise, if an error occurs, then successfully closed file descriptor
** entries are removed from the list, and UNQLITE_IOERR_CLOSE returned. 
** not deleted and UNQLITE_IOERR_CLOSE returned.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>closePendingFds</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pError</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pInode</name><operator>-&gt;</operator><name>pUnused</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_IOERR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pError</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pError</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>unqlite_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pUnused</name></name> <operator>=</operator> <name>pError</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Release a unixInodeInfo structure previously allocated by findInodeInfo().
**
** The mutex entered using the unixEnterMutex() function must be held
** when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>releaseInodeInfo</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pInode</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>closePendingFds</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>pPrev</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>inodeList</name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>unqlite_free</name><argument_list>(<argument><expr><name>pInode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
** Given a file descriptor, locate the unixInodeInfo object that
** describes that file descriptor.  Create a new one if necessary.  The
** return value might be uninitialized if an error occurs.
**
** The mutex entered using the unixEnterMutex() function must be held
** when this function is called.
**
** Return an appropriate error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>findInodeInfo</name><parameter_list>(
  <parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,               <comment type="block">/* Unix file with file desc used in the key */</comment>
  <parameter><decl><type><name>unixInodeInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppInode</name></decl></parameter>        <comment type="block">/* Return the unixInodeInfo object here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                        <comment type="block">/* System call return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>                        <comment type="block">/* The file descriptor for pFile */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>unixFileId</name></name></type> <name>fileId</name></decl>;</decl_stmt>      <comment type="block">/* Lookup key for the unixInodeInfo */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>           <comment type="block">/* Low-level file information */</comment>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Candidate unixInodeInfo object */</comment>

  <comment type="block">/* Get low-level information about the file that we can used to
  ** create a unique name for the file.
  */</comment>
  <expr_stmt><expr><name>fd</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EOVERFLOW</name></cpp:ifdef>
	<if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name><operator>==</operator><name>EOVERFLOW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>UNQLITE_NOTIMPLEMENTED</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
  <comment type="block">/* On OS X on an msdos filesystem, the inode number is reported
  ** incorrectly for zero-size files.  See ticket #3260.  To work
  ** around this problem (we consider it a bug in OS X, not SQLite)
  ** we always increase the file size to 1 by writing a single byte
  ** prior to accessing the inode number.  The one byte written is
  ** an ASCII 'S' character which also happens to be the first byte
  ** in the header of every SQLite database.  In this way, if there
  ** is a race condition such that another thread has already populated
  ** the first page of the database, no damage is done.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>fsFlags</name></name> <operator>&amp;</operator> <name>UNQLITE_FSFLAGS_IS_MSDOS</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"S"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
      <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
      <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fileId</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fileId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fileId</name><operator>.</operator><name>dev</name></name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_dev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fileId</name><operator>.</operator><name>ino</name></name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_ino</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name>inodeList</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pInode</name> <operator>&amp;&amp;</operator> <call><name>SyMemcmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>fileId</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pInode</name><operator>-&gt;</operator><name>fileId</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fileId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pInode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pInode</name> <operator>=</operator> <operator>(</operator><name>unixInodeInfo</name> <operator>*</operator><operator>)</operator><call><name>unqlite_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pInode</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pInode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pInode</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pInode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>fileId</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pInode</name><operator>-&gt;</operator><name>fileId</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fileId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>inodeList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>inodeList</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>inodeList</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pInode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>inodeList</name> <operator>=</operator> <name>pInode</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppInode</name> <operator>=</operator> <name>pInode</name></expr>;</expr_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to UNQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>

 
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Because pFile-&gt;pInode is shared across threads */</comment>

  <comment type="block">/* Check if a thread in this process holds such a lock */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>reserved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Otherwise see if some other process holds it.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>reserved</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>lock</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>RESERVED_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_WRLCK</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_GETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if<condition>( <expr><name><name>lock</name><operator>.</operator><name>l_type</name></name><operator>!=</operator><name>F_UNLCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>reserved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  Use the unqliteOsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixLock</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* The following describes the implementation of the various locks and
  ** lock transitions in terms of the POSIX advisory shared and exclusive
  ** lock primitives (called read-locks and write-locks below, to avoid
  ** confusion with SQLite lock names). The algorithms are complicated
  ** slightly in order to be compatible with unixdows systems simultaneously
  ** accessing the same database file, in case that is ever required.
  **
  ** Symbols defined in os.h indentify the 'pending byte' and the 'reserved
  ** byte', each single bytes at well known offsets, and the 'shared byte
  ** range', a range of 510 bytes at a well known offset.
  **
  ** To obtain a SHARED lock, a read-lock is obtained on the 'pending
  ** byte'.  If this is successful, a random byte from the 'shared byte
  ** range' is read-locked and the lock on the 'pending byte' released.
  **
  ** A process may only obtain a RESERVED lock after it has a SHARED lock.
  ** A RESERVED lock is implemented by grabbing a write-lock on the
  ** 'reserved byte'. 
  **
  ** A process may only obtain a PENDING lock after it has obtained a
  ** SHARED lock. A PENDING lock is implemented by obtaining a write-lock
  ** on the 'pending byte'. This ensures that no new SHARED locks can be
  ** obtained, but existing SHARED locks are allowed to persist. A process
  ** does not have to obtain a RESERVED lock on the way to a PENDING lock.
  ** This property is used by the algorithm for rolling back a journal file
  ** after a crash.
  **
  ** An EXCLUSIVE lock, obtained after a PENDING lock is held, is
  ** implemented by obtaining a write-lock on the entire 'shared byte
  ** range'. Since all other locks require a read-lock on one of the bytes
  ** within this range, this ensures that no other locks are held on the
  ** database. 
  **
  ** The reason a single byte cannot be used instead of the 'shared byte
  ** range' is that some versions of unixdows do not support read-locks. By
  ** locking a random byte from a range, concurrent SHARED locks may exist
  ** even if the locking primitive used is always a write-lock.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If there is already a lock of this type or more restrictive on the
  ** unixFile, do nothing. Don't use the end_lock: exit path, as
  ** unixEnterMutex() hasn't been called yet.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;=</operator><name>eFileLock</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* This mutex is needed because pFile-&gt;pInode is shared across threads
  */</comment>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr>;</expr_stmt>

  <comment type="block">/* If some thread using this PID has a lock via a different unixFile*
  ** handle that precludes the requested lock, return BUSY.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>!=</operator><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>&amp;&amp;</operator> 
          <operator>(</operator><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;=</operator><name>PENDING_LOCK</name> <operator>||</operator> <name>eFileLock</name><operator>&gt;</operator><name>SHARED_LOCK</name><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>end_lock</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If a SHARED lock is requested, and some thread using this PID already
  ** has a SHARED or RESERVED lock, then increment reference counts and
  ** return UNQLITE_OK.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name> <operator>&amp;&amp;</operator> 
      <operator>(</operator><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>SHARED_LOCK</name> <operator>||</operator> <name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>RESERVED_LOCK</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>end_lock</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* A PENDING lock is needed before acquiring a SHARED lock and before
  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will
  ** be released.
  */</comment>
  <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">1L</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name> 
      <operator>||</operator> <operator>(</operator><name>eFileLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&lt;</operator><name>PENDING_LOCK</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr>?</condition><then><expr><name>F_RDLCK</name></expr></then><else>:<expr><name>F_WRLCK</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>s</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>end_lock</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* If control gets to this point, then actually go ahead and make
  ** operating system calls for the specified lock.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Now get the read-lock */</comment>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>SHARED_SIZE</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Drop the temporary PENDING lock */</comment>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">1L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_UNLCK</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>s</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* This could happen with a network mount */</comment>
        <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt> 
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <goto>goto <name>end_lock</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>s</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name> <operator>&amp;&amp;</operator> <name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* We are trying for an exclusive lock but another thread in this
    ** same process is still holding a shared lock. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The request was for a RESERVED or EXCLUSIVE lock.  It is
    ** assumed that there is a SHARED or greater lock on the file
    ** already.
    */</comment>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_WRLCK</name></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>eFileLock</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>RESERVED_LOCK</name></expr>:</case>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>RESERVED_BYTE</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>EXCLUSIVE_LOCK</name></expr>:</case>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>SHARED_SIZE</name></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
		  <comment type="block">/* Can't happen */</comment>
        <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>s</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>PENDING_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>PENDING_LOCK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>end_lock</name>:</label>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Add the file descriptor used by file handle pFile to the corresponding
** pUnused list.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setPendingFd</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pUnused</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pUnused</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pUnused</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pUnused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
** 
** If handleNFSUnlock is true, then on downgrading an EXCLUSIVE_LOCK to SHARED
** the byte range is divided into 2 parts and the first part is unlocked then
** set to a read lock, then the other part is simply unlocked.  This works 
** around a bug in BSD NFS lockd (also seen on MacOSX 10.3+) that fails to 
** remove the write lock on a region when a read lock is set.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_posixUnlock</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>handleNFSUnlock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name></decl>;</decl_stmt>                      <comment type="block">/* Error code from system call errors */</comment>

   <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&lt;=</operator><name>eFileLock</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* downgrading to a shared lock on NFS involves clearing the write lock
    ** before establishing the readlock - to avoid a race condition we downgrade
    ** the lock in 2 blocks, so that part of the range will be covered by a 
    ** write lock until the rest is covered by a read lock:
    **  1:   [WWWWW]
    **  2:   [....W]
    **  3:   [RRRRW]
    **  4:   [RRRR.]
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>handleNFSUnlock</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>off_t</name></type> <name>divSize</name> <init>= <expr><name>SHARED_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_UNLCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>divSize</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <goto>goto <name>end_unlock</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_RDLCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>divSize</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <goto>goto <name>end_unlock</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_UNLCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name><operator>+</operator><name>divSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>SHARED_SIZE</name><operator>-</operator><name>divSize</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <goto>goto <name>end_unlock</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_RDLCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>SHARED_SIZE</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <goto>goto <name>end_unlock</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_UNLCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">2L</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>!=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>end_unlock</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>NO_LOCK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Decrement the shared lock counter.  Release the lock using an
    ** OS call only when all threads in this same process have released
    ** the lock.
    */</comment>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_UNLCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
      
      <if_stmt><if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>!=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>UNQLITE_LOCKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>tErrno</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Decrement the count of locks against this same file.  When the
    ** count reaches zero, close any other file descriptors whose close
    ** was deferred because of outstanding locks.
    */</comment>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>--</operator></expr>;</expr_stmt>
 
    <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><call><name>closePendingFds</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
	
<label><name>end_unlock</name>:</label>

  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>UNQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixUnlock</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>_posixUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>eFileLock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** This function performs the parts of the "close file" operation 
** common to all locking schemes. It closes the directory and file
** handles, if they are valid, and sets all fields of the unixFile
** structure to 0.
**
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closeUnixFile</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFile</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>dirfd</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>close</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>dirfd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>err</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
        <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>dirfd</name></name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>close</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>err</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
        <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>unqlite_free</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pUnused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unixFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Close a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixClose</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>id</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>unixUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If there are outstanding locks, do not actually close the file just
      ** yet because that would clear those locks.  Instead, add the file
      ** descriptor to pInode-&gt;pUnused list.  It will be automatically closed 
      ** when the last lock is cleared.
      */</comment>
      <expr_stmt><expr><call><name>setPendingFd</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>releaseInodeInfo</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/************** End of the posix advisory lock implementation *****************
******************************************************************************/</comment>
<comment type="block">/*
**
** The next division contains implementations for all methods of the 
** unqlite_file object other than the locking methods.  The locking
** methods were defined in divisions above (one locking method per
** division).  Those methods that are common to all locking modes
** are gather together into this division.
*/</comment>
<comment type="block">/*
** Seek to the offset passed as the second argument, then read cnt 
** bytes into pBuf. Return the number of bytes actually read.
**
** NB:  If you define USE_PREAD or USE_PREAD64, then it might also
** be necessary to define _XOPEN_SOURCE to be 500.  This varies from
** one system to another.  Since SQLite does not define USE_PREAD
** any form by default, we will not attempt to define _XOPEN_SOURCE.
** See tickets #2741 and #2681.
**
** To avoid stomping the errno value on a failed read the lastErrno value
** is set before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seekAndRead</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>unqlite_int64</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>got</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
  <decl_stmt><decl><type><name>unqlite_int64</name></type> <name>newOffset</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>pread</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>pread64</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>newOffset</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>newOffset</name><operator>!=</operator><name>offset</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>newOffset</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>lastErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>lastErrno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			
    </block_content>}</block></else></if_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>got</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>lastErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>got</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Read data from a file into a buffer.  Return UNQLITE_OK if all
** bytes were read successfully and UNQLITE_IOERR if anything goes
** wrong.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixRead</name><parameter_list>(
  <parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, 
  <parameter><decl><type><name>unqlite_int64</name></type> <name>amt</name></decl></parameter>,
  <parameter><decl><type><name>unqlite_int64</name></type> <name>offset</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>got</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>seekAndRead</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>got</name><operator>==</operator><operator>(</operator><name>int</name><operator>)</operator><name>amt</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>got</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* lastErrno set by seekAndRead */</comment>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* not a system error */</comment>
    <comment type="block">/* Unread parts of the buffer must be zero-filled */</comment>
    <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>got</name></expr>]</index></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>amt</name><operator>-</operator><name>got</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
** Seek to the offset in id-&gt;offset then read cnt bytes into pBuf.
** Return the number of bytes actually read.  Update the offset.
**
** To avoid stomping the errno value on a failed write the lastErrno value
** is set before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seekAndWrite</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>unqlite_int64</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>unqlite_int64</name></type> <name>cnt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>got</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
  <decl_stmt><decl><type><name>unqlite_int64</name></type> <name>newOffset</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>pwrite</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>pwrite64</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>newOffset</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>newOffset</name><operator>!=</operator><name>offset</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>newOffset</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>lastErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>lastErrno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			
    </block_content>}</block></else></if_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>got</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>lastErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>got</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Write data from a buffer into a file.  Return UNQLITE_OK on success
** or some other error code on failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixWrite</name><parameter_list>(
  <parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, 
  <parameter><decl><type><name>unqlite_int64</name></type> <name>amt</name></decl></parameter>,
  <parameter><decl><type><name>unqlite_int64</name></type> <name>offset</name></decl></parameter> 
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wrote</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>amt</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>wrote</name> <operator>=</operator> <call><name>seekAndWrite</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>amt</name> <operator>-=</operator> <name>wrote</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>wrote</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>wrote</name></expr>]</index></expr>;</expr_stmt>
  </block_content>}</block></while>
  
  <if_stmt><if>if<condition>( <expr><name>amt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>wrote</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* lastErrno set by seekAndWrite */</comment>
      <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* not a system error */</comment>
      <return>return <expr><name>UNQLITE_FULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** We do not trust systems to provide a working fdatasync().  Some do.
** Others do no.  To be safe, we will stick with the (slower) fsync().
** If you know that your system does support fdatasync() correctly,
** then simply compile with -Dfdatasync=fdatasync
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>fdatasync</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>fdatasync</name></cpp:macro> <cpp:value>fsync</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Define HAVE_FULLFSYNC to 0 or 1 depending on whether or not
** the F_FULLFSYNC macro is defined.  F_FULLFSYNC is currently
** only available on Mac OS X.  But that could change.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_FULLFSYNC</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FULLFSYNC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FULLFSYNC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** The fsync() system call does not work as advertised on many
** unix systems.  The following procedure is an attempt to make
** it work better.
**
**
** SQLite sets the dataOnly flag if the size of the file is unchanged.
** The idea behind dataOnly is that it should only write the file content
** to disk, not the inode.  We only set dataOnly if the file size is 
** unchanged since the file size is part of the inode.  However, 
** Ted Ts'o tells us that fdatasync() will also write the inode if the
** file size has changed.  The only real difference between fdatasync()
** and fsync(), Ted tells us, is that fdatasync() will not flush the
** inode if the mtime or owner or other inode attributes have changed.
** We only care about the file size, not the other file attributes, so
** as far as SQLite is concerned, an fdatasync() is always adequate.
** So, we always use fdatasync() if it is available, regardless of
** the value of the dataOnly flag.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>full_fsync</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fullSync</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dataOnly</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_FULLFSYNC</name></expr></cpp:if>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>dataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>fullSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>dataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If we compiled with the UNQLITE_NO_SYNC flag, then syncing is a
  ** no-op
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_FULLFSYNC</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>fullSync</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_FULLFSYNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* If the FULLFSYNC failed, fall back to attempting an fsync().
  ** It shouldn't be possible for fullfsync to fail on the local 
  ** file system (on OSX), so failure indicates that FULLFSYNC
  ** isn't supported for this file system. So, attempt an fsync 
  ** and (for now) ignore the overhead of a superfluous fcntl call.  
  ** It'd be better to detect fullfsync support once and avoid 
  ** the fcntl call every time sync is called.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <comment type="block">/* fdatasync() on HFS+ doesn't yet flush the file size if it changed correctly
  ** so currently we default to the macro that redefines fdatasync to fsync
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fdatasync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifdef UNQLITE_NO_SYNC elif HAVE_FULLFSYNC */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Make sure all writes to a particular file are committed to disk.
**
** If dataOnly==0 then both the file itself and its metadata (file
** size, access time, etc) are synced.  If dataOnly!=0 then only the
** file data is synced.
**
** Under Unix, also make sure that the directory entry for the file
** has been created by fsync-ing the directory that contains the file.
** If we do not do this and we encounter a power failure, the directory
** entry for the journal might not exist after we reboot.  The next
** SQLite to access the file will not know that the journal exists (because
** the directory entry for the journal was never created) and the transaction
** will not roll back - possibly leading to database corruption.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixSync</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>isDataOnly</name> <init>= <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><name>UNQLITE_SYNC_DATAONLY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isFullsync</name> <init>= <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">0x0F</literal><operator>)</operator><operator>==</operator><name>UNQLITE_SYNC_FULL</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>full_fsync</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>isFullsync</name></expr></argument>, <argument><expr><name>isDataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>dirfd</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_DISABLE_DIRSYNC</name></cpp:ifndef>
    <comment type="block">/* The directory sync is only attempted if full_fsync is
    ** turned off or unavailable.  If a full_fsync occurred above,
    ** then the directory sync is superfluous.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>!</operator><name>HAVE_FULLFSYNC</name> <operator>||</operator> <operator>!</operator><name>isFullsync</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>full_fsync</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>dirfd</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <comment type="block">/*
       ** We have received multiple reports of fsync() returning
       ** errors when applied to directories on certain file systems.
       ** A failed directory sync is not a big deal.  So it seems
       ** better to ignore the error.  Ticket #1657
       */</comment>
       <comment type="block">/* pFile-&gt;lastErrno = errno; */</comment>
       <comment type="block">/* return UNQLITE_IOERR; */</comment>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>close</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>dirfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Only need to sync once, so close the */</comment>
    <if_stmt><if>if<condition>( <expr><name>err</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>              <comment type="block">/* directory when we are done */</comment>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>dirfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_IOERR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Truncate an open file to a specified size
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixTruncate</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>sxi64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ftruncate</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
** Determine the current size of a file in bytes
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixFileSize</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,<parameter><decl><type><name>sxi64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>lastErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>

  <comment type="block">/* When opening a zero-size database, the findInodeInfo() procedure
  ** writes a single byte into that file in order to work around a bug
  ** in the OS-X msdos filesystem.  In order to avoid problems with upper
  ** layers, we need to report this file size as zero even though it is
  ** really 1.   Ticket #3260.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pSize</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Return the sector size in bytes of the underlying block device for
** the specified file. This is almost always 512 bytes, but may be
** larger for some devices.
**
** SQLite code assumes this function cannot fail. It also assumes that
** if two files are created in the same file-system directory (i.e.
** a database and its journal file) that the sector size will be the
** same for both.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixSectorSize</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>UNQLITE_DEFAULT_SECTOR_SIZE</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** This vector defines all the methods that can operate on an
** unqlite_file for Windows systems.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unqlite_io_methods</name></type> <name>unixIoMethod</name> <init>= <expr><block>{
  <expr><literal type="number">1</literal></expr>,                              <comment type="block">/* iVersion */</comment>
  <expr><name>unixClose</name></expr>,                       <comment type="block">/* xClose */</comment>
  <expr><name>unixRead</name></expr>,                        <comment type="block">/* xRead */</comment>
  <expr><name>unixWrite</name></expr>,                       <comment type="block">/* xWrite */</comment>
  <expr><name>unixTruncate</name></expr>,                    <comment type="block">/* xTruncate */</comment>
  <expr><name>unixSync</name></expr>,                        <comment type="block">/* xSync */</comment>
  <expr><name>unixFileSize</name></expr>,                    <comment type="block">/* xFileSize */</comment>
  <expr><name>unixLock</name></expr>,                        <comment type="block">/* xLock */</comment>
  <expr><name>unixUnlock</name></expr>,                      <comment type="block">/* xUnlock */</comment>
  <expr><name>unixCheckReservedLock</name></expr>,           <comment type="block">/* xCheckReservedLock */</comment>
  <expr><name>unixSectorSize</name></expr>,                  <comment type="block">/* xSectorSize */</comment>
}</block></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/****************************************************************************
**************************** unqlite_vfs methods ****************************
**
** This division contains the implementation of methods on the
** unqlite_vfs object.
*/</comment>
<comment type="block">/*
** Initialize the contents of the unixFile structure pointed to by pId.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fillInUnixFile</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,      <comment type="block">/* Pointer to vfs object */</comment>
  <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>,                  <comment type="block">/* Open file descriptor of file being opened */</comment>
  <parameter><decl><type><name>int</name></type> <name>dirfd</name></decl></parameter>,              <comment type="block">/* Directory file descriptor */</comment>
  <parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pId</name></decl></parameter>,      <comment type="block">/* Write to the unixFile structure here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,  <comment type="block">/* Name of the file being opened */</comment>
  <parameter><decl><type><name>int</name></type> <name>noLock</name></decl></parameter>,             <comment type="block">/* Omit locking if true */</comment>
  <parameter><decl><type><name>int</name></type> <name>isDelete</name></decl></parameter>            <comment type="block">/* Delete on close if true */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unqlite_io_methods</name> <modifier>*</modifier></type><name>pLockingStyle</name> <init>= <expr><operator>&amp;</operator><name>unixIoMethod</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>pId</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Parameter isDelete is only used on vxworks. Express this explicitly 
  ** here to prevent compiler warnings about unused parameters.
  */</comment>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>isDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>noLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>dirfd</name></name> <operator>=</operator> <name>dirfd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>fileFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <name>zFilename</name></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>findInodeInfo</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>pInode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If an error occured in findInodeInfo(), close the file descriptor
      ** immediately, before releasing the mutex. findInodeInfo() may fail
      ** in two scenarios:
      **
      **   (a) A call to fstat() failed.
      **   (b) A malloc failed.
      **
      ** Scenario (b) may only occur if the process is holding no other
      ** file descriptors open on the same file. If there were other file
      ** descriptors on this file, then no malloc would be required by
      ** findInodeInfo(). If this is the case, it is quite safe to close
      ** handle h - as it is guaranteed that no posix locks will be released
      ** by doing so.
      **
      ** If scenario (a) caused the error then things are not so safe. The
      ** implicit assumption here is that if fstat() fails, things are in
      ** such bad shape that dropping a lock or two doesn't matter much.
      */</comment>
      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>dirfd</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>dirfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* silent leak if fail, already in error */</comment>
    <if_stmt><if>if<condition>( <expr><name>h</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>=</operator> <name>pLockingStyle</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Open a file descriptor to the directory containing file zFilename.
** If successful, *pFd is set to the opened file descriptor and
** UNQLITE_OK is returned. If an error occurs, either UNQLITE_NOMEM
** or UNQLITE_CANTOPEN is returned and *pFd is set to an undefined
** value.
**
** If UNQLITE_OK is returned, the caller is responsible for closing
** the file descriptor *pFd using close().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>openDirectory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sxu32</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zDirname</name><index>[<expr><name>MAX_PATHNAME</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>Systrcpy</name><argument_list>(<argument><expr><name>zDirname</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zDirname</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zFilename</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name>n</name></expr>;</init> <condition><expr><name>ii</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zDirname</name><index>[<expr><name>ii</name></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr>;</condition> <incr><expr><name>ii</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <if_stmt><if>if<condition>( <expr><name>ii</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>zDirname</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>zDirname</name></expr></argument>, <argument><expr><name>O_RDONLY</name><operator>|</operator><name>O_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FD_CLOEXEC</name></cpp:ifdef>
      <expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>|</operator> <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pFd</name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>fd</name><operator>&gt;=</operator><literal type="number">0</literal></expr>?</condition><then><expr><name>UNQLITE_OK</name></expr></then><else>: <expr><name>UNQLITE_IOERR</name></expr></else></ternary> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Search for an unused file descriptor that was opened on the database 
** file (not a journal or master-journal file) identified by pathname
** zPath with UNQLITE_OPEN_XXX flags matching those passed as the second
** argument to this function.
**
** Such a file descriptor may exist if a database connection was closed
** but the associated file descriptor could not be closed because some
** other file descriptor open on the same file is holding a file-lock.
** Refer to comments in the unixClose() function and the lengthy comment
** describing "Posix Advisory Locking" at the start of this file for 
** further details. Also, ticket #4018.
**
** If a suitable file descriptor is found, then it is returned. If no
** such file descriptor is located, -1 is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>UnixUnusedFd</name> <modifier>*</modifier></type><name>findReusableFd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pUnused</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>                   <comment type="block">/* Results of stat() call */</comment>
  <comment type="block">/* A stat() call may fail for various reasons. If this happens, it is
  ** almost certain that an open() call on the same path will also fail.
  ** For this reason, if an error occurs in the stat() call here, it is
  ** ignored and -1 is returned. The caller will try to open a new file
  ** descriptor on the same path, fail, and return an error to SQLite.
  **
  ** Even if a subsequent open() call does succeed, the consequences of
  ** not searching for a resusable file descriptor are not dire.  */</comment>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>stat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name>inodeList</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pInode</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pInode</name><operator>-&gt;</operator><name>fileId</name><operator>.</operator><name>dev</name></name><operator>!=</operator><name><name>sStat</name><operator>.</operator><name>st_dev</name></name>
                     <operator>||</operator> <name><name>pInode</name><operator>-&gt;</operator><name>fileId</name><operator>.</operator><name>ino</name></name><operator>!=</operator><name><name>sStat</name><operator>.</operator><name>st_ino</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>pInode</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pInode</name><operator>-&gt;</operator><name>pUnused</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>flags</name></name><operator>!=</operator><name>flags</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <expr_stmt><expr><name>pUnused</name> <operator>=</operator> <operator>*</operator><name>pp</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pUnused</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pUnused</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pUnused</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** This function is called by unixOpen() to determine the unix permissions
** to create new files with. If no error occurs, then UNQLITE_OK is returned
** and a value suitable for passing as the third argument to open(2) is
** written to *pMode. If an IO error occurs, an SQLite error code is 
** returned and the value of *pMode is not modified.
**
** If the file being opened is a temporary file, it is always created with
** the octal permissions 0600 (read/writable by owner only). If the file
** is a database or master journal file, it is created with the permissions 
** mask UNQLITE_DEFAULT_FILE_PERMISSIONS.
**
** Finally, if the file being opened is a WAL or regular journal file, then 
** this function queries the file-system for the permissions on the 
** corresponding database file and sets *pMode to this value. Whenever 
** possible, WAL and journal files are created using the same permissions 
** as the associated database file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>findCreateFileMode</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,              <comment type="block">/* Path of file (possibly) being created */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                      <comment type="block">/* Flags passed as 4th argument to xOpen() */</comment>
  <parameter><decl><type><name>mode_t</name> <modifier>*</modifier></type><name>pMode</name></decl></parameter>                   <comment type="block">/* OUT: Permissions to open file with */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_TEMP_DB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pMode</name> <operator>=</operator> <literal type="number">0600</literal></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pMode</name> <operator>=</operator> <name>UNQLITE_DEFAULT_FILE_PERMISSIONS</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Open the file zPath.
** 
** Previously, the SQLite OS layer used three functions in place of this
** one:
**
**     unqliteOsOpenReadWrite();
**     unqliteOsOpenReadOnly();
**     unqliteOsOpenExclusive();
**
** These calls correspond to the following combinations of flags:
**
**     ReadWrite() -&gt;     (READWRITE | CREATE)
**     ReadOnly()  -&gt;     (READONLY) 
**     OpenExclusive() -&gt; (READWRITE | CREATE | EXCLUSIVE)
**
** The old OpenExclusive() accepted a boolean argument - "delFlag". If
** true, the file was configured to be automatically deleted when the
** file handle closed. To achieve the same effect using this new 
** interface, add the DELETEONCLOSE flag to those specified above for 
** OpenExclusive().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixOpen</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,           <comment type="block">/* The VFS for which this is the xOpen method */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,           <comment type="block">/* Pathname of file to be opened */</comment>
  <parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,         <comment type="block">/* The file descriptor to be filled in */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>           <comment type="block">/* Input flags to control the opening */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* File descriptor returned by open() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>dirfd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Directory file descriptor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>openFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Flags to pass to open() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>noLock</name></decl>;</decl_stmt>                    <comment type="block">/* True to omit locking primitives */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Function Return Code */</comment>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pUnused</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isExclusive</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_EXCLUSIVE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isDelete</name>     <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_TEMP_DB</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isCreate</name>     <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_CREATE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadonly</name>   <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_READONLY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadWrite</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_READWRITE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <comment type="block">/* If creating a master or main-file journal, this function will open
  ** a file-descriptor on the directory too. The first time unixSync()
  ** is called the directory file descriptor will be fsync()ed and close()d.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isOpenDirectory</name> <init>= <expr><name>isCreate</name></expr></init></decl> ;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name>zPath</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unixFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>pUnused</name> <operator>=</operator> <call><name>findReusableFd</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pUnused</name></expr> )</condition><block>{<block_content>
	  <expr_stmt><expr><name>fd</name> <operator>=</operator> <name><name>pUnused</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
	  <expr_stmt><expr><name>pUnused</name> <operator>=</operator> <call><name>unqlite_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pUnused</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pUnused</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUnused</name></name> <operator>=</operator> <name>pUnused</name></expr>;</expr_stmt>
  
  <comment type="block">/* Determine the value of the flags parameter passed to POSIX function
  ** open(). These must be calculated even if open() is not called, as
  ** they may be stored as part of the file handle and used by the 
  ** 'conch file' locking functions later on.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isReadonly</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_RDONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isReadWrite</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_RDWR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isCreate</name></expr> )</condition><block type="pseudo"><block_content>    <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_CREAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isExclusive</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <operator>(</operator><name>O_EXCL</name><operator>|</operator><name>O_NOFOLLOW</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <operator>(</operator><name>O_LARGEFILE</name><operator>|</operator><name>O_BINARY</name><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>mode_t</name></type> <name>openMode</name></decl>;</decl_stmt>              <comment type="block">/* Permissions to create file with */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>findCreateFileMode</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>openMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><name>openMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
	  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_IOERR</name></expr>;</expr_stmt>
      <goto>goto <name>open_finished</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pUnused</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUnused</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUnused</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>isDelete</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>isOpenDirectory</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>openDirectory</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* It is safe to close fd at this point, because it is guaranteed not
      ** to be open on a database file. If it were open on a database file,
      ** it would not be safe to close as this would release any locks held
      ** on the file by this process.  */</comment>
      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="block">/* silently leak if fail, already in error */</comment>
      <goto>goto <name>open_finished</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FD_CLOEXEC</name></cpp:ifdef>
  <expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>|</operator> <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>noLock</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if> 
  <decl_stmt><decl><type><name><name>struct</name> <name>statfs</name></name></type> <name>fsInfo</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fstatfs</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsInfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>lastErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>dirfd</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>dirfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* silently leak if fail, in error */</comment>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* silently leak if fail, in error */</comment>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>SyStrncmp</name><argument_list>(<argument><expr><literal type="string">"msdos"</literal></expr></argument>, <argument><expr><name><name>fsInfo</name><operator>.</operator><name>f_fstypename</name></name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>fsFlags</name> <operator>|=</operator> <name>UNQLITE_FSFLAGS_IS_MSDOS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fillInUnixFile</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>dirfd</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>noLock</name></expr></argument>, <argument><expr><name>isDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>open_finished</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>unqlite_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUnused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Delete the file at zPath. If the dirSync argument is true, fsync()
** the directory after deleting the file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixDelete</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>,     <comment type="block">/* VFS containing this as the xDelete method */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,        <comment type="block">/* Name of file to be deleted */</comment>
  <parameter><decl><type><name>int</name></type> <name>dirSync</name></decl></parameter>               <comment type="block">/* If true, fsync() directory after deleting file */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>( <expr><call><name>unlink</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>errno</name><operator>!=</operator><name>ENOENT</name></expr> )</condition><block>{<block_content>
	  <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_DISABLE_DIRSYNC</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>dirSync</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>openDirectory</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr> )</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_IOERR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_IOERR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Sleep for a little while.  Return the amount of time slept.
** The argument is the number of microseconds we want to sleep.
** The return value is the number of microseconds of sleep actually
** requested from the underlying operating system, a number which
** might be greater than or equal to the argument, but not less
** than the argument.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixSleep</name><parameter_list>(<parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>microseconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USLEEP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_USLEEP</name></expr></cpp:if>
  <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name>microseconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>microseconds</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>seconds</name> <init>= <expr><operator>(</operator><name>microseconds</name><operator>+</operator><literal type="number">999999</literal><operator>)</operator><operator>/</operator><literal type="number">1000000</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>seconds</name><operator>*</operator><literal type="number">1000000</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<comment type="block">/*
 * Export the current system time.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixCurrentTime</name><parameter_list>(<parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,<parameter><decl><type><name>Sytm</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pTm</name></expr> )</condition><block>{<block_content> <comment type="block">/* Yes, it can fail */</comment>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>,<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Test the existance of or access permissions of file zPath. The
** test performed depends on the value of flags:
**
**     UNQLITE_ACCESS_EXISTS: Return 1 if the file exists
**     UNQLITE_ACCESS_READWRITE: Return 1 if the file is read and writable.
**     UNQLITE_ACCESS_READONLY: Return 1 if the file is readable.
**
** Otherwise return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixAccess</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>,   <comment type="block">/* The VFS containing this xAccess method */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,      <comment type="block">/* Path of the file to examine */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,              <comment type="block">/* What do we want to learn about the zPath file? */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>            <comment type="block">/* Write result boolean here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>amode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>flags</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>UNQLITE_ACCESS_EXISTS</name></expr>:</case>
      <expr_stmt><expr><name>amode</name> <operator>=</operator> <name>F_OK</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>UNQLITE_ACCESS_READWRITE</name></expr>:</case>
      <expr_stmt><expr><name>amode</name> <operator>=</operator> <name>W_OK</name><operator>|</operator><name>R_OK</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>UNQLITE_ACCESS_READ</name></expr>:</case>
      <expr_stmt><expr><name>amode</name> <operator>=</operator> <name>R_OK</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
		<comment type="block">/* Can't happen */</comment>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <operator>(</operator><call><name>access</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>amode</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>==</operator><name>UNQLITE_ACCESS_EXISTS</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pResOut</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>stat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>.</operator><name>st_size</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Turn a relative pathname into a full pathname. The relative path
** is stored as a nul-terminated string in the buffer pointed to by
** zPath. 
**
** zOut points to a buffer of at least unqlite_vfs.mxPathname bytes 
** (in this case, MAX_PATHNAME bytes). The full-path is written to
** this buffer before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixFullPathname</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,            <comment type="block">/* Pointer to vfs object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,            <comment type="block">/* Possibly relative input path */</comment>
  <parameter><decl><type><name>int</name></type> <name>nOut</name></decl></parameter>,                     <comment type="block">/* Size of output buffer in bytes */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>                    <comment type="block">/* Output buffer */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
	  <expr_stmt><expr><call><name>Systrcpy</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nOut</name></expr></argument>,<argument><expr><name>zPath</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sxu32</name></type> <name>nCwd</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>getcwd</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>nOut</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nCwd</name> <operator>=</operator> <call><name>SyStrlen</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SyBufferFormat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>nCwd</name></expr>]</index></name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nOut</name><operator>-</operator><name>nCwd</name></expr></argument>,<argument><expr><literal type="string">"/%s"</literal></expr></argument>,<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Export the Unix Vfs.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <specifier>const</specifier> <name>unqlite_vfs</name> <modifier>*</modifier></type> <name>unqliteExportBuiltinVfs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unqlite_vfs</name></type> <name>sUnixvfs</name> <init>= <expr><block>{
		<expr><literal type="string">"Unix"</literal></expr>,              <comment type="block">/* Vfs name */</comment>
		<expr><literal type="number">1</literal></expr>,                   <comment type="block">/* Vfs structure version */</comment>
		<expr><sizeof>sizeof<argument_list>(<argument><expr><name>unixFile</name></expr></argument>)</argument_list></sizeof></expr>,    <comment type="block">/* szOsFile */</comment>
		<expr><name>MAX_PATHNAME</name></expr>,        <comment type="block">/* mxPathName */</comment>
		<expr><name>unixOpen</name></expr>,            <comment type="block">/* xOpen */</comment>
		<expr><name>unixDelete</name></expr>,          <comment type="block">/* xDelete */</comment>
		<expr><name>unixAccess</name></expr>,          <comment type="block">/* xAccess */</comment>
		<expr><name>unixFullPathname</name></expr>,    <comment type="block">/* xFullPathname */</comment>
		<expr><literal type="number">0</literal></expr>,                   <comment type="block">/* xTmp */</comment>
		<expr><name>unixSleep</name></expr>,           <comment type="block">/* xSleep */</comment>
		<expr><name>unixCurrentTime</name></expr>,     <comment type="block">/* xCurrentTime */</comment>
		<expr><literal type="number">0</literal></expr>,                   <comment type="block">/* xGetLastError */</comment>
	}</block></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>&amp;</operator><name>sUnixvfs</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __UNIXES__ */</comment>
</unit>
