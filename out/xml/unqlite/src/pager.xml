<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/src/pager.c"><comment type="block">/*
 * Symisc unQLite: An Embeddable NoSQL (Post Modern) Database Engine.
 * Copyright (C) 2012-2013, Symisc Systems http://unqlite.org/
 * Copyright (C) 2014, Yuras Shumovich &lt;shumovichy@gmail.com&gt;
 * Version 1.1.6
 * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES
 * please contact Symisc Systems via:
 *       legal@symisc.net
 *       licensing@symisc.net
 *       contact@symisc.net
 * or visit:
 *      http://unqlite.org/licensing.html
 */</comment>
 <comment type="block">/* $SymiscID: pager.c v1.1 Win7 2012-11-29 03:46 stable &lt;chm@symisc.net&gt; $ */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unqliteInt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** This file implements the pager and the transaction manager for UnQLite (Mostly inspired from the SQLite3 Source tree).
**
** The Pager.eState variable stores the current 'state' of a pager. A
** pager may be in any one of the seven states shown in the following
** state diagram.
**
**                            OPEN &lt;------+------+
**                              |         |      |
**                              V         |      |
**               +---------&gt; READER-------+      |
**               |              |                |
**               |              V                |
**               |&lt;-------WRITER_LOCKED---------&gt;| 
**               |              |                |  
**               |              V                |
**               |&lt;------WRITER_CACHEMOD--------&gt;|
**               |              |                |
**               |              V                |
**               |&lt;-------WRITER_DBMOD----------&gt;|
**               |              |                |
**               |              V                |
**               +&lt;------WRITER_FINISHED--------&gt;+
** 
**  OPEN:
**
**    The pager starts up in this state. Nothing is guaranteed in this
**    state - the file may or may not be locked and the database size is
**    unknown. The database may not be read or written.
**
**    * No read or write transaction is active.
**    * Any lock, or no lock at all, may be held on the database file.
**    * The dbSize and dbOrigSize variables may not be trusted.
**
**  READER:
**
**    In this state all the requirements for reading the database in 
**    rollback mode are met. Unless the pager is (or recently
**    was) in exclusive-locking mode, a user-level read transaction is 
**    open. The database size is known in this state.
** 
**    * A read transaction may be active (but a write-transaction cannot).
**    * A SHARED or greater lock is held on the database file.
**    * The dbSize variable may be trusted (even if a user-level read 
**      transaction is not active). The dbOrigSize variables
**      may not be trusted at this point.
**    * Even if a read-transaction is not open, it is guaranteed that 
**      there is no hot-journal in the file-system.
**
**  WRITER_LOCKED:
**
**    The pager moves to this state from READER when a write-transaction
**    is first opened on the database. In WRITER_LOCKED state, all locks 
**    required to start a write-transaction are held, but no actual 
**    modifications to the cache or database have taken place.
**
**    In rollback mode, a RESERVED or (if the transaction was opened with 
**    EXCLUSIVE flag) EXCLUSIVE lock is obtained on the database file when
**    moving to this state, but the journal file is not written to or opened 
**    to in this state. If the transaction is committed or rolled back while 
**    in WRITER_LOCKED state, all that is required is to unlock the database 
**    file.
**
**    * A write transaction is active.
**    * If the connection is open in rollback-mode, a RESERVED or greater 
**      lock is held on the database file.
**    * The dbSize and dbOrigSize variables are all valid.
**    * The contents of the pager cache have not been modified.
**    * The journal file may or may not be open.
**    * Nothing (not even the first header) has been written to the journal.
**
**  WRITER_CACHEMOD:
**
**    A pager moves from WRITER_LOCKED state to this state when a page is
**    first modified by the upper layer. In rollback mode the journal file
**    is opened (if it is not already open) and a header written to the
**    start of it. The database file on disk has not been modified.
**
**    * A write transaction is active.
**    * A RESERVED or greater lock is held on the database file.
**    * The journal file is open and the first header has been written 
**      to it, but the header has not been synced to disk.
**    * The contents of the page cache have been modified.
**
**  WRITER_DBMOD:
**
**    The pager transitions from WRITER_CACHEMOD into WRITER_DBMOD state
**    when it modifies the contents of the database file.
**
**    * A write transaction is active.
**    * An EXCLUSIVE or greater lock is held on the database file.
**    * The journal file is open and the first header has been written 
**      and synced to disk.
**    * The contents of the page cache have been modified (and possibly
**      written to disk).
**
**  WRITER_FINISHED:
**
**    A rollback-mode pager changes to WRITER_FINISHED state from WRITER_DBMOD
**    state after the entire transaction has been successfully written into the
**    database file. In this state the transaction may be committed simply
**    by finalizing the journal file. Once in WRITER_FINISHED state, it is 
**    not possible to modify the database further. At this point, the upper 
**    layer must either commit or rollback the transaction.
**
**    * A write transaction is active.
**    * An EXCLUSIVE or greater lock is held on the database file.
**    * All writing and syncing of journal and database data has finished.
**      If no error occured, all that remains is to finalize the journal to
**      commit the transaction. If an error did occur, the caller will need
**      to rollback the transaction. 
**  
**
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NULL</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NULL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_OPEN</name></cpp:macro>                  <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_READER</name></cpp:macro>                <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_WRITER_LOCKED</name></cpp:macro>         <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_WRITER_CACHEMOD</name></cpp:macro>       <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_WRITER_DBMOD</name></cpp:macro>          <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_WRITER_FINISHED</name></cpp:macro>       <cpp:value>5</cpp:value></cpp:define>
<comment type="block">/*
** Journal files begin with the following magic string.  The data
** was obtained from /dev/random.  It is used only as a sanity check.
**
** NOTE: These values must be different from the one used by SQLite3
** to avoid journal file collision.
**
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>aJournalMagic</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0xa6</literal></expr>, <expr><literal type="number">0xe8</literal></expr>, <expr><literal type="number">0xcd</literal></expr>, <expr><literal type="number">0x2b</literal></expr>, <expr><literal type="number">0x1c</literal></expr>, <expr><literal type="number">0x92</literal></expr>, <expr><literal type="number">0xdb</literal></expr>, <expr><literal type="number">0x9f</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/*
** The journal header size for this pager. This is usually the same 
** size as a single disk sector. See also setSectorSize().
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JOURNAL_HDR_SZ</name><parameter_list>(<parameter><type><name>pPager</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(pPager-&gt;iSectorSize)</cpp:value></cpp:define>
<comment type="block">/*
 * Database page handle.
 * Each raw disk page is represented in memory by an instance
 * of the following structure.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>Page</name></name></type> <name>Page</name>;</typedef>
<struct>struct <name>Page</name> <block>{
  <comment type="block">/* Must correspond to unqlite_page */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zData</name></decl>;</decl_stmt>           <comment type="block">/* Content of this page */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl>;</decl_stmt>                <comment type="block">/* Extra content */</comment>
  <decl_stmt><decl><type><name>pgno</name></type> <name>pgno</name></decl>;</decl_stmt>                      <comment type="block">/* Page number for this page */</comment>
  <comment type="block" format="doxygen">/**********************************************************************
  ** Elements above are public.  All that follows is private to pcache.c
  ** and should not be accessed by other modules.
  */</comment>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>                 <comment type="block">/* The pager this page is part of */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                     <comment type="block">/* Page flags defined below */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                      <comment type="block">/* Number of users of this page */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pPrev</name></decl>;</decl_stmt>    <comment type="block">/* A list of all pages */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pDirtyNext</name></decl>;</decl_stmt>             <comment type="block">/* Next element in list of dirty pages */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pDirtyPrev</name></decl>;</decl_stmt>             <comment type="block">/* Previous element in list of dirty pages */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNextCollide</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pPrevCollide</name></decl>;</decl_stmt> <comment type="block">/* Collission chain */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNextHot</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pPrevHot</name></decl>;</decl_stmt>    <comment type="block">/* Hot dirty pages chain */</comment>
}</block>;</struct>
<comment type="block">/* Bit values for Page.flags */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_DIRTY</name></cpp:macro>             <cpp:value>0x002</cpp:value></cpp:define>  <comment type="block">/* Page has changed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_NEED_SYNC</name></cpp:macro>         <cpp:value>0x004</cpp:value></cpp:define>  <comment type="block">/* fsync the rollback journal before
                                       ** writing this page to the database */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_DONT_WRITE</name></cpp:macro>        <cpp:value>0x008</cpp:value></cpp:define>  <comment type="block">/* Dont write page content to disk */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_NEED_READ</name></cpp:macro>         <cpp:value>0x010</cpp:value></cpp:define>  <comment type="block">/* Content is unread */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_IN_JOURNAL</name></cpp:macro>        <cpp:value>0x020</cpp:value></cpp:define>  <comment type="block">/* Page written to the journal */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_HOT_DIRTY</name></cpp:macro>         <cpp:value>0x040</cpp:value></cpp:define>  <comment type="block">/* Hot dirty page */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_DONT_MAKE_HOT</name></cpp:macro>     <cpp:value>0x080</cpp:value></cpp:define>  <comment type="block">/* Dont make this page Hot. In other words,
									   * do not link it to the hot dirty list.
									   */</comment>
<comment type="block">/*
 * Each active database pager is represented by an instance of
 * the following structure.
 */</comment>
<struct>struct <name>Pager</name>
<block>{
  <decl_stmt><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pAllocator</name></decl>;</decl_stmt>      <comment type="block">/* Memory backend */</comment>
  <decl_stmt><decl><type><name>unqlite</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                  <comment type="block">/* DB handle that own this instance */</comment>
  <decl_stmt><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl>;</decl_stmt>    <comment type="block">/* Underlying KV storage engine */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>               <comment type="block">/* Name of the database file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zJournal</name></decl>;</decl_stmt>                <comment type="block">/* Name of the journal file */</comment>
  <decl_stmt><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl>;</decl_stmt>             <comment type="block">/* Underlying virtual file system */</comment>
  <decl_stmt><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pfd</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pjfd</name></decl>;</decl_stmt>       <comment type="block">/* File descriptors for database and journal */</comment>
  <decl_stmt><decl><type><name>pgno</name></type> <name>dbSize</name></decl>;</decl_stmt>                   <comment type="block">/* Number of pages in the file */</comment>
  <decl_stmt><decl><type><name>pgno</name></type> <name>dbOrigSize</name></decl>;</decl_stmt>               <comment type="block">/* dbSize before the current change */</comment>
  <decl_stmt><decl><type><name>sxi64</name></type> <name>dbByteSize</name></decl>;</decl_stmt>              <comment type="block">/* Database size in bytes */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pMmap</name></decl>;</decl_stmt>                   <comment type="block">/* Read-only Memory view (mmap) of the whole file if requested (UNQLITE_OPEN_MMAP). */</comment>
  <decl_stmt><decl><type><name>sxu32</name></type> <name>nRec</name></decl>;</decl_stmt>                    <comment type="block">/* Number of pages written to the journal */</comment>
  <decl_stmt><decl><type><name>SyPRNGCtx</name></type> <name>sPrng</name></decl>;</decl_stmt>               <comment type="block">/* PRNG Context */</comment>
  <decl_stmt><decl><type><name>sxu32</name></type> <name>cksumInit</name></decl>;</decl_stmt>               <comment type="block">/* Quasi-random value added to every checksum */</comment>
  <decl_stmt><decl><type><name>sxu32</name></type> <name>iOpenFlags</name></decl>;</decl_stmt>              <comment type="block">/* Flag passed to unqlite_open() after processing */</comment>
  <decl_stmt><decl><type><name>sxi64</name></type> <name>iJournalOfft</name></decl>;</decl_stmt>            <comment type="block">/* Journal offset we are reading from */</comment>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xBusyHandler</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>   <comment type="block">/* Busy handler */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBusyHandlerArg</name></decl>;</decl_stmt>         <comment type="block">/* First arg to xBusyHandler() */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xPageUnpin</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>    <comment type="block">/* Page Unpin callback */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xPageReload</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>   <comment type="block">/* Page Reload callback */</comment>
  <decl_stmt><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>pVec</name></decl>;</decl_stmt>                  <comment type="block">/* Bitmap */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pHeader</name></decl>;</decl_stmt>                 <comment type="block">/* Page one of the database (Unqlite header) */</comment>
  <decl_stmt><decl><type><name>Sytm</name></type> <name>tmCreate</name></decl>;</decl_stmt>                 <comment type="block">/* Database creation time */</comment>
  <decl_stmt><decl><type><name>SyString</name></type> <name>sKv</name></decl>;</decl_stmt>                  <comment type="block">/* Underlying Key/Value storage engine name */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iState</name></decl>;</decl_stmt>                    <comment type="block">/* Pager state */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLock</name></decl>;</decl_stmt>                     <comment type="block">/* Lock state */</comment>
  <decl_stmt><decl><type><name>sxi32</name></type> <name>iFlags</name></decl>;</decl_stmt>                  <comment type="block">/* Control flags (see below) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>is_mem</name></decl>;</decl_stmt>                    <comment type="block">/* True for an in-memory database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>is_rdonly</name></decl>;</decl_stmt>                 <comment type="block">/* True for a read-only database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>no_jrnl</name></decl>;</decl_stmt>                   <comment type="block">/* TRUE to omit journaling */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPageSize</name></decl>;</decl_stmt>                 <comment type="block">/* Page size in bytes (default 4K) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSectorSize</name></decl>;</decl_stmt>               <comment type="block">/* Size of a single sector on disk */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zTmpPage</name></decl>;</decl_stmt>       <comment type="block">/* Temporary page */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pFirstDirty</name></decl>;</decl_stmt>             <comment type="block">/* First dirty pages */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pDirty</name></decl>;</decl_stmt>                  <comment type="block">/* Transient list of dirty pages */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pAll</name></decl>;</decl_stmt>                    <comment type="block">/* List of all pages */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pHotDirty</name></decl>;</decl_stmt>               <comment type="block">/* List of hot dirty pages */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pFirstHot</name></decl>;</decl_stmt>               <comment type="block">/* First hot dirty page */</comment>
  <decl_stmt><decl><type><name>sxu32</name></type> <name>nHot</name></decl>;</decl_stmt>                    <comment type="block">/* Total number of hot dirty pages */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>apHash</name></decl>;</decl_stmt>                 <comment type="block">/* Page table */</comment>
  <decl_stmt><decl><type><name>sxu32</name></type> <name>nSize</name></decl>;</decl_stmt>                   <comment type="block">/* apHash[] size: Must be a power of two  */</comment>
  <decl_stmt><decl><type><name>sxu32</name></type> <name>nPage</name></decl>;</decl_stmt>                   <comment type="block">/* Total number of page loaded in memory */</comment>
  <decl_stmt><decl><type><name>sxu32</name></type> <name>nCacheMax</name></decl>;</decl_stmt>               <comment type="block">/* Maximum page to cache*/</comment>
}</block>;</struct>
<comment type="block">/* Control flags */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_CTRL_COMMIT_ERR</name></cpp:macro>   <cpp:value>0x001</cpp:value></cpp:define> <comment type="block">/* Commit error */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_CTRL_DIRTY_COMMIT</name></cpp:macro> <cpp:value>0x002</cpp:value></cpp:define> <comment type="block">/* Dirty commit has been applied */</comment> 
<comment type="block">/*
** Read a 32-bit integer from the given file descriptor. 
** All values are stored on disk as big-endian.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ReadInt32</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>,<parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>,<parameter><decl><type><name>sxi64</name></type> <name>iOfft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsRead</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Read a 64-bit integer from the given file descriptor. 
** All values are stored on disk as big-endian.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ReadInt64</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>,<parameter><decl><type><name>sxu64</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>,<parameter><decl><type><name>sxi64</name></type> <name>iOfft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsRead</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyBigEndianUnpack64</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Write a 32-bit integer into the given file descriptor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>WriteInt32</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>iNum</name></decl></parameter>,<parameter><decl><type><name>sxi64</name></type> <name>iOfft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><name>iNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsWrite</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Write a 64-bit integer into the given file descriptor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>WriteInt64</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>,<parameter><decl><type><name>sxu64</name></type> <name>iNum</name></decl></parameter>,<parameter><decl><type><name>sxi64</name></type> <name>iOfft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><name>iNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsWrite</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** The maximum allowed sector size. 64KiB. If the xSectorsize() method 
** returns a value larger than this, then MAX_SECTOR_SIZE is used instead.
** This could conceivably cause corruption following a power failure on
** such a system. This is currently an undocumented limit.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SECTOR_SIZE</name></cpp:macro> <cpp:value>0x10000</cpp:value></cpp:define>
<comment type="block">/*
** Get the size of a single sector on disk.
** The sector size will be used used  to determine the size
** and alignment of journal header and within created journal files.
**
** The default sector size is set to 512.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>GetSectorSize</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>iSectorSize</name> <init>= <expr><name>UNQLITE_DEFAULT_SECTOR_SIZE</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pFd</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>iSectorSize</name> <operator>=</operator> <call><name>unqliteOsSectorSize</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iSectorSize</name> <operator>&lt;</operator> <literal type="number">32</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iSectorSize</name> <operator>=</operator> <literal type="number">512</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>iSectorSize</name> <operator>&gt;</operator> <name>MAX_SECTOR_SIZE</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>iSectorSize</name> <operator>=</operator> <name>MAX_SECTOR_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>iSectorSize</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Hash function for page number  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_HASH</name><parameter_list>(<parameter><type><name>PNUM</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(PNUM)</cpp:value></cpp:define>
<comment type="block">/*
 * Fetch a page from the cache.
 */</comment>
<function><type><specifier>static</specifier> <name>Page</name> <modifier>*</modifier></type> <name>pager_fetch_page</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>page_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>nPage</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother hashing */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Perform the lookup */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><call><name>PAGE_HASH</name><argument_list>(<argument><expr><name>page_num</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pEntry</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>pgno</name></name> <operator>==</operator> <name>page_num</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>pEntry</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry in the colission chain */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* No such page */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Allocate and initialize a new page.
 */</comment>
<function><type><specifier>static</specifier> <name>Page</name> <modifier>*</modifier></type> <name>pager_alloc_page</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>num_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>Page</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the structure */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Page data */</comment>
	<expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zData</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Fill in the structure */</comment>
	<expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pPager</name></name> <operator>=</operator> <name>pPager</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pgno</name></name> <operator>=</operator> <name>num_page</name></expr>;</expr_stmt>
	<return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Increment the reference count of a given page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>page_ref</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>SyMutexEnter</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>SyMutexLeave</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Release an in-memory page after its reference count reach zero.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_release_page</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_DIRTY</name><operator>)</operator></expr>)</condition><block>{<block_content>
		<comment type="block">/* Invoke the unpin callback if available */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>xPageUnpin</name></name> <operator>&amp;&amp;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pUserData</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name><name>pPager</name><operator>-&gt;</operator><name>xPageUnpin</name></name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Dirty page, it will be released later when a dirty commit
		 * or the final commit have been applied.
		 */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_LOCKED</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pager_unlink_page</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * Decrement the reference count of a given page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>page_unref</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>SyMutexEnter</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>nRef</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>SyMutexLeave</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nRef</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
		<decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_DIRTY</name><operator>)</operator></expr>  )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>pager_unlink_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Release the page */</comment>
			<expr_stmt><expr><call><name>pager_release_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_DONT_MAKE_HOT</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Do not add this page to the hot dirty list */</comment>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_HOT_DIRTY</name><operator>)</operator></expr> )</condition><block>{<block_content>
				<comment type="block">/* Add to the hot dirty list */</comment>
				<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPrevHot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstHot</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstHot</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pHotDirty</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
				</block_content>}</block></if><else>else<block>{<block_content>
					<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pNextHot</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pHotDirty</name></name></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pHotDirty</name></name></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pHotDirty</name><operator>-&gt;</operator><name>pPrevHot</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pHotDirty</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nHot</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PAGE_HOT_DIRTY</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Link a freshly created page to the list of active page.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_link_page</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nBucket</name></decl>;</decl_stmt>
	<comment type="block">/* Install in the corresponding bucket */</comment>
	<expr_stmt><expr><name>nBucket</name> <operator>=</operator> <call><name>PAGE_HASH</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>nBucket</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>nBucket</name></expr>]</index></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>nBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCollide</name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>nBucket</name></expr>]</index></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
	<comment type="block">/* Link to the list of active pages */</comment>
	<expr_stmt><expr><call><name>MACRO_LD_PUSH</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAll</name></name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nPage</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>nPage</name></name> <operator>&gt;=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nSize</name></name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator>  <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nPage</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Grow the hashtable */</comment>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nNewSize</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>nSize</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pEntry</name></decl>,<decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>Page</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>apNew</name></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>sxu32</name></type> <name>iBucket</name></decl>;</decl_stmt>
			<comment type="block">/* Zero the new table */</comment>
			<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>apNew</name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Rehash all entries */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pAll</name></name></expr>;</expr_stmt>
			<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
				<comment type="block">/* Loop one */</comment>
				<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCollide</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/* Install in the new bucket */</comment>
				<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <call><name>PAGE_HASH</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>nNewSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCollide</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
				<comment type="block">/* Point to the next entry */</comment>
				<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
			<comment type="block">/* Release the old table and reflect the change */</comment>
			<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nSize</name></name>  <operator>=</operator> <name>nNewSize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Unlink a page from the list of active pages.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_unlink_page</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pNextCollide</name><operator>-&gt;</operator><name>pPrevCollide</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pPrevCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pPrevCollide</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPrevCollide</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>nBucket</name> <init>= <expr><call><name>PAGE_HASH</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>nBucket</name></expr>]</index></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>MACRO_LD_REMOVE</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAll</name></name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nPage</name></name><operator>--</operator></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Update the content of a cached page.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_fill_page</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>iNum</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pContents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
	<comment type="block">/* Fetch the page from the catch */</comment>
	<expr_stmt><expr><name>pPage</name> <operator>=</operator> <call><name>pager_fetch_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>iNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Reflect the change */</comment>
	<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>pContents</name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Read the content of a page from disk.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_get_page_contents</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>noContent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>is_mem</name></name> <operator>||</operator> <name>noContent</name> <operator>||</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name> <operator>&gt;=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Do not bother reading, zero the page contents only */</comment>
		<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>iOpenFlags</name></name> <operator>&amp;</operator> <name>UNQLITE_OPEN_MMAP</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>pMmap</name></name> <comment type="block">/* Paranoid edition */</comment><operator>)</operator></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zMap</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>pMmap</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>zData</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>zMap</name><index>[<expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name> <operator>*</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Read content */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsRead</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name> <operator>*</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Add a page to the dirty list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pager_page_to_dirty_list</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_DIRTY</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Already set */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Mark the page as dirty */</comment>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PAGE_DIRTY</name><operator>|</operator><name>PAGE_NEED_SYNC</name><operator>|</operator><name>PAGE_IN_JOURNAL</name></expr>;</expr_stmt>
	<comment type="block">/* Link to the list */</comment>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pDirty</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDirty</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstDirty</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstDirty</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Merge sort.
 * The merge sort implementation is based on the one used by
 * the PH7 Embeddable PHP Engine (http://ph7.symisc.net/).
 */</comment>
<comment type="block">/*
** Inputs:
**   a:       A sorted, null-terminated linked list.  (May be null).
**   b:       A sorted, null-terminated linked list.  (May be null).
**   cmp:     A pointer to the comparison function.
**
** Return Value:
**   A pointer to the head of a sorted list containing the elements
**   of both a and b.
**
** Side effects:
**   The "next", "prev" pointers for elements in the lists a and b are
**   changed.
*/</comment>
<function><type><specifier>static</specifier> <name>Page</name> <modifier>*</modifier></type> <name>page_merge_dirty</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type> <name>result</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pTail</name></decl>;</decl_stmt>
    <comment type="block">/* Prevent compiler warning */</comment>
	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>pDirtyNext</name></name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>pDirtyPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>pTail</name> <operator>=</operator> <operator>&amp;</operator><name>result</name></expr>;</expr_stmt>
	<while>while<condition>( <expr><name>pA</name> <operator>&amp;&amp;</operator> <name>pB</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>pgno</name></name> <operator>&lt;</operator> <name><name>pB</name><operator>-&gt;</operator><name>pgno</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pB</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>pA</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pB</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <name><name>pTail</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name><name>result</name><operator>.</operator><name>pDirtyPrev</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Inputs:
**   Map:       Input hashmap
**   cmp:       A comparison function.
**
** Return Value:
**   Sorted hashmap.
**
** Side effects:
**   The "next" pointers for elements in list are changed.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_SORT_BUCKET</name></cpp:macro>  <cpp:value>32</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>Page</name> <modifier>*</modifier></type> <name>pager_get_dirty_pages</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name><name>a</name><index>[<expr><name>N_SORT_BUCKET</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstDirty</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother sorting, the list is already empty */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Point to the first inserted entry */</comment>
	<expr_stmt><expr><name>pIn</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pFirstDirty</name></name></expr>;</expr_stmt>
	<while>while<condition>( <expr><name>pIn</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pIn</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N_SORT_BUCKET</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>page_merge_dirty</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>N_SORT_BUCKET</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* To get here, there need to be 2^(N_SORT_BUCKET) elements in he input list.
			 * But that is impossible.
			 */</comment>
			<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>page_merge_dirty</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N_SORT_BUCKET</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>page_merge_dirty</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * See block comment above.
 */</comment>
<function><type><specifier>static</specifier> <name>Page</name> <modifier>*</modifier></type> <name>page_merge_hot</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type> <name>result</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pTail</name></decl>;</decl_stmt>
    <comment type="block">/* Prevent compiler warning */</comment>
	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>pNextHot</name></name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>pPrevHot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>pTail</name> <operator>=</operator> <operator>&amp;</operator><name>result</name></expr>;</expr_stmt>
	<while>while<condition>( <expr><name>pA</name> <operator>&amp;&amp;</operator> <name>pB</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>pgno</name></name> <operator>&lt;</operator> <name><name>pB</name><operator>-&gt;</operator><name>pgno</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pPrevHot</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pNextHot</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pPrevHot</name></name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pPrevHot</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pNextHot</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pB</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pPrevHot</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>pA</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pPrevHot</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pNextHot</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pB</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pPrevHot</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pNextHot</name></name> <operator>=</operator> <name>pTail</name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pPrevHot</name></name> <operator>=</operator> <name><name>pTail</name><operator>-&gt;</operator><name>pNextHot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name><name>result</name><operator>.</operator><name>pPrevHot</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Inputs:
**   Map:       Input hashmap
**   cmp:       A comparison function.
**
** Return Value:
**   Sorted hashmap.
**
** Side effects:
**   The "next" pointers for elements in list are changed.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_SORT_BUCKET</name></cpp:macro>  <cpp:value>32</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>Page</name> <modifier>*</modifier></type> <name>pager_get_hot_pages</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name><name>a</name><index>[<expr><name>N_SORT_BUCKET</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstHot</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother sorting, the list is already empty */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Point to the first inserted entry */</comment>
	<expr_stmt><expr><name>pIn</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pFirstHot</name></name></expr>;</expr_stmt>
	<while>while<condition>( <expr><name>pIn</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pIn</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrevHot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrevHot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N_SORT_BUCKET</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>page_merge_hot</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>N_SORT_BUCKET</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* To get here, there need to be 2^(N_SORT_BUCKET) elements in he input list.
			 * But that is impossible.
			 */</comment>
			<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>page_merge_hot</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N_SORT_BUCKET</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>page_merge_hot</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNextHot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** The format for the journal header is as follows:
** - 8 bytes: Magic identifying journal format.
** - 4 bytes: Number of records in journal.
** - 4 bytes: Random number used for page hash.
** - 8 bytes: Initial database page count.
** - 4 bytes: Sector size used by the process that wrote this journal.
** - 4 bytes: Database page size.
** 
** Followed by (JOURNAL_HDR_SZ - 28) bytes of unused space.
*/</comment>
<comment type="block">/*
** Open the journal file and extract its header information.
**
** If the header is read successfully, *pNRec is set to the number of
** page records following this header and *pDbSize is set to the size of the
** database before the transaction began, in pages. Also, pPager-&gt;cksumInit
** is set to the value read from the journal header. UNQLITE_OK is returned
** in this case.
**
** If the journal header file appears to be corrupted, UNQLITE_DONE is
** returned and *pNRec and *PDbSize are undefined.  If JOURNAL_HDR_SZ bytes
** cannot be read from the journal file an error code is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_read_journal_header</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,               <comment type="block">/* Pager object */</comment>
  <parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pNRec</name></decl></parameter>,                <comment type="block">/* OUT: Value read from the nRec field */</comment>
  <parameter><decl><type><name>pgno</name>  <modifier>*</modifier></type><name>pDbSize</name></decl></parameter>               <comment type="block">/* OUT: Value of original database size field */</comment>
)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>iPageSize</name></decl>,<decl><type ref="prev"/><name>iSectorSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zMagic</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>iHdrOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>iSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Offset to start reading from */</comment>
	<expr_stmt><expr><name>iHdrOfft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Get the size of the journal */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsFileSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_DONE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* If the journal file is too small, return UNQLITE_DONE. */</comment>
	<if_stmt><if>if<condition>( <expr><literal type="number">32</literal> <comment type="block">/* Minimum sector size */</comment><operator>&gt;</operator> <name>iSize</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_DONE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Make sure we are dealing with a valid journal */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsRead</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>zMagic</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zMagic</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>iHdrOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>SyMemcmp</name><argument_list>(<argument><expr><name>zMagic</name></expr></argument>,<argument><expr><name>aJournalMagic</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zMagic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_DONE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iHdrOfft</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>zMagic</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	 <comment type="block">/* Read the first three 32-bit fields of the journal header: The nRec
      ** field, the checksum-initializer and the database size at the start
      ** of the transaction. Return an error code if anything goes wrong.
      */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ReadInt32</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>pNRec</name></expr></argument>,<argument><expr><name>iHdrOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iHdrOfft</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ReadInt32</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>cksumInit</name></name></expr></argument>,<argument><expr><name>iHdrOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iHdrOfft</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ReadInt64</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>pDbSize</name></expr></argument>,<argument><expr><name>iHdrOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iHdrOfft</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Read the page-size and sector-size journal header fields. */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ReadInt32</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iSectorSize</name></expr></argument>,<argument><expr><name>iHdrOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iHdrOfft</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ReadInt32</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iPageSize</name></expr></argument>,<argument><expr><name>iHdrOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Check that the values read from the page-size and sector-size fields
    ** are within range. To be 'in range', both values need to be a power
    ** of two greater than or equal to 512 or 32, and not greater than their 
    ** respective compile time maximum limits.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>iPageSize</name> <argument_list type="generic">&lt; <argument><expr><name>UNQLITE_MIN_PAGE_SIZE</name> <operator>||</operator> <name><name>iSectorSize</name><argument_list type="generic">&lt;<argument><expr><literal type="number">32</literal>
     <operator>||</operator> <name>iPageSize</name></expr></argument> &gt;</argument_list></name> <name>UNQLITE_MAX_PAGE_SIZE</name> <operator>||</operator> <name>iSectorSize</name></expr></argument>&gt;</argument_list></name><name>MAX_SECTOR_SIZE</name>
     <operator>||</operator> <operator>(</operator><operator>(</operator><name>iPageSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name>iPageSize</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>    <operator>||</operator> <operator>(</operator><operator>(</operator><name>iSectorSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name>iSectorSize</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> 
    )</condition><block>{<block_content>
      <comment type="block">/* If the either the page-size or sector-size in the journal-header is 
      ** invalid, then the process that wrote the journal-header must have 
      ** crashed before the header was synced. In this case stop reading 
      ** the journal file here.
      */</comment>
      <return>return <expr><name>UNQLITE_DONE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Update the assumed sector-size to match the value used by 
    ** the process that created this journal. If this journal was
    ** created by a process other than this one, then this routine
    ** is being called from within pager_playback(). The local value
    ** of Pager.sectorSize is restored at the end of that routine.
    */</comment>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name> <operator>=</operator> <name>iSectorSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name> <operator>=</operator> <name>iPageSize</name></expr>;</expr_stmt>
	<comment type="block">/* Ready to rollback */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iJournalOfft</name></name> <operator>=</operator> <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Write the journal header in the given memory buffer.
 * The given buffer is big enough to hold the whole header.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_write_journal_header</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zPtr</name> <init>= <expr><name>zBuf</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* 8 bytes magic number */</comment>
	<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>,<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<comment type="block">/* 4 bytes: Number of records in journal. */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<comment type="block">/* 4 bytes: Random number used to compute page checksum. */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>cksumInit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<comment type="block">/* 8 bytes: Initial database page count. */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* 4 bytes: Sector size used by the process that wrote this journal. */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zPtr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<comment type="block">/* 4 bytes: Database page size. */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Parameter aData must point to a buffer of pPager-&gt;pageSize bytes
** of data. Compute and return a checksum based ont the contents of the 
** page of data and the current value of pPager-&gt;cksumInit.
**
** This is not a real checksum. It is really just the sum of the 
** random initial value (pPager-&gt;cksumInit) and every 200th byte
** of the page data, starting with byte offset (pPager-&gt;pageSize%200).
** Each byte is interpreted as an 8-bit unsigned integer.
**
** Changing the formula used to compute this checksum results in an
** incompatible journal file format.
**
** If journal corruption occurs due to a power failure, the most likely 
** scenario is that one end or the other of the record will be changed. 
** It is much less likely that the two ends of the journal record will be
** correct and the middle be corrupt.  Thus, this "checksum" scheme,
** though fast and simple, catches the mostly likely kind of corruption.
*/</comment>
<function><type><specifier>static</specifier> <name>sxu32</name></type> <name>pager_cksum</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sxu32</name></type> <name>cksum</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>cksumInit</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Checksum value to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name><operator>-</operator><literal type="number">200</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Loop counter */</comment>
  <while>while<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cksum</name> <operator>+=</operator> <name><name>zData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>-=</operator> <literal type="number">200</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>cksum</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Read a single page from the journal file opened on file descriptor
** jfd. Playback this one page. Update the offset to read from.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_play_back_one_page</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>sxi64</name> <modifier>*</modifier></type><name>pOfft</name></decl></parameter>,<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zTmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zData</name> <init>= <expr><name>zTmp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>iOfft</name></decl>;</decl_stmt> <comment type="block">/* Offset to read from */</comment>
	<decl_stmt><decl><type><name>pgno</name></type> <name>iNum</name></decl>;</decl_stmt>   <comment type="block">/* Pager number */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>ckSum</name></decl>;</decl_stmt> <comment type="block">/* Sanity check */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Offset to start reading from */</comment>
	<expr_stmt><expr><name>iOfft</name> <operator>=</operator> <operator>*</operator><name>pOfft</name></expr>;</expr_stmt>
	<comment type="block">/* Database page number */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ReadInt64</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iNum</name></expr></argument>,<argument><expr><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content> <return>return <expr><name>rc</name></expr>;</return> </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iOfft</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<comment type="block">/* Page data */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsRead</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>zData</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>,<argument><expr><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content> <return>return <expr><name>rc</name></expr>;</return> </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iOfft</name> <operator>+=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr>;</expr_stmt>
	<comment type="block">/* Page cksum */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ReadInt32</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ckSum</name></expr></argument>,<argument><expr><name>iOfft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content> <return>return <expr><name>rc</name></expr>;</return> </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iOfft</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<comment type="block">/* Synchronize pointers */</comment>
	<expr_stmt><expr><operator>*</operator><name>pOfft</name> <operator>=</operator> <name>iOfft</name></expr>;</expr_stmt>
	<comment type="block">/* Make sure we are dealing with a valid page */</comment>
	<if_stmt><if>if<condition>( <expr><name>ckSum</name> <operator>!=</operator> <call><name>pager_cksum</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>zData</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* Ignore that page */</comment>
		<return>return <expr><name>SXERR_IGNORE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>iNum</name> <operator>&gt;=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Ignore that page */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* playback */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name>zData</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>,<argument><expr><name>iNum</name> <operator>*</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Flush the cache */</comment>
		<expr_stmt><expr><call><name>pager_fill_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>iNum</name></expr></argument>,<argument><expr><name>zData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Playback the journal and thus restore the database file to
** the state it was in before we started making changes.  
**
** The journal file format is as follows: 
**
**  (1)  8 byte prefix.  A copy of aJournalMagic[].
**  (2)  4 byte big-endian integer which is the number of valid page records
**       in the journal. 
**  (3)  4 byte big-endian integer which is the initial value for the 
**       sanity checksum.
**  (4)  8 byte integer which is the number of pages to truncate the
**       database to during a rollback.
**  (5)  4 byte big-endian integer which is the sector size.  The header
**       is this many bytes in size.
**  (6)  4 byte big-endian integer which is the page size.
**  (7)  zero padding out to the next sector size.
**  (8)  Zero or more pages instances, each as follows:
**        +  4 byte page number.
**        +  pPager-&gt;pageSize bytes of data.
**        +  4 byte checksum
**
** When we speak of the journal header, we mean the first 7 items above.
** Each entry in the journal is an instance of the 8th item.
**
** Call the value from the second bullet "nRec".  nRec is the number of
** valid page entries in the journal.  In most cases, you can compute the
** value of nRec from the size of the journal file.  But if a power
** failure occurred while the journal was being written, it could be the
** case that the size of the journal file had already been increased but
** the extra entries had not yet made it safely to disk.  In such a case,
** the value of nRec computed from the file size would be too large.  For
** that reason, we always use the nRec value in the header.
**
** If the file opened as the journal file is not a well-formed
** journal file then all pages up to the first corrupted page are rolled
** back (or no pages if the journal header is corrupted). The journal file
** is then deleted and SQLITE_OK returned, just as if no corruption had
** been encountered.
**
** If an I/O or malloc() error occurs, the journal-file is not deleted
** and an error code is returned.
**
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_playback</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zTmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc warning */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>,<decl><type ref="prev"/><name>nRec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>iOfft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Read the journal header*/</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_read_journal_header</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nRec</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_DONE</name></expr> )</condition><block>{<block_content>
			<goto>goto <name>end_playback</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"IO error while reading journal file '%s' header"</literal></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Truncate the database back to its original size */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsTruncate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name> <operator>*</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"IO error while truncating database file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Allocate a temporary page */</comment>
	<expr_stmt><expr><name>zTmp</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>zTmp</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zTmp</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Copy original pages out of the journal and back into the 
    ** database file and/or page cache.
    */</comment>
	<expr_stmt><expr><name>iOfft</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iJournalOfft</name></name></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nRec</name></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_play_back_one_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iOfft</name></expr></argument>,<argument><expr><name>zTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXERR_IGNORE</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Page playback error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>end_playback</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
<label><name>end_playback</name>:</label>
	<comment type="block">/* Release the temp page */</comment>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Sync the database file */</comment>
		<expr_stmt><expr><call><name>unqliteOsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name>UNQLITE_SYNC_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_DONE</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Return to the caller */</comment>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Unlock the database file to level eLock, which must be either NO_LOCK
** or SHARED_LOCK. Regardless of whether or not the call to xUnlock()
** succeeds, set the Pager.iLock variable to match the (attempted) new lock.
**
** Except, if Pager.iLock is set to NO_LOCK when this function is
** called, do not modify it. See the comment above the #define of 
** NO_LOCK for an explanation of this.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_unlock_db</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iLock</name></name> <operator>!=</operator> <name>NO_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsUnlock</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iLock</name></name> <operator>=</operator> <name>eLock</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Lock the database file to level eLock, which must be either SHARED_LOCK,
** RESERVED_LOCK or EXCLUSIVE_LOCK. If the caller is successful, set the
** Pager.eLock variable to the new locking state. 
**
** Except, if Pager.eLock is set to NO_LOCK when this function is 
** called, do not modify it unless the new locking state is EXCLUSIVE_LOCK. 
** See the comment above the #define of NO_LOCK for an explanation 
** of this.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_lock_db</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iLock</name></name> <operator>&lt;</operator> <name>eLock</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iLock</name></name> <operator>==</operator> <name>NO_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsLock</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iLock</name></name> <operator>=</operator> <name>eLock</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
			<argument><expr><ternary><condition><expr><name>rc</name> <operator>==</operator> <name>UNQLITE_BUSY</name></expr> ?</condition><then> <expr><literal type="string">"Another process or thread hold the requested lock"</literal></expr> </then><else>: <expr><literal type="string">"Error while requesting database lock"</literal></expr></else></ternary></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Try to obtain a lock of type locktype on the database file. If
** a similar or greater lock is already held, this function is a no-op
** (returning UNQLITE_OK immediately).
**
** Otherwise, attempt to obtain the lock using unqliteOsLock(). Invoke 
** the busy callback if the lock is currently not available. Repeat 
** until the busy callback returns false or until the attempt to 
** obtain the lock succeeds.
**
** Return UNQLITE_OK on success and an error code if we cannot obtain
** the lock. If the lock is obtained successfully, set the Pager.state 
** variable to locktype before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_wait_on_lock</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locktype</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                              <comment type="block">/* Return code */</comment>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_lock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>UNQLITE_BUSY</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>xBusyHandler</name></name> <operator>&amp;&amp;</operator> <call><name><name>pPager</name><operator>-&gt;</operator><name>xBusyHandler</name></name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBusyHandlerArg</name></name></expr></argument>)</argument_list></call></expr> )</condition>;</do>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** This function is called after transitioning from PAGER_OPEN to
** PAGER_SHARED state. It tests if there is a hot journal present in
** the file-system for the given pager. A hot journal is one that 
** needs to be played back. According to this function, a hot-journal
** file exists if the following criteria are met:
**
**   * The journal file exists in the file system, and
**   * No process holds a RESERVED or greater lock on the database file, and
**   * The database file itself is greater than 0 bytes in size, and
**   * The first byte of the journal file exists and is not 0x00.
**
** If the current size of the database file is 0 but a journal file
** exists, that is probably an old journal left over from a prior
** database with the same name. In this case the journal file is
** just deleted using OsDelete, *pExists is set to 0 and UNQLITE_OK
** is returned.
**
** If a hot-journal file is found to exist, *pExists is set to 1 and 
** UNQLITE_OK returned. If no hot-journal file is present, *pExists is
** set to 0 and UNQLITE_OK returned. If an IO error occurs while trying
** to determine whether or not a hot-journal file exists, the IO error
** code is returned and the value of *pExists is undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_has_hot_journal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pExists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>exists</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* True if a journal file is present */</comment>

  <expr_stmt><expr><operator>*</operator><name>pExists</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><name>UNQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>UNQLITE_OK</name> <operator>&amp;&amp;</operator> <name>exists</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>locked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* True if some process holds a RESERVED lock */</comment>

    <comment type="block">/* Race condition here:  Another process might have been holding the
    ** the RESERVED lock and have a journal open at the unqliteOsAccess() 
    ** call above, but then delete the journal and drop the lock before
    ** we get to the following unqliteOsCheckReservedLock() call.  If that
    ** is the case, this routine might think there is a hot journal when
    ** in fact there is none.  This results in a false-positive which will
    ** be dealt with by the playback routine.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsCheckReservedLock</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>UNQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>locked</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sxi64</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Size of db file in bytes */</comment>
 
      <comment type="block">/* Check the size of the database file. If it consists of 0 pages,
      ** then delete the journal file. See the header comment above for 
      ** the reasoning here.  Delete the obsolete journal file under
      ** a RESERVED lock to avoid race conditions.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsFileSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>pager_lock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>RESERVED_LOCK</name></expr></argument>)</argument_list></call><operator>==</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>unqliteOsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pager_unlock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* The journal file exists and no other connection has a reserved
          ** or greater lock on the database file. */</comment>
			<expr_stmt><expr><operator>*</operator><name>pExists</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Rollback a journal file. (See block-comment above).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_journal_rollback</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>check_hot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>check_hot</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>iExists</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc warning */</comment>
		<comment type="block">/* Check if the journal file exists */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_has_hot_journal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr>  )</condition><block>{<block_content>
			<comment type="block">/* IO error */</comment>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name>iExists</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Journal file does not exists */</comment>
			<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>is_rdonly</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
			<argument><expr><literal type="string">"Cannot rollback journal file '%s' due to a read-only database handle"</literal></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_READ_ONLY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Get an EXCLUSIVE lock on the database file. At this point it is
      ** important that a RESERVED lock is not obtained on the way to the
      ** EXCLUSIVE lock. If it were, another process might open the
      ** database file, detect the RESERVED lock, and conclude that the
      ** database is safe to read while this process is still rolling the 
      ** hot-journal back.
      ** 
      ** Because the intermediate RESERVED lock is not requested, any
      ** other process attempting to access the database file will get to 
      ** this point in the code and fail to obtain its own EXCLUSIVE lock 
      ** on the database file.
      **
      ** Unless the pager is in locking_mode=exclusive mode, the lock is
      ** downgraded to SHARED_LOCK before this function returns.
      */</comment>
	<comment type="block">/* Open the journal file */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>UNQLITE_OPEN_READWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"IO error while opening journal file: '%s'"</literal></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_lock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Cannot acquire an exclusive lock on the database while journal rollback"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Sync the journal file */</comment>
	<expr_stmt><expr><call><name>unqliteOsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>UNQLITE_SYNC_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Finally rollback the database */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_playback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Switch back to shared lock */</comment>
	<expr_stmt><expr><call><name>pager_unlock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fail</name>:</label>
	<comment type="block">/* Close the journal handle */</comment>
	<expr_stmt><expr><call><name>unqliteOsCloseFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Delete the journal file */</comment>
		<expr_stmt><expr><call><name>unqliteOsDelete</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>,<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Write the unqlite header (First page). (Big-Endian)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_write_db_header</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pHeader</name><operator>-&gt;</operator><name>zData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nDos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nLen</name></decl>;</decl_stmt>
	<comment type="block">/* Database signature */</comment>
	<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>UNQLITE_DB_SIG</name></expr></argument>,<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UNQLITE_DB_SIG</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UNQLITE_DB_SIG</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* Database magic number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name>UNQLITE_DB_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* 4 byte magic number */</comment>
	<comment type="block">/* Database creation time */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>tmCreate</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Sytm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>tmCreate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* DOS time format (4 bytes) */</comment>
	<expr_stmt><expr><call><name>SyTimeFormatToDos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>tmCreate</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nDos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name>nDos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* 4 byte DOS time */</comment>
	<comment type="block">/* Sector size */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* 4 byte sector size */</comment>
	<comment type="block">/* Page size */</comment>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* 4 byte page size */</comment>
	<comment type="block">/* Key value storage engine */</comment>
	<expr_stmt><expr><name>nLen</name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><call><name>SyStrlen</name><argument_list>(<argument><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 2 byte storage engine name */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zRaw</name></expr></argument>,<argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <name>nLen</name></expr>;</expr_stmt>
	<comment type="block">/* All rest are meta-data available to the host application */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Read the unqlite header (first page). (Big-Endian)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_extract_header</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRaw</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zRaw</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nDos</name></decl>,<decl><type ref="prev"/><name>iMagic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zKv</name></decl>;</decl_stmt>
	<comment type="block">/* Database signature */</comment>
	<if_stmt><if>if<condition>( <expr><call><name>SyMemcmp</name><argument_list>(<argument><expr><name>UNQLITE_DB_SIG</name></expr></argument>,<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UNQLITE_DB_SIG</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Corrupt database */</comment>
		<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UNQLITE_DB_SIG</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* Database magic number */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iMagic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* 4 byte magic number */</comment>
	<if_stmt><if>if<condition>( <expr><name>iMagic</name> <operator>!=</operator> <name>UNQLITE_DB_MAGIC</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Corrupt database */</comment>
		<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Database creation time */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nDos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* 4 byte DOS time format */</comment>
	<expr_stmt><expr><call><name>SyDosTimeFormat</name><argument_list>(<argument><expr><name>nDos</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>tmCreate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Sector size */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* 4 byte sector size */</comment>
	<comment type="block">/* Page size */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack32</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* 4 byte page size */</comment>
	<comment type="block">/* Check that the values read from the page-size and sector-size fields
    ** are within range. To be 'in range', both values need to be a power
    ** of two greater than or equal to 512 or 32, and not greater than their 
    ** respective compile time maximum limits.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name><operator>&lt;</operator><name>UNQLITE_MIN_PAGE_SIZE</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name><operator>&lt;</operator><literal type="number">32</literal>
     <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name><operator>&gt;</operator><name>UNQLITE_MAX_PAGE_SIZE</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name><operator>&gt;</operator><name>MAX_SECTOR_SIZE</name>
     <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name><operator>&lt;</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>    <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> 
    )</condition><block>{<block_content>
      <return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Key value storage engine */</comment>
	<expr_stmt><expr><call><name>SyBigEndianUnpack16</name><argument_list>(<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 2 byte storage engine length */</comment>
	<expr_stmt><expr><name>zRaw</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&gt;</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name>zRaw</name><operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <operator>(</operator><name>sxu16</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name>zRaw</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zKv</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendDup</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>zRaw</name></expr></argument>,<argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>zKv</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>sKv</name></name></expr></argument>,<argument><expr><name>zKv</name></expr></argument>,<argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Read the database header.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_read_db_header</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zRaw</name><index>[<expr><name>UNQLITE_MIN_PAGE_SIZE</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Minimum page size */</comment>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Size of db file in bytes */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Get the file size first */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsFileSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbByteSize</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pKv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgno</name></type> <name>nPage</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>n</name> <operator>&lt;</operator> <name>UNQLITE_MIN_PAGE_SIZE</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* A valid unqlite database must be at least 512 bytes long */</comment>
			<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Malformed database image"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>UNQLITE_CORRUPT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Read the database header */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsRead</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zRaw</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"IO error while reading database header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Extract the header */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_extract_header</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>zRaw</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zRaw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><ternary><condition><expr><name>rc</name> <operator>==</operator> <name>UNQLITE_NOMEM</name></expr> ?</condition><then> <expr><literal type="string">"Unqlite is running out of memory"</literal></expr> </then><else>: <expr><literal type="string">"Malformed database image"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Update pager state  */</comment>
		<expr_stmt><expr><name>nPage</name> <operator>=</operator> <operator>(</operator><name>pgno</name><operator>)</operator><operator>(</operator><name>n</name> <operator>/</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nPage</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nPage</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <name>nPage</name></expr>;</expr_stmt>
		<comment type="block">/* Laod the target Key/Value storage engine */</comment>
		<expr_stmt><expr><name>pKv</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>sKv</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pMethods</name> <operator>=</operator> <call><name>unqliteFindKVStore</name><argument_list>(<argument><expr><name><name>pKv</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>,<argument><expr><name><name>pKv</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pMethods</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"No such Key/Value storage engine '%z'"</literal></expr></argument>,<argument><expr><name>pKv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>UNQLITE_NOTIMPLEMENTED</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Install the new KV storage engine */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlitePagerRegisterKvEngine</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Set a default page and sector size */</comment>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name> <operator>=</operator> <call><name>GetSectorSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name> <operator>=</operator> <call><name>unqliteGetPageSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>sKv</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,<argument><expr><call><name>SyStrlen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Allocate a temporary page size */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>zTmpPage</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>zTmpPage</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zTmpPage</name></name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Write the database header.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_create_header</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Allocate a new page */</comment>
	<expr_stmt><expr><name>pHeader</name> <operator>=</operator> <call><name>pager_alloc_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pHeader</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pHeader</name></name> <operator>=</operator> <name>pHeader</name></expr>;</expr_stmt>
	<comment type="block">/* Link the page */</comment>
	<expr_stmt><expr><call><name>pager_link_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Add to the dirty list */</comment>
	<expr_stmt><expr><call><name>pager_page_to_dirty_list</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Write the database header */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_write_db_header</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** This function is called to obtain a shared lock on the database file.
** It is illegal to call unqlitePagerAcquire() until after this function
** has been successfully called. If a shared-lock is already held when
** this function is called, it is a no-op.
**
** The following operations are also performed by this function.
**
**   1) If the pager is currently in PAGER_OPEN state (no lock held
**      on the database file), then an attempt is made to obtain a
**      SHARED lock on the database file. Immediately after obtaining
**      the SHARED lock, the file-system is checked for a hot-journal,
**      which is played back if present. 
**
** If everything is successful, UNQLITE_OK is returned. If an IO error 
** occurs while locking the database, checking for a hot-journal file or 
** rolling back a journal file, the IO error code is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_shared_lock</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>==</operator> <name>PAGER_OPEN</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>
		<comment type="block">/* Open the target database */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iOpenFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
				<argument><expr><literal type="string">"IO error while opening the target database file: %s"</literal></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Try to obtain a shared lock */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_wait_on_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iLock</name></name> <operator>&lt;=</operator> <name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Rollback any hot journal */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_journal_rollback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<return>return <expr><name>rc</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Read the database header */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_read_db_header</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iOpenFlags</name></name> <operator>&amp;</operator> <name>UNQLITE_OPEN_MMAP</name></expr> )</condition><block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>jx9_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><call><name>jx9ExportBuiltinVfs</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<comment type="block">/* Obtain a read-only memory view of the whole file */</comment>
					<if_stmt><if>if<condition>( <expr><name>pVfs</name> <operator>&amp;&amp;</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>xMmap</name></name></expr> )</condition><block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type> <name>vr</name></decl>;</decl_stmt>
						<expr_stmt><expr><name>vr</name> <operator>=</operator> <call><name><name>pVfs</name><operator>-&gt;</operator><name>xMmap</name></name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pMmap</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbByteSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if<condition>( <expr><name>vr</name> <operator>!=</operator> <name>JX9_OK</name></expr> )</condition><block>{<block_content>
							<comment type="block">/* Generate a warning */</comment>
							<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Cannot obtain a read-only memory view of the target database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iOpenFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>UNQLITE_OPEN_MMAP</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if><else>else<block>{<block_content>
						<comment type="block">/* Generate a warning */</comment>
						<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Cannot obtain a read-only memory view of the target database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iOpenFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>UNQLITE_OPEN_MMAP</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Update the pager state */</comment>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>PAGER_READER</name></expr>;</expr_stmt>
			<comment type="block">/* Invoke the xOpen methods if available */</comment>
			<expr_stmt><expr><name>pMethods</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pMethods</name><operator>-&gt;</operator><name>xOpen</name></name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMethods</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,
						<argument><expr><literal type="string">"xOpen() method of the underlying KV engine '%z' failed"</literal></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>sKv</name></name></expr></argument>
						)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pager_unlock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>PAGER_OPEN</name></expr>;</expr_stmt>
					<return>return <expr><name>rc</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_BUSY</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Another process or thread have a reserved or exclusive lock on this database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>		
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Begin a write-transaction on the specified pager object. If a 
** write-transaction has already been opened, this function is a no-op.
*/</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqlitePagerBegin</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Obtain a shared lock on the database first */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_shared_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>&gt;=</operator> <name>PAGER_WRITER_LOCKED</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>is_rdonly</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Read-only database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Read only database */</comment>
		<return>return <expr><name>UNQLITE_READ_ONLY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Obtain a reserved lock on the database */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_wait_on_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>RESERVED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Create the bitvec */</comment>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name> <operator>=</operator> <call><name>unqliteBitvecCreate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_NOMEM</name></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Change to the WRITER_LOCK state */</comment>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>PAGER_WRITER_LOCKED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iJournalOfft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Write the  database header */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_create_header</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<goto>goto <name>fail</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_BUSY</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Another process or thread have a reserved lock on this database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
<label><name>fail</name>:</label>
	<comment type="block">/* Downgrade to shared lock */</comment>
	<expr_stmt><expr><call><name>pager_unlock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** This function is called at the start of every write transaction.
** There must already be a RESERVED or EXCLUSIVE lock on the database 
** file when this routine is called.
**
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteOpenJournal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>is_mem</name></name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>no_jrnl</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Journaling is omitted for this database */</comment>
		<goto>goto <name>finish</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>&gt;=</operator> <name>PAGER_WRITER_CACHEMOD</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Already opened */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Delete any previously journal with the same name */</comment>
	<expr_stmt><expr><call><name>unqliteOsDelete</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Open the journal file */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>UNQLITE_OPEN_CREATE</name><operator>|</operator><name>UNQLITE_OPEN_READWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"IO error while opening journal file: %s"</literal></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Write the journal header */</comment>
	<expr_stmt><expr><name>zHeader</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>zHeader</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pager_write_journal_header</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>zHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Perform the disk write */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>zHeader</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Offset to start writing from */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iJournalOfft</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iSectorSize</name></name></expr>;</expr_stmt>
	<comment type="block">/* All done, journal will be synced later */</comment>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name>zHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>finish</name>:</label>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>PAGER_WRITER_CACHEMOD</name></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<label><name>fail</name>:</label>
	<comment type="block">/* Unlink the journal file if something goes wrong */</comment>
	<expr_stmt><expr><call><name>unqliteOsCloseFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unqliteOsDelete</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Sync the journal. In other words, make sure all the pages that have
** been written to the journal have actually reached the surface of the
** disk and can be restored in the event of a hot-journal rollback.
*
* This routine try also to obtain an exlusive lock on the database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteFinalizeJournal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRetry</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>close_jrnl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>pRetry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Grab the exclusive lock first */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_lock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Retry the excusive lock process */</comment>
		<expr_stmt><expr><operator>*</operator><name>pRetry</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>no_jrnl</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Journaling is omitted, return immediately */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* BUGFIX: https://github.com/symisc/unqlite/issues/137 */</comment>
		<return>return <expr><name>UNQLITE_ABORT</name></expr>;</return> <comment type="block">/* Ongoing operation must be aborted */</comment>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Write the total number of database records */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WriteInt32</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument> <comment type="block">/* sizeof(aJournalRec) */</comment>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Not so fatal */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Sync the journal and close it */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>UNQLITE_SYNC_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>close_jrnl</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* close the journal file */</comment>
		<if_stmt><if>if<condition>( <expr><name>UNQLITE_OK</name> <operator>!=</operator> <call><name>unqliteOsCloseFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> <comment type="block">/* unqliteOsSync */</comment> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pRetry</name><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><call><name>pager_lock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Got exclusive lock */</comment>
			<expr_stmt><expr><operator>*</operator><name>pRetry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Mark a single data page as writeable. The page is written into the 
 * main journal as required.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>page_write</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>is_mem</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>no_jrnl</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Write the page to the transaction journal */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name> <operator>&lt;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>unqliteBitvecTest</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>sxu32</name></type> <name>cksum</name></decl>;</decl_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name> <operator>==</operator> <name>SXU32_HIGH</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Journal Limit reached */</comment>
				<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Journal record limit reached, commit your changes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>UNQLITE_LIMIT</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Write the page number */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WriteInt64</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iJournalOfft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content> <return>return <expr><name>rc</name></expr>;</return> </block_content>}</block></if></if_stmt>
			<comment type="block">/* Write the raw page */</comment>
			<comment type="block" format="doxygen">/** CODEC */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iJournalOfft</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content> <return>return <expr><name>rc</name></expr>;</return> </block_content>}</block></if></if_stmt>
			<comment type="block">/* Compute the checksum */</comment>
			<expr_stmt><expr><name>cksum</name> <operator>=</operator> <call><name>pager_cksum</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WriteInt32</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>cksum</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iJournalOfft</name></name> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content> <return>return <expr><name>rc</name></expr>;</return> </block_content>}</block></if></if_stmt>
			<comment type="block">/* Update the journal offset */</comment>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iJournalOfft</name></name> <operator>+=</operator> <literal type="number">8</literal> <comment type="block">/* page num */</comment> <operator>+</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name> <operator>+</operator> <literal type="number">4</literal></expr> <comment type="block">/* cksum */</comment>;</expr_stmt>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* Mark as journalled  */</comment>
			<expr_stmt><expr><call><name>unqliteBitvecSet</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Add the page to the dirty list */</comment>
	<expr_stmt><expr><call><name>pager_page_to_dirty_list</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Update the database size and return. */</comment>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name><operator>)</operator> <operator>&gt;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>==</operator> <name>SXU64_HIGH</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Database maximum page limit (64-bit) reached"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>UNQLITE_LIMIT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>	
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** The argument is the first in a linked list of dirty pages connected
** by the PgHdr.pDirty pointer. This function writes each one of the
** in-memory pages in the list to the database file. The argument may
** be NULL, representing an empty list. In this case this function is
** a no-op.
**
** The pager must hold at least a RESERVED lock when this function
** is called. Before writing anything to the database file, this lock
** is upgraded to an EXCLUSIVE lock. If the lock cannot be obtained,
** UNQLITE_BUSY is returned and no data is written to the database file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_write_dirty_pages</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pDirty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pDirty</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next dirty page */</comment>
		<expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pDirty</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr>;</expr_stmt> <comment type="block">/* Not a bug: Reverse link */</comment>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDirty</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_DONT_WRITE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name><name>pDirty</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>,<argument><expr><name><name>pDirty</name><operator>-&gt;</operator><name>pgno</name></name> <operator>*</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* A rollback should be done */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Remove stale flags */</comment>
		<expr_stmt><expr><name><name>pDirty</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>PAGE_DIRTY</name><operator>|</operator><name>PAGE_DONT_WRITE</name><operator>|</operator><name>PAGE_NEED_SYNC</name><operator>|</operator><name>PAGE_IN_JOURNAL</name><operator>|</operator><name>PAGE_HOT_DIRTY</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pDirty</name><operator>-&gt;</operator><name>nRef</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Unlink the page now it is unused */</comment>
			<expr_stmt><expr><call><name>pager_unlink_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Release the page */</comment>
			<expr_stmt><expr><call><name>pager_release_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next page */</comment>
		<expr_stmt><expr><name>pDirty</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pFirstDirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pHotDirty</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pFirstHot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nHot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** The argument is the first in a linked list of hot dirty pages connected
** by the PgHdr.pHotDirty pointer. This function writes each one of the
** in-memory pages in the list to the database file. The argument may
** be NULL, representing an empty list. In this case this function is
** a no-op.
**
** The pager must hold at least a RESERVED lock when this function
** is called. Before writing anything to the database file, this lock
** is upgraded to an EXCLUSIVE lock. If the lock cannot be obtained,
** UNQLITE_BUSY is returned and no data is written to the database file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_write_hot_dirty_pages</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pDirty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pDirty</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next page */</comment>
		<expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pDirty</name><operator>-&gt;</operator><name>pPrevHot</name></name></expr>;</expr_stmt> <comment type="block">/* Not a bug: Reverse link */</comment>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDirty</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_DONT_WRITE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name><name>pDirty</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>,<argument><expr><name><name>pDirty</name><operator>-&gt;</operator><name>pgno</name></name> <operator>*</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Remove stale flags */</comment>
		<expr_stmt><expr><name><name>pDirty</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>PAGE_DIRTY</name><operator>|</operator><name>PAGE_DONT_WRITE</name><operator>|</operator><name>PAGE_NEED_SYNC</name><operator>|</operator><name>PAGE_IN_JOURNAL</name><operator>|</operator><name>PAGE_HOT_DIRTY</name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* Unlink from the list of dirty pages */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pDirty</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pDirty</name><operator>-&gt;</operator><name>pDirtyPrev</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <name><name>pDirty</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name><name>pDirty</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pDirty</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pDirty</name><operator>-&gt;</operator><name>pDirtyNext</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <name><name>pDirty</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstDirty</name></name> <operator>=</operator> <name><name>pDirty</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Discard */</comment>
		<expr_stmt><expr><call><name>pager_unlink_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Release the page */</comment>
		<expr_stmt><expr><call><name>pager_release_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Next hot page */</comment>
		<expr_stmt><expr><name>pDirty</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Commit a transaction: Phase one.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_commit_phase1</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>get_excl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pDirty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* If no database changes have been made, return early. */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>&lt;</operator> <name>PAGER_WRITER_CACHEMOD</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>is_mem</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* An in-memory database */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>is_rdonly</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Read-Only DB */</comment>
		<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Read-Only database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_READ_ONLY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Finalize the journal file */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteFinalizeJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>get_excl</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Get the dirty pages */</comment>
	<expr_stmt><expr><name>pDirty</name> <operator>=</operator> <call><name>pager_get_dirty_pages</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>get_excl</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Wait one last time for the exclusive lock */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_wait_on_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Cannot obtain an Exclusive lock on the target database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <name>PAGER_CTRL_DIRTY_COMMIT</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Synce the database first if a dirty commit have been applied */</comment>
		<expr_stmt><expr><call><name>unqliteOsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name>UNQLITE_SYNC_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Write the dirty pages */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_write_dirty_pages</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Rollback your DB */</comment>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>|=</operator> <name>PAGER_CTRL_COMMIT_ERR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstDirty</name></name> <operator>=</operator> <name>pDirty</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"IO error while writing dirty pages, rollback your database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* release all pages */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

        <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pAll</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>pager_unlink_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block>
	<comment type="block">/* If the file on disk is not the same size as the database image,
     * then use unqliteOsTruncate to grow or shrink the file here.
     */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>!=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteOsTruncate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name> <operator>*</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Sync the database file */</comment>
	<expr_stmt><expr><call><name>unqliteOsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>,<argument><expr><name>UNQLITE_SYNC_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Remove stale flags */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iJournalOfft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Commit a transaction: Phase two.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_commit_phase2</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>is_mem</name></name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>==</operator> <name>PAGER_OPEN</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>!=</operator> <name>PAGER_READER</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>no_jrnl</name></name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Finally, unlink the journal file */</comment>
				<expr_stmt><expr><call><name>unqliteOsDelete</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Downgrade to shraed lock */</comment>
			<expr_stmt><expr><call><name>pager_unlock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>PAGER_READER</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><call><name>unqliteBitvecDestroy</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Perform a dirty commit.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_dirty_commit</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>get_excl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pHot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Finalize the journal file without closing it */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteFinalizeJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>get_excl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* It's not a fatal error if something goes wrong here since
		 * its not the final commit.
		 */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Point to the list of hot pages */</comment>
	<expr_stmt><expr><name>pHot</name> <operator>=</operator> <call><name>pager_get_hot_pages</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pHot</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>get_excl</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Wait one last time for the exclusive lock */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_wait_on_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Not so fatal, will try another time */</comment>
			<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Tell that a dirty commit happen */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>|=</operator> <name>PAGER_CTRL_DIRTY_COMMIT</name></expr>;</expr_stmt>
	<comment type="block">/* Write the hot pages now */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_write_hot_dirty_pages</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pHot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>|=</operator> <name>PAGER_CTRL_COMMIT_ERR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"IO error while writing hot dirty pages, rollback your database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstHot</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pHotDirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nHot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* No need to sync the database file here, since the journal is already
	 * open here and this is not the final commit.
	 */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Commit a transaction and sync the database file for the pager pPager.
**
** This routine ensures that:
**
**   * the journal is synced,
**   * all dirty pages are written to the database file, 
**   * the database file is truncated (if required), and
**   * the database file synced.
**   * the journal file is deleted.
*/</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqlitePagerCommit</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Commit: Phase One */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_commit_phase1</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Commit: Phase Two */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_commit_phase2</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Remove stale flags */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PAGER_CTRL_COMMIT_ERR</name></expr>;</expr_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
<label><name>fail</name>:</label>
	<comment type="block">/* Disable the auto-commit flag */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>|=</operator> <name>UNQLITE_FL_DISABLE_AUTO_COMMIT</name></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Reset the pager to its initial state. This is caused by
 * a rollback operation.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_reset_state</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>bResetKvEngine</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pPtr</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pAll</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unqlite_kv_io</name> <modifier>*</modifier></type><name>pIo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Remove stale flags */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>PAGER_CTRL_COMMIT_ERR</name><operator>|</operator><name>PAGER_CTRL_DIRTY_COMMIT</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iJournalOfft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Database original size */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr>;</expr_stmt>
	<comment type="block">/* Discard all in-memory pages */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pPtr</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pPtr</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt> <comment type="block">/* Reverse link */</comment>
		<comment type="block">/* Remove stale flags */</comment>
		<expr_stmt><expr><name><name>pPtr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>PAGE_DIRTY</name><operator>|</operator><name>PAGE_DONT_WRITE</name><operator>|</operator><name>PAGE_NEED_SYNC</name><operator>|</operator><name>PAGE_IN_JOURNAL</name><operator>|</operator><name>PAGE_HOT_DIRTY</name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* Release the page */</comment>
		<expr_stmt><expr><call><name>pager_release_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Point to the next page */</comment>
		<expr_stmt><expr><name>pPtr</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAll</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pFirstDirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pHotDirty</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pFirstHot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nHot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Zero the table */</comment>
		<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteBitvecDestroy</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Switch back to shared lock */</comment>
	<expr_stmt><expr><call><name>pager_unlock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>PAGER_READER</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>bResetKvEngine</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Reset the underlying KV engine */</comment>
		<expr_stmt><expr><name>pIo</name> <operator>=</operator> <name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRelease</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Call the release callback */</comment>
			<expr_stmt><expr><call><name><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRelease</name></name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Zero the structure */</comment>
		<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>szKv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Fill in */</comment>
		<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name></name> <operator>=</operator> <name>pIo</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xInit</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Call the init method */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xInit</name></name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>iPageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xOpen</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Call the xOpen method */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>rc</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* All done */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** If a write transaction is open, then all changes made within the 
** transaction are reverted and the current write-transaction is closed.
** The pager falls back to PAGER_READER state if successful.
**
** Otherwise, in rollback mode, this function performs two functions:
**
**   1) It rolls back the journal file, restoring all database file and 
**      in-memory cache pages to the state they were in when the transaction
**      was opened, and
**
**   2) It finalizes the journal file, so that it is not used for hot
**      rollback at any point in the future (i.e. deletion).
**
** Finalization of the journal file (task 2) is only performed if the 
** rollback is successful.
**
*/</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqlitePagerRollback</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>bResetKvEngine</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>&lt;</operator> <name>PAGER_WRITER_LOCKED</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* A write transaction must be opened */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>is_mem</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* As of this release 1.1.6: Transactions are not supported for in-memory databases */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>is_rdonly</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Read-Only DB */</comment>
		<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Read-Only database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_READ_ONLY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>&gt;=</operator> <name>PAGER_WRITER_CACHEMOD</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>no_jrnl</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Close any outstanding joural file */</comment>
			<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr> )</condition><block>{<block_content>
				<comment type="block">/* Sync the journal file */</comment>
				<expr_stmt><expr><call><name>unqliteOsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>,<argument><expr><name>UNQLITE_SYNC_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>unqliteOsCloseFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pjfd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>PAGER_CTRL_COMMIT_ERR</name><operator>|</operator><name>PAGER_CTRL_DIRTY_COMMIT</name><operator>)</operator></expr> )</condition><block>{<block_content>
				<comment type="block">/* Perform the rollback */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_journal_rollback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
					<comment type="block">/* Set the auto-commit flag */</comment>
					<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>|=</operator> <name>UNQLITE_FL_DISABLE_AUTO_COMMIT</name></expr>;</expr_stmt>
					<return>return <expr><name>rc</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Unlink the journal file */</comment>
		<expr_stmt><expr><call><name>unqliteOsDelete</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Reset the pager state */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_reset_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>bResetKvEngine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Mostly an unlikely scenario */</comment>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>iFlags</name></name> <operator>|=</operator> <name>UNQLITE_FL_DISABLE_AUTO_COMMIT</name></expr>;</expr_stmt> <comment type="block">/* Set the auto-commit flag */</comment>
			<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Error while reseting pager to its initial state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Downgrade to shared lock */</comment>
		<expr_stmt><expr><call><name>pager_unlock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>PAGER_READER</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 *  Mark a data page as non writeable.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqlitePagerDontWrite</name><parameter_list>(<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pMyPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><operator>(</operator><name>Page</name> <operator>*</operator><operator>)</operator><name>pMyPage</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> <comment type="block">/* Page 0 is always writeable */</comment> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PAGE_DONT_WRITE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Mark a data page as writeable. This routine must be called before 
** making changes to a page. The caller must check the return value 
** of this function and be careful not to change any page data unless 
** this routine returns UNQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqlitePageWrite</name><parameter_list>(<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pMyPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><operator>(</operator><name>Page</name> <operator>*</operator><operator>)</operator><name>pMyPage</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Begin the write transaction */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlitePagerBegin</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>==</operator> <name>PAGER_WRITER_LOCKED</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* The journal file needs to be opened. Higher level routines have already
		 ** obtained the necessary locks to begin the write-transaction, but the
		 ** rollback journal might not yet be open. Open it now if this is the case.
		 */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteOpenJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>nHot</name></name> <operator>&gt;</operator> <literal type="number">127</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Write hot dirty pages */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_dirty_commit</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* A rollback must be done */</comment>
			<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><literal type="string">"Please perform a rollback"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Write the page to the journal file */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>page_write</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Acquire a reference to page number pgno in pager pPager (a page
** reference has type unqlite_page*). If the requested reference is 
** successfully obtained, it is copied to *ppPage and UNQLITE_OK returned.
**
** If the requested page is already in the cache, it is returned. 
** Otherwise, a new page object is allocated and populated with data
** read from the database file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqlitePagerAcquire</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,      <comment type="block">/* The pager open on the database file */</comment>
  <parameter><decl><type><name>pgno</name></type> <name>pgno</name></decl></parameter>,          <comment type="block">/* Page number to fetch */</comment>
  <parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,    <comment type="block">/* OUT: Acquired page */</comment>
  <parameter><decl><type><name>int</name></type> <name>fetchOnly</name></decl></parameter>,      <comment type="block">/* Cache lookup only */</comment>
  <parameter><decl><type><name>int</name></type> <name>noContent</name></decl></parameter>       <comment type="block">/* Do not bother reading content from disk if true */</comment>
)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Acquire a shared lock (if not yet done) on the database and rollback any hot-journal if present */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_shared_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fetch the page from the cache */</comment>
	<expr_stmt><expr><name>pPage</name> <operator>=</operator> <call><name>pager_fetch_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>fetchOnly</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>ppPage</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <operator>(</operator><name>unqlite_page</name> <operator>*</operator><operator>)</operator><name>pPage</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><ternary><condition><expr><name>pPage</name></expr> ?</condition><then> <expr><name>UNQLITE_OK</name></expr> </then><else>: <expr><name>UNQLITE_NOTFOUND</name></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Allocate a new page */</comment>
		<expr_stmt><expr><name>pPage</name> <operator>=</operator> <call><name>pager_alloc_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Read page contents */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_get_page_contents</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>noContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Link the page */</comment>
		<expr_stmt><expr><call><name>pager_link_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>ppPage</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>page_ref</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* All done, page is loaded in memeory */</comment>
	<if_stmt><if>if<condition>( <expr><name>ppPage</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <operator>(</operator><name>unqlite_page</name> <operator>*</operator><operator>)</operator><name>pPage</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Return true if we are dealing with an in-memory database.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteInMemory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* NULL or the empty string means an in-memory database */</comment>
		<return>return <expr><name>TRUE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SyStrlen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>n</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><literal type="string">":mem:"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> 
		<call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>,<argument><expr><literal type="string">":mem:"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">":mem:"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><name>TRUE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>n</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><literal type="string">":memory:"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> 
		<call><name>SyStrnicmp</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>,<argument><expr><literal type="string">":memory:"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">":memory:"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><name>TRUE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Allocate a new KV cursor.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteInitCursor</name><parameter_list>(<parameter><decl><type><name>unqlite</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nByte</name></decl>;</decl_stmt>
	<comment type="block">/* Storage engine methods */</comment>
	<expr_stmt><expr><name>pMethods</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>sDB</name><operator>.</operator><name>pPager</name><operator>-&gt;</operator><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pMethods</name><operator>-&gt;</operator><name>szCursor</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Implementation does not supprt cursors */</comment>
		<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><literal type="string">"Storage engine '%s' does not support cursors"</literal></expr></argument>,<argument><expr><name><name>pMethods</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_NOTIMPLEMENTED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>nByte</name> <operator>=</operator> <name><name>pMethods</name><operator>-&gt;</operator><name>szCursor</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_kv_cursor</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nByte</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_kv_cursor</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pCur</name> <operator>=</operator> <operator>(</operator><name>unqlite_kv_cursor</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the structure */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Save the cursor */</comment>
	<expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStore</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>sDB</name><operator>.</operator><name>pPager</name><operator>-&gt;</operator><name>pEngine</name></name></expr>;</expr_stmt>
	<comment type="block">/* Invoke the initialization callback if any */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pMethods</name><operator>-&gt;</operator><name>xCursorInit</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name><name>pMethods</name><operator>-&gt;</operator><name>xCursorInit</name></name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* All done */</comment>
	<expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pCur</name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Release a cursor.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqliteReleaseCursor</name><parameter_list>(<parameter><decl><type><name>unqlite</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,<parameter><decl><type><name>unqlite_kv_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>
	<comment type="block">/* Storage engine methods */</comment>
	<expr_stmt><expr><name>pMethods</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>sDB</name><operator>.</operator><name>pPager</name><operator>-&gt;</operator><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
	<comment type="block">/* Invoke the release callback if available */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pMethods</name><operator>-&gt;</operator><name>xCursorRelease</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name><name>pMethods</name><operator>-&gt;</operator><name>xCursorRelease</name></name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Finally, free the whole instance */</comment>
	<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Release the underlying KV storage engine and invoke
 * its associated callbacks if available.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pager_release_kv_engine</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_db</name> <modifier>*</modifier></type><name>pStorage</name> <init>= <expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>sDB</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pStorage</name><operator>-&gt;</operator><name>pCursor</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Release the associated cursor */</comment>
		<expr_stmt><expr><call><name>unqliteReleaseCursor</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><name><name>pStorage</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pStorage</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRelease</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRelease</name></name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Release the whole instance */</comment>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pEngine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pager_kv_io_init</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl></parameter>,<parameter><decl><type><name>unqlite_kv_io</name> <modifier>*</modifier></type><name>pIo</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * Allocate, initialize and register a new KV storage engine
 * within this database instance.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqlitePagerRegisterKvEngine</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_db</name> <modifier>*</modifier></type><name>pStorage</name> <init>= <expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>sDB</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_kv_engine</name> <modifier>*</modifier></type><name>pEngine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unqlite_kv_io</name> <modifier>*</modifier></type><name>pIo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nByte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name></name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pMethods</name> <operator>==</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name><operator>-&gt;</operator><name>pIo</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Ticket 1432: Same implementation */</comment>
			<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Release the old KV engine */</comment>
		<expr_stmt><expr><call><name>pager_release_kv_engine</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Allocate a new KV engine instance */</comment>
	<expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pMethods</name><operator>-&gt;</operator><name>szKv</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pEngine</name> <operator>=</operator> <operator>(</operator><name>unqlite_kv_engine</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pEngine</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pIo</name> <operator>=</operator> <operator>(</operator><name>unqlite_kv_io</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_kv_io</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pIo</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><name>pEngine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unqliteGenOutofMem</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the structure */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pIo</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unqlite_io_methods</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Populate the IO structure */</comment>
	<expr_stmt><expr><call><name>pager_kv_io_init</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pMethods</name></expr></argument>,<argument><expr><name>pIo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name></name> <operator>=</operator> <name>pIo</name></expr>;</expr_stmt>
	<comment type="block">/* Invoke the init callback if avaialble */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pMethods</name><operator>-&gt;</operator><name>xInit</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMethods</name><operator>-&gt;</operator><name>xInit</name></name><argument_list>(<argument><expr><name>pEngine</name></expr></argument>,<argument><expr><call><name>unqliteGetPageSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteGenErrorFormat</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,
				<argument><expr><literal type="string">"xInit() method of the underlying KV engine '%z' failed"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>sKv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pEngine</name><operator>-&gt;</operator><name>pIo</name></name> <operator>=</operator> <name>pIo</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pEngine</name></name> <operator>=</operator> <name>pEngine</name></expr>;</expr_stmt>
	<comment type="block">/* Allocate a new cursor */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqliteInitCursor</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pStorage</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><name>pEngine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><name>pIo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Return the underlying KV storage engine instance.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>unqlite_kv_engine</name> <modifier>*</modifier></type> <name>unqlitePagerGetKvEngine</name><parameter_list>(<parameter><decl><type><name>unqlite</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>pDb</name><operator>-&gt;</operator><name>sDB</name><operator>.</operator><name>pPager</name><operator>-&gt;</operator><name>pEngine</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
* Allocate and initialize a new Pager object. The pager should
* eventually be freed by passing it to unqlitePagerClose().
*
* The zFilename argument is the path to the database file to open.
* If zFilename is NULL or ":memory:" then all information is held
* in cache. It is never written to disk.  This can be used to implement
* an in-memory database.
*/</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqlitePagerOpen</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,       <comment type="block">/* The virtual file system to use */</comment>
  <parameter><decl><type><name>unqlite</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,            <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,   <comment type="block">/* Name of the database file to open */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iFlags</name></decl></parameter>      <comment type="block">/* flags controlling this file */</comment>
  )</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>is_mem</name></decl>,<decl><type ref="prev"/><name>rd_only</name></decl>,<decl><type ref="prev"/><name>no_jrnl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nByte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<comment type="block">/* Select the appropriate KV storage subsytem  */</comment>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_IN_MEMORY</name><operator>)</operator> <operator>||</operator> <call><name>unqliteInMemory</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<comment type="block">/* An in-memory database, record that  */</comment>
		<expr_stmt><expr><name>pMethods</name> <operator>=</operator> <call><name>unqliteFindKVStore</name><argument_list>(<argument><expr><literal type="string">"mem"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"mem"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Always available */</comment>
		<expr_stmt><expr><name>iFlags</name> <operator>|=</operator> <name>UNQLITE_OPEN_IN_MEMORY</name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Install the default key value storage subsystem [i.e. Linear Hash] */</comment>
		<expr_stmt><expr><name>pMethods</name> <operator>=</operator> <call><name>unqliteFindKVStore</name><argument_list>(<argument><expr><literal type="string">"hash"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"hash"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pMethods</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Use the b+tree storage backend if the linear hash storage is not available */</comment>
			<expr_stmt><expr><name>pMethods</name> <operator>=</operator> <call><name>unqliteFindKVStore</name><argument_list>(<argument><expr><literal type="string">"btree"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"btree"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pMethods</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Can't happen */</comment>
		<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><literal type="string">"Cannot install a default Key/Value storage engine"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>UNQLITE_NOTIMPLEMENTED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>is_mem</name> <operator>=</operator> <operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_IN_MEMORY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rd_only</name> <operator>=</operator> <operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_READONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>no_jrnl</name> <operator>=</operator> <operator>(</operator><name>iFlags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_OMIT_JOURNALING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>is_mem</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Omit journaling for in-memory database */</comment>
		<expr_stmt><expr><name>no_jrnl</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Total number of bytes to allocate */</comment>
	<expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pager</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>nLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><name>is_mem</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <call><name>SyStrlen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nByte</name> <operator>+=</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name> <operator>+</operator> <name>nLen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr> <comment type="block">/* null termniator */</comment>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Allocate */</comment>
	<expr_stmt><expr><name>pPager</name> <operator>=</operator> <operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pPager</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the structure */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fill-in the structure */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>sDB</name><operator>.</operator><name>pPager</name></name> <operator>=</operator> <name>pPager</name></expr>;</expr_stmt>
	<comment type="block">/* Allocate page table */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt> <comment type="block">/* Must be a power of two */</comment>
	<expr_stmt><expr><name>nByte</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name></name> <operator>=</operator> <operator>(</operator><name>Page</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>,<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>is_mem</name></name> <operator>=</operator> <name>is_mem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>no_jrnl</name></name> <operator>=</operator> <name>no_jrnl</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>is_rdonly</name></name> <operator>=</operator> <name>rd_only</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iOpenFlags</name></name> <operator>=</operator> <name>iFlags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name> <operator>=</operator> <name>pVfs</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyRandomnessInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>sPrng</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyRandomness</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>sPrng</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>cksumInit</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Unlimited cache size */</comment>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nCacheMax</name></name> <operator>=</operator> <name>SXU32_HIGH</name></expr>;</expr_stmt>
	<comment type="block">/* Copy filename and journal name */</comment>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><name>is_mem</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pPager</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pVfs</name><operator>-&gt;</operator><name>xFullPathname</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVfs</name><operator>-&gt;</operator><name>xFullPathname</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>,<argument><expr><name>zFilename</name></expr></argument>,<argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name> <operator>+</operator> <name>nLen</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Simple filename copy */</comment>
			<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>,<argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name><index>[<expr><name>nLen</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name>nLen</name> <operator>=</operator> <call><name>SyStrlen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name>nLen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UNQLITE_JOURNAL_FILE_SUFFIX</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_NOMEM</name></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Copy filename */</comment>
		<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>,<argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Copy journal suffix */</comment>
		<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>UNQLITE_JOURNAL_FILE_SUFFIX</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name><index>[<expr><name>nLen</name></expr>]</index></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UNQLITE_JOURNAL_FILE_SUFFIX</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Append the nul terminator to the journal path */</comment>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name><index>[<expr><name>nLen</name> <operator>+</operator> <operator>(</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UNQLITE_JOURNAL_FILE_SUFFIX</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Finally, register the selected KV engine */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlitePagerRegisterKvEngine</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>pMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<goto>goto <name>fail</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Set the pager state */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>is_mem</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>PAGER_WRITER_FINISHED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iLock</name></name> <operator>=</operator> <name>EXCLUSIVE_LOCK</name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>=</operator> <name>PAGER_OPEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* All done, ready for processing */</comment>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>sMem</name></name></expr></argument>,<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Set a cache limit. Note that, this is a simple hint, the pager is not
 * forced to honor this limit.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqlitePagerSetCachesize</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>mxPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>mxPage</name> <operator>&lt;</operator> <literal type="number">256</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>UNQLITE_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nCacheMax</name></name> <operator>=</operator> <name>mxPage</name></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Shutdown the page cache. Free all memory and close the database file.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>int</name></type> <name>unqlitePagerClose</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Release the KV engine */</comment>
	<expr_stmt><expr><call><name>pager_release_kv_engine</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iOpenFlags</name></name> <operator>&amp;</operator> <name>UNQLITE_OPEN_MMAP</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>jx9_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><call><name>jx9ExportBuiltinVfs</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>pVfs</name> <operator>&amp;&amp;</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>xUnmap</name></name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pMmap</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xUnmap</name></name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pMmap</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbByteSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>is_mem</name></name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>&gt;</operator> <name>PAGER_OPEN</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Release all lock on this database handle */</comment>
		<expr_stmt><expr><call><name>pager_unlock_db</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Close the file  */</comment>
		<expr_stmt><expr><call><name>unqliteOsCloseFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>unqliteBitvecDestroy</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Generate a random string.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>void</name></type> <name>unqlitePagerRandomString</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zBase</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"abcdefghijklmnopqrstuvwxyz"</literal></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* English Alphabet */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>i</name></decl>;</decl_stmt>
	<comment type="block">/* Generate a binary string first */</comment>
	<expr_stmt><expr><call><name>SyRandomness</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>sPrng</name></name></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Turn the binary string into english based alphabet */</comment>
	<for>for<control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLen</name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr> )</control><block>{<block_content>
		 <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zBase</name><index>[<expr><name><name>zBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>%</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zBase</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	 </block_content>}</block></for>
</block_content>}</block></function>
<comment type="block">/*
 * Generate a random number.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <name>sxu32</name></type> <name>unqlitePagerRandomNum</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>iNum</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SyRandomness</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>sPrng</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iNum</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>iNum</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Exported KV IO Methods */</comment>
<comment type="block">/* 
 * Refer to [unqlitePagerAcquire()]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIoPageGet</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_handle</name></type> <name>pHandle</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>iNum</name></decl></parameter>,<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlitePagerAcquire</name><argument_list>(<argument><expr><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>pHandle</name></expr></argument>,<argument><expr><name>iNum</name></expr></argument>,<argument><expr><name>ppPage</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Refer to [unqlitePagerAcquire()]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIoPageLookup</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_handle</name></type> <name>pHandle</name></decl></parameter>,<parameter><decl><type><name>pgno</name></type> <name>iNum</name></decl></parameter>,<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlitePagerAcquire</name><argument_list>(<argument><expr><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>pHandle</name></expr></argument>,<argument><expr><name>iNum</name></expr></argument>,<argument><expr><name>ppPage</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Refer to [unqlitePagerAcquire()]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIoNewPage</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_handle</name></type> <name>pHandle</name></decl></parameter>,<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>pHandle</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* 
	 * Acquire a reader-lock first so that pPager-&gt;dbSize get initialized.
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_shared_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlitePagerAcquire</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><ternary><condition><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <comment type="block">/* Page 0 is reserved */</comment> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></else></ternary></expr></argument> ,<argument><expr><name>ppPage</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Refer to [unqlitePageWrite()]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIopageWrite</name><parameter_list>(<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* TICKET 1433-0348 */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlitePageWrite</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Refer to [unqlitePagerDontWrite()]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIoPageDontWrite</name><parameter_list>(<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* TICKET 1433-0348 */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlitePagerDontWrite</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Refer to [unqliteBitvecSet()]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIoPageDontJournal</name><parameter_list>(<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pRaw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><operator>(</operator><name>Page</name> <operator>*</operator><operator>)</operator><name>pRaw</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* TICKET 1433-0348 */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pPager</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pPager</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>iState</name></name> <operator>&gt;=</operator> <name>PAGER_WRITER_LOCKED</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>no_jrnl</name></name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>unqliteBitvecTest</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>unqliteBitvecSet</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVec</name></name></expr></argument>,<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Do not add a page to the hot dirty list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIoPageDontMakeHot</name><parameter_list>(<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pRaw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><operator>(</operator><name>Page</name> <operator>*</operator><operator>)</operator><name>pRaw</name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if<condition>( <expr><name>pPage</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* TICKET 1433-0348 */</comment>
		<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PAGE_DONT_MAKE_HOT</name></expr>;</expr_stmt>

	<comment type="block">/* Remove from hot dirty list if it is already there */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_HOT_DIRTY</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pNextHot</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pNextHot</name><operator>-&gt;</operator><name>pPrevHot</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pPrevHot</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pPrevHot</name></name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPrevHot</name><operator>-&gt;</operator><name>pNextHot</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pNextHot</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstHot</name></name> <operator>==</operator> <name>pPage</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pFirstHot</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pPrevHot</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pHotDirty</name></name> <operator>==</operator> <name>pPage</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pHotDirty</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pNextHot</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nHot</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PAGE_HOT_DIRTY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Refer to [page_ref()]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIopage_ref</name><parameter_list>(<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>pPage</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>page_ref</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name> <operator>*</operator><operator>)</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Refer to [page_unref()]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIoPageUnRef</name><parameter_list>(<parameter><decl><type><name>unqlite_page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>pPage</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>page_unref</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name> <operator>*</operator><operator>)</operator><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Refer to the declaration of the [Pager] structure
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIoReadOnly</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_handle</name></type> <name>pHandle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>pHandle</name><operator>)</operator><operator>-&gt;</operator><name>is_rdonly</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Refer to the declaration of the [Pager] structure
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unqliteKvIoPageSize</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_handle</name></type> <name>pHandle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>pHandle</name><operator>)</operator><operator>-&gt;</operator><name>iPageSize</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Refer to the declaration of the [Pager] structure
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>unqliteKvIoTempPage</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_handle</name></type> <name>pHandle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>pHandle</name><operator>)</operator><operator>-&gt;</operator><name>zTmpPage</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* 
 * Set a page unpin callback.
 * Refer to the declaration of the [Pager] structure
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unqliteKvIoPageUnpin</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_handle</name></type> <name>pHandle</name></decl></parameter>,<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xPageUnpin</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>pHandle</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>xPageUnpin</name></name> <operator>=</operator> <name>xPageUnpin</name></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* 
 * Set a page reload callback.
 * Refer to the declaration of the [Pager] structure
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unqliteKvIoPageReload</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_handle</name></type> <name>pHandle</name></decl></parameter>,<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xPageReload</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>pHandle</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>xPageReload</name></name> <operator>=</operator> <name>xPageReload</name></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* 
 * Log an error.
 * Refer to the declaration of the [Pager] structure
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unqliteKvIoErr</name><parameter_list>(<parameter><decl><type><name>unqlite_kv_handle</name></type> <name>pHandle</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>pHandle</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>unqliteGenError</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>,<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Init an instance of the [unqlite_kv_io] structure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_kv_io_init</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,<parameter><decl><type><name>unqlite_kv_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl></parameter>,<parameter><decl><type><name>unqlite_kv_io</name> <modifier>*</modifier></type><name>pIo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>pHandle</name></name> <operator>=</operator>  <name>pPager</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <name>pMethods</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xGet</name></name>    <operator>=</operator> <name>unqliteKvIoPageGet</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xLookup</name></name> <operator>=</operator> <name>unqliteKvIoPageLookup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xNew</name></name>    <operator>=</operator> <name>unqliteKvIoNewPage</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xWrite</name></name>     <operator>=</operator> <name>unqliteKvIopageWrite</name></expr>;</expr_stmt> 
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xDontWrite</name></name> <operator>=</operator> <name>unqliteKvIoPageDontWrite</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xDontJournal</name></name> <operator>=</operator> <name>unqliteKvIoPageDontJournal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xDontMkHot</name></name> <operator>=</operator> <name>unqliteKvIoPageDontMakeHot</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xPageRef</name></name>   <operator>=</operator> <name>unqliteKvIopage_ref</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xPageUnref</name></name> <operator>=</operator> <name>unqliteKvIoPageUnRef</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xPageSize</name></name> <operator>=</operator> <name>unqliteKvIoPageSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xReadOnly</name></name> <operator>=</operator> <name>unqliteKvIoReadOnly</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xTmpPage</name></name> <operator>=</operator>  <name>unqliteKvIoTempPage</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xSetUnpin</name></name> <operator>=</operator> <name>unqliteKvIoPageUnpin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xSetReload</name></name> <operator>=</operator> <name>unqliteKvIoPageReload</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pIo</name><operator>-&gt;</operator><name>xErr</name></name> <operator>=</operator> <name>unqliteKvIoErr</name></expr>;</expr_stmt>

	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
