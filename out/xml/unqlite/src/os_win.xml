<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/src/os_win.c"><comment type="block">/*
 * Symisc unQLite: An Embeddable NoSQL (Post Modern) Database Engine.
 * Copyright (C) 2012-2013, Symisc Systems http://unqlite.org/
 * Version 1.1.6
 * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES
 * please contact Symisc Systems via:
 *       legal@symisc.net
 *       licensing@symisc.net
 *       contact@symisc.net
 * or visit:
 *      http://unqlite.org/licensing.html
 */</comment>
 <comment type="block">/* $SymiscID: os_win.c v1.2 Win7 2012-11-10 12:10 devel &lt;chm@symisc.net&gt; $ */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unqliteInt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* Omit the whole layer from the build if compiling for platforms other than Windows */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
<comment type="block">/* This file contains code that is specific to windows. (Mostly SQLite3 source tree) */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Windows.h&gt;</cpp:file></cpp:include>
<comment type="block">/*
** Some microsoft compilers lack this definition.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INVALID_FILE_ATTRIBUTES</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_FILE_ATTRIBUTES</name></cpp:macro> <cpp:value>((DWORD)-1)</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** WinCE lacks native support for file locking so we have to fake it
** with some code of our own.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WIN_CE__</name></cpp:ifdef>
<typedef>typedef <type><struct>struct <name>winceLock</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nReaders</name></decl>;</decl_stmt>       <comment type="block">/* Number of reader locks obtained */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>bPending</name></decl>;</decl_stmt>      <comment type="block">/* Indicates a pending lock has been obtained */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>bReserved</name></decl>;</decl_stmt>     <comment type="block">/* Indicates a reserved lock has been obtained */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>bExclusive</name></decl>;</decl_stmt>    <comment type="block">/* Indicates an exclusive lock has been obtained */</comment>
}</block></struct></type> <name>winceLock</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AreFileApisANSI</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FormatMessageW</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The winFile structure is a subclass of unqlite_file* specific to the win32
** portability layer.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>winFile</name></name></type> <name>winFile</name>;</typedef>
<struct>struct <name>winFile</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>unqlite_io_methods</name> <modifier>*</modifier></type><name>pMethod</name></decl>;</decl_stmt> <comment type="block" format="doxygen">/*** Must be first ***/</comment>
  <decl_stmt><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl>;</decl_stmt>      <comment type="block">/* The VFS used to open this file */</comment>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>               <comment type="block">/* Handle for accessing the file */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>locktype</name></decl>;</decl_stmt>          <comment type="block">/* Type of lock currently held on this file */</comment>
  <decl_stmt><decl><type><name>short</name></type> <name>sharedLockByte</name></decl>;</decl_stmt>   <comment type="block">/* Randomly chosen byte used as a shared lock */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name></decl>;</decl_stmt>        <comment type="block">/* The Windows errno from the last I/O error */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>sectorSize</name></decl>;</decl_stmt>       <comment type="block">/* Sector size of the device file is on */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szChunk</name></decl>;</decl_stmt>            <comment type="block">/* Chunk size */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WIN_CE__</name></cpp:ifdef>
  <decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>zDeleteOnClose</name></decl>;</decl_stmt>  <comment type="block">/* Name of file to delete when closing */</comment>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>hMutex</name></decl>;</decl_stmt>          <comment type="block">/* Mutex used to control access to shared lock */</comment>  
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>hShared</name></decl>;</decl_stmt>         <comment type="block">/* Shared memory segment used for locking */</comment>
  <decl_stmt><decl><type><name>winceLock</name></type> <name>local</name></decl>;</decl_stmt>        <comment type="block">/* Locks obtained by this instance of winFile */</comment>
  <decl_stmt><decl><type><name>winceLock</name> <modifier>*</modifier></type><name>shared</name></decl>;</decl_stmt>      <comment type="block">/* Global shared lock memory for the file  */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>
<comment type="block">/*
** Convert a UTF-8 string to microsoft unicode (UTF-16?). 
**
** Space to hold the returned string is obtained from HeapAlloc().
*/</comment>
<function><type><specifier>static</specifier> <name>WCHAR</name> <modifier>*</modifier></type><name>utf8ToUnicode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nChar</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>zWideFilename</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nChar</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zWideFilename</name> <operator>=</operator> <operator>(</operator><name>WCHAR</name> <operator>*</operator><operator>)</operator><call><name>HeapAlloc</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>nChar</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>zWideFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zWideFilename</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nChar</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zWideFilename</name></expr></argument>, <argument><expr><name>nChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nChar</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zWideFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zWideFilename</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zWideFilename</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert microsoft unicode to UTF-8.  Space to hold the returned string is
** obtained from malloc().
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>unicodeToUtf8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WCHAR</name> <modifier>*</modifier></type><name>zWideFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zWideFilename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>HeapAlloc</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zWideFilename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>,
                              <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zFilename</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert an ansi string to microsoft unicode, based on the
** current codepage settings for file apis.
** 
** Space to hold the returned string is obtained
** from malloc.
*/</comment>
<function><type><specifier>static</specifier> <name>WCHAR</name> <modifier>*</modifier></type><name>mbcsToUnicode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>zMbcsFilename</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>codepage</name> <init>= <expr><ternary><condition><expr><call><name>AreFileApisANSI</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>CP_ACP</name></expr> </then><else>: <expr><name>CP_OEMCP</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>codepage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMbcsFilename</name> <operator>=</operator> <operator>(</operator><name>WCHAR</name> <operator>*</operator><operator>)</operator><call><name>HeapAlloc</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>nByte</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>zMbcsFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zMbcsFilename</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>codepage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zMbcsFilename</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zMbcsFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zMbcsFilename</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zMbcsFilename</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Convert multibyte character string to UTF-8.  Space to hold the
** returned string is obtained from malloc().
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>unqlite_win32_mbcs_to_utf8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFilenameUtf8</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>zTmpWide</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zTmpWide</name> <operator>=</operator> <call><name>mbcsToUnicode</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTmpWide</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zFilenameUtf8</name> <operator>=</operator> <call><name>unicodeToUtf8</name><argument_list>(<argument><expr><name>zTmpWide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zTmpWide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zFilenameUtf8</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Some microsoft compilers lack this definition.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INVALID_SET_FILE_POINTER</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_SET_FILE_POINTER</name></cpp:macro> <cpp:value>((DWORD)-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Move the current position of the file handle passed as the first 
** argument to offset iOffset within the file. If successful, return 0. 
** Otherwise, set pFile-&gt;lastErrno and return non-zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seekWinFile</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>unqlite_int64</name></type> <name>iOffset</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LONG</name></type> <name>upperBits</name></decl>;</decl_stmt>                 <comment type="block">/* Most sig. 32 bits of new offset */</comment>
  <decl_stmt><decl><type><name>LONG</name></type> <name>lowerBits</name></decl>;</decl_stmt>                 <comment type="block">/* Least sig. 32 bits of new offset */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwRet</name></decl>;</decl_stmt>                    <comment type="block">/* Value returned by SetFilePointer() */</comment>

  <expr_stmt><expr><name>upperBits</name> <operator>=</operator> <operator>(</operator><name>LONG</name><operator>)</operator><operator>(</operator><operator>(</operator><name>iOffset</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>lowerBits</name> <operator>=</operator> <operator>(</operator><name>LONG</name><operator>)</operator><operator>(</operator><name>iOffset</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* API oddity: If successful, SetFilePointer() returns a dword 
  ** containing the lower 32-bits of the new file-offset. Or, if it fails,
  ** it returns INVALID_SET_FILE_POINTER. However according to MSDN, 
  ** INVALID_SET_FILE_POINTER may also be a valid new offset. So to determine 
  ** whether an error has actually occured, it is also necessary to call 
  ** GetLastError().
  */</comment>
  <expr_stmt><expr><name>dwRet</name> <operator>=</operator> <call><name>SetFilePointer</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>lowerBits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upperBits</name></expr></argument>, <argument><expr><name>FILE_BEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>dwRet</name><operator>==</operator><name>INVALID_SET_FILE_POINTER</name> <operator>&amp;&amp;</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call><operator>!=</operator><name>NO_ERROR</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Close a file.
**
** It is reported that an attempt to close a handle might sometimes
** fail.  This is a very unreasonable result, but windows is notorious
** for being unreasonable so I do not doubt that it might happen.  If
** the close fails, we pause for 100 milliseconds and try again.  As
** many as MX_CLOSE_ATTEMPT attempts to close the handle are made before
** giving up and returning an error.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MX_CLOSE_ATTEMPT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winClose</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>++</operator><name>cnt</name> <operator>&lt;</operator> <name>MX_CLOSE_ATTEMPT</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>Sleep</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr> )</condition>;</do>

  <return>return <expr><ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><name>UNQLITE_OK</name></expr> </then><else>: <expr><name>UNQLITE_IOERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Read data from a file into a buffer.  Return UNQLITE_OK if all
** bytes were read successfully and UNQLITE_IOERR if anything goes
** wrong.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winRead</name><parameter_list>(
  <parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,          <comment type="block">/* File to read from */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,                <comment type="block">/* Write content into this buffer */</comment>
  <parameter><decl><type><name>unqlite_int64</name></type> <name>amt</name></decl></parameter>,        <comment type="block">/* Number of bytes to read */</comment>
  <parameter><decl><type><name>unqlite_int64</name></type> <name>offset</name></decl></parameter>       <comment type="block">/* Begin reading at this offset */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* file handle */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>nRead</name></decl>;</decl_stmt>                    <comment type="block">/* Number of bytes actually read from file */</comment>

  <if_stmt><if>if<condition>( <expr><call><name>seekWinFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_FULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ReadFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><name>amt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRead</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nRead</name><operator>&lt;</operator><operator>(</operator><name>DWORD</name><operator>)</operator><name>amt</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Unread parts of the buffer must be zero-filled */</comment>
    <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>nRead</name></expr>]</index></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>amt</name><operator>-</operator><name>nRead</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write data from a buffer into a file.  Return UNQLITE_OK on success
** or some other error code on failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winWrite</name><parameter_list>(
  <parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,               <comment type="block">/* File to write into */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,               <comment type="block">/* The bytes to be written */</comment>
  <parameter><decl><type><name>unqlite_int64</name></type> <name>amt</name></decl></parameter>,                        <comment type="block">/* Number of bytes to write */</comment>
  <parameter><decl><type><name>unqlite_int64</name></type> <name>offset</name></decl></parameter>            <comment type="block">/* Offset into the file to begin writing at */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* True if error has occured, else false */</comment>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* File handle */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>seekWinFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sxu8</name> <modifier>*</modifier></type><name>aRem</name> <init>= <expr><operator>(</operator><name>sxu8</name> <operator>*</operator><operator>)</operator><name>pBuf</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Data yet to be written */</comment>
    <decl_stmt><decl><type><name>unqlite_int64</name></type> <name>nRem</name> <init>= <expr><name>amt</name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Number of bytes yet to be written */</comment>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>nWrite</name></decl>;</decl_stmt>                 <comment type="block">/* Bytes written by each WriteFile() call */</comment>

    <while>while<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>WriteFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>aRem</name></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><name>nRem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nWrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>nWrite</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aRem</name> <operator>+=</operator> <name>nWrite</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nWrite</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name><operator>==</operator><name>ERROR_HANDLE_DISK_FULL</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>UNQLITE_FULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate an open file to a specified size
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winTruncate</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>unqlite_int64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* File handle object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code for this function */</comment>


  <comment type="block">/* If the user has configured a chunk-size for this file, truncate the
  ** file so that it consists of an integer number of chunks (i.e. the
  ** actual file size after the operation may be larger than the requested
  ** size).
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nByte</name> <operator>+</operator> <name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name><operator>)</operator> <operator>*</operator> <name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* SetEndOfFile() returns non-zero when successful, or zero when it fails. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>seekWinFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_IOERR</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>SetEndOfFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_IOERR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Make sure all writes to a particular file are committed to disk.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winSync</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* MSVC warning */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>FlushFileBuffers</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
** Determine the current size of a file in bytes
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winFileSize</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>unqlite_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>upperBits</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lowerBits</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>error</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>lowerBits</name> <operator>=</operator> <call><name>GetFileSize</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upperBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(   <expr><operator>(</operator><name>lowerBits</name> <operator>==</operator> <name>INVALID_FILE_SIZE</name><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>error</name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NO_ERROR</name><operator>)</operator></expr> )</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>unqlite_int64</name><operator>)</operator><name>upperBits</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>+</operator> <name>lowerBits</name></expr>;</expr_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** LOCKFILE_FAIL_IMMEDIATELY is undefined on some Windows systems.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LOCKFILE_FAIL_IMMEDIATELY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>LOCKFILE_FAIL_IMMEDIATELY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Acquire a reader lock.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getReadLock</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>OVERLAPPED</name></type> <name>ovlp</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ovlp</name><operator>.</operator><name>Offset</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ovlp</name><operator>.</operator><name>OffsetHigh</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ovlp</name><operator>.</operator><name>hEvent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockFileEx</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>LOCKFILE_FAIL_IMMEDIATELY</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ovlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Undo a readlock
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unlockReadLock</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>UnlockFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Lock the file with the lock specified by parameter locktype - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  The winUnlock() routine
** erases all locks at once and returns us immediately to locking level 0.
** It is not possible to lower the locking level one step at a time.  You
** must go straight to locking level 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winLock</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locktype</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Return code from subroutines */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Result of a windows lock call */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>newLocktype</name></decl>;</decl_stmt>       <comment type="block">/* Set pFile-&gt;locktype to this value before exiting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>gotPendingLock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt><comment type="block">/* True if we acquired a PENDING lock this time */</comment>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>error</name> <init>= <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If there is already a lock of this type or more restrictive on the
  ** OsFile, do nothing.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>&gt;=</operator><name>locktype</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure the locking sequence is correct
  assert( pFile-&gt;locktype!=NO_LOCK || locktype==SHARED_LOCK );
  assert( locktype!=PENDING_LOCK );
  assert( locktype!=RESERVED_LOCK || pFile-&gt;locktype==SHARED_LOCK );
  */</comment>
  <comment type="block">/* Lock the PENDING_LOCK byte if we need to acquire a PENDING lock or
  ** a SHARED lock.  If we are acquiring a SHARED lock, the acquisition of
  ** the PENDING_LOCK byte is temporary.
  */</comment>
  <expr_stmt><expr><name>newLocktype</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(   <expr><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>==</operator><name>NO_LOCK</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator>   <operator>(</operator><name>locktype</name><operator>==</operator><name>EXCLUSIVE_LOCK</name><operator>)</operator>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>==</operator><name>RESERVED_LOCK</name><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>cnt</name><operator>--</operator><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>LockFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Try 3 times to get the pending lock.  The pending lock might be
      ** held by another reader process who will release it momentarily.
	  */</comment>
      <expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>gotPendingLock</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Acquire a shared lock
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>SHARED_LOCK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition><block>{<block_content>
   <comment type="block">/* assert( pFile-&gt;locktype==NO_LOCK ); */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>getReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>newLocktype</name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Acquire a RESERVED lock
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>RESERVED_LOCK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* assert( pFile-&gt;locktype==SHARED_LOCK ); */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>newLocktype</name> <operator>=</operator> <name>RESERVED_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Acquire a PENDING lock
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>EXCLUSIVE_LOCK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>newLocktype</name> <operator>=</operator> <name>PENDING_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>gotPendingLock</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Acquire an EXCLUSIVE lock
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>EXCLUSIVE_LOCK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* assert( pFile-&gt;locktype&gt;=SHARED_LOCK ); */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>unlockReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>newLocktype</name> <operator>=</operator> <name>EXCLUSIVE_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>getReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we are holding a PENDING lock that ought to be released, then
  ** release it now.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>gotPendingLock</name> <operator>&amp;&amp;</operator> <name>locktype</name><operator>==</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>UnlockFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Update the state of the lock has held in the file descriptor then
  ** return the appropriate result code.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name> <operator>=</operator> <operator>(</operator><name>sxu8</name><operator>)</operator><name>newLocktype</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, return
** non-zero, otherwise zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>&gt;=</operator><name>RESERVED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>LockFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>UnlockFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>!</operator><name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Lower the locking level on file descriptor id to locktype.  locktype
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
**
** It is not possible for this routine to fail if the second argument
** is NO_LOCK.  If the second argument is SHARED_LOCK then this routine
** might return UNQLITE_IOERR;
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winUnlock</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locktype</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>type</name><operator>&gt;=</operator><name>EXCLUSIVE_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>UnlockFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>SHARED_LOCK</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>getReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* This should never happen.  We should always be able to
      ** reacquire the read lock */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>UNQLITE_IOERR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>type</name><operator>&gt;=</operator><name>RESERVED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>UnlockFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>NO_LOCK</name> <operator>&amp;&amp;</operator> <name>type</name><operator>&gt;=</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>unlockReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>type</name><operator>&gt;=</operator><name>PENDING_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>UnlockFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name> <operator>=</operator> <operator>(</operator><name>sxu8</name><operator>)</operator><name>locktype</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Return the sector size in bytes of the underlying block device for
** the specified file. This is almost always 512 bytes, but may be
** larger for some devices.
**
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winSectorSize</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>sectorSize</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** This vector defines all the methods that can operate on an
** unqlite_file for Windows systems.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unqlite_io_methods</name></type> <name>winIoMethod</name> <init>= <expr><block>{
  <expr><literal type="number">1</literal></expr>,                              <comment type="block">/* iVersion */</comment>
  <expr><name>winClose</name></expr>,                       <comment type="block">/* xClose */</comment>
  <expr><name>winRead</name></expr>,                        <comment type="block">/* xRead */</comment>
  <expr><name>winWrite</name></expr>,                       <comment type="block">/* xWrite */</comment>
  <expr><name>winTruncate</name></expr>,                    <comment type="block">/* xTruncate */</comment>
  <expr><name>winSync</name></expr>,                        <comment type="block">/* xSync */</comment>
  <expr><name>winFileSize</name></expr>,                    <comment type="block">/* xFileSize */</comment>
  <expr><name>winLock</name></expr>,                        <comment type="block">/* xLock */</comment>
  <expr><name>winUnlock</name></expr>,                      <comment type="block">/* xUnlock */</comment>
  <expr><name>winCheckReservedLock</name></expr>,           <comment type="block">/* xCheckReservedLock */</comment>
  <expr><name>winSectorSize</name></expr>,                  <comment type="block">/* xSectorSize */</comment>
}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Windows VFS Methods.
 */</comment>
<comment type="block">/*
** Convert a UTF-8 filename into whatever form the underlying
** operating system wants filenames in.  Space to hold the result
** is obtained from malloc and must be freed by the calling
** function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>convertUtf8Filename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>utf8ToUnicode</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* caller will handle out of memory */</comment>
  <return>return <expr><name>zConverted</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Delete the named file.
**
** Note that windows does not allow a file to be deleted if some other
** process has it open.  Sometimes a virus scanner or indexing program
** will open a journal file shortly after it is created in order to do
** whatever it does.  While this other process is holding the
** file open, we will be unable to delete it.  To work around this
** problem, we delay 100 milliseconds and try to delete again.  Up
** to MX_DELETION_ATTEMPTs deletion attempts are run before giving
** up and returning an error.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MX_DELETION_ATTEMPTS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winDelete</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,          <comment type="block">/* Not used on win32 */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,      <comment type="block">/* Name of file to delete */</comment>
  <parameter><decl><type><name>int</name></type> <name>syncDir</name></decl></parameter>                 <comment type="block">/* Not used on win32 */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>convertUtf8Filename</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zConverted</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
	   <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	   <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>syncDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <do>do<block>{<block_content>
	  <expr_stmt><expr><call><name>DeleteFileW</name><argument_list>(<argument><expr><operator>(</operator><name>LPCWSTR</name><operator>)</operator><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>(   <expr><operator>(</operator>   <operator>(</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>GetFileAttributesW</name><argument_list>(<argument><expr><operator>(</operator><name>LPCWSTR</name><operator>)</operator><name>zConverted</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>INVALID_FILE_ATTRIBUTES</name><operator>)</operator>
	  <operator>||</operator> <operator>(</operator><operator>(</operator><name>error</name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>ERROR_ACCESS_DENIED</name><operator>)</operator><operator>)</operator>
	  <operator>&amp;&amp;</operator> <operator>(</operator><operator>++</operator><name>cnt</name> <operator>&lt;</operator> <name>MX_DELETION_ATTEMPTS</name><operator>)</operator>
	  <operator>&amp;&amp;</operator> <operator>(</operator><call><name>Sleep</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr>
	  )</condition>;</do>
	<expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
  <return>return <expr><ternary><condition><expr><operator>(</operator>   <operator>(</operator><name>rc</name> <operator>==</operator> <name>INVALID_FILE_ATTRIBUTES</name><operator>)</operator> 
          <operator>&amp;&amp;</operator> <operator>(</operator><name>error</name> <operator>==</operator> <name>ERROR_FILE_NOT_FOUND</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>UNQLITE_OK</name></expr> </then><else>: <expr><name>UNQLITE_IOERR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Check the existance and status of a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winAccess</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,         <comment type="block">/* Not used  */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,     <comment type="block">/* Name of file to check */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                 <comment type="block">/* Type of test to make on this file */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>               <comment type="block">/* OUT: Result */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name></type> <name>sAttrData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>attr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>convertUtf8Filename</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zConverted</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sAttrData</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sAttrData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>GetFileAttributesExW</name><argument_list>(<argument><expr><operator>(</operator><name>WCHAR</name><operator>*</operator><operator>)</operator><name>zConverted</name></expr></argument>,
	  <argument><expr><name>GetFileExInfoStandard</name></expr></argument>, 
	  <argument><expr><operator>&amp;</operator><name>sAttrData</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* For an UNQLITE_ACCESS_EXISTS query, treat a zero-length file
      ** as if it does not exist.
      */</comment>
      <if_stmt><if>if<condition>(    <expr><name>flags</name><operator>==</operator><name>UNQLITE_ACCESS_EXISTS</name>
          <operator>&amp;&amp;</operator> <name><name>sAttrData</name><operator>.</operator><name>nFileSizeHigh</name></name><operator>==</operator><literal type="number">0</literal> 
          <operator>&amp;&amp;</operator> <name><name>sAttrData</name><operator>.</operator><name>nFileSizeLow</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name>INVALID_FILE_ATTRIBUTES</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>sAttrData</name><operator>.</operator><name>dwFileAttributes</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>GetLastError</name><argument_list>()</argument_list></call><operator>!=</operator><name>ERROR_FILE_NOT_FOUND</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name>INVALID_FILE_ATTRIBUTES</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>flags</name></expr> )</condition><block>{<block_content>
     <case>case <expr><name>UNQLITE_ACCESS_READWRITE</name></expr>:</case>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>attr</name> <operator>&amp;</operator> <name>FILE_ATTRIBUTE_READONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>UNQLITE_ACCESS_READ</name></expr>:</case>
    <case>case <expr><name>UNQLITE_ACCESS_EXISTS</name></expr>:</case>
	<default>default:</default>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>attr</name><operator>!=</operator><name>INVALID_FILE_ATTRIBUTES</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Turn a relative pathname into a full pathname.  Write the full
** pathname into zOut[].  zOut[] will be at least pVfs-&gt;mxPathname
** bytes in size.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winFullPathname</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,            <comment type="block">/* Pointer to vfs object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRelative</name></decl></parameter>,        <comment type="block">/* Possibly relative input path */</comment>
  <parameter><decl><type><name>int</name></type> <name>nFull</name></decl></parameter>,                    <comment type="block">/* Size of output buffer in bytes */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zFull</name></decl></parameter>                   <comment type="block">/* Output buffer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>zTemp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>convertUtf8Filename</name><argument_list>(<argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zConverted</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
	  <return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>GetFullPathNameW</name><argument_list>(<argument><expr><operator>(</operator><name>WCHAR</name><operator>*</operator><operator>)</operator><name>zConverted</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTemp</name> <operator>=</operator> <operator>(</operator><name>WCHAR</name> <operator>*</operator><operator>)</operator><call><name>HeapAlloc</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>nByte</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>zTemp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTemp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
	  <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>GetFullPathNameW</name><argument_list>(<argument><expr><operator>(</operator><name>WCHAR</name><operator>*</operator><operator>)</operator><name>zConverted</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>unicodeToUtf8</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>Systrcpy</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>,<argument><expr><name>zOut</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Get the sector size of the device used to store
** file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getSectorSize</name><parameter_list>(
    <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRelative</name></decl></parameter>     <comment type="block">/* UTF-8 file name */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>bytesPerSector</name> <init>= <expr><name>UNQLITE_DEFAULT_SECTOR_SIZE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zFullpath</name><index>[<expr><name>MAX_PATH</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwDummy</name></decl>;</decl_stmt>
  <comment type="block">/*
  ** We need to get the full path name of the file
  ** to get the drive letter to look up the sector
  ** size.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winFullPathname</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>, <argument><expr><name>MAX_PATH</name></expr></argument>, <argument><expr><name>zFullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>UNQLITE_OK</name></expr> )</condition>
  <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name> <init>= <expr><call><name>convertUtf8Filename</name><argument_list>(<argument><expr><name>zFullpath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zConverted</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* trim path to just drive reference */</comment>
        <decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>WCHAR</name> <operator>*</operator><operator>)</operator><name>zConverted</name></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init>;</init><condition><expr><operator>*</operator><name>p</name></expr>;</condition><incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>dwRet</name> <operator>=</operator> <call><name>GetDiskFreeSpaceW</name><argument_list>(<argument><expr><operator>(</operator><name>WCHAR</name><operator>*</operator><operator>)</operator><name>zConverted</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>dwDummy</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>bytesPerSector</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>dwDummy</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>dwDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		 <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>dwRet</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bytesPerSector</name> <operator>=</operator> <name>UNQLITE_DEFAULT_SECTOR_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>bytesPerSector</name></expr>;</return> 
</block_content>}</block></function>
<comment type="block">/*
** Sleep for a little while.  Return the amount of time slept.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winSleep</name><parameter_list>(<parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>microsec</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><operator>(</operator><name>microsec</name><operator>+</operator><literal type="number">999</literal><operator>)</operator><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><operator>(</operator><name>microsec</name><operator>+</operator><literal type="number">999</literal><operator>)</operator><operator>/</operator><literal type="number">1000</literal><operator>)</operator><operator>*</operator><literal type="number">1000</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Export the current system time.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winCurrentTime</name><parameter_list>(<parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,<parameter><decl><type><name>Sytm</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>sSys</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SYSTEMTIME_TO_SYTM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSys</name></expr></argument>,<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** The idea is that this function works like a combination of
** GetLastError() and FormatMessage() on windows (or errno and
** strerror_r() on unix). After an error is returned by an OS
** function, UnQLite calls this function with zBuf pointing to
** a buffer of nBuf bytes. The OS layer should populate the
** buffer with a nul-terminated UTF-8 encoded error message
** describing the last IO error to have occurred within the calling
** thread.
**
** If the error message is too large for the supplied buffer,
** it should be truncated. The return value of xGetLastError
** is zero if the error message fits in the buffer, or non-zero
** otherwise (if the message was truncated). If non-zero is returned,
** then it is not necessary to include the nul-terminator character
** in the output buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winGetLastError</name><parameter_list>(<parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* FormatMessage returns 0 on failure.  Otherwise it
  ** returns the number of TCHARs written to the output
  ** buffer, excluding the terminating null char.
  */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>zTempWide</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwLen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dwLen</name> <operator>=</operator> <call><name>FormatMessageW</name><argument_list>(
	  <argument><expr><name>FORMAT_MESSAGE_ALLOCATE_BUFFER</name> <operator>|</operator> <name>FORMAT_MESSAGE_FROM_SYSTEM</name> <operator>|</operator> <name>FORMAT_MESSAGE_IGNORE_INSERTS</name></expr></argument>,
	  <argument><expr><literal type="number">0</literal></expr></argument>,
	  <argument><expr><name>error</name></expr></argument>,
	  <argument><expr><literal type="number">0</literal></expr></argument>,
	  <argument><expr><operator>(</operator><name>LPWSTR</name><operator>)</operator> <operator>&amp;</operator><name>zTempWide</name></expr></argument>,
	  <argument><expr><literal type="number">0</literal></expr></argument>,
	  <argument><expr><literal type="number">0</literal></expr></argument>
	  )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>dwLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* allocate a buffer and convert to UTF8 */</comment>
      <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>unicodeToUtf8</name><argument_list>(<argument><expr><name>zTempWide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* free the system buffer allocated by FormatMessage */</comment>
      <expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><name>zTempWide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><literal type="number">0</literal> <operator>==</operator> <name>dwLen</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>Systrcpy</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nBuf</name></expr></argument>,<argument><expr><literal type="string">"OS Error"</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"OS Error"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* copy a maximum of nBuf chars to output buffer */</comment>
		<expr_stmt><expr><call><name>Systrcpy</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nBuf</name></expr></argument>,<argument><expr><name>zOut</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* Compute input length automatically */</comment>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* free the UTF8 buffer */</comment>
		<expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Open a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winOpen</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,        <comment type="block">/* Not used */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,        <comment type="block">/* Name of the file (UTF-8) */</comment>
  <parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,         <comment type="block">/* Write the UnQLite file handle here */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>                <comment type="block">/* Open mode flags */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwDesiredAccess</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwShareMode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwCreationDisposition</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwFlagsAndAttributes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl>;</decl_stmt>              <comment type="block">/* Filename in OS encoding */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUtf8Name</name> <init>= <expr><name>zName</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Filename in UTF-8 encoding */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isExclusive</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_EXCLUSIVE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isDelete</name>     <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_TEMP_DB</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isCreate</name>     <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_CREATE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadWrite</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_READWRITE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
  <comment type="block">/* Convert the filename to the system encoding. */</comment>
  <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>convertUtf8Filename</name><argument_list>(<argument><expr><name>zUtf8Name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zConverted</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isReadWrite</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>dwDesiredAccess</name> <operator>=</operator> <name>GENERIC_READ</name> <operator>|</operator> <name>GENERIC_WRITE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>dwDesiredAccess</name> <operator>=</operator> <name>GENERIC_READ</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* UNQLITE_OPEN_EXCLUSIVE is used to make sure that a new file is 
  ** created.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isExclusive</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Creates a new file, only if it does not already exist. */</comment>
    <comment type="block">/* If the file exists, it fails. */</comment>
    <expr_stmt><expr><name>dwCreationDisposition</name> <operator>=</operator> <name>CREATE_NEW</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>isCreate</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Open existing file, or create if it doesn't exist */</comment>
    <expr_stmt><expr><name>dwCreationDisposition</name> <operator>=</operator> <name>OPEN_ALWAYS</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Opens a file, only if it exists. */</comment>
    <expr_stmt><expr><name>dwCreationDisposition</name> <operator>=</operator> <name>OPEN_EXISTING</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>dwShareMode</name> <operator>=</operator> <name>FILE_SHARE_READ</name> <operator>|</operator> <name>FILE_SHARE_WRITE</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>isDelete</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>dwFlagsAndAttributes</name> <operator>=</operator> <name>FILE_ATTRIBUTE_TEMPORARY</name>
                               <operator>|</operator> <name>FILE_ATTRIBUTE_HIDDEN</name>
                               <operator>|</operator> <name>FILE_FLAG_DELETE_ON_CLOSE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>dwFlagsAndAttributes</name> <operator>=</operator> <name>FILE_ATTRIBUTE_NORMAL</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>CreateFileW</name><argument_list>(<argument><expr><operator>(</operator><name>WCHAR</name><operator>*</operator><operator>)</operator><name>zConverted</name></expr></argument>,
       <argument><expr><name>dwDesiredAccess</name></expr></argument>,
       <argument><expr><name>dwShareMode</name></expr></argument>,
       <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><name>dwCreationDisposition</name></expr></argument>,
       <argument><expr><name>dwFlagsAndAttributes</name></expr></argument>,
       <argument><expr><name>NULL</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>h</name><operator>==</operator><name>INVALID_HANDLE_VALUE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>=</operator> <operator>&amp;</operator><name>winIoMethod</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>NO_ERROR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pVfs</name></name> <operator>=</operator> <name>pVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <call><name>getSectorSize</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zUtf8Name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Export the Windows Vfs.
 */</comment>
<function><type><name>UNQLITE_PRIVATE</name> <specifier>const</specifier> <name>unqlite_vfs</name> <modifier>*</modifier></type> <name>unqliteExportBuiltinVfs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unqlite_vfs</name></type> <name>sWinvfs</name> <init>= <expr><block>{
		<expr><literal type="string">"Windows"</literal></expr>,           <comment type="block">/* Vfs name */</comment>
		<expr><literal type="number">1</literal></expr>,                   <comment type="block">/* Vfs structure version */</comment>
		<expr><sizeof>sizeof<argument_list>(<argument><expr><name>winFile</name></expr></argument>)</argument_list></sizeof></expr>,     <comment type="block">/* szOsFile */</comment>
		<expr><name>MAX_PATH</name></expr>,            <comment type="block">/* mxPathName */</comment>
		<expr><name>winOpen</name></expr>,             <comment type="block">/* xOpen */</comment>
		<expr><name>winDelete</name></expr>,           <comment type="block">/* xDelete */</comment>
		<expr><name>winAccess</name></expr>,           <comment type="block">/* xAccess */</comment>
		<expr><name>winFullPathname</name></expr>,     <comment type="block">/* xFullPathname */</comment>
		<expr><literal type="number">0</literal></expr>,                   <comment type="block">/* xTmp */</comment>
		<expr><name>winSleep</name></expr>,            <comment type="block">/* xSleep */</comment>
		<expr><name>winCurrentTime</name></expr>,      <comment type="block">/* xCurrentTime */</comment>
		<expr><name>winGetLastError</name></expr>,     <comment type="block">/* xGetLastError */</comment>
	}</block></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>&amp;</operator><name>sWinvfs</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __WINNT__ */</comment>
</unit>
