<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/src/jx9_lib.c"><comment type="block">/*
 * Symisc JX9: A Highly Efficient Embeddable Scripting Engine Based on JSON.
 * Copyright (C) 2012-2013, Symisc Systems http://jx9.symisc.net/
 * Version 1.7.2
 * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES
 * please contact Symisc Systems via:
 *       legal@symisc.net
 *       licensing@symisc.net
 *       contact@symisc.net
 * or visit:
 *      http://jx9.symisc.net/
 */</comment>
 <comment type="block">/* $SymiscID: lib.c v5.1 Win7 2012-08-08 04:19 stable &lt;chm@symisc.net&gt; $ */</comment>
<comment type="block">/*
 * Symisc Run-Time API: A modern thread safe replacement of the standard libc
 * Copyright (C) Symisc Systems 2007-2012, http://www.symisc.net/
 *
 * The Symisc Run-Time API is an independent project developed by symisc systems
 * internally as a secure replacement of the standard libc.
 * The library is re-entrant, thread-safe and platform independent.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_AMALGAMATION</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jx9Int.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WINNT__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Windows.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JX9_ENABLE_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* SyRunTimeApi: sxmutex.c */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WINNT__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>SyMutex</name>
<block>{
	<decl_stmt><decl><type><name>CRITICAL_SECTION</name></type> <name>sMutex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nType</name></decl>;</decl_stmt> <comment type="block">/* Mutex type, one of SXMUTEX_TYPE_* */</comment>
}</block>;</struct>
<comment type="block">/* Preallocated static mutex */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SyMutex</name></type> <name><name>aStaticMutexes</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><name>SXMUTEX_TYPE_STATIC_1</name></expr>}</block></expr>, 
		<expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><name>SXMUTEX_TYPE_STATIC_2</name></expr>}</block></expr>, 
		<expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><name>SXMUTEX_TYPE_STATIC_3</name></expr>}</block></expr>, 
		<expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><name>SXMUTEX_TYPE_STATIC_4</name></expr>}</block></expr>, 
		<expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><name>SXMUTEX_TYPE_STATIC_5</name></expr>}</block></expr>, 
		<expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><name>SXMUTEX_TYPE_STATIC_6</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>winMutexInit</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LONG</name></type> <name>winMutexLock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>WinMutexGlobaInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LONG</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>InterlockedCompareExchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>winMutexLock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>( <expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
		<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name>  <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>aStaticMutexes</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
			<expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aStaticMutexes</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>winMutexInit</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Someone else is doing this for us */</comment>
		<while>while<condition>( <expr><name>winMutexInit</name> <operator>==</operator> <name>FALSE</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>WinMutexGlobalRelease</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LONG</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>InterlockedCompareExchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>winMutexLock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* The first to decrement to zero does the actual global release */</comment>
		<if_stmt><if>if<condition>( <expr><name>winMutexInit</name> <operator>==</operator> <name>TRUE</name></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
			<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>aStaticMutexes</name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr> )</control><block>{<block_content>
				<expr_stmt><expr><call><name>DeleteCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aStaticMutexes</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>winMutexInit</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>SyMutex</name> <modifier>*</modifier></type> <name>WinMutexNew</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nType</name> <operator>==</operator> <name>SXMUTEX_TYPE_FAST</name> <operator>||</operator> <name>nType</name> <operator>==</operator> <name>SXMUTEX_TYPE_RECURSIVE</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Allocate a new mutex */</comment>
		<expr_stmt><expr><name>pMutex</name> <operator>=</operator> <operator>(</operator><name>SyMutex</name> <operator>*</operator><operator>)</operator><call><name>HeapAlloc</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyMutex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pMutex</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMutex</name><operator>-&gt;</operator><name>sMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Use a pre-allocated static mutex */</comment>
		<if_stmt><if>if<condition>( <expr><name>nType</name> <operator>&gt;</operator> <name>SXMUTEX_TYPE_STATIC_6</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nType</name> <operator>=</operator> <name>SXMUTEX_TYPE_STATIC_6</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pMutex</name> <operator>=</operator> <operator>&amp;</operator><name><name>aStaticMutexes</name><index>[<expr><name>nType</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>pMutex</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>nType</name></expr>;</expr_stmt>
	<return>return <expr><name>pMutex</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>WinMutexRelease</name><parameter_list>(<parameter><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name><name>pMutex</name><operator>-&gt;</operator><name>nType</name></name> <operator>==</operator> <name>SXMUTEX_TYPE_FAST</name> <operator>||</operator> <name><name>pMutex</name><operator>-&gt;</operator><name>nType</name></name> <operator>==</operator> <name>SXMUTEX_TYPE_RECURSIVE</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>DeleteCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMutex</name><operator>-&gt;</operator><name>sMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>WinMutexEnter</name><parameter_list>(<parameter><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMutex</name><operator>-&gt;</operator><name>sMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>WinMutexTryEnter</name><parameter_list>(<parameter><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32_WINNT</name></cpp:ifdef>
	<decl_stmt><decl><type><name>BOOL</name></type> <name>rc</name></decl>;</decl_stmt>
	<comment type="block">/* Only WindowsNT platforms */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>TryEnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMutex</name><operator>-&gt;</operator><name>sMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if><else>else<block>{<block_content>
		<return>return <expr><name>SXERR_BUSY</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>SXERR_NOTIMPLEMENTED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>WinMutexLeave</name><parameter_list>(<parameter><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMutex</name><operator>-&gt;</operator><name>sMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* Export Windows mutex interfaces */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>SyMutexMethods</name></type> <name>sWinMutexMethods</name> <init>= <expr><block>{
	<expr><name>WinMutexGlobaInit</name></expr>,  <comment type="block">/* xGlobalInit() */</comment>
	<expr><name>WinMutexGlobalRelease</name></expr>, <comment type="block">/* xGlobalRelease() */</comment>
	<expr><name>WinMutexNew</name></expr>,     <comment type="block">/* xNew() */</comment>
	<expr><name>WinMutexRelease</name></expr>, <comment type="block">/* xRelease() */</comment>
	<expr><name>WinMutexEnter</name></expr>,   <comment type="block">/* xEnter() */</comment>
	<expr><name>WinMutexTryEnter</name></expr>, <comment type="block">/* xTryEnter() */</comment>
	<expr><name>WinMutexLeave</name></expr>     <comment type="block">/* xLeave() */</comment>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>JX9_PRIVATE</name> <specifier>const</specifier> <name>SyMutexMethods</name> <modifier>*</modifier></type> <name>SyMutexExportMethods</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>sWinMutexMethods</name></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__UNIXES__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<struct>struct <name>SyMutex</name>
<block>{
	<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>sMutex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nType</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>SyMutex</name> <modifier>*</modifier></type> <name>UnixMutexNew</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>SyMutex</name></type> <name><name>aStaticMutexes</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>, <expr><name>SXMUTEX_TYPE_STATIC_1</name></expr>}</block></expr>, 
		<expr><block>{<expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>, <expr><name>SXMUTEX_TYPE_STATIC_2</name></expr>}</block></expr>, 
		<expr><block>{<expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>, <expr><name>SXMUTEX_TYPE_STATIC_3</name></expr>}</block></expr>, 
		<expr><block>{<expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>, <expr><name>SXMUTEX_TYPE_STATIC_4</name></expr>}</block></expr>, 
		<expr><block>{<expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>, <expr><name>SXMUTEX_TYPE_STATIC_5</name></expr>}</block></expr>, 
		<expr><block>{<expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>, <expr><name>SXMUTEX_TYPE_STATIC_6</name></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl>;</decl_stmt>
	
	<if_stmt><if>if<condition>( <expr><name>nType</name> <operator>==</operator> <name>SXMUTEX_TYPE_FAST</name> <operator>||</operator> <name>nType</name> <operator>==</operator> <name>SXMUTEX_TYPE_RECURSIVE</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>pthread_mutexattr_t</name></type> <name>sRecursiveAttr</name></decl>;</decl_stmt>
  		<comment type="block">/* Allocate a new mutex */</comment>
  		<expr_stmt><expr><name>pMutex</name> <operator>=</operator> <operator>(</operator><name>SyMutex</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyMutex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  		<if_stmt><if>if<condition>( <expr><name>pMutex</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
  			<return>return <expr><literal type="number">0</literal></expr>;</return>
  		</block_content>}</block></if></if_stmt>
  		<if_stmt><if>if<condition>( <expr><name>nType</name> <operator>==</operator> <name>SXMUTEX_TYPE_RECURSIVE</name></expr> )</condition><block>{<block_content>
  			<expr_stmt><expr><call><name>pthread_mutexattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRecursiveAttr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  			<expr_stmt><expr><call><name>pthread_mutexattr_settype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRecursiveAttr</name></expr></argument>, <argument><expr><name>PTHREAD_MUTEX_RECURSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  		</block_content>}</block></if></if_stmt>
  		<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMutex</name><operator>-&gt;</operator><name>sMutex</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>nType</name> <operator>==</operator> <name>SXMUTEX_TYPE_RECURSIVE</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>sRecursiveAttr</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(	<expr><name>nType</name> <operator>==</operator> <name>SXMUTEX_TYPE_RECURSIVE</name></expr> )</condition><block>{<block_content>
   			<expr_stmt><expr><call><name>pthread_mutexattr_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sRecursiveAttr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Use a pre-allocated static mutex */</comment>
		<if_stmt><if>if<condition>( <expr><name>nType</name> <operator>&gt;</operator> <name>SXMUTEX_TYPE_STATIC_6</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nType</name> <operator>=</operator> <name>SXMUTEX_TYPE_STATIC_6</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pMutex</name> <operator>=</operator> <operator>&amp;</operator><name><name>aStaticMutexes</name><index>[<expr><name>nType</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pMutex</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>nType</name></expr>;</expr_stmt>
  
  <return>return <expr><name>pMutex</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>UnixMutexRelease</name><parameter_list>(<parameter><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name><name>pMutex</name><operator>-&gt;</operator><name>nType</name></name> <operator>==</operator> <name>SXMUTEX_TYPE_FAST</name> <operator>||</operator> <name><name>pMutex</name><operator>-&gt;</operator><name>nType</name></name> <operator>==</operator> <name>SXMUTEX_TYPE_RECURSIVE</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMutex</name><operator>-&gt;</operator><name>sMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>UnixMutexEnter</name><parameter_list>(<parameter><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMutex</name><operator>-&gt;</operator><name>sMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>UnixMutexLeave</name><parameter_list>(<parameter><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMutex</name><operator>-&gt;</operator><name>sMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* Export pthread mutex interfaces */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>SyMutexMethods</name></type> <name>sPthreadMutexMethods</name> <init>= <expr><block>{
	<expr><literal type="number">0</literal></expr>, <comment type="block">/* xGlobalInit() */</comment>
	<expr><literal type="number">0</literal></expr>, <comment type="block">/* xGlobalRelease() */</comment>
	<expr><name>UnixMutexNew</name></expr>,      <comment type="block">/* xNew() */</comment>
	<expr><name>UnixMutexRelease</name></expr>,  <comment type="block">/* xRelease() */</comment>
	<expr><name>UnixMutexEnter</name></expr>,    <comment type="block">/* xEnter() */</comment>
	<expr><literal type="number">0</literal></expr>,                 <comment type="block">/* xTryEnter() */</comment>
	<expr><name>UnixMutexLeave</name></expr>     <comment type="block">/* xLeave() */</comment>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>JX9_PRIVATE</name> <specifier>const</specifier> <name>SyMutexMethods</name> <modifier>*</modifier></type> <name>SyMutexExportMethods</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>sPthreadMutexMethods</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Host application must register their own mutex subsystem if the target
 * platform is not an UNIX-like or windows systems.
 */</comment>
<struct>struct <name>SyMutex</name>
<block>{
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nType</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>SyMutex</name> <modifier>*</modifier></type> <name>DummyMutexNew</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>SyMutex</name></type> <name>sMutex</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>nType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name>sMutex</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>DummyMutexRelease</name><parameter_list>(<parameter><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>DummyMutexEnter</name><parameter_list>(<parameter><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>DummyMutexLeave</name><parameter_list>(<parameter><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* Export the dummy mutex interfaces */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>SyMutexMethods</name></type> <name>sDummyMutexMethods</name> <init>= <expr><block>{
	<expr><literal type="number">0</literal></expr>, <comment type="block">/* xGlobalInit() */</comment>
	<expr><literal type="number">0</literal></expr>, <comment type="block">/* xGlobalRelease() */</comment>
	<expr><name>DummyMutexNew</name></expr>,      <comment type="block">/* xNew() */</comment>
	<expr><name>DummyMutexRelease</name></expr>,  <comment type="block">/* xRelease() */</comment>
	<expr><name>DummyMutexEnter</name></expr>,    <comment type="block">/* xEnter() */</comment>
	<expr><literal type="number">0</literal></expr>,                  <comment type="block">/* xTryEnter() */</comment>
	<expr><name>DummyMutexLeave</name></expr>     <comment type="block">/* xLeave() */</comment>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>JX9_PRIVATE</name> <specifier>const</specifier> <name>SyMutexMethods</name> <modifier>*</modifier></type> <name>SyMutexExportMethods</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>sDummyMutexMethods</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __WINNT__ */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_ENABLE_THREADS */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>SyOSHeapAlloc</name><parameter_list>(<parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WINNT__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>HeapAlloc</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>SyOSHeapRealloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WINNT__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>HeapReAlloc</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>pNew</name></expr>;</return>	
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SyOSHeapFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WINNT__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>HeapFree</name><argument_list>(<argument><expr><call><name>GetProcessHeap</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<comment type="block">/* SyRunTimeApi:sxstr.c */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxu32</name></type> <name>SyStrlen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>zSrc</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>	
	</block_content>}</block></for>
	<return>return <expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <name>zSrc</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyByteFind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>sxi32</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>zStr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt><if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pPos</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <name>zStr</name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt><if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pPos</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <name>zStr</name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt><if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pPos</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <name>zStr</name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt><if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pPos</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <name>zStr</name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyByteFind2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>sxi32</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>zStr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>( <init>;</init><condition>;</condition> <incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><name><name>zEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pPos</name> <operator>=</operator>  <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name>zIn</name><operator>)</operator></expr>;</expr_stmt></block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zEnd</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><name><name>zEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pPos</name> <operator>=</operator>  <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name>zIn</name><operator>)</operator></expr>;</expr_stmt></block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zEnd</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><name><name>zEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pPos</name> <operator>=</operator>  <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name>zIn</name><operator>)</operator></expr>;</expr_stmt></block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zEnd</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zEnd</name> <operator>&lt;</operator> <name>zIn</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><name><name>zEnd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pPos</name> <operator>=</operator>  <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name>zIn</name><operator>)</operator></expr>;</expr_stmt></block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zEnd</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return> 
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyByteListFind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zList</name></decl></parameter>, <parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pFirstPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>zSrc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>c</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt>	<for>for<control>(<init><expr><name>zPtr</name> <operator>=</operator> <name>zList</name></expr> ;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>zPtr</name><operator>++</operator></expr></incr> )</control><block>{<block_content> <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pFirstPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pFirstPos</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <name>zSrc</name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> </block_content>}</block></for> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt>	<for>for<control>(<init><expr><name>zPtr</name> <operator>=</operator> <name>zList</name></expr> ;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>zPtr</name><operator>++</operator></expr></incr> )</control><block>{<block_content> <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pFirstPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pFirstPos</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <name>zSrc</name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> </block_content>}</block></for> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt>	<for>for<control>(<init><expr><name>zPtr</name> <operator>=</operator> <name>zList</name></expr> ;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>zPtr</name><operator>++</operator></expr></incr> )</control><block>{<block_content> <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pFirstPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pFirstPos</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <name>zSrc</name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> </block_content>}</block></for> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt>	<for>for<control>(<init><expr><name>zPtr</name> <operator>=</operator> <name>zList</name></expr> ;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>zPtr</name><operator>++</operator></expr></incr> )</control><block>{<block_content> <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pFirstPos</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pFirstPos</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <name>zSrc</name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> </block_content>}</block></for> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>	
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return> 
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JX9_DISABLE_BUILTIN_FUNC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyStrncmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRight</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zP</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zLeft</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zQ</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zRight</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zP</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zQ</name></expr></argument>)</argument_list></call></expr>  )</condition><block>{<block_content>
			<return>return <expr><ternary><condition><expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zP</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zQ</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr> </then><else>:<expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><name><name>zP</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zQ</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zP</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>zQ</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zP</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zQ</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nLen</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><name><name>zP</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zQ</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zP</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>zQ</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zP</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zQ</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nLen</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><name><name>zP</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zQ</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zP</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>zQ</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zP</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zQ</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nLen</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><name><name>zP</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zQ</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zP</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>zQ</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zP</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zQ</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nLen</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><operator>(</operator><name>sxi32</name><operator>)</operator><operator>(</operator><name><name>zP</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>zQ</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>	
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyStrnicmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRight</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>SLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  	<decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zLeft</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zRight</name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><ternary><condition><expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><ternary><condition><expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr> </then><else>:<expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name>SLen</name></expr> )</condition><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt><if_stmt><if>if<condition>( <expr><operator>!</operator><operator>*</operator><name>p</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>q</name> <operator>||</operator> <call><name>SyCharToLower</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>SyCharToLower</name><argument_list>(<argument><expr><operator>*</operator><name>q</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt><expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt><expr_stmt><expr><name>q</name><operator>++</operator></expr>;</expr_stmt><expr_stmt><expr><operator>--</operator><name>SLen</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name>SLen</name></expr> )</condition><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt><if_stmt><if>if<condition>( <expr><operator>!</operator><operator>*</operator><name>p</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>q</name> <operator>||</operator> <call><name>SyCharToLower</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>SyCharToLower</name><argument_list>(<argument><expr><operator>*</operator><name>q</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt><expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt><expr_stmt><expr><name>q</name><operator>++</operator></expr>;</expr_stmt><expr_stmt><expr><operator>--</operator><name>SLen</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name>SLen</name></expr> )</condition><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt><if_stmt><if>if<condition>( <expr><operator>!</operator><operator>*</operator><name>p</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>q</name> <operator>||</operator> <call><name>SyCharToLower</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>SyCharToLower</name><argument_list>(<argument><expr><operator>*</operator><name>q</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt><expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt><expr_stmt><expr><name>q</name><operator>++</operator></expr>;</expr_stmt><expr_stmt><expr><operator>--</operator><name>SLen</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><operator>!</operator><name>SLen</name></expr> )</condition><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt><if_stmt><if>if<condition>( <expr><operator>!</operator><operator>*</operator><name>p</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>q</name> <operator>||</operator> <call><name>SyCharToLower</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>SyCharToLower</name><argument_list>(<argument><expr><operator>*</operator><name>q</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt><expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt><expr_stmt><expr><name>q</name><operator>++</operator></expr>;</expr_stmt><expr_stmt><expr><operator>--</operator><name>SLen</name></expr>;</expr_stmt>
		
	</block_content>}</block></for>
	<return>return <expr><operator>(</operator><name>sxi32</name><operator>)</operator><operator>(</operator><call><name>SyCharToLower</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>SyCharToLower</name><argument_list>(<argument><expr><name><name>q</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxu32</name></type> <name>Systrcpy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zDest</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nDestLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBuf</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zDest</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zSrc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>==</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>zDest</name></expr> )</condition><block>{<block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nLen</name> <operator>=</operator> <call><name>SyStrlen</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>nDestLen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <comment type="block">/* reserve a room for the null terminator */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zBuf</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <name>nLen</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zBuf</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nLen</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zBuf</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <name>nLen</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zBuf</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nLen</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zBuf</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <name>nLen</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zBuf</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nLen</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zBuf</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <name>nLen</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zBuf</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nLen</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zBuf</name><operator>-</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zDest</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* SyRunTimeApi:sxmem.c */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SyZero</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zSrc</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pSrc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return ;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>nSize</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyMemcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pB1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pB2</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pB1</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pB2</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><ternary><condition><expr><name>pB1</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>pB2</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SX_MACRO_FAST_CMP</name><argument_list>(<argument><expr><name>pB1</name></expr></argument>, <argument><expr><name>pB2</name></expr></argument>, <argument><expr><name>nSize</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxu32</name></type> <name>SyMemcpy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>pSrc</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pDest</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pSrc</name> <operator>==</operator> <operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>pDest</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>nLen</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SX_MACRO_FAST_MEMCPY</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nLen</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>MemOSAlloc</name><parameter_list>(<parameter><decl><type><name>sxu32</name></type> <name>nBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pChunk</name> <operator>=</operator> <operator>(</operator><name>sxu32</name> <operator>*</operator><operator>)</operator><call><name>SyOSHeapAlloc</name><argument_list>(<argument><expr><name>nBytes</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pChunk</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pChunk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nBytes</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pChunk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>MemOSRealloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pOldChunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pOldChunk</name> <operator>=</operator> <operator>(</operator><name>sxu32</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pOld</name><operator>)</operator><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pOldChunk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <name>nBytes</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>pOld</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pChunk</name> <operator>=</operator> <operator>(</operator><name>sxu32</name> <operator>*</operator><operator>)</operator><call><name>SyOSHeapRealloc</name><argument_list>(<argument><expr><name>pOldChunk</name></expr></argument>, <argument><expr><name>nBytes</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pChunk</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pChunk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nBytes</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pChunk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>MemOSFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pChunk</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pBlock</name><operator>)</operator><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyOSHeapFree</name><argument_list>(<argument><expr><name>pChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxu32</name></type> <name>MemOSChunkSize</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pChunk</name> <operator>=</operator> <operator>(</operator><name>sxu32</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pBlock</name><operator>)</operator><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name><name>pChunk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Export OS allocation methods */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>SyMemMethods</name></type> <name>sOSAllocMethods</name> <init>= <expr><block>{
	<expr><name>MemOSAlloc</name></expr>, 
	<expr><name>MemOSRealloc</name></expr>, 
	<expr><name>MemOSFree</name></expr>, 
	<expr><name>MemOSChunkSize</name></expr>, 
	<expr><literal type="number">0</literal></expr>, 
	<expr><literal type="number">0</literal></expr>, 
	<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>MemBackendAlloc</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyMemBlock</name> <modifier>*</modifier></type><name>pBlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>nRetry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Append an extra block so we can tracks allocated chunks and avoid memory
	 * leaks.
	 */</comment>
	<expr_stmt><expr><name>nByte</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyMemBlock</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<expr_stmt><expr><name>pBlock</name> <operator>=</operator> <operator>(</operator><name>SyMemBlock</name> <operator>*</operator><operator>)</operator><call><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xAlloc</name></name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pBlock</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pBackend</name><operator>-&gt;</operator><name>xMemError</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nRetry</name> <operator>&gt;</operator> <name>SXMEM_BACKEND_RETRY</name> 
			<operator>||</operator> <name>SXERR_RETRY</name> <operator>!=</operator> <call><name><name>pBackend</name><operator>-&gt;</operator><name>xMemError</name></name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nRetry</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name>pBlock</name>  <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Link to the list of already tracked blocks */</comment>
	<expr_stmt><expr><call><name>MACRO_LD_PUSH</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pBlocks</name></name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>nGuard</name></name> <operator>=</operator> <name>SXMEM_BACKEND_MAGIC</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pBlock</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name> <modifier>*</modifier></type> <name>SyMemBackendAlloc</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SXMEM_BACKEND_CORRUPT</name><argument_list>(<argument><expr><name>pBackend</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexEnter</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pChunk</name> <operator>=</operator> <call><name>MemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexLeave</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>pChunk</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>MemBackendRealloc</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pOld</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyMemBlock</name> <modifier>*</modifier></type><name>pBlock</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNew</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pPrev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nRetry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>( <expr><name>pOld</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><call><name>MemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pBlock</name> <operator>=</operator> <operator>(</operator><name>SyMemBlock</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pOld</name><operator>)</operator> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyMemBlock</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name><name>pBlock</name><operator>-&gt;</operator><name>nGuard</name></name> <operator>!=</operator> <name>SXMEM_BACKEND_MAGIC</name></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>nByte</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyMemBlock</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>pPrev</name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>SyMemBlock</name> <operator>*</operator><operator>)</operator><call><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRealloc</name></name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pNew</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pBackend</name><operator>-&gt;</operator><name>xMemError</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nRetry</name> <operator>&gt;</operator> <name>SXMEM_BACKEND_RETRY</name> <operator>||</operator>
			<name>SXERR_RETRY</name> <operator>!=</operator> <call><name><name>pBackend</name><operator>-&gt;</operator><name>xMemError</name></name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
				<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nRetry</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name>pNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNew</name> <operator>!=</operator> <name>pBlock</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pPrev</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pBlocks</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>pNext</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pNext</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nGuard</name></name> <operator>=</operator> <name>SXMEM_BACKEND_MAGIC</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name> <modifier>*</modifier></type> <name>SyMemBackendRealloc</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pOld</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SXMEM_BACKEND_CORRUPT</name><argument_list>(<argument><expr><name>pBackend</name></expr></argument>)</argument_list></call></expr>  )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexEnter</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pChunk</name> <operator>=</operator> <call><name>MemBackendRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexLeave</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>pChunk</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>MemBackendFree</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pChunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyMemBlock</name> <modifier>*</modifier></type><name>pBlock</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pBlock</name> <operator>=</operator> <operator>(</operator><name>SyMemBlock</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pChunk</name><operator>)</operator> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyMemBlock</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name><name>pBlock</name><operator>-&gt;</operator><name>nGuard</name></name> <operator>!=</operator> <name>SXMEM_BACKEND_MAGIC</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Unlink from the list of active blocks */</comment>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Release the block */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<comment type="block">/* Mark as stale block */</comment>
		<expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>nGuard</name></name> <operator>=</operator> <literal type="number">0x635B</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>MACRO_LD_REMOVE</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pBlocks</name></name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFree</name></name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyMemBackendFree</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pChunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SXMEM_BACKEND_CORRUPT</name><argument_list>(<argument><expr><name>pBackend</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name>pChunk</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexEnter</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>MemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>pChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexLeave</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JX9_ENABLE_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyMemBackendMakeThreadSafe</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SyMutexMethods</name> <modifier>*</modifier></type><name>pMethods</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyMutex</name> <modifier>*</modifier></type><name>pMutex</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SXMEM_BACKEND_CORRUPT</name><argument_list>(<argument><expr><name>pBackend</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>pMethods</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pMethods</name><operator>-&gt;</operator><name>xNew</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>pMutex</name> <operator>=</operator> <call><name><name>pMethods</name><operator>-&gt;</operator><name>xNew</name></name><argument_list>(<argument><expr><name>SXMUTEX_TYPE_FAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pMutex</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_OS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Attach the mutex to the memory backend */</comment>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name> <operator>=</operator> <name>pMutex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name> <operator>=</operator> <name>pMethods</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyMemBackendDisbaleMutexing</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SXMEM_BACKEND_CORRUPT</name><argument_list>(<argument><expr><name>pBackend</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* There is no mutex subsystem at all */</comment>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyMutexRelease</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Memory pool allocator
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXMEM_POOL_MAGIC</name></cpp:macro>		<cpp:value>0xDEAD</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXMEM_POOL_MAXALLOC</name></cpp:macro>		<cpp:value>(1&lt;&lt;(SXMEM_POOL_NBUCKETS+SXMEM_POOL_INCR))</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXMEM_POOL_MINALLOC</name></cpp:macro>		<cpp:value>(1&lt;&lt;(SXMEM_POOL_INCR))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>MemPoolBucketAlloc</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nBucket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBucket</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zBucketEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyMemHeader</name> <modifier>*</modifier></type><name>pHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nBucketSize</name></decl>;</decl_stmt>
	
	<comment type="block">/* Allocate one big block first */</comment>
	<expr_stmt><expr><name>zBucket</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>MemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>SXMEM_POOL_MAXALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>zBucket</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zBucketEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBucket</name><index>[<expr><name>SXMEM_POOL_MAXALLOC</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Divide the big block into mini bucket pool */</comment>
	<expr_stmt><expr><name>nBucketSize</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>nBucket</name> <operator>+</operator> <name>SXMEM_POOL_INCR</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>apPool</name><index>[<expr><name>nBucket</name></expr>]</index></name> <operator>=</operator> <name>pHeader</name> <operator>=</operator> <operator>(</operator><name>SyMemHeader</name> <operator>*</operator><operator>)</operator><name>zBucket</name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>&amp;</operator><name><name>zBucket</name><index>[<expr><name>nBucketSize</name></expr>]</index></name> <operator>&gt;=</operator> <name>zBucketEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <operator>(</operator><name>SyMemHeader</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zBucket</name><index>[<expr><name>nBucketSize</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Advance the cursor to the next available chunk */</comment>
		<expr_stmt><expr><name>pHeader</name> <operator>=</operator> <name><name>pHeader</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>zBucket</name> <operator>+=</operator> <name>nBucketSize</name></expr>;</expr_stmt>	
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>MemBackendPoolAlloc</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyMemHeader</name> <modifier>*</modifier></type><name>pBucket</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nBucketSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nBucket</name></decl>;</decl_stmt>

	<if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyMemHeader</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name>SXMEM_POOL_MAXALLOC</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Allocate a big chunk directly */</comment>
		<expr_stmt><expr><name>pBucket</name> <operator>=</operator> <operator>(</operator><name>SyMemHeader</name> <operator>*</operator><operator>)</operator><call><name>MemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>nByte</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SyMemHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pBucket</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Record as big block */</comment>
		<expr_stmt><expr><name><name>pBucket</name><operator>-&gt;</operator><name>nBucket</name></name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>SXMEM_POOL_MAGIC</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name>SXU16_HIGH</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>pBucket</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Locate the appropriate bucket */</comment>
	<expr_stmt><expr><name>nBucket</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nBucketSize</name> <operator>=</operator> <name>SXMEM_POOL_MINALLOC</name></expr>;</expr_stmt>
	<while>while<condition>( <expr><name>nByte</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyMemHeader</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>nBucketSize</name></expr>  )</condition><block>{<block_content>
		<expr_stmt><expr><name>nBucketSize</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nBucket</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>pBucket</name> <operator>=</operator> <name><name>pBackend</name><operator>-&gt;</operator><name>apPool</name><index>[<expr><name>nBucket</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pBucket</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>MemPoolBucketAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>nBucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pBucket</name> <operator>=</operator> <name><name>pBackend</name><operator>-&gt;</operator><name>apPool</name><index>[<expr><name>nBucket</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Remove from the free list */</comment>
	<expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pBucket</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>apPool</name><index>[<expr><name>nBucket</name></expr>]</index></name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
	<comment type="block">/* Record bucket&amp;magic number */</comment>
	<expr_stmt><expr><name><name>pBucket</name><operator>-&gt;</operator><name>nBucket</name></name> <operator>=</operator> <operator>(</operator><name>SXMEM_POOL_MAGIC</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name>nBucket</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pBucket</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name> <modifier>*</modifier></type> <name>SyMemBackendPoolAlloc</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SXMEM_BACKEND_CORRUPT</name><argument_list>(<argument><expr><name>pBackend</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexEnter</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pChunk</name> <operator>=</operator> <call><name>MemBackendPoolAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexLeave</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>pChunk</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>MemBackendPoolFree</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pChunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyMemHeader</name> <modifier>*</modifier></type><name>pHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nBucket</name></decl>;</decl_stmt>
	<comment type="block">/* Get the corresponding bucket */</comment>
	<expr_stmt><expr><name>pHeader</name> <operator>=</operator> <operator>(</operator><name>SyMemHeader</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pChunk</name><operator>)</operator> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyMemHeader</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* Sanity check to avoid misuse */</comment>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pHeader</name><operator>-&gt;</operator><name>nBucket</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>!=</operator> <name>SXMEM_POOL_MAGIC</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>nBucket</name> <operator>=</operator> <name><name>pHeader</name><operator>-&gt;</operator><name>nBucket</name></name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>nBucket</name> <operator>==</operator> <name>SXU16_HIGH</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Free the big block */</comment>
		<expr_stmt><expr><call><name>MemBackendFree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>pHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<comment type="block">/* Return to the free list */</comment>
		<expr_stmt><expr><name><name>pHeader</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pBackend</name><operator>-&gt;</operator><name>apPool</name><index>[<expr><name>nBucket</name> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>apPool</name><index>[<expr><name>nBucket</name> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr>]</index></name> <operator>=</operator> <name>pHeader</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyMemBackendPoolFree</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pChunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SXMEM_BACKEND_CORRUPT</name><argument_list>(<argument><expr><name>pBackend</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>pChunk</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexEnter</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>MemBackendPoolFree</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>pChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexLeave</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void * MemBackendPoolRealloc(SyMemBackend *pBackend, void * pOld, sxu32 nByte)
{
	sxu32 nBucket, nBucketSize;
	SyMemHeader *pHeader;
	void * pNew;

	if( pOld == 0 ){
		<comment type="block">/* Allocate a new pool */</comment>
		pNew = MemBackendPoolAlloc(&amp;(*pBackend), nByte);
		return pNew;
	}
	<comment type="block">/* Get the corresponding bucket */</comment>
	pHeader = (SyMemHeader *)(((char *)pOld) - sizeof(SyMemHeader));
	<comment type="block">/* Sanity check to avoid misuse */</comment>
	if( (pHeader-&gt;nBucket &gt;&gt; 16) != SXMEM_POOL_MAGIC ){
		return 0;
	}
	nBucket = pHeader-&gt;nBucket &amp; 0xFFFF;
	if( nBucket == SXU16_HIGH ){
		<comment type="block">/* Big block */</comment>
		return MemBackendRealloc(&amp;(*pBackend), pHeader, nByte);
	}
	nBucketSize = 1 &lt;&lt; (nBucket + SXMEM_POOL_INCR);
	if( nBucketSize &gt;= nByte + sizeof(SyMemHeader) ){
		<comment type="block">/* The old bucket can honor the requested size */</comment>
		return pOld;
	}
	<comment type="block">/* Allocate a new pool */</comment>
	pNew = MemBackendPoolAlloc(&amp;(*pBackend), nByte);
	if( pNew == 0 ){
		return 0;
	}
	<comment type="block">/* Copy the old data into the new block */</comment>
	SyMemcpy(pOld, pNew, nBucketSize);
	<comment type="block">/* Free the stale block */</comment>
	MemBackendPoolFree(&amp;(*pBackend), pOld);
	return pNew;
}
JX9_PRIVATE void * SyMemBackendPoolRealloc(SyMemBackend *pBackend, void * pOld, sxu32 nByte)
{
	void *pChunk;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	if( SXMEM_BACKEND_CORRUPT(pBackend) ){
		return 0;
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	if( pBackend-&gt;pMutexMethods ){
		SyMutexEnter(pBackend-&gt;pMutexMethods, pBackend-&gt;pMutex);
	}
	pChunk = MemBackendPoolRealloc(&amp;(*pBackend), pOld, nByte);
	if( pBackend-&gt;pMutexMethods ){
		SyMutexLeave(pBackend-&gt;pMutexMethods, pBackend-&gt;pMutex);
	}
	return pChunk;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyMemBackendInit</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><name>ProcMemError</name></type> <name>xMemErr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>pBackend</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Zero the allocator first */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyMemBackend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>xMemError</name></name> <operator>=</operator> <name>xMemErr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pUserData</name></expr>;</expr_stmt>
	<comment type="block">/* Switch to the OS memory allocator */</comment>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>sOSAllocMethods</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xInit</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Initialize the backend  */</comment>
		<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>!=</operator> <call><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xInit</name></name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <name>SXMEM_BACKEND_MAGIC</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyMemBackendInitFromOthers</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SyMemMethods</name> <modifier>*</modifier></type><name>pMethods</name></decl></parameter>, <parameter><decl><type><name>ProcMemError</name></type> <name>xMemErr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>pBackend</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pMethods</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name><name>pMethods</name><operator>-&gt;</operator><name>xAlloc</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pMethods</name><operator>-&gt;</operator><name>xRealloc</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pMethods</name><operator>-&gt;</operator><name>xFree</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pMethods</name><operator>-&gt;</operator><name>xChunkSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* mandatory methods are missing */</comment>
		<return>return <expr><name>SXERR_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the allocator first */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyMemBackend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>xMemError</name></name> <operator>=</operator> <name>xMemErr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pUserData</name></expr>;</expr_stmt>
	<comment type="block">/* Switch to the host application memory allocator */</comment>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <name>pMethods</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xInit</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Initialize the backend  */</comment>
		<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>!=</operator> <call><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xInit</name></name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <name>SXMEM_BACKEND_MAGIC</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyMemBackendInitFromParent</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>SyMemBackend</name> <modifier>*</modifier></type><name>pParent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu8</name></type> <name>bInheritMutex</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>pBackend</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>SXMEM_BACKEND_CORRUPT</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Zero the allocator first */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyMemBackend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name></name>  <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>xMemError</name></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>xMemError</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pUserData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bInheritMutex</name> <operator>=</operator> <ternary><condition><expr><name><name>pParent</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>bInheritMutex</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr>;</expr_stmt>
		<comment type="block">/* Create a private mutex */</comment>
		<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name> <operator>=</operator> <call><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name><operator>-&gt;</operator><name>xNew</name></name><argument_list>(<argument><expr><name>SXMUTEX_TYPE_FAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name> <operator>==</operator>  <literal type="number">0</literal></expr>)</condition><block>{<block_content>
			<return>return <expr><name>SXERR_OS</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <name>SXMEM_BACKEND_MAGIC</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>MemBackendRelease</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyMemBlock</name> <modifier>*</modifier></type><name>pBlock</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pBlock</name> <operator>=</operator> <name><name>pBackend</name><operator>-&gt;</operator><name>pBlocks</name></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pNext</name>  <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFree</name></name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pBlock</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name><operator>--</operator></expr>;</expr_stmt>
		<comment type="block">/* LOOP ONE */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pNext</name>  <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFree</name></name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pBlock</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name><operator>--</operator></expr>;</expr_stmt>
		<comment type="block">/* LOOP TWO */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pNext</name>  <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFree</name></name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pBlock</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name><operator>--</operator></expr>;</expr_stmt>
		<comment type="block">/* LOOP THREE */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pNext</name>  <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFree</name></name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pBlock</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>nBlock</name></name><operator>--</operator></expr>;</expr_stmt>
		<comment type="block">/* LOOP FOUR */</comment>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRelease</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRelease</name></name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pBlocks</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>pBackend</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <literal type="number">0x2626</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyMemBackendRelease</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SXMEM_BACKEND_CORRUPT</name><argument_list>(<argument><expr><name>pBackend</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexEnter</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>MemBackendRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMutexLeave</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyMutexRelease</name><argument_list>(<argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutexMethods</name></name></expr></argument>, <argument><expr><name><name>pBackend</name><operator>-&gt;</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name> <modifier>*</modifier></type> <name>SyMemBackendDup</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>pSrc</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>char</name> <modifier>*</modifier></type> <name>SyMemBackendStrDup</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pBackend</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDest</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>zDest</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBackend</name><operator>)</operator></expr></argument>, <argument><expr><name>nSize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>zDest</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>Systrcpy</name><argument_list>(<argument><expr><name>zDest</name></expr></argument>, <argument><expr><name>nSize</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zSrc</name></expr></argument>, <argument><expr><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>zDest</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobInitFromBuf</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>pBlob</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pBuffer</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nSize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <name>pBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>=</operator> <name>nSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pAllocator</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nFlags</name></name> <operator>=</operator> <name>SXBLOB_LOCKED</name><operator>|</operator><name>SXBLOB_STATIC</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobInit</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pAllocator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>pBlob</name> <operator>==</operator> <literal type="number">0</literal></expr>  )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name>	<operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pAllocator</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pAllocator</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobReadOnly</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>pBlob</name> <operator>==</operator> <literal type="number">0</literal></expr>  )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nFlags</name></name> <operator>|=</operator> <name>SXBLOB_RDONLY</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SXBLOB_MIN_GROWTH</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXBLOB_MIN_GROWTH</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>BlobPrepareGrow</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nByte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>*</operator><name>pByte</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBlob</name><operator>-&gt;</operator><name>nFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SXBLOB_LOCKED</name><operator>|</operator><name>SXBLOB_STATIC</name><operator>)</operator></expr> )</condition><block>{<block_content>
		<if_stmt><if>if <condition>( <expr><call><name>SyBlobFreeSpace</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>nByte</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>pByte</name> <operator>=</operator> <call><name>SyBlobFreeSpace</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pByte</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_SHORT</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBlob</name><operator>-&gt;</operator><name>nFlags</name></name> <operator>&amp;</operator> <name>SXBLOB_RDONLY</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Make a copy of the read-only item */</comment>
		<if_stmt><if>if<condition>( <expr><name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>SyMemBackendDup</name><argument_list>(<argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name></expr></argument>, <argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_MEM</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Remove the read-only flag */</comment>
		<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SXBLOB_RDONLY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>SyBlobFreeSpace</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>nByte</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>nByte</name> <operator>+</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <name>SXBLOB_MIN_GROWTH</name></expr>;</expr_stmt>
	</block_content>}</block></if><if type="elseif">else if <condition>( <expr><name>nByte</name> <operator>&lt;</operator> <name>SXBLOB_MIN_GROWTH</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>SXBLOB_MIN_GROWTH</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>SyMemBackendRealloc</name><argument_list>(<argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobAppend</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu8</name> <modifier>*</modifier></type><name>zBlob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nSize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>BlobPrepareGrow</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBlob</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>!=</operator> <name>rc</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pData</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zBlob</name> <operator>=</operator> <operator>(</operator><name>sxu8</name> <operator>*</operator><operator>)</operator><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name></expr> ;</expr_stmt>
		<expr_stmt><expr><name>zBlob</name> <operator>=</operator> <operator>&amp;</operator><name><name>zBlob</name><index>[<expr><name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name> <operator>+=</operator> <name>nSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SX_MACRO_FAST_MEMCPY</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>zBlob</name></expr></argument>, <argument><expr><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobNullAppend</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBlob</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><literal type="string">"\0"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobDup</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name> <init>= <expr><name>SXRET_OK</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nByte</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pDest</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pBlob</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobReset</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pBlob</name><operator>-&gt;</operator><name>nFlags</name></name> <operator>&amp;</operator> <name>SXBLOB_RDONLY</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Read-only (Not malloced chunk) */</comment>
		<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SXBLOB_RDONLY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobTruncate</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nNewLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>nNewLen</name> <operator>&lt;</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <name>nNewLen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobRelease</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pBlob</name><operator>-&gt;</operator><name>nFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SXBLOB_STATIC</name><operator>|</operator><name>SXBLOB_RDONLY</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>mByte</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobSearch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pPattern</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>pLen</name></decl></parameter>, <parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pOfft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pBlob</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>pLen</name> <operator>&gt;</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name><operator>-</operator><name>pLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><call><name>SX_MACRO_FAST_CMP</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>pPattern</name></expr></argument>, <argument><expr><name>pLen</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pOfft</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pOfft</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pBlob</name><operator>)</operator></expr>;</expr_stmt></block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><call><name>SX_MACRO_FAST_CMP</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>pPattern</name></expr></argument>, <argument><expr><name>pLen</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pOfft</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pOfft</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pBlob</name><operator>)</operator></expr>;</expr_stmt></block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><call><name>SX_MACRO_FAST_CMP</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>pPattern</name></expr></argument>, <argument><expr><name>pLen</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pOfft</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pOfft</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pBlob</name><operator>)</operator></expr>;</expr_stmt></block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><call><name>SX_MACRO_FAST_CMP</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>pPattern</name></expr></argument>, <argument><expr><name>pLen</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content> <if_stmt><if>if<condition>( <expr><name>pOfft</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pOfft</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zIn</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pBlob</name><operator>)</operator></expr>;</expr_stmt></block_content>}</block></if></if_stmt> <return>return <expr><name>SXRET_OK</name></expr>;</return> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
<comment type="block">/* SyRunTimeApi:sxds.c */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SySetInit</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>, <parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pAllocator</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>ElemSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>eSize</name></name> <operator>=</operator> <name>ElemSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>pAllocator</name></name> <operator>=</operator> <name>pAllocator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name> <operator>=</operator>  <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SySetPut</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zbase</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>&gt;=</operator> <name><name>pSet</name><operator>-&gt;</operator><name>nSize</name></name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>pAllocator</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return  <expr><name>SXERR_LOCKED</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>nSize</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>SyMemBackendRealloc</name><argument_list>(<argument><expr><name><name>pSet</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name></expr></argument>, <argument><expr><name><name>pSet</name><operator>-&gt;</operator><name>eSize</name></name> <operator>*</operator> <name><name>pSet</name><operator>-&gt;</operator><name>nSize</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<return>return <expr><name>SXERR_MEM</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nSize</name></name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zbase</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SX_MACRO_FAST_MEMCPY</name><argument_list>(<argument><expr><name>pItem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zbase</name><index>[<expr><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>*</operator> <name><name>pSet</name><operator>-&gt;</operator><name>eSize</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pSet</name><operator>-&gt;</operator><name>eSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>;</expr_stmt>	
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SySetAlloc</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>, <parameter><decl><type><name>sxi32</name></type> <name>nItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>nSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_LOCKED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>nItem</name> <operator>&lt;</operator> <literal type="number">8</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nItem</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name> <operator>=</operator> <call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><name><name>pSet</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name><name>pSet</name><operator>-&gt;</operator><name>eSize</name></name> <operator>*</operator> <name>nItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <name>nItem</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function> 
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SySetReset</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SySetResetCursor</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SySetGetNextEntry</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>&gt;=</operator> <name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Reset cursor */</comment>
		<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>SXERR_EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zSrc</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>SySetBasePtr</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>ppEntry</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ppEntry</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name><name>pSet</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>*</operator> <name><name>pSet</name><operator>-&gt;</operator><name>eSize</name></name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nCursor</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SySetRelease</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name> <init>= <expr><name>SXRET_OK</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>pAllocator</name></name> <operator>&amp;&amp;</operator> <name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name><name>pSet</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name> <modifier>*</modifier></type> <name>SySetPeek</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBase</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zBase</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zBase</name><index>[<expr><operator>(</operator><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>pSet</name><operator>-&gt;</operator><name>eSize</name></name></expr>]</index></name></expr>;</return> 
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name> <modifier>*</modifier></type> <name>SySetPop</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBase</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zBase</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>pData</name> <operator>=</operator>  <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zBase</name><index>[<expr><name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>*</operator> <name><name>pSet</name><operator>-&gt;</operator><name>eSize</name></name></expr>]</index></name></expr>;</expr_stmt> 
	<return>return <expr><name>pData</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name> <modifier>*</modifier></type> <name>SySetAt</name><parameter_list>(<parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBase</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>nIdx</name> <operator>&gt;=</operator> <name><name>pSet</name><operator>-&gt;</operator><name>nUsed</name></name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Out of range */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zBase</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pSet</name><operator>-&gt;</operator><name>pBase</name></name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zBase</name><index>[<expr><name>nIdx</name> <operator>*</operator> <name><name>pSet</name><operator>-&gt;</operator><name>eSize</name></name></expr>]</index></name></expr>;</return> 
</block_content>}</block></function>
<comment type="block">/* Private hash entry */</comment>
<struct>struct <name>SyHashEntry_Pr</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <comment type="block">/* Hash key */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl>;</decl_stmt>    <comment type="block">/* Key length */</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl>;</decl_stmt>  <comment type="block">/* User private data */</comment>
	<comment type="block">/* Private fields */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pNext</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pPrev</name></decl>;</decl_stmt> <comment type="block">/* Next and previous entry in the list */</comment>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pNextCollide</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pPrevCollide</name></decl>;</decl_stmt> <comment type="block">/* Collision list */</comment>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_HASH</name><parameter_list>(<parameter><type><name>H</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((H)-&gt;apBucket == 0)</cpp:value></cpp:define>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyHashInit</name><parameter_list>(<parameter><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pAllocator</name></decl></parameter>, <parameter><decl><type><name>ProcHash</name></type> <name>xHash</name></decl></parameter>, <parameter><decl><type><name>ProcCmp</name></type> <name>xCmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>pHash</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Allocate a new table */</comment>
	<expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>SyHashEntry_Pr</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pAllocator</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyHashEntry_Pr</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>SXHASH_BUCKET_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>apNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>apNew</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyHashEntry_Pr</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>SXHASH_BUCKET_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>pAllocator</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pAllocator</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>xHash</name></name> <operator>=</operator> <ternary><condition><expr><name>xHash</name></expr> ?</condition><then> <expr><name>xHash</name></expr> </then><else>: <expr><name>SyBinHash</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>xCmp</name></name> <operator>=</operator> <ternary><condition><expr><name>xCmp</name></expr> ?</condition><then> <expr><name>xCmp</name></expr> </then><else>: <expr><name>SyMemcmp</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nBucketSize</name></name> <operator>=</operator> <name>SXHASH_BUCKET_SIZE</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyHashRelease</name><parameter_list>(<parameter><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pEntry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>INVALID_HASH</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>  )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pHash</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nEntry</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nBucketSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>pAllocator</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>SyHashEntry_Pr</name> <modifier>*</modifier></type> <name>HashGetEntry</name><parameter_list>(<parameter><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nHash</name> <operator>=</operator> <call><name><name>pHash</name><operator>-&gt;</operator><name>xHash</name></name><argument_list>(<argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pHash</name><operator>-&gt;</operator><name>nBucketSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pEntry</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>==</operator> <name>nHash</name> <operator>&amp;&amp;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>nKeyLen</name></name> <operator>==</operator> <name>nKeyLen</name> <operator>&amp;&amp;</operator> 
			<call><name><name>pHash</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<return>return <expr><name>pEntry</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Entry not found */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>SyHashEntry</name> <modifier>*</modifier></type> <name>SyHashGet</name><parameter_list>(<parameter><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>INVALID_HASH</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name><name>pHash</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>nKeyLen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Don't bother hashing, return immediately */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>HashGetEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pHash</name><operator>)</operator></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pEntry</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>SyHashEntry</name> <operator>*</operator><operator>)</operator><name>pEntry</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashDeleteEntry</name><parameter_list>(<parameter><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCollide</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pHash</name><operator>-&gt;</operator><name>nBucketSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCollide</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name><operator>-&gt;</operator><name>pPrevCollide</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCollide</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>MACRO_LD_REMOVE</name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nEntry</name></name><operator>--</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>ppUserData</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Write a pointer to the user data */</comment>
		<expr_stmt><expr><operator>*</operator><name>ppUserData</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pUserData</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Release the entry */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyHashDeleteEntry</name><parameter_list>(<parameter><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>INVALID_HASH</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>HashGetEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pHash</name><operator>)</operator></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKeyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pEntry</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashDeleteEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pHash</name><operator>)</operator></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>ppUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyHashForEach</name><parameter_list>(<parameter><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><function_decl><type><name>sxi32</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>SyHashEntry</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>INVALID_HASH</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>xStep</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pHash</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
		<comment type="block">/* Invoke the callback */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xStep</name><argument_list>(<argument><expr><operator>(</operator><name>SyHashEntry</name> <operator>*</operator><operator>)</operator><name>pEntry</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashGrowTable</name><parameter_list>(<parameter><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nNewSize</name> <init>= <expr><name><name>pHash</name><operator>-&gt;</operator><name>nBucketSize</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>iBucket</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate a new larger table */</comment>
	<expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>SyHashEntry_Pr</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyHashEntry_Pr</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>apNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Not so fatal, simply a performance hit */</comment>
		<return>return <expr><name>SXRET_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the new table */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>apNew</name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyHashEntry_Pr</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Rehash all entries */</comment>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>pEntry</name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>pList</name></name></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pHash</name><operator>-&gt;</operator><name>nEntry</name></name></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>  )</control><block>{<block_content>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevCollide</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Install in the new bucket */</comment>
		<expr_stmt><expr><name>iBucket</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name>nNewSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCollide</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>apNew</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
		<comment type="block">/* Point to the next entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Release the old table and reflect the change */</comment>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nBucketSize</name></name> <operator>=</operator> <name>nNewSize</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>HashInsert</name><parameter_list>(<parameter><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>iBucket</name> <init>= <expr><name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pHash</name><operator>-&gt;</operator><name>nBucketSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Insert the entry in its corresponding bcuket */</comment>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextCollide</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>iBucket</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>iBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevCollide</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>apBucket</name><index>[<expr><name>iBucket</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
	<comment type="block">/* Link to the entry list */</comment>
	<expr_stmt><expr><call><name>MACRO_LD_PUSH</name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pHash</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>nEntry</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyHashInsert</name><parameter_list>(<parameter><decl><type><name>SyHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nKeyLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyHashEntry_Pr</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>INVALID_HASH</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>pKey</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>( <expr><name><name>pHash</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&gt;=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>nBucketSize</name></name> <operator>*</operator> <name>SXHASH_FILL_FACTOR</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashGrowTable</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pHash</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Allocate a new hash entry */</comment>
	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <operator>(</operator><name>SyHashEntry_Pr</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyHashEntry_Pr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pEntry</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Zero the entry */</comment>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyHashEntry_Pr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pHash</name></name> <operator>=</operator> <name>pHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pKey</name></name> <operator>=</operator> <name>pKey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nKeyLen</name></name> <operator>=</operator> <name>nKeyLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pUserData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <call><name><name>pHash</name><operator>-&gt;</operator><name>xHash</name></name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pKey</name></name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nKeyLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Finally insert the entry in its corresponding bucket */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pHash</name><operator>)</operator></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* SyRunTimeApi:sxutils.c */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyStrIsNumeric</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>sxu8</name> <modifier>*</modifier></type><name>pReal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name>  <modifier>*</modifier><modifier>*</modifier></type><name>pzTail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNTRUST</name></cpp:ifdef>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Jump leading white spaces */</comment>
	<while>while<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal>  <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zSrc</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pReal</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pReal</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xc0</literal> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for><empty_stmt>;</empty_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>zSrc</name> <argument_list type="generic">&lt; <argument><expr><name>zEnd</name> <operator>&amp;&amp;</operator> <name>zSrc</name></expr></argument> &gt;</argument_list></name> <name>zCur</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pReal</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>pReal</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>pzTail</name></expr> )</condition><block>{<block_content>
				<while>while<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
				<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<while>while<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
						<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></while>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>pReal</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>pReal</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>( <expr><name>pzTail</name></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<while>while<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pzTail</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Point to the non numeric part */</comment>
		<expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <name>zSrc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><name>zSrc</name> <operator>&gt;</operator> <name>zCur</name></expr> ?</condition><then> <expr><name>SXRET_OK</name></expr> <comment type="block">/* String prefix is numeric */</comment> </then><else>: <expr><name>SXERR_INVALID</name></expr></else></ternary></expr> <comment type="block">/* Not a digit stream */</comment>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXINT32_MIN_STR</name></cpp:macro>		<cpp:value>"2147483648"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXINT32_MAX_STR</name></cpp:macro>		<cpp:value>"2147483647"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXINT64_MIN_STR</name></cpp:macro>		<cpp:value>"9223372036854775808"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXINT64_MAX_STR</name></cpp:macro>		<cpp:value>"9223372036854775807"</cpp:value></cpp:define>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyStrToInt32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pOutVal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>zRest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>isNeg</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>nVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi16</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxi32</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>isNeg</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>:<expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Skip leading zero */</comment>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt> 
	</block_content>}</block></while>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zSrc</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">10</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Handle overflow */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><call><name>SyMemcmp</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>isNeg</name> <operator>==</operator> <name>TRUE</name><operator>)</operator></expr> ?</condition><then> <expr><name>SXINT32_MIN_STR</name></expr> </then><else>: <expr><name>SXINT32_MAX_STR</name></expr></else></ternary></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">10</literal></expr> </then><else>: <expr><literal type="number">9</literal></expr></else></ternary></expr>;</expr_stmt> 
	</block_content>}</block></if></if_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><name>i</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal> <operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>i</name></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><name>i</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal> <operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>i</name></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><name>i</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal> <operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>i</name></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><name>i</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal> <operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>i</name></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Skip trailing spaces */</comment>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zRest</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>zRest</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>zSrc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	
	<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>isNeg</name> <operator>==</operator> <name>TRUE</name> <operator>&amp;&amp;</operator> <name>nVal</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>-</operator><name>nVal</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxi32</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>)</operator></expr> ?</condition><then> <expr><name>SXRET_OK</name></expr> </then><else>: <expr><name>SXERR_SYNTAX</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyStrToInt64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pOutVal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>zRest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>isNeg</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>nVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi16</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxi32</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>isNeg</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>:<expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Skip leading zero */</comment>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">19</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name><operator>-</operator><name>zSrc</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">19</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><call><name>SyMemcmp</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>, <argument><expr><ternary><condition><expr><name>isNeg</name></expr> ?</condition><then> <expr><name>SXINT64_MIN_STR</name></expr> </then><else>: <expr><name>SXINT64_MAX_STR</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">19</literal></expr> </then><else>: <expr><literal type="number">18</literal></expr></else></ternary></expr> ;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>nVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><name>i</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal> <operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>i</name></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><name>i</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal> <operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>i</name></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><name>i</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal> <operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>i</name></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><name>i</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal> <operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>i</name></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Skip trailing spaces */</comment>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zRest</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>zRest</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>zSrc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	
	<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>isNeg</name> <operator>==</operator> <name>TRUE</name> <operator>&amp;&amp;</operator> <name>nVal</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>-</operator><name>nVal</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxi64</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>)</operator></expr> ?</condition><then> <expr><name>SXRET_OK</name></expr> </then><else>: <expr><name>SXERR_SYNTAX</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyHexToint</name><parameter_list>(<parameter><decl><type><name>sxi32</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch<condition>(<expr><name>c</name></expr>)</condition><block>{<block_content>
	<case>case <expr><literal type="char">'0'</literal></expr>:</case> <return>return <expr><literal type="number">0</literal></expr>;</return>
	<case>case <expr><literal type="char">'1'</literal></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>
	<case>case <expr><literal type="char">'2'</literal></expr>:</case> <return>return <expr><literal type="number">2</literal></expr>;</return>
	<case>case <expr><literal type="char">'3'</literal></expr>:</case> <return>return <expr><literal type="number">3</literal></expr>;</return>
	<case>case <expr><literal type="char">'4'</literal></expr>:</case> <return>return <expr><literal type="number">4</literal></expr>;</return>
	<case>case <expr><literal type="char">'5'</literal></expr>:</case> <return>return <expr><literal type="number">5</literal></expr>;</return>
	<case>case <expr><literal type="char">'6'</literal></expr>:</case> <return>return <expr><literal type="number">6</literal></expr>;</return>
	<case>case <expr><literal type="char">'7'</literal></expr>:</case> <return>return <expr><literal type="number">7</literal></expr>;</return>
	<case>case <expr><literal type="char">'8'</literal></expr>:</case> <return>return <expr><literal type="number">8</literal></expr>;</return>
	<case>case <expr><literal type="char">'9'</literal></expr>:</case> <return>return <expr><literal type="number">9</literal></expr>;</return>
	<case>case <expr><literal type="char">'A'</literal></expr>:</case> <case>case <expr><literal type="char">'a'</literal></expr>:</case> <return>return <expr><literal type="number">10</literal></expr>;</return>
	<case>case <expr><literal type="char">'B'</literal></expr>:</case> <case>case <expr><literal type="char">'b'</literal></expr>:</case> <return>return <expr><literal type="number">11</literal></expr>;</return>
	<case>case <expr><literal type="char">'C'</literal></expr>:</case> <case>case <expr><literal type="char">'c'</literal></expr>:</case> <return>return <expr><literal type="number">12</literal></expr>;</return>
	<case>case <expr><literal type="char">'D'</literal></expr>:</case> <case>case <expr><literal type="char">'d'</literal></expr>:</case> <return>return <expr><literal type="number">13</literal></expr>;</return>
	<case>case <expr><literal type="char">'E'</literal></expr>:</case> <case>case <expr><literal type="char">'e'</literal></expr>:</case> <return>return <expr><literal type="number">14</literal></expr>;</return>
	<case>case <expr><literal type="char">'F'</literal></expr>:</case> <case>case <expr><literal type="char">'f'</literal></expr>:</case> <return>return <expr><literal type="number">15</literal></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> 	
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyHexStrToInt64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pOutVal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>zRest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>isNeg</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>nVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxi32</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<while>while<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <operator>*</operator><name>zSrc</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>zSrc</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>isNeg</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>:<expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <operator>&amp;</operator><name><name>zEnd</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'X'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
		<comment type="block">/* Bypass hex prefix */</comment>
		<expr_stmt><expr><name>zSrc</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	
	<comment type="block">/* Skip leading zero */</comment>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <name>zSrc</name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><call><name>SyisHex</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">15</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>SyHexToint</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><call><name>SyisHex</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">15</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>SyHexToint</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><call><name>SyisHex</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">15</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>SyHexToint</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><call><name>SyisHex</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">15</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>SyHexToint</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt>
	</block_content>}</block></for>
	<while>while<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>	
	<if_stmt><if>if<condition>( <expr><name>zRest</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>zRest</name> <operator>=</operator> <name>zSrc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>isNeg</name> <operator>==</operator> <name>TRUE</name> <operator>&amp;&amp;</operator> <name>nVal</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>-</operator><name>nVal</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxi64</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name></expr> ?</condition><then> <expr><name>SXRET_OK</name></expr> </then><else>: <expr><name>SXERR_SYNTAX</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyOctalStrToInt64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pOutVal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>zRest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>isNeg</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>nVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxi32</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>isNeg</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>:<expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Skip leading zero */</comment>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt> 
	</block_content>}</block></while>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <name>zSrc</name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">7</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition><block>{<block_content> <break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator>  <name>c</name></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">7</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition><block>{<block_content> <break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator>  <name>c</name></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">7</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition><block>{<block_content> <break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator>  <name>c</name></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">7</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition><block>{<block_content> <break>break;</break></block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>nVal</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator>  <name>c</name></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Skip trailing spaces */</comment>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zRest</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>zRest</name> <operator>=</operator> <name>zSrc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	
	<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>isNeg</name> <operator>==</operator> <name>TRUE</name> <operator>&amp;&amp;</operator> <name>nVal</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>-</operator><name>nVal</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxi64</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>)</operator></expr> ?</condition><then> <expr><name>SXRET_OK</name></expr> </then><else>: <expr><name>SXERR_SYNTAX</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBinaryStrToInt64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pOutVal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>zRest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>isNeg</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi64</name></type> <name>nVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxi32</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>isNeg</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>:<expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <operator>&amp;</operator><name><name>zEnd</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'B'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
		<comment type="block">/* Bypass binary prefix */</comment>
		<expr_stmt><expr><name>zSrc</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Skip leading zero */</comment>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt> 
	</block_content>}</block></while>
	<expr_stmt><expr><name>zIn</name> <operator>=</operator> <name>zSrc</name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">62</literal></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>(</operator><name>nVal</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">62</literal></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>(</operator><name>nVal</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">62</literal></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>(</operator><name>nVal</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name> <operator>||</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zSrc</name><operator>-</operator><name>zIn</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">62</literal></expr>)</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>(</operator><name>nVal</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Skip trailing spaces */</comment>
	<while>while<condition>(<expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zRest</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>zRest</name> <operator>=</operator> <name>zSrc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	
	<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>isNeg</name> <operator>==</operator> <name>TRUE</name> <operator>&amp;&amp;</operator> <name>nVal</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>-</operator><name>nVal</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxi64</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <name>nVal</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>)</operator></expr> ?</condition><then> <expr><name>SXRET_OK</name></expr> </then><else>: <expr><name>SXERR_SYNTAX</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyStrToReal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pOutVal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>zRest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXDBL_DIG</name></cpp:macro>        <cpp:value>15</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXDBL_MAX_EXP</name></cpp:macro>    <cpp:value>308</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXDBL_MIN_EXP_PLUS</name></cpp:macro>	<cpp:value>307</cpp:value></cpp:define>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sxreal</name></type> <name><name>aTab</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">10</literal></expr>, 
	<expr><literal type="number">1.0e2</literal></expr>, 
	<expr><literal type="number">1.0e4</literal></expr>, 
	<expr><literal type="number">1.0e8</literal></expr>, 
	<expr><literal type="number">1.0e16</literal></expr>, 
	<expr><literal type="number">1.0e32</literal></expr>, 
	<expr><literal type="number">1.0e64</literal></expr>, 
	<expr><literal type="number">1.0e128</literal></expr>, 
	<expr><literal type="number">1.0e256</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu8</name></type> <name>neg</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxreal</name></type> <name>Val</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>Lim</name></decl>, <decl><type ref="prev"/><name>exp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxreal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNTRUST</name></cpp:ifdef>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call></expr>  )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxreal</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<while>while<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt> 
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>neg</name> <operator>=</operator>  <ternary><condition><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr> ;</expr_stmt>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>Lim</name> <operator>=</operator> <name>SXDBL_DIG</name></expr> ;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>||</operator><operator>!</operator><name>Lim</name><operator>||</operator><operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break ;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>Val</name> <operator>=</operator> <name>Val</name> <operator>*</operator> <literal type="number">10.0</literal> <operator>+</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>Lim</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>||</operator><operator>!</operator><name>Lim</name><operator>||</operator><operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break ;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>Val</name> <operator>=</operator> <name>Val</name> <operator>*</operator> <literal type="number">10.0</literal> <operator>+</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>Lim</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>||</operator><operator>!</operator><name>Lim</name><operator>||</operator><operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break ;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>Val</name> <operator>=</operator> <name>Val</name> <operator>*</operator> <literal type="number">10.0</literal> <operator>+</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>Lim</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>||</operator><operator>!</operator><name>Lim</name><operator>||</operator><operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break ;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>Val</name> <operator>=</operator> <name>Val</name> <operator>*</operator> <literal type="number">10.0</literal> <operator>+</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt> <expr_stmt><expr><operator>--</operator><name>Lim</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal> <operator>)</operator></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>sxreal</name></type> <name>dec</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>||</operator><operator>!</operator><name>Lim</name><operator>||</operator><operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break ;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>Val</name> <operator>=</operator> <name>Val</name> <operator>*</operator> <literal type="number">10.0</literal> <operator>+</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><name>dec</name> <operator>*=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt><expr_stmt><expr><operator>--</operator><name>Lim</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>||</operator><operator>!</operator><name>Lim</name><operator>||</operator><operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break ;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>Val</name> <operator>=</operator> <name>Val</name> <operator>*</operator> <literal type="number">10.0</literal> <operator>+</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><name>dec</name> <operator>*=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt><expr_stmt><expr><operator>--</operator><name>Lim</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>||</operator><operator>!</operator><name>Lim</name><operator>||</operator><operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break ;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>Val</name> <operator>=</operator> <name>Val</name> <operator>*</operator> <literal type="number">10.0</literal> <operator>+</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><name>dec</name> <operator>*=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt><expr_stmt><expr><operator>--</operator><name>Lim</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name><operator>||</operator><operator>!</operator><name>Lim</name><operator>||</operator><operator>!</operator><call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break ;</break></block_content></block></if></if_stmt> <expr_stmt><expr><name>Val</name> <operator>=</operator> <name>Val</name> <operator>*</operator> <literal type="number">10.0</literal> <operator>+</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr> ;</expr_stmt> <expr_stmt><expr><name>dec</name> <operator>*=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>zSrc</name><operator>++</operator></expr> ;</expr_stmt><expr_stmt><expr><operator>--</operator><name>Lim</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>Val</name> <operator>/=</operator> <name>dec</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>neg</name> <operator>==</operator> <name>TRUE</name> <operator>&amp;&amp;</operator> <name>Val</name> <operator>!=</operator> <literal type="number">0.0</literal></expr> )</condition> <block>{<block_content>
		<expr_stmt><expr><name>Val</name> <operator>=</operator> <operator>-</operator><name>Val</name></expr> ;</expr_stmt> 
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>Lim</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* jump overflow digit */</comment>
		<while>while<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
				<break>break;</break>  
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>neg</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal> <operator>)</operator></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>neg</name> <operator>=</operator> <ternary><condition><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr> ;</expr_stmt>
			<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>exp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisDigit</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>exp</name> <operator>&lt;</operator> <name>SXDBL_MAX_EXP</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>exp</name> <operator>=</operator> <name>exp</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>neg</name></expr>  )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>exp</name> <operator>&gt;</operator> <name>SXDBL_MIN_EXP_PLUS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>exp</name> <operator>=</operator> <name>SXDBL_MIN_EXP_PLUS</name></expr> ;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if><if type="elseif">else if <condition>( <expr><name>exp</name> <operator>&gt;</operator> <name>SXDBL_MAX_EXP</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>exp</name> <operator>=</operator> <name>SXDBL_MAX_EXP</name></expr>;</expr_stmt> 
		</block_content>}</block></if></if_stmt>		
		<for>for<control>( <init><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>sxreal</name> <operator>*</operator><operator>)</operator><name>aTab</name></expr> ;</init> <condition><expr><name>exp</name></expr> ;</condition> <incr><expr><name>exp</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr> <operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>exp</name> <operator>&amp;</operator> <literal type="number">01</literal></expr> )</condition><block>{<block_content>
				<if_stmt><if>if<condition>( <expr><name>neg</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>Val</name> <operator>/=</operator> <operator>*</operator><name>p</name></expr> ;</expr_stmt>
				</block_content>}</block></if><else>else<block>{<block_content>
					<expr_stmt><expr><name>Val</name> <operator>*=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<while>while<condition>( <expr><name>zSrc</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>SyisSpace</name><argument_list>(<argument><expr><name><name>zSrc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>zSrc</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if<condition>( <expr><name>zRest</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>zRest</name> <operator>=</operator> <name>zSrc</name></expr>;</expr_stmt> 
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>pOutVal</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxreal</name> <operator>*</operator><operator>)</operator><name>pOutVal</name> <operator>=</operator> <name>Val</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><name>zSrc</name> <operator>&gt;=</operator> <name>zEnd</name></expr> ?</condition><then> <expr><name>SXRET_OK</name></expr> </then><else>: <expr><name>SXERR_SYNTAX</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* SyRunTimeApi:sxlib.c  */</comment>
<function><type><name>JX9_PRIVATE</name> <name>sxu32</name></type> <name>SyBinHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pSrc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nH</name> <init>= <expr><literal type="number">5381</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><name>nH</name> <operator>=</operator> <name>nH</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>	
	<return>return <expr><name>nH</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBase64Encode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>ProcConsumer</name></type> <name>xConsumer</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>zBase64</name><index>[]</index></name> <init>= <expr><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zSrc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>z64</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>xConsumer</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>nLen</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr></incr>)</control><block>{<block_content>
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>zBase64</name><index>[<expr><operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>zBase64</name><index>[<expr><operator>(</operator> <operator>(</operator><operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x03</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator>   <operator>|</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt> 
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>zBase64</name><index>[<expr><operator>(</operator> <operator>(</operator><operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>zBase64</name><index>[ <expr><name><name>zIn</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>z64</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z64</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content><return>return <expr><name>SXERR_ABORT</name></expr>;</return></block_content>}</block></if></if_stmt>

	</block_content>}</block></for>	
	<if_stmt><if>if <condition>( <expr><name>i</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>zBase64</name><index>[<expr><operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>zBase64</name><index>[<expr><operator>(</operator> <operator>(</operator><operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x03</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator>   <operator>|</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt> 
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>zBase64</name><index>[<expr><operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr> ]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'='</literal></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>z64</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z64</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content><return>return <expr><name>SXERR_ABORT</name></expr>;</return></block_content>}</block></if></if_stmt>

	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name> <operator>&lt;</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>zBase64</name><index>[<expr><operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">1</literal></expr>]</index></name>   <operator>=</operator> <name><name>zBase64</name><index>[<expr><operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x03</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'='</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z64</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'='</literal></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>z64</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z64</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content><return>return <expr><name>SXERR_ABORT</name></expr>;</return></block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBase64Decode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zB64</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>ProcConsumer</name></type> <name>xConsumer</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sxu32</name></type> <name><name>aBase64Trans</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 
	<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">62</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">63</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">53</literal></expr>, <expr><literal type="number">54</literal></expr>, <expr><literal type="number">55</literal></expr>, <expr><literal type="number">56</literal></expr>, <expr><literal type="number">57</literal></expr>, <expr><literal type="number">58</literal></expr>, <expr><literal type="number">59</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">61</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, 
	<expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">27</literal></expr>, 
	<expr><literal type="number">28</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">33</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">35</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">38</literal></expr>, <expr><literal type="number">39</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">43</literal></expr>, <expr><literal type="number">44</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">46</literal></expr>, <expr><literal type="number">47</literal></expr>, <expr><literal type="number">48</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">51</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 
	<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zOut</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zB64</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>xConsumer</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<while>while<condition>(<expr><name>nLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zB64</name><index>[<expr><name>nLen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>nLen</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>n</name><operator>+</operator><literal type="number">3</literal><operator>&lt;</operator><name>nLen</name></expr> ;</condition> <incr><expr><name>n</name> <operator>+=</operator> <literal type="number">4</literal></expr></incr>)</control><block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>aBase64Trans</name><index>[<expr><name><name>zB64</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>aBase64Trans</name><index>[<expr><name><name>zB64</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>aBase64Trans</name><index>[<expr><name><name>zB64</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>aBase64Trans</name><index>[<expr><name><name>zB64</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>w</name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFC</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x03</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xF0</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>y</name><operator>&gt;&gt;</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>y</name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xC0</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zOut</name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content> <return>return <expr><name>SXERR_ABORT</name></expr>;</return></block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name>n</name><operator>+</operator><literal type="number">2</literal> <operator>&lt;</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>aBase64Trans</name><index>[<expr><name><name>zB64</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>aBase64Trans</name><index>[<expr><name><name>zB64</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>aBase64Trans</name><index>[<expr><name><name>zB64</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>w</name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFC</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x03</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xF0</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>y</name><operator>&gt;&gt;</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zOut</name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content> <return>return <expr><name>SXERR_ABORT</name></expr>;</return></block_content>}</block></if></if_stmt>
	</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>n</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>aBase64Trans</name><index>[<expr><name><name>zB64</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>aBase64Trans</name><index>[<expr><name><name>zB64</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>w</name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFC</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x03</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zOut</name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content> <return>return <expr><name>SXERR_ABORT</name></expr>;</return></block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_LEXER</name><parameter_list>(<parameter><type><name>LEX</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(  LEX == 0  || LEX-&gt;xTokenizer == 0 )</cpp:value></cpp:define>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyLexInit</name><parameter_list>(<parameter><decl><type><name>SyLex</name> <modifier>*</modifier></type><name>pLex</name></decl></parameter>, <parameter><decl><type><name>SySet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>, <parameter><decl><type><name>ProcTokenizer</name></type> <name>xTokenizer</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyStream</name> <modifier>*</modifier></type><name>pStream</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>( <expr><name>pLex</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>xTokenizer</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>pLex</name><operator>-&gt;</operator><name>pTokenSet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Initialize lexer fields */</comment>
	<if_stmt><if>if<condition>( <expr><name>pSet</name></expr> )</condition><block>{<block_content>
		<if_stmt><if>if <condition>( <expr><call><name>SySetElemSize</name><argument_list>(<argument><expr><name>pSet</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyToken</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
			<return>return <expr><name>SXERR_INVALID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pLex</name><operator>-&gt;</operator><name>pTokenSet</name></name> <operator>=</operator> <name>pSet</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pStream</name> <operator>=</operator> <operator>&amp;</operator><name><name>pLex</name><operator>-&gt;</operator><name>sStream</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pLex</name><operator>-&gt;</operator><name>xTokenizer</name></name> <operator>=</operator> <name>xTokenizer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pLex</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pUserData</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>nLine</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>nIgn</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>pSet</name></name>  <operator>=</operator> <name>pSet</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyLexTokenizeInput</name><parameter_list>(<parameter><decl><type><name>SyLex</name> <modifier>*</modifier></type><name>pLex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtxData</name></decl></parameter>, <parameter><decl><type><name>ProcSort</name></type> <name>xSort</name></decl></parameter>, <parameter><decl><type><name>ProcCmp</name></type> <name>xCmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyStream</name> <modifier>*</modifier></type><name>pStream</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyToken</name></type> <name>sToken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>( <expr><call><name>INVALID_LEXER</name><argument_list>(<argument><expr><name>pLex</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zInput</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>pStream</name> <operator>=</operator> <operator>&amp;</operator><name><name>pLex</name><operator>-&gt;</operator><name>sStream</name></name></expr>;</expr_stmt>
	<comment type="block">/* Point to the head of the input */</comment>
	<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zInput</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zInput</name></expr>;</expr_stmt>
	<comment type="block">/* Point to the end of the input */</comment>
	<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pStream</name><operator>-&gt;</operator><name>zInput</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>&gt;=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zEnd</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* End of the input reached */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name></expr>;</expr_stmt>
		<comment type="block">/* Call the tokenizer callback */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pLex</name><operator>-&gt;</operator><name>xTokenizer</name></name><argument_list>(<argument><expr><name>pStream</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sToken</name></expr></argument>, <argument><expr><name><name>pLex</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>, <argument><expr><name>pCtxData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>!=</operator> <name>SXERR_CONTINUE</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Tokenizer callback request an operation abort */</comment>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXERR_ABORT</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXERR_CONTINUE</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Request to ignore this token */</comment>
			<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>nIgn</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pLex</name><operator>-&gt;</operator><name>pTokenSet</name></name></expr>  )</condition><block>{<block_content>
			<comment type="block">/* Put the token in the set */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SySetPut</name><argument_list>(<argument><expr><name><name>pLex</name><operator>-&gt;</operator><name>pTokenSet</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&gt;=</operator> <name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Automatic advance of the stream cursor */</comment>
			<expr_stmt><expr><name><name>pStream</name><operator>-&gt;</operator><name>zText</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>zCur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name>xSort</name> <operator>&amp;&amp;</operator>  <name><name>pLex</name><operator>-&gt;</operator><name>pTokenSet</name></name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><name>SyToken</name> <modifier>*</modifier></type><name>aToken</name> <init>= <expr><operator>(</operator><name>SyToken</name> <operator>*</operator><operator>)</operator><call><name>SySetBasePtr</name><argument_list>(<argument><expr><name><name>pLex</name><operator>-&gt;</operator><name>pTokenSet</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Sort the extrated tokens */</comment>
		<if_stmt><if>if<condition>( <expr><name>xCmp</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Use a default comparison function */</comment>
			<expr_stmt><expr><name>xCmp</name> <operator>=</operator> <name>SyMemcmp</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>xSort</name><argument_list>(<argument><expr><name>aToken</name></expr></argument>, <argument><expr><call><name>SySetUsed</name><argument_list>(<argument><expr><name><name>pLex</name><operator>-&gt;</operator><name>pTokenSet</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyToken</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>xCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyLexRelease</name><parameter_list>(<parameter><decl><type><name>SyLex</name> <modifier>*</modifier></type><name>pLex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name> <init>= <expr><name>SXRET_OK</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>( <expr><call><name>INVALID_LEXER</name><argument_list>(<argument><expr><name>pLex</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pLex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Prevent compiler warning */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAFE_HTTP</name><parameter_list>(<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(SyisAlphaNum(c) || c == '_' || c == '-' || c == '$' || c == '.' )</cpp:value></cpp:define>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyUriEncode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>ProcConsumer</name></type> <name>xConsumer</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zSrc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zHex</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="char">'%'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zOut</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNTRUST</name></cpp:ifdef>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>xConsumer</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXRET_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>!=</operator> <name>zIn</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zCur</name><operator>-</operator><name>zIn</name><operator>)</operator></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><call><name>SAFE_HTTP</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zCur</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>!=</operator> <name>zIn</name> <operator>&amp;&amp;</operator> <name>SXRET_OK</name> <operator>!=</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zCur</name><operator>-</operator><name>zIn</name><operator>)</operator></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>		
		<if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zOut</name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<expr_stmt><expr><name><name>zHex</name><index>[<expr><literal type="number">1</literal></expr>]</index></name>	<operator>=</operator> <literal type="string">"0123456789ABCDEF"</literal><index>[<expr><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>]</index></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>zHex</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"0123456789ABCDEF"</literal><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>]</index></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>zHex</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zHex</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>!=</operator> <name>rc</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>				
		<expr_stmt><expr><name>zIn</name> <operator>=</operator> <operator>&amp;</operator><name><name>zCur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr> ;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><ternary><condition><expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> ?</condition><then> <expr><name>SXRET_OK</name></expr> </then><else>: <expr><name>SXERR_ABORT</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>SyAsciiToHex</name><parameter_list>(<parameter><decl><type><name>sxi32</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">10</literal> <operator>-</operator> <literal type="char">'a'</literal></expr>;</expr_stmt>
		<return>return <expr><name>c</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
		<return>return <expr><name>c</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>( <expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'F'</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">10</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt>
		<return>return <expr><name>c</name></expr>;</return>
	</block_content>}</block></if></if_stmt>		
	<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyUriDecode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>ProcConsumer</name></type> <name>xConsumer</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bUTF8</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sxu8</name></type> <name><name>Utf8Trans</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x05</literal></expr>, <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0x07</literal></expr>, 
		<expr><literal type="number">0x08</literal></expr>, <expr><literal type="number">0x09</literal></expr>, <expr><literal type="number">0x0a</literal></expr>, <expr><literal type="number">0x0b</literal></expr>, <expr><literal type="number">0x0c</literal></expr>, <expr><literal type="number">0x0d</literal></expr>, <expr><literal type="number">0x0e</literal></expr>, <expr><literal type="number">0x0f</literal></expr>, 
		<expr><literal type="number">0x10</literal></expr>, <expr><literal type="number">0x11</literal></expr>, <expr><literal type="number">0x12</literal></expr>, <expr><literal type="number">0x13</literal></expr>, <expr><literal type="number">0x14</literal></expr>, <expr><literal type="number">0x15</literal></expr>, <expr><literal type="number">0x16</literal></expr>, <expr><literal type="number">0x17</literal></expr>, 
		<expr><literal type="number">0x18</literal></expr>, <expr><literal type="number">0x19</literal></expr>, <expr><literal type="number">0x1a</literal></expr>, <expr><literal type="number">0x1b</literal></expr>, <expr><literal type="number">0x1c</literal></expr>, <expr><literal type="number">0x1d</literal></expr>, <expr><literal type="number">0x1e</literal></expr>, <expr><literal type="number">0x1f</literal></expr>, 
		<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x05</literal></expr>, <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0x07</literal></expr>, 
		<expr><literal type="number">0x08</literal></expr>, <expr><literal type="number">0x09</literal></expr>, <expr><literal type="number">0x0a</literal></expr>, <expr><literal type="number">0x0b</literal></expr>, <expr><literal type="number">0x0c</literal></expr>, <expr><literal type="number">0x0d</literal></expr>, <expr><literal type="number">0x0e</literal></expr>, <expr><literal type="number">0x0f</literal></expr>, 
		<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x05</literal></expr>, <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0x07</literal></expr>, 
		<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>zSrc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu8</name> <modifier>*</modifier></type><name>zOutPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu8</name></type> <name><name>zOut</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>xConsumer</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXRET_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zCur</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<while>while<condition>(<expr><name>zCur</name> <operator>&lt;</operator> <name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'%'</literal> <operator>&amp;&amp;</operator> <name><name>zCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>zCur</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>!=</operator> <name>zIn</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Consume input */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>zCur</name><operator>-</operator><name>zIn</name><operator>)</operator></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<comment type="block">/* User consumer routine request an operation abort */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>zCur</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXRET_OK</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Decode unsafe HTTP characters */</comment>
		<expr_stmt><expr><name>zOutPtr</name> <operator>=</operator> <name>zOut</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>zCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>zOutPtr</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>zCur</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><operator>&amp;</operator><name><name>zCur</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_OVERFLOW</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><call><name>SyAsciiToHex</name><argument_list>(<argument><expr><name><name>zCur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>|</operator> <call><name>SyAsciiToHex</name><argument_list>(<argument><expr><name><name>zCur</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>zCur</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x000C0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>zOutPtr</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>sxu8</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>Utf8Trans</name><index>[<expr><name>c</name><operator>-</operator><literal type="number">0xC0</literal></expr>]</index></name></expr>;</expr_stmt>
				<while>while<condition>( <expr><name><name>zCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><call><name>SyAsciiToHex</name><argument_list>(<argument><expr><name><name>zCur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>|</operator> <call><name>SyAsciiToHex</name><argument_list>(<argument><expr><name><name>zCur</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if<condition>( <expr><operator>(</operator><name>d</name><operator>&amp;</operator><literal type="number">0xC0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">0x3f</literal> <operator>&amp;</operator> <name>d</name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>zCur</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				</block_content>}</block></while>
				<if_stmt><if>if<condition>( <expr><name>bUTF8</name> <operator>==</operator> <name>FALSE</name></expr> )</condition><block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>zOutPtr</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>sxu8</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
				</block_content>}</block></if><else>else<block>{<block_content>
					<expr_stmt><expr><call><name>SX_WRITE_UTF8</name><argument_list>(<argument><expr><name>zOutPtr</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Consume the decoded characters */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zOut</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>zOutPtr</name><operator>-</operator><name>zOut</name><operator>)</operator></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Synchronize pointers */</comment>
		<expr_stmt><expr><name>zIn</name> <operator>=</operator> <name>zCur</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>zEngDay</name><index>[]</index></name> <init>= <expr><block>{ 
	<expr><literal type="string">"Sunday"</literal></expr>, <expr><literal type="string">"Monday"</literal></expr>, <expr><literal type="string">"Tuesday"</literal></expr>, <expr><literal type="string">"Wednesday"</literal></expr>, 
	<expr><literal type="string">"Thursday"</literal></expr>, <expr><literal type="string">"Friday"</literal></expr>, <expr><literal type="string">"Saturday"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>zEngMonth</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"January"</literal></expr>, <expr><literal type="string">"February"</literal></expr>, <expr><literal type="string">"March"</literal></expr>, <expr><literal type="string">"April"</literal></expr>, 
	<expr><literal type="string">"May"</literal></expr>, <expr><literal type="string">"June"</literal></expr>, <expr><literal type="string">"July"</literal></expr>, <expr><literal type="string">"August"</literal></expr>, 
	<expr><literal type="string">"September"</literal></expr>, <expr><literal type="string">"October"</literal></expr>, <expr><literal type="string">"November"</literal></expr>, <expr><literal type="string">"December"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetDay</name><parameter_list>(<parameter><decl><type><name>sxi32</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>zEngDay</name><index>[ <expr><name>i</name> <operator>%</operator> <literal type="number">7</literal></expr> ]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetMonth</name><parameter_list>(<parameter><decl><type><name>sxi32</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>zEngMonth</name><index>[ <expr><name>i</name> <operator>%</operator> <literal type="number">12</literal></expr> ]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>SyTimeGetDay</name><parameter_list>(<parameter><decl><type><name>sxi32</name></type> <name>iDay</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetDay</name><argument_list>(<argument><expr><name>iDay</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>SyTimeGetMonth</name><parameter_list>(<parameter><decl><type><name>sxi32</name></type> <name>iMonth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetMonth</name><argument_list>(<argument><expr><name>iMonth</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
<comment type="block">/* SyRunTimeApi: sxfmt.c */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_BUFSIZ</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define> <comment type="block">/* Conversion buffer size */</comment>
<comment type="block">/*
** Conversion types fall into various categories as defined by the
** following enumeration.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_RADIX</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define> <comment type="block">/* Integer types.%d, %x, %o, and so forth */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_FLOAT</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define> <comment type="block">/* Floating point.%f */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_EXP</name></cpp:macro>         <cpp:value>3</cpp:value></cpp:define> <comment type="block">/* Exponentional notation.%e and %E */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_GENERIC</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define> <comment type="block">/* Floating or exponential, depending on exponent.%g */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_SIZE</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define> <comment type="block">/* Total number of characters processed so far.%n */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_STRING</name></cpp:macro>      <cpp:value>6</cpp:value></cpp:define> <comment type="block">/* Strings.%s */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_PERCENT</name></cpp:macro>     <cpp:value>7</cpp:value></cpp:define> <comment type="block">/* Percent symbol.%% */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_CHARX</name></cpp:macro>       <cpp:value>8</cpp:value></cpp:define> <comment type="block">/* Characters.%c */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_ERROR</name></cpp:macro>       <cpp:value>9</cpp:value></cpp:define> <comment type="block">/* Used to indicate no such conversion type */</comment>
<comment type="block">/* Extension by Symisc Systems */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_RAWSTR</name></cpp:macro>     <cpp:value>13</cpp:value></cpp:define> <comment type="block">/* %z Pointer to raw string (SyString *) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_UNUSED</name></cpp:macro>     <cpp:value>15</cpp:value></cpp:define> 
<comment type="block">/*
** Allowed values for SyFmtInfo.flags
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFLAG_SIGNED</name></cpp:macro>	<cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFLAG_UNSIGNED</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<comment type="block">/* Allowed values for SyFmtConsumer.nType */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_CONS_PROC</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* Consumer is a procedure */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_CONS_STR</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>	<comment type="block">/* Consumer is a managed string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_CONS_FILE</name></cpp:macro>		<cpp:value>5</cpp:value></cpp:define>	<comment type="block">/* Consumer is an open File */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXFMT_CONS_BLOB</name></cpp:macro>		<cpp:value>6</cpp:value></cpp:define>	<comment type="block">/* Consumer is a BLOB */</comment>
<comment type="block">/*
** Each builtin conversion character (ex: the 'd' in "%d") is described
** by an instance of the following structure
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>SyFmtInfo</name></name></type> <name>SyFmtInfo</name>;</typedef>
<struct>struct <name>SyFmtInfo</name>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name>fmttype</name></decl>;</decl_stmt>  <comment type="block">/* The format field code letter [i.e: 'd', 's', 'x'] */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>base</name></decl>;</decl_stmt>     <comment type="block">/* The base for radix conversion */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>    <comment type="block">/* One or more of SXFLAG_ constants below */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>type</name></decl>;</decl_stmt>     <comment type="block">/* Conversion paradigm */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>charset</name></decl>;</decl_stmt> <comment type="block">/* The character set for conversion */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>  <comment type="block">/* Prefix on non-zero values in alt format */</comment>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>SyFmtConsumer</name></name></type> <name>SyFmtConsumer</name>;</typedef>
<struct>struct <name>SyFmtConsumer</name>
<block>{
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nLen</name></decl>;</decl_stmt> <comment type="block">/* Total output length */</comment>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>nType</name></decl>;</decl_stmt> <comment type="block">/* Type of the consumer see below */</comment>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>	<comment type="block">/* Consumer return value;Abort processing if rc != SXRET_OK */</comment>
 <union>union<block>{
	<struct>struct<block>{	
	<decl_stmt><decl><type><name>ProcConsumer</name></type> <name>xUserConsumer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl>;</decl_stmt>
	}</block><decl><name>sFunc</name></decl>;</struct>  
	<decl_stmt><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl>;</decl_stmt>
 }</block><decl><name>uConsumer</name></decl>;</union>	
}</block>;</struct> 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SX_OMIT_FLOATINGPOINT</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getdigit</name><parameter_list>(<parameter><decl><type><name>sxlongreal</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sxlongreal</name></type> <name>d</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>digit</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>cnt</name><operator>)</operator><operator>++</operator> <operator>&gt;=</operator> <literal type="number">16</literal></expr> )</condition><block>{<block_content>
	  <return>return <expr><literal type="char">'0'</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>digit</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>val</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name> <operator>=</operator> <name>digit</name></expr>;</expr_stmt>
   <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>val</name> <operator>-</operator> <name>d</name><operator>)</operator><operator>*</operator><literal type="number">10.0</literal></expr>;</expr_stmt>
  <return>return <expr><name>digit</name> <operator>+</operator> <literal type="char">'0'</literal></expr> ;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SX_OMIT_FLOATINGPOINT */</comment>
<comment type="block">/*
 * The following routine was taken from the SQLITE2 source tree and was
 * extended by Symisc Systems to fit its need.
 * Status: Public Domain
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>InternFormat</name><parameter_list>(<parameter><decl><type><name>ProcConsumer</name></type> <name>xConsumer</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The following table is searched linearly, so it is good to put the most frequently
	 * used conversion types first.
	 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>SyFmtInfo</name></type> <name><name>aFmt</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{  <expr><literal type="char">'d'</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>SXFLAG_SIGNED</name></expr>, <expr><name>SXFMT_RADIX</name></expr>, <expr><literal type="string">"0123456789"</literal></expr>, <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'s'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_STRING</name></expr>,     <expr><literal type="number">0</literal></expr>,                  <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'c'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_CHARX</name></expr>,      <expr><literal type="number">0</literal></expr>,                  <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'x'</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_RADIX</name></expr>,      <expr><literal type="string">"0123456789abcdef"</literal></expr>, <expr><literal type="string">"x0"</literal></expr> }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'X'</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_RADIX</name></expr>,      <expr><literal type="string">"0123456789ABCDEF"</literal></expr>, <expr><literal type="string">"X0"</literal></expr> }</block></expr>, 
         <comment type="block">/* -- Extensions by Symisc Systems -- */</comment>
  <expr><block>{  <expr><literal type="char">'z'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_RAWSTR</name></expr>,     <expr><literal type="number">0</literal></expr>,                   <expr><literal type="number">0</literal></expr>   }</block></expr>, <comment type="block">/* Pointer to a raw string (SyString *) */</comment>
  <expr><block>{  <expr><literal type="char">'B'</literal></expr>,  <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_RADIX</name></expr>,      <expr><literal type="string">"01"</literal></expr>,                <expr><literal type="string">"b0"</literal></expr>}</block></expr>, 
         <comment type="block">/* -- End of Extensions -- */</comment>
  <expr><block>{  <expr><literal type="char">'o'</literal></expr>,  <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_RADIX</name></expr>,      <expr><literal type="string">"01234567"</literal></expr>,         <expr><literal type="string">"0"</literal></expr>  }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'u'</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_RADIX</name></expr>,      <expr><literal type="string">"0123456789"</literal></expr>,       <expr><literal type="number">0</literal></expr>    }</block></expr>, 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SX_OMIT_FLOATINGPOINT</name></cpp:ifndef>
  <expr><block>{  <expr><literal type="char">'f'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>SXFLAG_SIGNED</name></expr>, <expr><name>SXFMT_FLOAT</name></expr>,       <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'e'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>SXFLAG_SIGNED</name></expr>, <expr><name>SXFMT_EXP</name></expr>,        <expr><literal type="string">"e"</literal></expr>,    <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'E'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>SXFLAG_SIGNED</name></expr>, <expr><name>SXFMT_EXP</name></expr>,        <expr><literal type="string">"E"</literal></expr>,    <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'g'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>SXFLAG_SIGNED</name></expr>, <expr><name>SXFMT_GENERIC</name></expr>,    <expr><literal type="string">"e"</literal></expr>,    <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'G'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><name>SXFLAG_SIGNED</name></expr>, <expr><name>SXFMT_GENERIC</name></expr>,    <expr><literal type="string">"E"</literal></expr>,    <expr><literal type="number">0</literal></expr>    }</block></expr>, 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><block>{  <expr><literal type="char">'i'</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>SXFLAG_SIGNED</name></expr>, <expr><name>SXFMT_RADIX</name></expr>, <expr><literal type="string">"0123456789"</literal></expr>, <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'n'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_SIZE</name></expr>,       <expr><literal type="number">0</literal></expr>,                  <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'%'</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_PERCENT</name></expr>,    <expr><literal type="number">0</literal></expr>,                  <expr><literal type="number">0</literal></expr>    }</block></expr>, 
  <expr><block>{  <expr><literal type="char">'p'</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>SXFMT_RADIX</name></expr>,      <expr><literal type="string">"0123456789"</literal></expr>,       <expr><literal type="number">0</literal></expr>    }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>                     <comment type="block">/* Next character in the format string */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bufpt</name></decl>;</decl_stmt>               <comment type="block">/* Pointer to the conversion buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>precision</name></decl>;</decl_stmt>             <comment type="block">/* Precision of the current field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>                <comment type="block">/* Length of the field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>                   <comment type="block">/* A general purpose loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>                 <comment type="block">/* Width of the current field */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>flag_leftjustify</name></decl>;</decl_stmt>   <comment type="block">/* True if "-" flag is present */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>flag_plussign</name></decl>;</decl_stmt>      <comment type="block">/* True if "+" flag is present */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>flag_blanksign</name></decl>;</decl_stmt>     <comment type="block">/* True if " " flag is present */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>flag_alternateform</name></decl>;</decl_stmt> <comment type="block">/* True if "#" flag is present */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>flag_zeropad</name></decl>;</decl_stmt>       <comment type="block">/* True if field width constant starts with zero */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>flag_long</name></decl>;</decl_stmt>          <comment type="block">/* True if "l" flag is present */</comment>
  <decl_stmt><decl><type><name>sxi64</name></type> <name>longvalue</name></decl>;</decl_stmt>         <comment type="block">/* Value for integer types */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>SyFmtInfo</name> <modifier>*</modifier></type><name>infop</name></decl>;</decl_stmt>  <comment type="block">/* Pointer to the appropriate info structure */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>SXFMT_BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Conversion buffer */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>prefix</name></decl>;</decl_stmt>             <comment type="block">/* Prefix character."+" or "-" or " " or '\0'.*/</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>errorflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* True if an error is encountered */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>xtype</name></decl>;</decl_stmt>              <comment type="block">/* Conversion paradigm */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExtra</name></decl>;</decl_stmt>    
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>spaces</name><index>[]</index></name> <init>= <expr><literal type="string">"                                                  "</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>etSPACESIZE</name></cpp:macro> <cpp:value>((int)sizeof(spaces)-1)</cpp:value></cpp:define>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SX_OMIT_FLOATINGPOINT</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sxlongreal</name></type> <name>realvalue</name></decl>;</decl_stmt>    <comment type="block">/* Value for real types */</comment>
  <decl_stmt><decl><type><name>int</name></type>  <name>exp</name></decl>;</decl_stmt>                <comment type="block">/* exponent of real numbers */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>rounder</name></decl>;</decl_stmt>          <comment type="block">/* Used for rounding floating point values */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>flag_dp</name></decl>;</decl_stmt>            <comment type="block">/* True if decimal point should be shown */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>flag_rtz</name></decl>;</decl_stmt>           <comment type="block">/* True if trailing zeros should be removed */</comment>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>flag_exp</name></decl>;</decl_stmt>           <comment type="block">/* True to force display of the exponent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nsd</name></decl>;</decl_stmt>                 <comment type="block">/* Number of significant digits returned */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init>;</init> <condition><expr><operator>(</operator><name>c</name><operator>=</operator><operator>(</operator><operator>*</operator><name>zFormat</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>zFormat</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>amt</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>zFormat</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>amt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><operator>(</operator><operator>*</operator><operator>++</operator><name>zFormat</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="char">'%'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>amt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>bufpt</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		  <return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
	  </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
		  <return>return <expr><ternary><condition><expr><name>errorflag</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SXERR_FORMAT</name></expr> </then><else>: <expr><name>SXRET_OK</name></expr></else></ternary></expr>;</return>
	  </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><operator>(</operator><operator>*</operator><operator>++</operator><name>zFormat</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>errorflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><literal type="string">"%"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"%"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		  <return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
	  </block_content>}</block></if></if_stmt>
      <return>return <expr><ternary><condition><expr><name>errorflag</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SXERR_FORMAT</name></expr> </then><else>: <expr><name>SXRET_OK</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Find out what flags are present */</comment>
    <expr_stmt><expr><name>flag_leftjustify</name> <operator>=</operator> <name>flag_plussign</name> <operator>=</operator> <name>flag_blanksign</name> <operator>=</operator> 
     <name>flag_alternateform</name> <operator>=</operator> <name>flag_zeropad</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <switch>switch<condition>( <expr><name>c</name></expr> )</condition><block>{<block_content>
        <case>case <expr><literal type="char">'-'</literal></expr>:</case>   <expr_stmt><expr><name>flag_leftjustify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>     <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <break>break;</break>
        <case>case <expr><literal type="char">'+'</literal></expr>:</case>   <expr_stmt><expr><name>flag_plussign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <break>break;</break>
        <case>case <expr><literal type="char">' '</literal></expr>:</case>   <expr_stmt><expr><name>flag_blanksign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>       <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <break>break;</break>
        <case>case <expr><literal type="char">'#'</literal></expr>:</case>   <expr_stmt><expr><name>flag_alternateform</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <break>break;</break>
        <case>case <expr><literal type="char">'0'</literal></expr>:</case>   <expr_stmt><expr><name>flag_zeropad</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>         <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <break>break;</break>
        <default>default:</default>                                       <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block>while<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>=</operator><operator>(</operator><operator>*</operator><operator>++</operator><name>zFormat</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
    <comment type="block">/* Get the field width */</comment>
    <expr_stmt><expr><name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>width</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>flag_leftjustify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>width</name> <operator>=</operator> <operator>-</operator><name>width</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>zFormat</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <while>while<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>width</name> <operator>=</operator> <name>width</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>zFormat</name></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>width</name> <operator>&gt;</operator> <name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>width</name> <operator>=</operator> <name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">10</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Get the precision */</comment>
	<expr_stmt><expr><name>precision</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>zFormat</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>precision</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name> <operator>=</operator> <operator>-</operator><name>precision</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>zFormat</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <while>while<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>precision</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>zFormat</name></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Get the conversion type modifier */</comment>
	<expr_stmt><expr><name>flag_long</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'l'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'q'</literal></expr> <comment type="block">/* BSD quad (expect a 64-bit integer) */</comment> )</condition><block>{<block_content>
      <expr_stmt><expr><name>flag_long</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'q'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>zFormat</name></expr>;</expr_stmt>
	  <if_stmt><if>if<condition>( <expr><name>c</name> <operator>==</operator> <literal type="char">'l'</literal></expr> )</condition><block>{<block_content>
		  <comment type="block">/* Standard printf emulation 'lld' (expect a 64bit integer) */</comment>
		  <expr_stmt><expr><name>flag_long</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Fetch the info entry for the field */</comment>
    <expr_stmt><expr><name>infop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>SXFMT_ERROR</name></expr>;</expr_stmt>
	<for>for<control>(<init><expr><name>idx</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name><operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name>aFmt</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name><name>aFmt</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>fmttype</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>infop</name> <operator>=</operator> <operator>&amp;</operator><name><name>aFmt</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xtype</name> <operator>=</operator> <name><name>infop</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>zExtra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
    ** At this point, variables are initialized as follows:
    **
    **   flag_alternateform          TRUE if a '#' is present.
    **   flag_plussign               TRUE if a '+' is present.
    **   flag_leftjustify            TRUE if a '-' is present or if the
    **                               field width was negative.
    **   flag_zeropad                TRUE if the width began with 0.
    **   flag_long                   TRUE if the letter 'l' (ell) or 'q'(BSD quad) prefixed
    **                               the conversion character.
    **   flag_blanksign              TRUE if a ' ' is present.
    **   width                       The specified field width.This is
    **                               always non-negative.Zero is the default.
    **   precision                   The specified precision.The default
    **                               is -1.
    **   xtype                       The object of the conversion.
    **   infop                       Pointer to the appropriate info struct.
    */</comment>
    <switch>switch<condition>( <expr><name>xtype</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SXFMT_RADIX</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>flag_long</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>flag_long</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* BSD quad: expect a 64-bit integer */</comment>
				<expr_stmt><expr><name>longvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sxi64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>longvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sxlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name><name>infop</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SXFLAG_SIGNED</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>longvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sxi32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if><else>else<block>{<block_content>
				<expr_stmt><expr><name>longvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sxu32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Limit the precision to prevent overflowing buf[] during conversion */</comment>
      <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;</operator><name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">40</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">40</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
        <comment type="block">/* For the format %#x, the value zero is printed "0" not "0x0".
        ** I think this is stupid.*/</comment>
        <if_stmt><if>if<condition>( <expr><name>longvalue</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flag_alternateform</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* More sensible: turn off the prefix for octal (to prevent "00"), 
        ** but leave the prefix for hex.*/</comment>
        <if_stmt><if>if<condition>( <expr><name>longvalue</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>infop</name><operator>-&gt;</operator><name>base</name></name><operator>==</operator><literal type="number">8</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flag_alternateform</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>( <expr><name><name>infop</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SXFLAG_SIGNED</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>longvalue</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> 
            <expr_stmt><expr><name>longvalue</name> <operator>=</operator> <operator>-</operator><name>longvalue</name></expr>;</expr_stmt>
			<comment type="block">/* Ticket 1433-003 */</comment>
			<if_stmt><if>if<condition>( <expr><name>longvalue</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<comment type="block">/* Overflow */</comment>
				<expr_stmt><expr><name>longvalue</name><operator>=</operator> <literal type="number">0x7FFFFFFFFFFFFFFF</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flag_plussign</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></if>
          <if type="elseif">else if<condition>( <expr><name>flag_blanksign</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>                       <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>longvalue</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><name>longvalue</name> <operator>=</operator> <operator>-</operator><name>longvalue</name></expr>;</expr_stmt>
				<comment type="block">/* Ticket 1433-003 */</comment>
				<if_stmt><if>if<condition>( <expr><name>longvalue</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
					<comment type="block">/* Overflow */</comment>
					<expr_stmt><expr><name>longvalue</name><operator>=</operator> <literal type="number">0x7FFFFFFFFFFFFFFF</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>flag_zeropad</name> <operator>&amp;&amp;</operator> <name>precision</name><operator>&lt;</operator><name>width</name><operator>-</operator><operator>(</operator><name>prefix</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>width</name><operator>-</operator><operator>(</operator><name>prefix</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <block>{<block_content>
          <decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type><name>cset</name></decl>;</decl_stmt>      <comment type="block">/* Use registers for speed */</comment>
          <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>base</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>cset</name> <operator>=</operator> <name><name>infop</name><operator>-&gt;</operator><name>charset</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>infop</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
          <do>do<block>{<block_content>                                           <comment type="block">/* Convert to ascii */</comment>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <name><name>cset</name><index>[<expr><name>longvalue</name><operator>%</operator><name>base</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>longvalue</name> <operator>=</operator> <name>longvalue</name><operator>/</operator><name>base</name></expr>;</expr_stmt>
          </block_content>}</block>while<condition>( <expr><name>longvalue</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>
        </block_content>}</block>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-</operator><name>bufpt</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>idx</name><operator>=</operator><name>precision</name><operator>-</operator><name>length</name></expr>;</init> <condition><expr><name>idx</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>idx</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>                             <comment type="block">/* Zero pad */</comment>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>prefix</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt></block_content></block></if></if_stmt>               <comment type="block">/* Add sign */</comment>
        <if_stmt><if>if<condition>( <expr><name>flag_alternateform</name> <operator>&amp;&amp;</operator> <name><name>infop</name><operator>-&gt;</operator><name>prefix</name></name></expr> )</condition><block>{<block_content>      <comment type="block">/* Add "0" or "0x" */</comment>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pre</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>pre</name> <operator>=</operator> <name><name>infop</name><operator>-&gt;</operator><name>prefix</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>*</operator><name>bufpt</name><operator>!=</operator><name><name>pre</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
            <for>for<control>(<init><expr><name>pre</name><operator>=</operator><name><name>infop</name><operator>-&gt;</operator><name>prefix</name></name></expr>;</init> <condition><expr><operator>(</operator><name>x</name><operator>=</operator><operator>(</operator><operator>*</operator><name>pre</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>pre</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufpt</name><operator>)</operator> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></for>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-</operator><name>bufpt</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>SXFMT_FLOAT</name></expr>:</case>
      <case>case <expr><name>SXFMT_EXP</name></expr>:</case>
      <case>case <expr><name>SXFMT_GENERIC</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SX_OMIT_FLOATINGPOINT</name></cpp:ifndef>
		<expr_stmt><expr><name>realvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>double</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>         <comment type="block">/* Set default precision */</comment>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;</operator><name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">40</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">40</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>realvalue</name><operator>&lt;</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>realvalue</name> <operator>=</operator> <operator>-</operator><name>realvalue</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>flag_plussign</name></expr> )</condition><block type="pseudo"><block_content>          <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></if>
          <if type="elseif">else if<condition>( <expr><name>flag_blanksign</name></expr> )</condition><block type="pseudo"><block_content>    <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>                         <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>infop</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SXFMT_GENERIC</name> <operator>&amp;&amp;</operator> <name>precision</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rounder</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        <comment type="block">/* Rounding works like BSD when the constant 0.4999 is used.Wierd! */</comment>
        for(idx=precision, rounder=0.4999; idx&gt;0; idx--, rounder*=0.1);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* It makes more sense to use 0.5 */</comment>
        <for>for<control>(<init><expr><name>idx</name><operator>=</operator><name>precision</name></expr><operator>,</operator> <expr><name>rounder</name><operator>=</operator><literal type="number">0.5</literal></expr>;</init> <condition><expr><name>idx</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>idx</name><operator>--</operator></expr><operator>,</operator> <expr><name>rounder</name><operator>*=</operator><literal type="number">0.1</literal></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>( <expr><name><name>infop</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SXFMT_FLOAT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>realvalue</name> <operator>+=</operator> <name>rounder</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Normalize realvalue to within 10.0 &gt; realvalue &gt;= 1.0 */</comment>
        <expr_stmt><expr><name>exp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>realvalue</name><operator>&gt;</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
          <while>while<condition>( <expr><name>realvalue</name><operator>&gt;=</operator><literal type="number">1e8</literal> <operator>&amp;&amp;</operator> <name>exp</name><operator>&lt;=</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">1e-8</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>+=</operator><literal type="number">8</literal></expr>;</expr_stmt> </block_content>}</block></while>
          <while>while<condition>( <expr><name>realvalue</name><operator>&gt;=</operator><literal type="number">10.0</literal> <operator>&amp;&amp;</operator> <name>exp</name><operator>&lt;=</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">0.1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
          <while>while<condition>( <expr><name>realvalue</name><operator>&lt;</operator><literal type="number">1e-8</literal> <operator>&amp;&amp;</operator> <name>exp</name><operator>&gt;=</operator><operator>-</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">1e8</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>-=</operator><literal type="number">8</literal></expr>;</expr_stmt> </block_content>}</block></while>
          <while>while<condition>( <expr><name>realvalue</name><operator>&lt;</operator><literal type="number">1.0</literal> <operator>&amp;&amp;</operator> <name>exp</name><operator>&gt;=</operator><operator>-</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
          <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&gt;</operator><literal type="number">350</literal> <operator>||</operator> <name>exp</name><operator>&lt;</operator><operator>-</operator><literal type="number">350</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <literal type="string">"NaN"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
        <comment type="block">/*
        ** If the field type is etGENERIC, then convert to either etEXP
        ** or etFLOAT, as appropriate.
        */</comment>
        <expr_stmt><expr><name>flag_exp</name> <operator>=</operator> <name>xtype</name><operator>==</operator><name>SXFMT_EXP</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>!=</operator><name>SXFMT_FLOAT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>realvalue</name> <operator>+=</operator> <name>rounder</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>realvalue</name><operator>&gt;=</operator><literal type="number">10.0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>realvalue</name> <operator>*=</operator> <literal type="number">0.1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>==</operator><name>SXFMT_GENERIC</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>flag_rtz</name> <operator>=</operator> <operator>!</operator><name>flag_alternateform</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>exp</name><argument_list type="generic">&lt;<argument><expr><operator>-</operator><literal type="number">4</literal> <operator>||</operator> <name>exp</name></expr></argument>&gt;</argument_list></name><name>precision</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>SXFMT_EXP</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>precision</name> <operator>-</operator> <name>exp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>xtype</name> <operator>=</operator> <name>SXFMT_FLOAT</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>flag_rtz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/*
        ** The "exp+precision" test causes output to be of type etEXP if
        ** the precision is too large to fit in buf[].
        */</comment>
        <expr_stmt><expr><name>nsd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>xtype</name><operator>==</operator><name>SXFMT_FLOAT</name> <operator>&amp;&amp;</operator> <name>exp</name><operator>+</operator><name>precision</name><operator>&lt;</operator><name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">30</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>flag_dp</name> <operator>=</operator> <operator>(</operator><name>precision</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>flag_alternateform</name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>prefix</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt></block_content></block></if></if_stmt>         <comment type="block">/* Sign */</comment>
          <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>            <comment type="block">/* Digits before "." */</comment>
          <else>else<block type="pseudo"><block_content> <for>for<control>(<init>;</init> <condition><expr><name>exp</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>exp</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>getdigit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>flag_dp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>           <comment type="block">/* The decimal point */</comment>
          <for>for<control>(<init><expr><name>exp</name><operator>++</operator></expr>;</init> <condition><expr><name><name>exp</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>precision</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr>;</condition> <incr><expr><name>precision</name><operator>--</operator></expr><operator>,</operator> <expr><name>exp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
          </block_content>}</block></for>
          <while>while<condition>( <expr><operator>(</operator><name>precision</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>getdigit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>--</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                           <comment type="block">/* Null terminate */</comment>
          <if_stmt><if>if<condition>( <expr><name>flag_rtz</name> <operator>&amp;&amp;</operator> <name>flag_dp</name></expr> )</condition><block>{<block_content>     <comment type="block">/* Remove trailing zeros and "." */</comment>
            <while>while<condition>( <expr><name>bufpt</name><operator>&gt;=</operator><name>buf</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>bufpt</name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>--</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
            <if_stmt><if>if<condition>( <expr><name>bufpt</name><operator>&gt;=</operator><name>buf</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>bufpt</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>--</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>bufpt</name><operator>++</operator></expr>;</expr_stmt>                            <comment type="block">/* point to next free slot */</comment>
        </block_content>}</block></if><else>else<block>{<block_content>    <comment type="block">/* etEXP or etGENERIC */</comment>
          <expr_stmt><expr><name>flag_dp</name> <operator>=</operator> <operator>(</operator><name>precision</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>flag_alternateform</name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>prefix</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* Sign */</comment>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>getdigit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* First digit */</comment>
          <if_stmt><if>if<condition>( <expr><name>flag_dp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>     <comment type="block">/* Decimal point */</comment>
          <while>while<condition>( <expr><operator>(</operator><name>precision</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>getdigit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><name>bufpt</name><operator>--</operator></expr>;</expr_stmt>                            <comment type="block">/* point to last digit */</comment>
          <if_stmt><if>if<condition>( <expr><name>flag_rtz</name> <operator>&amp;&amp;</operator> <name>flag_dp</name></expr> )</condition><block>{<block_content>          <comment type="block">/* Remove tail zeros */</comment>
            <while>while<condition>( <expr><name>bufpt</name><operator>&gt;=</operator><name>buf</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>bufpt</name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>--</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
            <if_stmt><if>if<condition>( <expr><name>bufpt</name><operator>&gt;=</operator><name>buf</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>bufpt</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>--</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>bufpt</name><operator>++</operator></expr>;</expr_stmt>                            <comment type="block">/* point to next free slot */</comment>
          <if_stmt><if>if<condition>( <expr><name>exp</name> <operator>||</operator> <name>flag_exp</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>infop</name><operator>-&gt;</operator><name>charset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name> <operator>=</operator> <operator>-</operator><name>exp</name></expr>;</expr_stmt> </block_content>}</block></if> <comment type="block">/* sign of exp */</comment>
            <else>else       <block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>exp</name><operator>&gt;=</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>exp</name><operator>/</operator><literal type="number">100</literal><operator>)</operator><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>                <comment type="block">/* 100's digit */</comment>
              <expr_stmt><expr><name>exp</name> <operator>%=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>exp</name><operator>/</operator><literal type="number">10</literal><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>                     <comment type="block">/* 10's digit */</comment>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bufpt</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>exp</name><operator>%</operator><literal type="number">10</literal><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>                     <comment type="block">/* 1's digit */</comment>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* The converted number is in buf[] and zero terminated.Output it.
        ** Note that the number is in the usual order, not reversed as with
        ** integer conversions.*/</comment>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <name>bufpt</name><operator>-</operator><name>buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

        <comment type="block">/* Special case:  Add leading zeros if the flag_zeropad flag is
        ** set and we are not left justified */</comment>
        <if_stmt><if>if<condition>( <expr><name>flag_zeropad</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>flag_leftjustify</name> <operator>&amp;&amp;</operator> <name>length</name> <operator>&lt;</operator> <name>width</name></expr>)</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nPad</name> <init>= <expr><name>width</name> <operator>-</operator> <name>length</name></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>width</name></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><name>nPad</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>bufpt</name><index>[<expr><name>i</name><operator>-</operator><name>nPad</name></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><name>i</name> <operator>=</operator> <name>prefix</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
          <while>while<condition>( <expr><name>nPad</name><operator>--</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><name>length</name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
         <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
		 <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SX_OMIT_FLOATINGPOINT */</comment>
        <break>break;</break>
      <case>case <expr><name>SXFMT_SIZE</name></expr>:</case><block>{<block_content>
		 <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pSize</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		 <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SyFmtConsumer</name> <operator>*</operator><operator>)</operator><name>pUserData</name><operator>)</operator><operator>-&gt;</operator><name>nLen</name></expr>;</expr_stmt>
		 <expr_stmt><expr><name>length</name> <operator>=</operator> <name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					  </block_content>}</block>
        <break>break;</break>
      <case>case <expr><name>SXFMT_PERCENT</name></expr>:</case>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'%'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>SXFMT_CHARX</name></expr>:</case>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
		<comment type="block">/* Limit the precision to prevent overflowing buf[] during conversion */</comment>
		<if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;</operator><name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">40</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>precision</name> <operator>=</operator> <name>SXFMT_BUFSIZ</name><operator>-</operator><literal type="number">40</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>idx</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>idx</name><operator>&lt;</operator><name>precision</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>buf</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt></block_content></block></for>
          <expr_stmt><expr><name>length</name> <operator>=</operator> <name>precision</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>length</name> <operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>SXFMT_STRING</name></expr>:</case>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bufpt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
		  <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		  <break>break;</break>
        </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <name>precision</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>precision</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Symisc extension */</comment>
			<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>SyStrlen</name><argument_list>(<argument><expr><name>bufpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>precision</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>precision</name><operator>&lt;</operator><name>length</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>length</name> <operator>=</operator> <name>precision</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
	<case>case <expr><name>SXFMT_RAWSTR</name></expr>:</case><block>{<block_content>
		<comment type="block">/* Symisc extension */</comment>
		<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pStr</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>SyString</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><name>pStr</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			 <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
		     <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		     <break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>bufpt</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pStr</name><operator>-&gt;</operator><name>zString</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pStr</name><operator>-&gt;</operator><name>nByte</name></name></expr>;</expr_stmt>
		<break>break;</break>
					  </block_content>}</block>
      <case>case <expr><name>SXFMT_ERROR</name></expr>:</case>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufpt</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zFormat</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
    </block_content>}</block></switch><comment type="block">/* End switch over the format type */</comment>
    <comment type="block">/*
    ** The text of the conversion is pointed to by "bufpt" and is
    ** "length" characters long.The field width is "width".Do
    ** the output.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>flag_leftjustify</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>nspace</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>nspace</name> <operator>=</operator> <name>width</name><operator>-</operator><name>length</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nspace</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name>nspace</name><operator>&gt;=</operator><name>etSPACESIZE</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>spaces</name></expr></argument>, <argument><expr><name>etSPACESIZE</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>nspace</name> <operator>-=</operator> <name>etSPACESIZE</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>nspace</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>spaces</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>nspace</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>length</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>bufpt</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>length</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		  <return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
		</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>flag_leftjustify</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>nspace</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>nspace</name> <operator>=</operator> <name>width</name><operator>-</operator><name>length</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nspace</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name>nspace</name><operator>&gt;=</operator><name>etSPACESIZE</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>spaces</name></expr></argument>, <argument><expr><name>etSPACESIZE</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>nspace</name> <operator>-=</operator> <name>etSPACESIZE</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>nspace</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><name>spaces</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>nspace</name></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_ABORT</name></expr>;</return> <comment type="block">/* Consumer routine request an operation abort */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for><comment type="block">/* End for loop over the format string */</comment>
  <return>return <expr><ternary><condition><expr><name>errorflag</name></expr> ?</condition><then> <expr><name>SXERR_FORMAT</name></expr> </then><else>: <expr><name>SXRET_OK</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function> 
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>FormatConsumer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyFmtConsumer</name> <modifier>*</modifier></type><name>pConsumer</name> <init>= <expr><operator>(</operator><name>SyFmtConsumer</name> <operator>*</operator><operator>)</operator><name>pData</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name> <init>= <expr><name>SXERR_ABORT</name></expr></init></decl>;</decl_stmt>
	<switch>switch<condition>(<expr><name><name>pConsumer</name><operator>-&gt;</operator><name>nType</name></name></expr>)</condition><block>{<block_content>
	<case>case <expr><name>SXFMT_CONS_PROC</name></expr>:</case>
			<comment type="block">/* User callback */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pConsumer</name><operator>-&gt;</operator><name>uConsumer</name><operator>.</operator><name>sFunc</name><operator>.</operator><name>xUserConsumer</name></name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>, <argument><expr><name><name>pConsumer</name><operator>-&gt;</operator><name>uConsumer</name><operator>.</operator><name>sFunc</name><operator>.</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	<case>case <expr><name>SXFMT_CONS_BLOB</name></expr>:</case>
			<comment type="block">/* Blob consumer */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppend</name><argument_list>(<argument><expr><name><name>pConsumer</name><operator>-&gt;</operator><name>uConsumer</name><operator>.</operator><name>pBlob</name></name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default> 
			<comment type="block">/* Unknown consumer */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<comment type="block">/* Update total number of bytes consumed so far */</comment>
	<expr_stmt><expr><name><name>pConsumer</name><operator>-&gt;</operator><name>nLen</name></name> <operator>+=</operator> <name>nLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pConsumer</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>	
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>FormatMount</name><parameter_list>(<parameter><decl><type><name>sxi32</name></type> <name>nType</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pConsumer</name></decl></parameter>, <parameter><decl><type><name>ProcConsumer</name></type> <name>xUserCons</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>, <parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pOutLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyFmtConsumer</name></type> <name>sCons</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>sCons</name><operator>.</operator><name>nType</name></name> <operator>=</operator> <name>nType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sCons</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>SXRET_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sCons</name><operator>.</operator><name>nLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pOutLen</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pOutLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<switch>switch<condition>(<expr><name>nType</name></expr>)</condition><block>{<block_content>
	<case>case <expr><name>SXFMT_CONS_PROC</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<if_stmt><if>if<condition>( <expr><name>xUserCons</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
				<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name><name>sCons</name><operator>.</operator><name>uConsumer</name><operator>.</operator><name>sFunc</name><operator>.</operator><name>xUserConsumer</name></name> <operator>=</operator> <name>xUserCons</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sCons</name><operator>.</operator><name>uConsumer</name><operator>.</operator><name>sFunc</name><operator>.</operator><name>pUserData</name></name>	    <operator>=</operator> <name>pUserData</name></expr>;</expr_stmt>
		<break>break;</break>
		<case>case <expr><name>SXFMT_CONS_BLOB</name></expr>:</case>
			<expr_stmt><expr><name><name>sCons</name><operator>.</operator><name>uConsumer</name><operator>.</operator><name>pBlob</name></name> <operator>=</operator> <operator>(</operator><name>SyBlob</name> <operator>*</operator><operator>)</operator><name>pConsumer</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default> 
			<return>return <expr><name>SXERR_UNKNOWN</name></expr>;</return>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>InternFormat</name><argument_list>(<argument><expr><name>FormatConsumer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCons</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<if_stmt><if>if<condition>( <expr><name>pOutLen</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pOutLen</name> <operator>=</operator> <name><name>sCons</name><operator>.</operator><name>nLen</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>sCons</name><operator>.</operator><name>rc</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyProcFormat</name><parameter_list>(<parameter><decl><type><name>ProcConsumer</name></type> <name>xConsumer</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>	
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>FormatMount</name><argument_list>(<argument><expr><name>SXFMT_CONS_PROC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xConsumer</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxu32</name></type> <name>SyBlobFormat</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>	
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>			
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FormatMount</name><argument_list>(<argument><expr><name>SXFMT_CONS_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBlob</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxu32</name></type> <name>SyBlobFormatAp</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc warning */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>	
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	
	<expr_stmt><expr><call><name>FormatMount</name><argument_list>(<argument><expr><name>SXFMT_CONS_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pBlob</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxu32</name></type> <name>SyBufferFormat</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyBlob</name></type> <name>sBlob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>	
	<if_stmt><if>if<condition>( <expr><call><name>SX_EMPTY_STR</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	
	<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>!=</operator> <call><name>SyBlobInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sBlob</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>nLen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>		
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FormatMount</name><argument_list>(<argument><expr><name>SXFMT_CONS_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sBlob</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SyBlobLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Append the null terminator */</comment>
	<expr_stmt><expr><name><name>sBlob</name><operator>.</operator><name>mByte</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyBlobAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sBlob</name></expr></argument>, <argument><expr><literal type="string">"\0"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<comment type="block">/*
 * Zip File Format:
 *
 * Byte order: Little-endian
 * 
 * [Local file header + Compressed data [+ Extended local header]?]*
 * [Central directory]*
 * [End of central directory record]
 * 
 * Local file header:*
 * Offset   Length   Contents
 *  0      4 bytes  Local file header signature (0x04034b50)
 *  4      2 bytes  Version needed to extract
 *  6      2 bytes  General purpose bit flag
 *  8      2 bytes  Compression method
 * 10      2 bytes  Last mod file time
 * 12      2 bytes  Last mod file date
 * 14      4 bytes  CRC-32
 * 18      4 bytes  Compressed size (n)
 * 22      4 bytes  Uncompressed size
 * 26      2 bytes  Filename length (f)
 * 28      2 bytes  Extra field length (e)
 * 30     (f)bytes  Filename
 *        (e)bytes  Extra field
 *        (n)bytes  Compressed data
 *
 * Extended local header:*
 * Offset   Length   Contents
 *  0      4 bytes  Extended Local file header signature (0x08074b50)
 *  4      4 bytes  CRC-32
 *  8      4 bytes  Compressed size
 * 12      4 bytes  Uncompressed size
 *
 * Extra field:?(if any)
 * Offset 	Length		Contents
 * 0	  	2 bytes		Header ID (0x001 until 0xfb4a) see extended appnote from Info-zip
 * 2	  	2 bytes		Data size (g)
 * 		  	(g) bytes	(g) bytes of extra field
 * 
 * Central directory:*
 * Offset   Length   Contents
 *  0      4 bytes  Central file header signature (0x02014b50)
 *  4      2 bytes  Version made by
 *  6      2 bytes  Version needed to extract
 *  8      2 bytes  General purpose bit flag
 * 10      2 bytes  Compression method
 * 12      2 bytes  Last mod file time
 * 14      2 bytes  Last mod file date
 * 16      4 bytes  CRC-32
 * 20      4 bytes  Compressed size
 * 24      4 bytes  Uncompressed size
 * 28      2 bytes  Filename length (f)
 * 30      2 bytes  Extra field length (e)
 * 32      2 bytes  File comment length (c)
 * 34      2 bytes  Disk number start
 * 36      2 bytes  Internal file attributes
 * 38      4 bytes  External file attributes
 * 42      4 bytes  Relative offset of local header
 * 46     (f)bytes  Filename
 *        (e)bytes  Extra field
 *        (c)bytes  File comment
 *
 * End of central directory record:
 * Offset   Length   Contents
 *  0      4 bytes  End of central dir signature (0x06054b50)
 *  4      2 bytes  Number of this disk
 *  6      2 bytes  Number of the disk with the start of the central directory
 *  8      2 bytes  Total number of entries in the central dir on this disk
 * 10      2 bytes  Total number of entries in the central dir
 * 12      4 bytes  Size of the central directory
 * 16      4 bytes  Offset of start of central directory with respect to the starting disk number
 * 20      2 bytes  zipfile comment length (c)
 * 22     (c)bytes  zipfile comment
 *
 * compression method: (2 bytes)
 *          0 - The file is stored (no compression)
 *          1 - The file is Shrunk
 *          2 - The file is Reduced with compression factor 1
 *          3 - The file is Reduced with compression factor 2
 *          4 - The file is Reduced with compression factor 3
 *          5 - The file is Reduced with compression factor 4
 *          6 - The file is Imploded
 *          7 - Reserved for Tokenizing compression algorithm
 *          8 - The file is Deflated
 */</comment> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXMAKE_ZIP_WORKBUF</name></cpp:macro>	<cpp:value>(SXU16_HIGH/2)</cpp:value></cpp:define>	<comment type="block">/* 32KB Initial working buffer size */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXMAKE_ZIP_EXTRACT_VER</name></cpp:macro>	<cpp:value>0x000a</cpp:value></cpp:define>	<comment type="block">/* Version needed to extract */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXMAKE_ZIP_VER</name></cpp:macro>	<cpp:value>0x003</cpp:value></cpp:define>	<comment type="block">/* Version made by */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXZIP_CENTRAL_MAGIC</name></cpp:macro>			<cpp:value>0x02014b50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXZIP_END_CENTRAL_MAGIC</name></cpp:macro>		<cpp:value>0x06054b50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXZIP_LOCAL_MAGIC</name></cpp:macro>			<cpp:value>0x04034b50</cpp:value></cpp:define>
<comment type="block">/*#define SXZIP_CRC32_START			0xdebb20e3*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXZIP_LOCAL_HDRSZ</name></cpp:macro>		<cpp:value>30</cpp:value></cpp:define>	<comment type="block">/* Local header size */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXZIP_LOCAL_EXT_HDRZ</name></cpp:macro>	<cpp:value>16</cpp:value></cpp:define>	<comment type="block">/* Extended local header(footer) size */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXZIP_CENTRAL_HDRSZ</name></cpp:macro>		<cpp:value>46</cpp:value></cpp:define>	<comment type="block">/* Central directory header size */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXZIP_END_CENTRAL_HDRSZ</name></cpp:macro>	<cpp:value>22</cpp:value></cpp:define>	<comment type="block">/* End of central directory header size */</comment>
	 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXARCHIVE_HASH_SIZE</name></cpp:macro>	<cpp:value>64</cpp:value></cpp:define> <comment type="block">/* Starting hash table size(MUST BE POWER OF 2)*/</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>SyLittleEndianUnpack32</name><parameter_list>(<parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>uNB</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>Len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>Len</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content> 
		<return>return <expr><name>SXERR_SHORT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>uNB</name> <operator>=</operator>  <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>SyLittleEndianUnpack16</name><parameter_list>(<parameter><decl><type><name>sxu16</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sxu16</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_SHORT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>pOut</name> <operator>=</operator> <name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>zBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
	
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Archive hashtable manager
 */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ArchiveHashGetEntry</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pBucketEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyString</name></type> <name>sEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nHash</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nHash</name> <operator>=</operator> <call><name><name>pArch</name><operator>-&gt;</operator><name>xHash</name></name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pBucketEntry</name> <operator>=</operator> <name><name>pArch</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>nHash</name> <operator>&amp;</operator> <operator>(</operator><name><name>pArch</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SyStringInitFromBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>pBucketEntry</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name>nHash</name> <operator>==</operator> <name><name>pBucketEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;&amp;</operator> <call><name><name>pArch</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>sEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pBucketEntry</name><operator>-&gt;</operator><name>sFileName</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<if_stmt><if>if<condition>( <expr><name>ppEntry</name></expr> )</condition><block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>ppEntry</name> <operator>=</operator> <name>pBucketEntry</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>SXRET_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pBucketEntry</name> <operator>=</operator> <name><name>pBucketEntry</name><operator>-&gt;</operator><name>pNextHash</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>SXERR_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ArchiveHashBucketInstall</name><parameter_list>(<parameter><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>apTable</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nBucket</name></decl></parameter>, <parameter><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextHash</name></name> <operator>=</operator> <name><name>apTable</name><index>[<expr><name>nBucket</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>apTable</name><index>[<expr><name>nBucket</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name><name>apTable</name><index>[<expr><name>nBucket</name></expr>]</index></name><operator>-&gt;</operator><name>pPrevHash</name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>apTable</name><index>[<expr><name>nBucket</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ArchiveHashGrowTable</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nNewSize</name> <init>= <expr><name><name>pArch</name><operator>-&gt;</operator><name>nSize</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>n</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate a new table */</comment>
	<expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>SyArchiveEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyArchiveEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>apNew</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXRET_OK</name></expr>;</return> <comment type="block">/* Not so fatal, simply a performance hit */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>apNew</name></expr></argument>, <argument><expr><name>nNewSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyArchiveEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Rehash old entries */</comment>
	<for>for<control>( <init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr> <operator>,</operator> <expr><name>pEntry</name> <operator>=</operator> <name><name>pArch</name><operator>-&gt;</operator><name>pList</name></name></expr> ;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pArch</name><operator>-&gt;</operator><name>nLoaded</name></name></expr> ;</condition> <incr><expr><name>n</name><operator>++</operator></expr> <operator>,</operator> <expr><name>pEntry</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr> )</control><block>{<block_content>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextHash</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pPrevHash</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArchiveHashBucketInstall</name><argument_list>(<argument><expr><name>apNew</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name>nNewSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Release the old table */</comment>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>apHash</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <name>nNewSize</name></expr>;</expr_stmt>

	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ArchiveHashInstallEntry</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>, <parameter><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name><name>pArch</name><operator>-&gt;</operator><name>nLoaded</name></name> <operator>&gt;</operator> <name><name>pArch</name><operator>-&gt;</operator><name>nSize</name></name> <operator>*</operator> <literal type="number">3</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>ArchiveHashGrowTable</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pArch</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <call><name><name>pArch</name><operator>-&gt;</operator><name>xHash</name></name><argument_list>(<argument><expr><call><name>SyStringData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>sFileName</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SyStringLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>sFileName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Install the entry in its bucket */</comment>
	<expr_stmt><expr><call><name>ArchiveHashBucketInstall</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pArch</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MACRO_LD_PUSH</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>nLoaded</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
 <comment type="block">/*
  * Parse the End of central directory and report status
  */</comment> 
 <function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ParseEndOfCentralDirectory</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nMagic</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc -O6 warning */</comment>
 	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
 	
 	<comment type="block">/* Sanity check */</comment>
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyLittleEndianUnpack32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nMagic</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>( <comment type="block">/* rc != SXRET_OK || */</comment><expr><name>nMagic</name> <operator>!=</operator> <name>SXZIP_END_CENTRAL_MAGIC</name></expr> )</condition><block>{<block_content>
 		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
 	</block_content>}</block></if></if_stmt>
 	<comment type="block">/* # of entries */</comment>
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyLittleEndianUnpack16</name><argument_list>(<argument><expr><operator>(</operator><name>sxu16</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pArch</name><operator>-&gt;</operator><name>nEntry</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>( <comment type="block">/* rc != SXRET_OK || */</comment> <expr><name><name>pArch</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&gt;</operator> <name>SXI16_HIGH</name></expr> <comment type="block">/* SXU16_HIGH */</comment> )</condition><block>{<block_content>
 		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
 	</block_content>}</block></if></if_stmt>
 	<comment type="block">/* Size of central directory */</comment>
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyLittleEndianUnpack32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pArch</name><operator>-&gt;</operator><name>nCentralSize</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>( <comment type="block">/*rc != SXRET_OK ||*/</comment> <expr><name><name>pArch</name><operator>-&gt;</operator><name>nCentralSize</name></name> <operator>&gt;</operator> <name>SXI32_HIGH</name></expr> )</condition><block>{<block_content>
 		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
 	</block_content>}</block></if></if_stmt>
 	<comment type="block">/* Starting offset of central directory */</comment>
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyLittleEndianUnpack32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pArch</name><operator>-&gt;</operator><name>nCentralOfft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>( <comment type="block">/*rc != SXRET_OK ||*/</comment> <expr><name><name>pArch</name><operator>-&gt;</operator><name>nCentralSize</name></name> <operator>&gt;</operator> <name>SXI32_HIGH</name></expr> )</condition><block>{<block_content>
 		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
 	</block_content>}</block></if></if_stmt>
 	
 	<return>return <expr><name>SXRET_OK</name></expr>;</return>
 </block_content>}</block></function>
 <comment type="block">/*
  * Fill the zip entry with the appropriate information from the central directory
  */</comment>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>GetCentralDirectoryEntry</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>, <parameter><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zCentral</name></decl></parameter>, <parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pNextOffset</name></decl></parameter>)</parameter_list>
 <block>{<block_content> 
 	<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pName</name> <init>= <expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>sFileName</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* File name */</comment>
 	<decl_stmt><decl><type><name>sxu16</name></type> <name>nDosDate</name></decl>, <decl><type ref="prev"/><name>nDosTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nComment</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nMagic</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* cc -O6 warning */</comment>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt> 	
	<expr_stmt><expr><name>nDosDate</name> <operator>=</operator> <name>nDosTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* cc -O6 warning */</comment>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pArch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<comment type="block">/* Sanity check */</comment>
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyLittleEndianUnpack32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nMagic</name></expr></argument>, <argument><expr><name>zCentral</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>( <comment type="block">/* rc != SXRET_OK || */</comment> <expr><name>nMagic</name> <operator>!=</operator> <name>SXZIP_CENTRAL_MAGIC</name></expr> )</condition><block>{<block_content>
 		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_CORRUPT</name></expr>;</expr_stmt> 		
 		<comment type="block">/*
 		 * Try to recover by examing the next central directory record.
 		 * Dont worry here, there is no risk of an infinite loop since
		 * the buffer size is delimited.
 		 */</comment>

 		<comment type="block">/* pName-&gt;nByte = 0; nComment = 0; pName-&gt;nExtra = 0 */</comment>
 		<goto>goto <name>update</name>;</goto>
 	</block_content>}</block></if></if_stmt>
 	<comment type="block">/*
 	 * entry name length
 	 */</comment>
 	<expr_stmt><expr><call><name>SyLittleEndianUnpack16</name><argument_list>(<argument><expr><operator>(</operator><name>sxu16</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>( <expr><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name> <operator>&gt;</operator> <name>SXI16_HIGH</name></expr> <comment type="block">/* SXU16_HIGH */</comment>)</condition><block>{<block_content>
 		 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_BIG</name></expr>;</expr_stmt>
 		 <goto>goto <name>update</name>;</goto>
 	</block_content>}</block></if></if_stmt>
 	<comment type="block">/* Extra information */</comment>
 	<expr_stmt><expr><call><name>SyLittleEndianUnpack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>nExtra</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><literal type="number">30</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<comment type="block">/* Comment length  */</comment>
 	<expr_stmt><expr><call><name>SyLittleEndianUnpack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nComment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 	
 	<comment type="block">/* Compression method 0 == stored / 8 == deflated */</comment>
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyLittleEndianUnpack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>nComprMeth</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<comment type="block">/* DOS Timestamp */</comment>
 	<expr_stmt><expr><call><name>SyLittleEndianUnpack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nDosTime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<expr_stmt><expr><call><name>SyLittleEndianUnpack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nDosDate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<expr_stmt><expr><call><name>SyDosTimeFormat</name><argument_list>(<argument><expr><operator>(</operator><name>nDosDate</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal> <operator>|</operator> <name>nDosTime</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>sFmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Little hack to fix month index  */</comment>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>sFmt</name><operator>.</operator><name>tm_mon</name></name><operator>--</operator></expr>;</expr_stmt>
 	<comment type="block">/* CRC32 */</comment>
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyLittleEndianUnpack32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>nCrc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<comment type="block">/* Content size before compression */</comment>
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyLittleEndianUnpack32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>(  <expr><name><name>pEntry</name><operator>-&gt;</operator><name>nByte</name></name> <operator>&gt;</operator> <name>SXI32_HIGH</name></expr> )</condition><block>{<block_content>
 		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_BIG</name></expr>;</expr_stmt>
 		<goto>goto <name>update</name>;</goto> 
 	</block_content>}</block></if></if_stmt> 	
 	<comment type="block">/*
 	 * Content size after compression.
 	 * Note that if the file is stored pEntry-&gt;nByte should be equal to pEntry-&gt;nByteCompr
 	 */</comment> 
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyLittleEndianUnpack32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>nByteCompr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>nByteCompr</name></name> <operator>&gt;</operator> <name>SXI32_HIGH</name></expr> )</condition><block>{<block_content>
 		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_BIG</name></expr>;</expr_stmt>
 		<goto>goto <name>update</name>;</goto> 
 	</block_content>}</block></if></if_stmt> 	 	
 	<comment type="block">/* Finally grab the contents offset */</comment>
 	<expr_stmt><expr><call><name>SyLittleEndianUnpack32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>nOfft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><literal type="number">42</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>nOfft</name></name> <operator>&gt;</operator> <name>SXI32_HIGH</name></expr> )</condition><block>{<block_content>
 		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXERR_BIG</name></expr>;</expr_stmt>
 		<goto>goto <name>update</name>;</goto>
 	</block_content>}</block></if></if_stmt> 	
  	 <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SXRET_OK</name></expr>;</expr_stmt>
<label><name>update</name>:</label>	  
 	<comment type="block">/* Update the offset to point to the next central directory record */</comment>
 	<expr_stmt><expr><operator>*</operator><name>pNextOffset</name> <operator>=</operator>  <name>SXZIP_CENTRAL_HDRSZ</name> <operator>+</operator> <name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name> <operator>+</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>+</operator> <name>nComment</name></expr>;</expr_stmt>
 	<return>return <expr><name>rc</name></expr>;</return> <comment type="block">/* Report failure or success */</comment>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ZipFixOffset</name><parameter_list>(<parameter><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>	
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nExtra</name></decl>, <decl><type ref="prev"/><name>nNameLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zHdr</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>nExtra</name> <operator>=</operator> <name>nNameLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>zHdr</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pSrc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zHdr</name> <operator>=</operator> <operator>&amp;</operator><name><name>zHdr</name><index>[<expr><name><name>pEntry</name><operator>-&gt;</operator><name>nOfft</name></name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><call><name>SyMemcmp</name><argument_list>(<argument><expr><name>zHdr</name></expr></argument>, <argument><expr><literal type="string">"PK\003\004"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyLittleEndianUnpack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nNameLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zHdr</name><index>[<expr><literal type="number">26</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyLittleEndianUnpack16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nExtra</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zHdr</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fix contents offset */</comment>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nOfft</name></name> <operator>+=</operator> <name>SXZIP_LOCAL_HDRSZ</name> <operator>+</operator> <name>nExtra</name> <operator>+</operator> <name>nNameLen</name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Extract all valid entries from the central directory 
 */</comment>	 
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ZipExtract</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zCentral</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pDup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl> ;</decl_stmt> <comment type="block">/* End of central directory */</comment>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>nIncr</name></decl>, <decl><type ref="prev"/><name>nOfft</name></decl>;</decl_stmt>          <comment type="block">/* Central Offset */</comment>
	<decl_stmt><decl><type><name>SyString</name> <modifier>*</modifier></type><name>pName</name></decl>;</decl_stmt>	        <comment type="block">/* Entry name */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>nOfft</name> <operator>=</operator> <name>nIncr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zCentral</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><name>nOfft</name></expr>]</index></name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Add a new entry */</comment>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <operator>(</operator><name>SyArchiveEntry</name> <operator>*</operator><operator>)</operator><call><name>SyMemBackendPoolAlloc</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyArchiveEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>pEntry</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyArchiveEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <name>SXARCH_MAGIC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nIncr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>GetCentralDirectoryEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pArch</name><operator>)</operator></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><name>nOfft</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Fix the starting record offset so we can access entry contents correctly */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ZipFixOffset</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<decl_stmt><decl><type><name>sxu32</name></type> <name>nJmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Try to recover by brute-forcing for a valid central directory record */</comment>
			<if_stmt><if>if<condition>( <expr><name>SXRET_OK</name> <operator>==</operator> <call><name>SyBlobSearch</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><name>nOfft</name> <operator>+</operator> <name>nIncr</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <operator>&amp;</operator><name><name>zCentral</name><index>[<expr><name>nOfft</name> <operator>+</operator> <name>nIncr</name></expr>]</index></name><operator>)</operator></expr></argument>, 
				<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><literal type="string">"PK\001\002"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>nJmp</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
					<expr_stmt><expr><name>nOfft</name> <operator>+=</operator> <name>nIncr</name> <operator>+</operator> <name>nJmp</name></expr>;</expr_stmt> <comment type="block">/* Check next entry */</comment>
					<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<break>break;</break> <comment type="block">/* Giving up, archive is hopelessly corrupted */</comment>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pName</name> <operator>=</operator> <operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>sFileName</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pName</name><operator>-&gt;</operator><name>zString</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zCentral</name><index>[<expr><name>nOfft</name> <operator>+</operator> <name>SXZIP_CENTRAL_HDRSZ</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>nByte</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pName</name><operator>-&gt;</operator><name>zString</name><index>[<expr><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
			<comment type="block">/* Ignore zero length records (except folders) and records without names */</comment>
			<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		 	<expr_stmt><expr><name>nOfft</name> <operator>+=</operator> <name>nIncr</name></expr>;</expr_stmt> <comment type="block">/* Check next entry */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>SyMemBackendStrDup</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	 	<if_stmt><if>if<condition>( <expr><name>zName</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
 	 		 <expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		 	 <expr_stmt><expr><name>nOfft</name> <operator>+=</operator> <name>nIncr</name></expr>;</expr_stmt> <comment type="block">/* Check next entry */</comment>
			<continue>continue;</continue>
 	 	</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pName</name><operator>-&gt;</operator><name>zString</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>zName</name></expr>;</expr_stmt>
		<comment type="block">/* Check for duplicates */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ArchiveHashGetEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pArch</name><operator>)</operator></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>zString</name></name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>==</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Another entry with the same name exists ; link them together */</comment>
			<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextName</name></name> <operator>=</operator> <name><name>pDup</name><operator>-&gt;</operator><name>pNextName</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pDup</name><operator>-&gt;</operator><name>pNextName</name></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pDup</name><operator>-&gt;</operator><name>nDup</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if><else>else<block>{<block_content>
			<comment type="block">/* Insert in hashtable */</comment>
			<expr_stmt><expr><call><name>ArchiveHashInstallEntry</name><argument_list>(<argument><expr><name>pArch</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>	
		<expr_stmt><expr><name>nOfft</name> <operator>+=</operator> <name>nIncr</name></expr>;</expr_stmt>	<comment type="block">/* Check next record */</comment>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <name><name>pArch</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
	
	<return>return <expr><ternary><condition><expr><name><name>pArch</name><operator>-&gt;</operator><name>nLoaded</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SXRET_OK</name></expr> </then><else>: <expr><name>SXERR_EMPTY</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function> 						
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyZipExtractFromBuf</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
 	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zCentral</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
 	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
 	<if_stmt><if>if<condition>( <expr><call><name>SXARCH_INVALID</name><argument_list>(<argument><expr><name>pArch</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zBuf</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
 		<return>return <expr><name>SXERR_INVALID</name></expr>;</return>
 	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 	
 	<comment type="block">/* The miminal size of a zip archive:
 	 * LOCAL_HDR_SZ + CENTRAL_HDR_SZ + END_OF_CENTRAL_HDR_SZ
 	 * 		30				46				22
 	 */</comment>
 	 <if_stmt><if>if<condition>( <expr><name>nLen</name> <operator>&lt;</operator> <name>SXZIP_LOCAL_HDRSZ</name> <operator>+</operator> <name>SXZIP_CENTRAL_HDRSZ</name> <operator>+</operator> <name>SXZIP_END_CENTRAL_HDRSZ</name></expr> )</condition><block>{<block_content>
 	 	<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return> <comment type="block">/* Don't bother processing return immediately */</comment>
 	 </block_content>}</block></if></if_stmt>
 	  		
 	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>nLen</name> <operator>-</operator> <name>SXZIP_END_CENTRAL_HDRSZ</name></expr>]</index></name></expr>;</expr_stmt>
 	<comment type="block">/* Find the end of central directory */</comment>
 	<while>while<condition>( <expr><operator>(</operator><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>nLen</name></expr>]</index></name> <operator>-</operator> <name>zEnd</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name>SXZIP_END_CENTRAL_HDRSZ</name> <operator>+</operator> <name>SXI16_HIGH</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>zEnd</name> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zBuf</name> <operator>&amp;&amp;</operator> <call><name>SyMemcmp</name><argument_list>(<argument><expr><name>zEnd</name></expr></argument>, <argument><expr><literal type="string">"PK\005\006"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
 		<expr_stmt><expr><name>zEnd</name><operator>--</operator></expr>;</expr_stmt>
 	</block_content>}</block></while> 	
 	<comment type="block">/* Parse the end of central directory */</comment>
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ParseEndOfCentralDirectory</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pArch</name><operator>)</operator></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
 		<return>return <expr><name>rc</name></expr>;</return>
 	</block_content>}</block></if></if_stmt> 	
 	
 	<comment type="block">/* Find the starting offset of the central directory */</comment>
 	<expr_stmt><expr><name>zCentral</name> <operator>=</operator> <operator>&amp;</operator><name><name>zEnd</name><index>[<expr><operator>-</operator><operator>(</operator><name>sxi32</name><operator>)</operator><name><name>pArch</name><operator>-&gt;</operator><name>nCentralSize</name></name></expr>]</index></name></expr>;</expr_stmt>
 	<if_stmt><if>if<condition>( <expr><name>zCentral</name> <operator>&lt;=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zBuf</name> <operator>||</operator> <call><name>SyMemcmp</name><argument_list>(<argument><expr><name>zCentral</name></expr></argument>, <argument><expr><literal type="string">"PK\001\002"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
 		<if_stmt><if>if<condition>( <expr><name><name>pArch</name><operator>-&gt;</operator><name>nCentralOfft</name></name> <operator>&gt;=</operator> <name>nLen</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Corrupted central directory offset */</comment>
 			<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
 		</block_content>}</block></if></if_stmt>
 		<expr_stmt><expr><name>zCentral</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name><name>pArch</name><operator>-&gt;</operator><name>nCentralOfft</name></name></expr>]</index></name></expr>;</expr_stmt>
 		<if_stmt><if>if<condition>( <expr><call><name>SyMemcmp</name><argument_list>(<argument><expr><name>zCentral</name></expr></argument>, <argument><expr><literal type="string">"PK\001\002"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sxu32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
 			<comment type="block">/* Corrupted zip archive */</comment>
 			<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
 		</block_content>}</block></if></if_stmt>
 		<comment type="block">/* Fall thru and extract all valid entries from the central directory */</comment>
 	</block_content>}</block></if></if_stmt>
 	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ZipExtract</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pArch</name><operator>)</operator></expr></argument>, <argument><expr><name>zCentral</name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><name>zEnd</name> <operator>-</operator> <name>zCentral</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<return>return <expr><name>rc</name></expr>;</return>
 </block_content>}</block></function>
<comment type="block">/*
  * Default comparison function.
  */</comment>
 <function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ArchiveHashCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SyString</name> <modifier>*</modifier></type><name>pStr1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SyString</name> <modifier>*</modifier></type><name>pStr2</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
	 <decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	 <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyStringCmp</name><argument_list>(<argument><expr><name>pStr1</name></expr></argument>, <argument><expr><name>pStr2</name></expr></argument>, <argument><expr><name>SyMemcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 <return>return <expr><name>rc</name></expr>;</return>
 </block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyArchiveInit</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>, <parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pAllocator</name></decl></parameter>, <parameter><decl><type><name>ProcHash</name></type> <name>xHash</name></decl></parameter>, <parameter><decl><type><name>ProcRawStrCmp</name></type> <name>xCmp</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
	<decl_stmt><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>apHash</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
 	<if_stmt><if>if<condition>( <expr><name>pArch</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
 		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
 	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
 	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>pArch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SyArchive</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<comment type="block">/* Allocate a new hashtable */</comment> 	
	<expr_stmt><expr><name>apHash</name> <operator>=</operator> <operator>(</operator><name>SyArchiveEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>SyMemBackendAlloc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pAllocator</name><operator>)</operator></expr></argument>, <argument><expr><name>SXARCHIVE_HASH_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyArchiveEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>apHash</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
		<return>return <expr><name>SXERR_MEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>apHash</name></expr></argument>, <argument><expr><name>SXARCHIVE_HASH_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SyArchiveEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>apHash</name></name> <operator>=</operator> <name>apHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>xHash</name></name>  <operator>=</operator> <ternary><condition><expr><name>xHash</name></expr> ?</condition><then> <expr><name>xHash</name></expr> </then><else>: <expr><name>SyBinHash</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>xCmp</name></name>   <operator>=</operator> <ternary><condition><expr><name>xCmp</name></expr> ?</condition><then> <expr><name>xCmp</name></expr> </then><else>: <expr><name>ArchiveHashCmp</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>nSize</name></name>  <operator>=</operator> <name>SXARCHIVE_HASH_SIZE</name></expr>;</expr_stmt>
 	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>pAllocator</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>*</operator><name>pAllocator</name><operator>)</operator></expr>;</expr_stmt>
 	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <name>SXARCH_MAGIC</name></expr>;</expr_stmt>
 	<return>return <expr><name>SXRET_OK</name></expr>;</return>
 </block_content>}</block></function>
 <function><type><specifier>static</specifier> <name>sxi32</name></type> <name>ArchiveReleaseEntry</name><parameter_list>(<parameter><decl><type><name>SyMemBackend</name> <modifier>*</modifier></type><name>pAllocator</name></decl></parameter>, <parameter><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
 	<decl_stmt><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pDup</name> <init>= <expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNextName</name></name></expr></init></decl>;</decl_stmt>
 	<decl_stmt><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pNextDup</name></decl>;</decl_stmt>
 	
 	<comment type="block">/* Release duplicates first since there are not stored in the hashtable */</comment>
 	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
 		<if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>nDup</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
 			<break>break;</break>
 		</block_content>}</block></if></if_stmt>
 		<expr_stmt><expr><name>pNextDup</name> <operator>=</operator> <name><name>pDup</name><operator>-&gt;</operator><name>pNextName</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pDup</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <literal type="number">0x2661</literal></expr>;</expr_stmt>
 		<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name>pAllocator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>SyStringData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDup</name><operator>-&gt;</operator><name>sFileName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><name>pAllocator</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 		
 		<expr_stmt><expr><name>pDup</name> <operator>=</operator> <name>pNextDup</name></expr>;</expr_stmt>
 		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nDup</name></name><operator>--</operator></expr>;</expr_stmt>
 	</block_content>}</block></for> 		
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <literal type="number">0x2661</literal></expr>;</expr_stmt>
  	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name>pAllocator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>SyStringData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>sFileName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<expr_stmt><expr><call><name>SyMemBackendPoolFree</name><argument_list>(<argument><expr><name>pAllocator</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	<return>return <expr><name>SXRET_OK</name></expr>;</return>
 </block_content>}</block></function> 	
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyArchiveRelease</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
	<decl_stmt><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
 	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name><name>pArch</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt> 	 	
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name><name>pArch</name><operator>-&gt;</operator><name>nLoaded</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MACRO_LD_REMOVE</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArchiveReleaseEntry</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>nLoaded</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>SyMemBackendFree</name><argument_list>(<argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>pAllocator</name></name></expr></argument>, <argument><expr><name><name>pArch</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <literal type="number">0x2626</literal></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
 </block_content>}</block></function>
 <function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyArchiveResetLoopCursor</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
	<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <name><name>pArch</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
 </block_content>}</block></function>
 <function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyArchiveGetNextEntry</name><parameter_list>(<parameter><decl><type><name>SyArchive</name> <modifier>*</modifier></type><name>pArch</name></decl></parameter>, <parameter><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppEntry</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
	<decl_stmt><decl><type><name>SyArchiveEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pArch</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<comment type="block">/* Rewind the cursor */</comment>
		<expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <name><name>pArch</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
		<return>return <expr><name>SXERR_EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>ppEntry</name> <operator>=</operator> <name><name>pArch</name><operator>-&gt;</operator><name>pCursor</name></name></expr>;</expr_stmt>
	 <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pArch</name><operator>-&gt;</operator><name>pCursor</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
	 <comment type="block">/* Advance the cursor to the next entry */</comment>
	 <expr_stmt><expr><name><name>pArch</name><operator>-&gt;</operator><name>pCursor</name></name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
	 <return>return <expr><name>SXRET_OK</name></expr>;</return>
  </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
<comment type="block">/*
 * Psuedo Random Number Generator (PRNG)
 * @authors: SQLite authors &lt;http://www.sqlite.org/&gt;
 * @status: Public Domain
 * NOTE:
 *  Nothing in this file or anywhere else in the library does any kind of
 *  encryption.The RC4 algorithm is being used as a PRNG (pseudo-random
 *  number generator) not as an encryption device.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SXPRNG_MAGIC</name></cpp:macro>	<cpp:value>0x13C4</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__UNIXES__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>sxi32</name></type> <name>SyOSUtilRandomSeed</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUnused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pBuf</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>nProcessID</name></decl>;</decl_stmt> <comment type="block">/* Yes, keep it uninitialized when compiling using the MinGW32 builds tools */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__UNIXES__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>char</name></type> <name><name>zGarbage</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Yes, keep this buffer uninitialized */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>SXUNUSED</name><argument_list>(<argument><expr><name>pUnused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WINNT__</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__MINGW32__</name></cpp:ifndef>
	<expr_stmt><expr><name>nProcessID</name> <operator>=</operator> <call><name>GetProcessId</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nProcessID</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><call><name>SXMIN</name><argument_list>(<argument><expr><name>nLen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DWORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>nLen</name></expr>]</index></name> <operator>-</operator> <operator>&amp;</operator><name><name>zBuf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>DWORD</name></expr></argument>)</argument_list></sizeof></expr>]</index></name><operator>)</operator> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SYSTEMTIME</name></expr></argument>)</argument_list></sizeof></expr>  )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>(</operator><name>LPSYSTEMTIME</name><operator>)</operator><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>DWORD</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__UNIXES__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><literal type="string">"/dev/urandom"</literal></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>SXRET_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* FALL THRU */</comment>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pid</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><call><name>SXMIN</name><argument_list>(<argument><expr><name>nLen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pid_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>nLen</name></expr>]</index></name> <operator>-</operator> <operator>&amp;</operator><name><name>zBuf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>pid_t</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>timeval</name></expr></argument>)</argument_list></sizeof></expr>  )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>(</operator>struct <name>timeval</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>pid_t</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* Fill with uninitialized data */</comment>
	<expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>zGarbage</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><call><name>SXMIN</name><argument_list>(<argument><expr><name>nLen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zGarbage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyRandomnessInit</name><parameter_list>(<parameter><decl><type><name>SyPRNGCtx</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>ProcRandomSeed</name></type> <name>xSeed</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>pUserData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>zSeed</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu8</name></type> <name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>==</operator> <name>SXPRNG_MAGIC</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXRET_OK</name></expr>;</return> <comment type="block">/* Already initialized */</comment>
	</block_content>}</block></if></if_stmt>
 <comment type="block">/* Initialize the state of the random number generator once, 
  ** the first time this routine is called.The seed value does
  ** not need to contain a lot of randomness since we are not
  ** trying to do secure encryption or anything like that...
  */</comment>	
	<if_stmt><if>if<condition>( <expr><name>xSeed</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><name>xSeed</name> <operator>=</operator> <name>SyOSUtilRandomSeed</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xSeed</name><argument_list>(<argument><expr><name>zSeed</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zSeed</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pUserData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>j</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>SX_ARRAYSIZE</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
		<expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>zSeed</name></expr></argument>)</argument_list></sizeof></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>j</name></name> <operator>+=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>zSeed</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name><name>pCtx</name><operator>-&gt;</operator><name>j</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name><name>pCtx</name><operator>-&gt;</operator><name>j</name></name></expr>]</index></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
    </block_content>}</block></for>
	<expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>=</operator> <name>SXPRNG_MAGIC</name></expr>;</expr_stmt>
	
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Get a single 8-bit random value using the RC4 PRNG.
 */</comment>
<function><type><specifier>static</specifier> <name>sxu8</name></type> <name>randomByte</name><parameter_list>(<parameter><decl><type><name>SyPRNGCtx</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sxu8</name></type> <name>t</name></decl>;</decl_stmt>
  
  <comment type="block">/* Generate and return single random byte */</comment>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name><name>pCtx</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>j</name></name> <operator>+=</operator> <name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name><name>pCtx</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name><name>pCtx</name><operator>-&gt;</operator><name>j</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name><name>pCtx</name><operator>-&gt;</operator><name>j</name></name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>+=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name><name>pCtx</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name><name>pCtx</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>t</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyRandomness</name><parameter_list>(<parameter><decl><type><name>SyPRNGCtx</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBuf</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pBuf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>nLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>pCtx</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pBuf</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if<condition>(<expr><name><name>pCtx</name><operator>-&gt;</operator><name>nMagic</name></name> <operator>!=</operator> <name>SXPRNG_MAGIC</name></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zBuf</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt>	<expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>randomByte</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<expr_stmt><expr><name>zBuf</name><operator>++</operator></expr>;</expr_stmt>	
		<if_stmt><if>if<condition>( <expr><name>zBuf</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt>	<expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>randomByte</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<expr_stmt><expr><name>zBuf</name><operator>++</operator></expr>;</expr_stmt>	
		<if_stmt><if>if<condition>( <expr><name>zBuf</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt>	<expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>randomByte</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<expr_stmt><expr><name>zBuf</name><operator>++</operator></expr>;</expr_stmt>	
		<if_stmt><if>if<condition>( <expr><name>zBuf</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content><break>break;</break></block_content>}</block></if></if_stmt>	<expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>randomByte</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<expr_stmt><expr><name>zBuf</name><operator>++</operator></expr>;</expr_stmt>	
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>  
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_HASH_FUNC</name></cpp:ifndef>
<comment type="block">/* SyRunTimeApi: sxhash.c */</comment>
<comment type="block">/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent, 
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SX_MD5_BINSZ</name></cpp:macro>	<cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SX_MD5_HEXSZ</name></cpp:macro>	<cpp:value>32</cpp:value></cpp:define>
<comment type="block">/*
 * Note: this code is harmless on little-endian machines.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>byteReverse</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>longs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>t</name></decl>;</decl_stmt>
        <do>do <block>{<block_content>
                <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>sxu32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal> <operator>|</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal> <operator>|</operator>
                            <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal> <operator>|</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sxu32</name><operator>*</operator><operator>)</operator><name>buf</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>buf</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><operator>--</operator><name>longs</name></expr>)</condition>;</do>
</block_content>}</block></function>
<comment type="block">/* The four core functions - F1 is optimized somewhat */</comment>

<comment type="block">/* #define F1(x, y, z) (x &amp; y | ~x &amp; z) */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F1</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>F1</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F2</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>F2</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F3</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>F3</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F4</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>F4</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F1</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(z ^ (x &amp; (y ^ z)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>F1(z, x, y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F3</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x ^ y ^ z)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F4</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(y ^ (x | ~z))</cpp:value></cpp:define>

<comment type="block">/* This is the central step in the MD5 algorithm.*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SX_MD5STEP</name><parameter_list>(<parameter><type><name>f</name></type></parameter>, <parameter><type><name>w</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>, <parameter><type><name>data</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> \
        <cpp:value>( w += f(x, y, z) + data,  w = w&lt;&lt;s | w&gt;&gt;(32-s),  w += x )</cpp:value></cpp:define>

<comment type="block">/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>MD5Transform</name><parameter_list>(<parameter><decl><type><name>sxu32</name></type> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sxu32</name></type> <name><name>in</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>sxu32</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>c</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">0xd76aa478</literal></expr></argument>,  <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">1</literal></expr>]</index></name><operator>+</operator><literal type="number">0xe8c7b756</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">2</literal></expr>]</index></name><operator>+</operator><literal type="number">0x242070db</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">3</literal></expr>]</index></name><operator>+</operator><literal type="number">0xc1bdceee</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">4</literal></expr>]</index></name><operator>+</operator><literal type="number">0xf57c0faf</literal></expr></argument>,  <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">5</literal></expr>]</index></name><operator>+</operator><literal type="number">0x4787c62a</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">6</literal></expr>]</index></name><operator>+</operator><literal type="number">0xa8304613</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">7</literal></expr>]</index></name><operator>+</operator><literal type="number">0xfd469501</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">8</literal></expr>]</index></name><operator>+</operator><literal type="number">0x698098d8</literal></expr></argument>,  <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">9</literal></expr>]</index></name><operator>+</operator><literal type="number">0x8b44f7af</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>+</operator><literal type="number">0xffff5bb1</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">11</literal></expr>]</index></name><operator>+</operator><literal type="number">0x895cd7be</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">12</literal></expr>]</index></name><operator>+</operator><literal type="number">0x6b901122</literal></expr></argument>,  <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">13</literal></expr>]</index></name><operator>+</operator><literal type="number">0xfd987193</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">14</literal></expr>]</index></name><operator>+</operator><literal type="number">0xa679438e</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F1</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">15</literal></expr>]</index></name><operator>+</operator><literal type="number">0x49b40821</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">1</literal></expr>]</index></name><operator>+</operator><literal type="number">0xf61e2562</literal></expr></argument>,  <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">6</literal></expr>]</index></name><operator>+</operator><literal type="number">0xc040b340</literal></expr></argument>,  <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">11</literal></expr>]</index></name><operator>+</operator><literal type="number">0x265e5a51</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">0xe9b6c7aa</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">5</literal></expr>]</index></name><operator>+</operator><literal type="number">0xd62f105d</literal></expr></argument>,  <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>+</operator><literal type="number">0x02441453</literal></expr></argument>,  <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">15</literal></expr>]</index></name><operator>+</operator><literal type="number">0xd8a1e681</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">4</literal></expr>]</index></name><operator>+</operator><literal type="number">0xe7d3fbc8</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">9</literal></expr>]</index></name><operator>+</operator><literal type="number">0x21e1cde6</literal></expr></argument>,  <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">14</literal></expr>]</index></name><operator>+</operator><literal type="number">0xc33707d6</literal></expr></argument>,  <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">3</literal></expr>]</index></name><operator>+</operator><literal type="number">0xf4d50d87</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">8</literal></expr>]</index></name><operator>+</operator><literal type="number">0x455a14ed</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">13</literal></expr>]</index></name><operator>+</operator><literal type="number">0xa9e3e905</literal></expr></argument>,  <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">2</literal></expr>]</index></name><operator>+</operator><literal type="number">0xfcefa3f8</literal></expr></argument>,  <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">7</literal></expr>]</index></name><operator>+</operator><literal type="number">0x676f02d9</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F2</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">12</literal></expr>]</index></name><operator>+</operator><literal type="number">0x8d2a4c8a</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">5</literal></expr>]</index></name><operator>+</operator><literal type="number">0xfffa3942</literal></expr></argument>,  <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">8</literal></expr>]</index></name><operator>+</operator><literal type="number">0x8771f681</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">11</literal></expr>]</index></name><operator>+</operator><literal type="number">0x6d9d6122</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">14</literal></expr>]</index></name><operator>+</operator><literal type="number">0xfde5380c</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">1</literal></expr>]</index></name><operator>+</operator><literal type="number">0xa4beea44</literal></expr></argument>,  <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">4</literal></expr>]</index></name><operator>+</operator><literal type="number">0x4bdecfa9</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">7</literal></expr>]</index></name><operator>+</operator><literal type="number">0xf6bb4b60</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>+</operator><literal type="number">0xbebfbc70</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">13</literal></expr>]</index></name><operator>+</operator><literal type="number">0x289b7ec6</literal></expr></argument>,  <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">0xeaa127fa</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">3</literal></expr>]</index></name><operator>+</operator><literal type="number">0xd4ef3085</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">6</literal></expr>]</index></name><operator>+</operator><literal type="number">0x04881d05</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">9</literal></expr>]</index></name><operator>+</operator><literal type="number">0xd9d4d039</literal></expr></argument>,  <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">12</literal></expr>]</index></name><operator>+</operator><literal type="number">0xe6db99e5</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">15</literal></expr>]</index></name><operator>+</operator><literal type="number">0x1fa27cf8</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F3</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">2</literal></expr>]</index></name><operator>+</operator><literal type="number">0xc4ac5665</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">0xf4292244</literal></expr></argument>,  <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">7</literal></expr>]</index></name><operator>+</operator><literal type="number">0x432aff97</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">14</literal></expr>]</index></name><operator>+</operator><literal type="number">0xab9423a7</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">5</literal></expr>]</index></name><operator>+</operator><literal type="number">0xfc93a039</literal></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">12</literal></expr>]</index></name><operator>+</operator><literal type="number">0x655b59c3</literal></expr></argument>,  <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">3</literal></expr>]</index></name><operator>+</operator><literal type="number">0x8f0ccc92</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>+</operator><literal type="number">0xffeff47d</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">1</literal></expr>]</index></name><operator>+</operator><literal type="number">0x85845dd1</literal></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">8</literal></expr>]</index></name><operator>+</operator><literal type="number">0x6fa87e4f</literal></expr></argument>,  <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">15</literal></expr>]</index></name><operator>+</operator><literal type="number">0xfe2ce6e0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">6</literal></expr>]</index></name><operator>+</operator><literal type="number">0xa3014314</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">13</literal></expr>]</index></name><operator>+</operator><literal type="number">0x4e0811a1</literal></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">4</literal></expr>]</index></name><operator>+</operator><literal type="number">0xf7537e82</literal></expr></argument>,  <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>in</name><index>[<expr><literal type="number">11</literal></expr>]</index></name><operator>+</operator><literal type="number">0xbd3af235</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">2</literal></expr>]</index></name><operator>+</operator><literal type="number">0x2ad7d2bb</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SX_MD5STEP</name><argument_list>(<argument><expr><name>F4</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>in</name><index>[ <expr><literal type="number">9</literal></expr>]</index></name><operator>+</operator><literal type="number">0xeb86d391</literal></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>b</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>c</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>d</name></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>MD5Update</name><parameter_list>(<parameter><decl><type><name>MD5Context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>t</name></decl>;</decl_stmt>

        <comment type="block">/* Update bitcount */</comment>
        <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>t</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>sxu32</name><operator>)</operator><name>len</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>&lt;</operator> <name>t</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Carry from low to high */</comment>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>len</name> <operator>&gt;&gt;</operator> <literal type="number">29</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>t</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>    <comment type="block">/* Bytes already in shsInfo-&gt;data */</comment>
        <comment type="block">/* Handle any leading odd-sized chunks */</comment>
        <if_stmt><if>if <condition>( <expr><name>t</name></expr> )</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name> <operator>+</operator> <name>t</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="number">64</literal><operator>-</operator><name>t</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>t</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>byteReverse</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MD5Transform</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>t</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>t</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Process data in 64-byte chunks */</comment>
        <while>while <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>byteReverse</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MD5Transform</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buf</name> <operator>+=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
        <comment type="block">/* Handle any remaining bytes of data.*/</comment>
        <expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern 
 * 1 0* (64-bit count of bits processed, MSB-first)
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>MD5Final</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>MD5Context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>count</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

        <comment type="block">/* Compute number of bytes mod 64 */</comment>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>;</expr_stmt>

        <comment type="block">/* Set the first char of padding to 0x80.This is safe since there is
           always at least one byte free */</comment>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>in</name></name> <operator>+</operator> <name>count</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>

        <comment type="block">/* Bytes of padding needed to make 64 bytes */</comment>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">64</literal> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>count</name></expr>;</expr_stmt>

        <comment type="block">/* Pad out to 56 mod 64 */</comment>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Two lots of padding:  Pad the first block to 64 bytes */</comment>
               <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>byteReverse</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MD5Transform</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Now fill the next block with 56 bytes */</comment>
                <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* Pad block to 56 bytes */</comment>
                <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>count</name><operator>-</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>byteReverse</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Append length in bits and transform */</comment>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>sxu32</name><operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name><operator>)</operator><index>[ <expr><literal type="number">14</literal></expr> ]</index> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>sxu32</name><operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name><operator>)</operator><index>[ <expr><literal type="number">15</literal></expr> ]</index> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MD5Transform</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>sxu32</name><operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>byteReverse</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><literal type="number">0x10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SyZero</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* In case it's sensitive */</comment>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>F1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>F2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>F3</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>F4</name></cpp:undef>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>MD5Init</name><parameter_list>(<parameter><decl><type><name>MD5Context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list>
<block>{<block_content>	
	<expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x67452301</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xefcdab89</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x98badcfe</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x10325476</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
   
   <return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyMD5Compute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zDigest</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MD5Context</name></type> <name>sCtx</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MD5Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MD5Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pIn</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MD5Final</name><argument_list>(<argument><expr><name>zDigest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * SHA-1 in C
 * By Steve Reid &lt;steve@edmweb.com&gt;
 * Status: Public Domain
 */</comment>
<comment type="block">/*
 * blk0() and blk() perform the initial expand.
 * I got the idea of expanding during the round function from SSLeay
 *
 * blk0le() for little-endian and blk0be() for big-endian.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__GNUC__</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<comment type="block">/*
 * GCC by itself only generates left rotates.  Use right rotates if
 * possible to be kinder to dinky implementations with iterative rotate
 * instructions.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHA_ROT</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> \
        <cpp:value>({ unsigned int y; asm(op " %1, %0" : "=r" (y) : "I" (k), "0" (x)); y; })</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rol</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SHA_ROT("roll", x, k)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ror</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SHA_ROT("rorl", x, k)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Generic C equivalent */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHA_ROT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>l</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &lt;&lt; (l) | (x) &gt;&gt; (r))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rol</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SHA_ROT(x, k, 32-(k))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ror</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SHA_ROT(x, 32-(k), k)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>blk0le</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(block[i] = (ror(block[i], 8)&amp;0xFF00FF00) \
    |(rol(block[i], 8)&amp;0x00FF00FF))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>blk0be</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>block[i]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>blk</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(block[i&amp;15] = rol(block[(i+13)&amp;15]^block[(i+8)&amp;15] \
    ^block[(i+2)&amp;15]^block[i&amp;15], 1))</cpp:value></cpp:define>

<comment type="block">/*
 * (R0+R1), R2, R3, R4 are the different operations (rounds) used in SHA1
 *
 * Rl0() for little-endian and Rb0() for big-endian.  Endianness is 
 * determined at run-time.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Rl0</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>w</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>z+=((w&amp;(x^y))^y)+blk0le(i)+0x5A827999+rol(v, 5);w=ror(w, 2);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Rb0</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>w</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>z+=((w&amp;(x^y))^y)+blk0be(i)+0x5A827999+rol(v, 5);w=ror(w, 2);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R1</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>w</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>z+=((w&amp;(x^y))^y)+blk(i)+0x5A827999+rol(v, 5);w=ror(w, 2);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R2</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>w</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v, 5);w=ror(w, 2);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R3</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>w</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>z+=(((w|x)&amp;y)|(w&amp;x))+blk(i)+0x8F1BBCDC+rol(v, 5);w=ror(w, 2);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R4</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>w</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v, 5);w=ror(w, 2);</cpp:value></cpp:define>

<comment type="block">/*
 * Hash a single 512-bit block. This is the core of the algorithm.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>a</name></cpp:macro> <cpp:value>qq[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>b</name></cpp:macro> <cpp:value>qq[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>c</name></cpp:macro> <cpp:value>qq[2]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>d</name></cpp:macro> <cpp:value>qq[3]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>e</name></cpp:macro> <cpp:value>qq[4]</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>SHA1Transform</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name><name>state</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>qq</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* a, b, c, d, e; */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>block</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>block</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>qq</name></expr></argument>, <argument><expr><literal type="number">5</literal><operator>*</operator>sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Copy context-&gt;state[] to working vars */</comment>
  <comment type="block">/*
  a = state[0];
  b = state[1];
  c = state[2];
  d = state[3];
  e = state[4];
  */</comment>

  <comment type="block">/* 4 rounds of 20 operations each. Loop unrolled. */</comment>
  <if_stmt><if>if<condition>( <expr><literal type="number">1</literal> <operator>==</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>one</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rl0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Rb0</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>R1</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R1</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R1</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R1</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">26</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">27</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">29</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">35</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">36</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">37</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">38</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R2</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">39</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">42</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">43</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">46</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">47</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">48</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">49</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">51</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">52</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">53</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">54</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">55</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">57</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">58</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R3</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">59</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">61</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">62</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">63</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">65</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">66</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">67</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">68</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">69</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">70</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">71</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">72</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">73</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">74</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">75</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">76</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">77</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">78</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>R4</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add the working vars back into context.state[] */</comment>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>b</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>d</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>a</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>b</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>c</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>d</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>e</name></cpp:undef>
<comment type="block">/*
 * SHA1Init - Initialize new context
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SHA1Init</name><parameter_list>(<parameter><decl><type><name>SHA1Context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
    <comment type="block">/* SHA1 initialization constants */</comment>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x67452301</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xEFCDAB89</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x98BADCFE</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x10325476</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xC3D2E1F0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>count</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>count</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Run your data through this.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SHA1Update</name><parameter_list>(<parameter><decl><type><name>SHA1Context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>count</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>count</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>len</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&lt;</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>count</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>len</name><operator>&gt;&gt;</operator><literal type="number">29</literal><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>j</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>SyMemcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,  <argument><expr><operator>(</operator><name>i</name> <operator>=</operator> <literal type="number">64</literal><operator>-</operator><name>j</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHA1Transform</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>( <init>;</init> <condition><expr><name>i</name> <operator>+</operator> <literal type="number">63</literal> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">64</literal></expr></incr>)</control><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>SHA1Transform</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>SyMemcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Add padding and return the message digest.
 */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SHA1Final</name><parameter_list>(<parameter><decl><type><name>SHA1Context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl></parameter>)</parameter_list><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>finalcount</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	<expr_stmt><expr><name><name>finalcount</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>count</name><index>[<expr><operator>(</operator><ternary><condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>]</index></name>
	 <operator>&gt;&gt;</operator> <operator>(</operator><operator>(</operator><literal type="number">3</literal><operator>-</operator><operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">8</literal><operator>)</operator> <operator>)</operator> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>	 <comment type="block">/* Endian independent */</comment>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>SHA1Update</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"\200"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>count</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">504</literal><operator>)</operator> <operator>!=</operator> <literal type="number">448</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>SHA1Update</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"\0"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>SHA1Update</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>finalcount</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Should cause a SHA1Transform() */</comment>

    <if_stmt><if>if <condition>(<expr><name>digest</name></expr>)</condition> <block>{<block_content>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">20</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>digest</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator>
		<operator>(</operator><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>state</name><index>[<expr><name>i</name><operator>&gt;&gt;</operator><literal type="number">2</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><operator>(</operator><literal type="number">3</literal><operator>-</operator><operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">8</literal><operator>)</operator> <operator>)</operator> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Rl0</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Rb0</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R3</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R4</name></cpp:undef>

<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SySha1Compute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zDigest</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SHA1Context</name></type> <name>sCtx</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SHA1Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHA1Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pIn</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHA1Final</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><name>zDigest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sxu32</name></type> <name><name>crc32_table</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x00000000</literal></expr>, <expr><literal type="number">0x77073096</literal></expr>, <expr><literal type="number">0xee0e612c</literal></expr>, <expr><literal type="number">0x990951ba</literal></expr>, 
	<expr><literal type="number">0x076dc419</literal></expr>, <expr><literal type="number">0x706af48f</literal></expr>, <expr><literal type="number">0xe963a535</literal></expr>, <expr><literal type="number">0x9e6495a3</literal></expr>, 
	<expr><literal type="number">0x0edb8832</literal></expr>, <expr><literal type="number">0x79dcb8a4</literal></expr>, <expr><literal type="number">0xe0d5e91e</literal></expr>, <expr><literal type="number">0x97d2d988</literal></expr>, 
	<expr><literal type="number">0x09b64c2b</literal></expr>, <expr><literal type="number">0x7eb17cbd</literal></expr>, <expr><literal type="number">0xe7b82d07</literal></expr>, <expr><literal type="number">0x90bf1d91</literal></expr>, 
	<expr><literal type="number">0x1db71064</literal></expr>, <expr><literal type="number">0x6ab020f2</literal></expr>, <expr><literal type="number">0xf3b97148</literal></expr>, <expr><literal type="number">0x84be41de</literal></expr>, 
	<expr><literal type="number">0x1adad47d</literal></expr>, <expr><literal type="number">0x6ddde4eb</literal></expr>, <expr><literal type="number">0xf4d4b551</literal></expr>, <expr><literal type="number">0x83d385c7</literal></expr>, 
	<expr><literal type="number">0x136c9856</literal></expr>, <expr><literal type="number">0x646ba8c0</literal></expr>, <expr><literal type="number">0xfd62f97a</literal></expr>, <expr><literal type="number">0x8a65c9ec</literal></expr>, 
	<expr><literal type="number">0x14015c4f</literal></expr>, <expr><literal type="number">0x63066cd9</literal></expr>, <expr><literal type="number">0xfa0f3d63</literal></expr>, <expr><literal type="number">0x8d080df5</literal></expr>, 
	<expr><literal type="number">0x3b6e20c8</literal></expr>, <expr><literal type="number">0x4c69105e</literal></expr>, <expr><literal type="number">0xd56041e4</literal></expr>, <expr><literal type="number">0xa2677172</literal></expr>, 
	<expr><literal type="number">0x3c03e4d1</literal></expr>, <expr><literal type="number">0x4b04d447</literal></expr>, <expr><literal type="number">0xd20d85fd</literal></expr>, <expr><literal type="number">0xa50ab56b</literal></expr>, 
	<expr><literal type="number">0x35b5a8fa</literal></expr>, <expr><literal type="number">0x42b2986c</literal></expr>, <expr><literal type="number">0xdbbbc9d6</literal></expr>, <expr><literal type="number">0xacbcf940</literal></expr>, 
	<expr><literal type="number">0x32d86ce3</literal></expr>, <expr><literal type="number">0x45df5c75</literal></expr>, <expr><literal type="number">0xdcd60dcf</literal></expr>, <expr><literal type="number">0xabd13d59</literal></expr>, 
	<expr><literal type="number">0x26d930ac</literal></expr>, <expr><literal type="number">0x51de003a</literal></expr>, <expr><literal type="number">0xc8d75180</literal></expr>, <expr><literal type="number">0xbfd06116</literal></expr>, 
	<expr><literal type="number">0x21b4f4b5</literal></expr>, <expr><literal type="number">0x56b3c423</literal></expr>, <expr><literal type="number">0xcfba9599</literal></expr>, <expr><literal type="number">0xb8bda50f</literal></expr>, 
	<expr><literal type="number">0x2802b89e</literal></expr>, <expr><literal type="number">0x5f058808</literal></expr>, <expr><literal type="number">0xc60cd9b2</literal></expr>, <expr><literal type="number">0xb10be924</literal></expr>, 
	<expr><literal type="number">0x2f6f7c87</literal></expr>, <expr><literal type="number">0x58684c11</literal></expr>, <expr><literal type="number">0xc1611dab</literal></expr>, <expr><literal type="number">0xb6662d3d</literal></expr>, 
	<expr><literal type="number">0x76dc4190</literal></expr>, <expr><literal type="number">0x01db7106</literal></expr>, <expr><literal type="number">0x98d220bc</literal></expr>, <expr><literal type="number">0xefd5102a</literal></expr>, 
	<expr><literal type="number">0x71b18589</literal></expr>, <expr><literal type="number">0x06b6b51f</literal></expr>, <expr><literal type="number">0x9fbfe4a5</literal></expr>, <expr><literal type="number">0xe8b8d433</literal></expr>, 
	<expr><literal type="number">0x7807c9a2</literal></expr>, <expr><literal type="number">0x0f00f934</literal></expr>, <expr><literal type="number">0x9609a88e</literal></expr>, <expr><literal type="number">0xe10e9818</literal></expr>, 
	<expr><literal type="number">0x7f6a0dbb</literal></expr>, <expr><literal type="number">0x086d3d2d</literal></expr>, <expr><literal type="number">0x91646c97</literal></expr>, <expr><literal type="number">0xe6635c01</literal></expr>, 
	<expr><literal type="number">0x6b6b51f4</literal></expr>, <expr><literal type="number">0x1c6c6162</literal></expr>, <expr><literal type="number">0x856530d8</literal></expr>, <expr><literal type="number">0xf262004e</literal></expr>, 
	<expr><literal type="number">0x6c0695ed</literal></expr>, <expr><literal type="number">0x1b01a57b</literal></expr>, <expr><literal type="number">0x8208f4c1</literal></expr>, <expr><literal type="number">0xf50fc457</literal></expr>, 
	<expr><literal type="number">0x65b0d9c6</literal></expr>, <expr><literal type="number">0x12b7e950</literal></expr>, <expr><literal type="number">0x8bbeb8ea</literal></expr>, <expr><literal type="number">0xfcb9887c</literal></expr>, 
	<expr><literal type="number">0x62dd1ddf</literal></expr>, <expr><literal type="number">0x15da2d49</literal></expr>, <expr><literal type="number">0x8cd37cf3</literal></expr>, <expr><literal type="number">0xfbd44c65</literal></expr>, 
	<expr><literal type="number">0x4db26158</literal></expr>, <expr><literal type="number">0x3ab551ce</literal></expr>, <expr><literal type="number">0xa3bc0074</literal></expr>, <expr><literal type="number">0xd4bb30e2</literal></expr>, 
	<expr><literal type="number">0x4adfa541</literal></expr>, <expr><literal type="number">0x3dd895d7</literal></expr>, <expr><literal type="number">0xa4d1c46d</literal></expr>, <expr><literal type="number">0xd3d6f4fb</literal></expr>, 
	<expr><literal type="number">0x4369e96a</literal></expr>, <expr><literal type="number">0x346ed9fc</literal></expr>, <expr><literal type="number">0xad678846</literal></expr>, <expr><literal type="number">0xda60b8d0</literal></expr>, 
	<expr><literal type="number">0x44042d73</literal></expr>, <expr><literal type="number">0x33031de5</literal></expr>, <expr><literal type="number">0xaa0a4c5f</literal></expr>, <expr><literal type="number">0xdd0d7cc9</literal></expr>, 
	<expr><literal type="number">0x5005713c</literal></expr>, <expr><literal type="number">0x270241aa</literal></expr>, <expr><literal type="number">0xbe0b1010</literal></expr>, <expr><literal type="number">0xc90c2086</literal></expr>, 
	<expr><literal type="number">0x5768b525</literal></expr>, <expr><literal type="number">0x206f85b3</literal></expr>, <expr><literal type="number">0xb966d409</literal></expr>, <expr><literal type="number">0xce61e49f</literal></expr>, 
	<expr><literal type="number">0x5edef90e</literal></expr>, <expr><literal type="number">0x29d9c998</literal></expr>, <expr><literal type="number">0xb0d09822</literal></expr>, <expr><literal type="number">0xc7d7a8b4</literal></expr>, 
	<expr><literal type="number">0x59b33d17</literal></expr>, <expr><literal type="number">0x2eb40d81</literal></expr>, <expr><literal type="number">0xb7bd5c3b</literal></expr>, <expr><literal type="number">0xc0ba6cad</literal></expr>, 
	<expr><literal type="number">0xedb88320</literal></expr>, <expr><literal type="number">0x9abfb3b6</literal></expr>, <expr><literal type="number">0x03b6e20c</literal></expr>, <expr><literal type="number">0x74b1d29a</literal></expr>, 
	<expr><literal type="number">0xead54739</literal></expr>, <expr><literal type="number">0x9dd277af</literal></expr>, <expr><literal type="number">0x04db2615</literal></expr>, <expr><literal type="number">0x73dc1683</literal></expr>, 
	<expr><literal type="number">0xe3630b12</literal></expr>, <expr><literal type="number">0x94643b84</literal></expr>, <expr><literal type="number">0x0d6d6a3e</literal></expr>, <expr><literal type="number">0x7a6a5aa8</literal></expr>, 
	<expr><literal type="number">0xe40ecf0b</literal></expr>, <expr><literal type="number">0x9309ff9d</literal></expr>, <expr><literal type="number">0x0a00ae27</literal></expr>, <expr><literal type="number">0x7d079eb1</literal></expr>, 
	<expr><literal type="number">0xf00f9344</literal></expr>, <expr><literal type="number">0x8708a3d2</literal></expr>, <expr><literal type="number">0x1e01f268</literal></expr>, <expr><literal type="number">0x6906c2fe</literal></expr>, 
	<expr><literal type="number">0xf762575d</literal></expr>, <expr><literal type="number">0x806567cb</literal></expr>, <expr><literal type="number">0x196c3671</literal></expr>, <expr><literal type="number">0x6e6b06e7</literal></expr>, 
	<expr><literal type="number">0xfed41b76</literal></expr>, <expr><literal type="number">0x89d32be0</literal></expr>, <expr><literal type="number">0x10da7a5a</literal></expr>, <expr><literal type="number">0x67dd4acc</literal></expr>, 
	<expr><literal type="number">0xf9b9df6f</literal></expr>, <expr><literal type="number">0x8ebeeff9</literal></expr>, <expr><literal type="number">0x17b7be43</literal></expr>, <expr><literal type="number">0x60b08ed5</literal></expr>, 
	<expr><literal type="number">0xd6d6a3e8</literal></expr>, <expr><literal type="number">0xa1d1937e</literal></expr>, <expr><literal type="number">0x38d8c2c4</literal></expr>, <expr><literal type="number">0x4fdff252</literal></expr>, 
	<expr><literal type="number">0xd1bb67f1</literal></expr>, <expr><literal type="number">0xa6bc5767</literal></expr>, <expr><literal type="number">0x3fb506dd</literal></expr>, <expr><literal type="number">0x48b2364b</literal></expr>, 
	<expr><literal type="number">0xd80d2bda</literal></expr>, <expr><literal type="number">0xaf0a1b4c</literal></expr>, <expr><literal type="number">0x36034af6</literal></expr>, <expr><literal type="number">0x41047a60</literal></expr>, 
	<expr><literal type="number">0xdf60efc3</literal></expr>, <expr><literal type="number">0xa867df55</literal></expr>, <expr><literal type="number">0x316e8eef</literal></expr>, <expr><literal type="number">0x4669be79</literal></expr>, 
	<expr><literal type="number">0xcb61b38c</literal></expr>, <expr><literal type="number">0xbc66831a</literal></expr>, <expr><literal type="number">0x256fd2a0</literal></expr>, <expr><literal type="number">0x5268e236</literal></expr>, 
	<expr><literal type="number">0xcc0c7795</literal></expr>, <expr><literal type="number">0xbb0b4703</literal></expr>, <expr><literal type="number">0x220216b9</literal></expr>, <expr><literal type="number">0x5505262f</literal></expr>, 
	<expr><literal type="number">0xc5ba3bbe</literal></expr>, <expr><literal type="number">0xb2bd0b28</literal></expr>, <expr><literal type="number">0x2bb45a92</literal></expr>, <expr><literal type="number">0x5cb36a04</literal></expr>, 
	<expr><literal type="number">0xc2d7ffa7</literal></expr>, <expr><literal type="number">0xb5d0cf31</literal></expr>, <expr><literal type="number">0x2cd99e8b</literal></expr>, <expr><literal type="number">0x5bdeae1d</literal></expr>, 
	<expr><literal type="number">0x9b64c2b0</literal></expr>, <expr><literal type="number">0xec63f226</literal></expr>, <expr><literal type="number">0x756aa39c</literal></expr>, <expr><literal type="number">0x026d930a</literal></expr>, 
	<expr><literal type="number">0x9c0906a9</literal></expr>, <expr><literal type="number">0xeb0e363f</literal></expr>, <expr><literal type="number">0x72076785</literal></expr>, <expr><literal type="number">0x05005713</literal></expr>, 
	<expr><literal type="number">0x95bf4a82</literal></expr>, <expr><literal type="number">0xe2b87a14</literal></expr>, <expr><literal type="number">0x7bb12bae</literal></expr>, <expr><literal type="number">0x0cb61b38</literal></expr>, 
	<expr><literal type="number">0x92d28e9b</literal></expr>, <expr><literal type="number">0xe5d5be0d</literal></expr>, <expr><literal type="number">0x7cdcefb7</literal></expr>, <expr><literal type="number">0x0bdbdf21</literal></expr>, 
	<expr><literal type="number">0x86d3d2d4</literal></expr>, <expr><literal type="number">0xf1d4e242</literal></expr>, <expr><literal type="number">0x68ddb3f8</literal></expr>, <expr><literal type="number">0x1fda836e</literal></expr>, 
	<expr><literal type="number">0x81be16cd</literal></expr>, <expr><literal type="number">0xf6b9265b</literal></expr>, <expr><literal type="number">0x6fb077e1</literal></expr>, <expr><literal type="number">0x18b74777</literal></expr>, 
	<expr><literal type="number">0x88085ae6</literal></expr>, <expr><literal type="number">0xff0f6a70</literal></expr>, <expr><literal type="number">0x66063bca</literal></expr>, <expr><literal type="number">0x11010b5c</literal></expr>, 
	<expr><literal type="number">0x8f659eff</literal></expr>, <expr><literal type="number">0xf862ae69</literal></expr>, <expr><literal type="number">0x616bffd3</literal></expr>, <expr><literal type="number">0x166ccf45</literal></expr>, 
	<expr><literal type="number">0xa00ae278</literal></expr>, <expr><literal type="number">0xd70dd2ee</literal></expr>, <expr><literal type="number">0x4e048354</literal></expr>, <expr><literal type="number">0x3903b3c2</literal></expr>, 
	<expr><literal type="number">0xa7672661</literal></expr>, <expr><literal type="number">0xd06016f7</literal></expr>, <expr><literal type="number">0x4969474d</literal></expr>, <expr><literal type="number">0x3e6e77db</literal></expr>, 
	<expr><literal type="number">0xaed16a4a</literal></expr>, <expr><literal type="number">0xd9d65adc</literal></expr>, <expr><literal type="number">0x40df0b66</literal></expr>, <expr><literal type="number">0x37d83bf0</literal></expr>, 
	<expr><literal type="number">0xa9bcae53</literal></expr>, <expr><literal type="number">0xdebb9ec5</literal></expr>, <expr><literal type="number">0x47b2cf7f</literal></expr>, <expr><literal type="number">0x30b5ffe9</literal></expr>, 
	<expr><literal type="number">0xbdbdf21c</literal></expr>, <expr><literal type="number">0xcabac28a</literal></expr>, <expr><literal type="number">0x53b39330</literal></expr>, <expr><literal type="number">0x24b4a3a6</literal></expr>, 
	<expr><literal type="number">0xbad03605</literal></expr>, <expr><literal type="number">0xcdd70693</literal></expr>, <expr><literal type="number">0x54de5729</literal></expr>, <expr><literal type="number">0x23d967bf</literal></expr>, 
	<expr><literal type="number">0xb3667a2e</literal></expr>, <expr><literal type="number">0xc4614ab8</literal></expr>, <expr><literal type="number">0x5d681b02</literal></expr>, <expr><literal type="number">0x2a6f2b94</literal></expr>, 
	<expr><literal type="number">0xb40bbe37</literal></expr>, <expr><literal type="number">0xc30c8ea1</literal></expr>, <expr><literal type="number">0x5a05df1b</literal></expr>, <expr><literal type="number">0x2d02ef8d</literal></expr>, 
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRC32C</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(c = ( crc32_table[(c ^ (d)) &amp; 0xFF] ^ (c&gt;&gt;8) ) )</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>sxu32</name></type> <name>SyCrc32Update</name><parameter_list>(<parameter><decl><type><name>sxu32</name></type> <name>crc32</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pSrc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>crc32</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><call><name>CRC32C</name><argument_list>(<argument><expr><name>crc32</name></expr></argument>, <argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><call><name>CRC32C</name><argument_list>(<argument><expr><name>crc32</name></expr></argument>, <argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><call><name>CRC32C</name><argument_list>(<argument><expr><name>crc32</name></expr></argument>, <argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr> )</condition><block>{<block_content> <break>break;</break> </block_content>}</block></if></if_stmt> <expr_stmt><expr><call><name>CRC32C</name><argument_list>(<argument><expr><name>crc32</name></expr></argument>, <argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
		
	<return>return <expr><name>crc32</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxu32</name></type> <name>SyCrc32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SyCrc32Update</name><argument_list>(<argument><expr><name>SXU32_HIGH</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>nLen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_HASH_FUNC */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JX9_DISABLE_BUILTIN_FUNC</name></cpp:ifndef>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBinToHexConsumer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>sxu32</name></type> <name>nLen</name></decl></parameter>, <parameter><decl><type><name>ProcConsumer</name></type> <name>xConsumer</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pConsumerData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>zHexTab</name><index>[]</index></name> <init>= <expr><literal type="string">"0123456789abcdef"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zOut</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNTRUST</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if<condition>( <expr><name>pIn</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>xConsumer</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
		<return>return <expr><name>SXERR_EMPTY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>zIn</name>   <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pIn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>zEnd</name>  <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nLen</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zIn</name> <operator>&gt;=</operator> <name>zEnd</name></expr>  )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>zHexTab</name><index>[<expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>  <expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>zHexTab</name><index>[<expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConsumer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zOut</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>pConsumerData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SXRET_OK</name></expr> )</condition><block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> 
	</block_content>}</block></for>
	<return>return <expr><name>SXRET_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JX9_DISABLE_BUILTIN_FUNC */</comment>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SyBigEndianPack32</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>nb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>nb</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr> ;</expr_stmt> <expr_stmt><expr><name>nb</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>nb</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr> ;</expr_stmt> <expr_stmt><expr><name>nb</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>nb</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr> ;</expr_stmt> <expr_stmt><expr><name>nb</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>nb</name></expr> ;</expr_stmt>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SyBigEndianUnpack32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,<parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>uNB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>uNB</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SyBigEndianPack16</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,<parameter><decl><type><name>sxu16</name></type> <name>nb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>nb</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr> ;</expr_stmt> <expr_stmt><expr><name>nb</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>nb</name></expr> ;</expr_stmt>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SyBigEndianUnpack16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,<parameter><decl><type><name>sxu16</name> <modifier>*</modifier></type><name>uNB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>uNB</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SyBigEndianPack64</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,<parameter><decl><type><name>sxu64</name></type> <name>n64</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>n64</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt> <expr_stmt><expr><name>n64</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>n64</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt> <expr_stmt><expr><name>n64</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>n64</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt> <expr_stmt><expr><name>n64</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>n64</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt> <expr_stmt><expr><name>n64</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>n64</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt> <expr_stmt><expr><name>n64</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>n64</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt> <expr_stmt><expr><name>n64</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>n64</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt> <expr_stmt><expr><name>n64</name> <operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>sxu8</name><operator>)</operator><name>n64</name></expr> ;</expr_stmt> 
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SyBigEndianUnpack64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,<parameter><decl><type><name>sxu64</name> <modifier>*</modifier></type><name>n64</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu32</name></type> <name>u1</name></decl>,<decl><type ref="prev"/><name>u2</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>u1</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>u2</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>n64</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>sxu64</name><operator>)</operator><name>u2</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <name>u1</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobAppendBig64</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>,<parameter><decl><type><name>sxu64</name></type> <name>n64</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack64</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><name>n64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zBuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobAppendBig32</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>,<parameter><decl><type><name>sxu32</name></type> <name>n32</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack32</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zBuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>sxi32</name></type> <name>SyBlobAppendBig16</name><parameter_list>(<parameter><decl><type><name>SyBlob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>,<parameter><decl><type><name>sxu16</name></type> <name>n16</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SyBigEndianPack16</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><name>n16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SyBlobAppend</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>zBuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SyTimeFormatToDos</name><parameter_list>(<parameter><decl><type><name>Sytm</name> <modifier>*</modifier></type><name>pFmt</name></decl></parameter>,<parameter><decl><type><name>sxu32</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxi32</name></type> <name>nDate</name></decl>,<decl><type ref="prev"/><name>nTime</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>nDate</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>pFmt</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1980</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">9</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>pFmt</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <name><name>pFmt</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nTime</name> <operator>=</operator> <operator>(</operator><name><name>pFmt</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&lt;&lt;</operator> <literal type="number">11</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>pFmt</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator><operator>+</operator> <operator>(</operator><name><name>pFmt</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>pOut</name> <operator>=</operator> <operator>(</operator><name>nDate</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name>nTime</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>JX9_PRIVATE</name> <name>void</name></type> <name>SyDosTimeFormat</name><parameter_list>(<parameter><decl><type><name>sxu32</name></type> <name>nDosDate</name></decl></parameter>, <parameter><decl><type><name>Sytm</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nDate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sxu16</name></type> <name>nTime</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>nDate</name> <operator>=</operator> <name>nDosDate</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nTime</name> <operator>=</operator> <name>nDosDate</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>tm_isdst</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>tm_year</name></name> 	<operator>=</operator> <literal type="number">1980</literal> <operator>+</operator> <operator>(</operator><name>nDate</name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>tm_mon</name></name>	<operator>=</operator> <operator>(</operator><name>nDate</name> <operator>%</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">9</literal><operator>)</operator><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">5</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>tm_mday</name></name>	<operator>=</operator> <operator>(</operator><name>nDate</name> <operator>%</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">9</literal><operator>)</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0x1F</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>tm_hour</name></name>	<operator>=</operator> <name>nTime</name> <operator>&gt;&gt;</operator> <literal type="number">11</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>tm_min</name></name>	<operator>=</operator> <operator>(</operator><name>nTime</name> <operator>%</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">11</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">5</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>tm_sec</name></name>	<operator>=</operator> <operator>(</operator><operator>(</operator><name>nTime</name> <operator>%</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">11</literal><operator>)</operator><operator>)</operator><operator>&amp;</operator> <literal type="number">0x1F</literal> <operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
