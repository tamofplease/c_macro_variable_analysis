<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/unqlite/example/demovfs/unqlite_demovfs.c"><comment type="block">/*
** 2015 June 12
** Author: Luca Sturaro 
** Based and "heavily inspired" by test_demovfs.c for SQLite3 (http://www.sqlite.org/vfs.html)
** 
**
*************************************************************************
**
** This file implements an example of a simple VFS following "litterally" 
** the test_demovfs for SQLite3. This works because UnQLite is based 
** on a similar implementation too. It has been created following the
** Unix POSIX calls but it can be changed for further customizations so 
** this will not compile under Windows systems. 
** 
** Compile this file together with the UnQLite database engine source code
** to generate the executable. For example: 
**  gcc unqlite_demovfs.c unqlite.c -o unqlite_demovfs
**
** We can pass a CFLAG for customization: HAVE_FTRUNCATE
**
**
**
** OVERVIEW
**
**   The code in this file implements a minimal UNQLITE VFS that can be 
**   used on Linux and other posix-like operating systems. The following 
**   system calls are used:
**
**    File-system: access(), unlink(), getcwd()
**    File IO:     open(), read(), write(), fsync(), close(), fstat()
**    Other:       sleep(), usleep(), time()
**
**   The following VFS features are omitted:
**
**     1. File locking. The user must ensure that there is at most one
**        connection to each database when using this VFS. 
**
**     2. This does not port Jx9 engine vfs. This is for UnQLite DBMS only.
**
**
**
**   It is assumed that the system uses UNIX-like path-names. Specifically,
**   that '/' characters are used to separate path components and that
**   a path-name is a relative path unless it begins with a '/'. And that
**   no UTF-8 encoded paths are greater than 512 bytes in length.
**
**   Code in this file allocates a fixed size buffer of 
**   UNQLITE_DEMOVFS_BUFFERSZ using unqlite_malloc() whenever a
**   file is opened. It uses the buffer to aggregate sequential
**   writes into aligned UNQLITE_DEMOVFS_BUFFERSZ blocks. When UnQLite
**   invokes the xSync() method to sync the contents of the file to disk,
**   all accumulated data is written out, even if it does not constitute
**   a complete block.
**
**   
**   WARNING:
**
**   This file should be used as a simple template for a custom VFS
**   according to your OS. This is NOT a replacement of the VFS provided
**   in UNQLite itself for UNIXES systems (see os_unix.c)
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unqlite.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>  <comment type="block">/* puts(), - see Fatal function and snprintf() in vfs;  */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include> <comment type="block">/* exit() */</comment>



<comment type="block">/*
** Size of the write buffer used by journal files in bytes.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_DEMOVFS_BUFFERSZ</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UNQLITE_DEMOVFS_BUFFERSZ</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Size of unqlite page file size.
** It is configured using unqlite_lib_config(UNQLITE_LIB_CONFIG_PAGE_SIZE, UNQLITE_PAGE_SIZE)
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNQLITE_PAGE_SIZE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UNQLITE_PAGE_SIZE</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<comment type="block">/*
** The maximum pathname length supported by this VFS.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATHNAME</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>

<comment type="block">/*
** When using this VFS, the unqlite_file* handles that UnQLite uses are
** actually pointers to instances of type DemoFile.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>DemoFile</name></name></type> <name>DemoFile</name>;</typedef>
<struct>struct <name>DemoFile</name> <block>{
  <decl_stmt><decl><type><name>unqlite_file</name></type> <name>base</name></decl>;</decl_stmt>              <comment type="block">/* Base class. Must be first. */</comment>
  <decl_stmt><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>uvfs</name></decl>;</decl_stmt>              <comment type="block">/* The VFS that created this DemoFile */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>                         <comment type="block">/* File descriptor */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuffer</name></decl>;</decl_stmt>                  <comment type="block">/* Pointer to malloc'd buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuffer</name></decl>;</decl_stmt>                    <comment type="block">/* Valid bytes of data in zBuffer */</comment>
  <decl_stmt><decl><type><name>unqlite_int64</name></type> <name>iBufferOfst</name></decl>;</decl_stmt>      <comment type="block">/* Offset in file of zBuffer[0] */</comment>
}</block>;</struct>


<comment type="block">/*
** Write directly to the file passed as the first argument. Even if the
** file has a write-buffer (DemoFile.aBuffer), ignore it.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoDirectWrite</name><parameter_list>(
  <parameter><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                    <comment type="block">/* File handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>,               <comment type="block">/* Buffer containing data to write */</comment>
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,                       <comment type="block">/* Size of data to write in bytes */</comment>
  <parameter><decl><type><name>unqlite_int64</name></type> <name>iOfst</name></decl></parameter>             <comment type="block">/* File offset to write to */</comment>
  )</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>off_t</name></type> <name>ofst</name></decl>;</decl_stmt>                     <comment type="block">/* Return value from lseek() */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nWrite</name></decl>;</decl_stmt>                  <comment type="block">/* Return value from write() */</comment>

  <expr_stmt><expr><name>ofst</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>ofst</name><operator>!=</operator><name>iOfst</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nWrite</name><operator>!=</operator><name>iAmt</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Flush the contents of the DemoFile.aBuffer buffer to disk. This is a
** no-op if this particular file does not have a buffer (i.e. it is not
** a journal file) or if the buffer is currently empty.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoFlushBuffer</name><parameter_list>(<parameter><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>demoDirectWrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iBufferOfst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoClose</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>demoFlushBuffer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unqlite_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read data from a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoRead</name><parameter_list>(
  <parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, 
  <parameter><decl><type><name>unqlite_int64</name></type> <name>iAmt</name></decl></parameter>, 
  <parameter><decl><type><name>unqlite_int64</name></type> <name>iOfst</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>off_t</name></type> <name>ofst</name></decl>;</decl_stmt>                     <comment type="block">/* Return value from lseek() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name></decl>;</decl_stmt>                      <comment type="block">/* Return value from read() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code from demoFlushBuffer() */</comment>

  <comment type="block">/* Flush any data in the write buffer to disk in case this operation
  ** is trying to read data the file-region currently cached in the buffer.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>demoFlushBuffer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>ofst</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>ofst</name><operator>!=</operator><name>iOfst</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nRead</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nRead</name><operator>==</operator><operator>(</operator><name>int</name><operator>)</operator><name>iAmt</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nRead</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write data to a crash-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoWrite</name><parameter_list>(
  <parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, 
  <parameter><decl><type><name>unqlite_int64</name></type> <name>iAmt</name></decl></parameter>, 
  <parameter><decl><type><name>unqlite_int64</name></type> <name>iOfst</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>zBuf</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Pointer to remaining data to write */</comment>
    <decl_stmt><decl><type><name>unqlite_int64</name></type> <name>n</name> <init>= <expr><name>iAmt</name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of bytes at z */</comment>
    <decl_stmt><decl><type><name>unqlite_int64</name></type> <name>i</name> <init>= <expr><name>iOfst</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* File offset to write to */</comment>

    <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes to copy into buffer */</comment>

      <comment type="block">/* If the buffer is full, or if this data is not being written directly
      ** following the data already buffered, flush the buffer. Flushing
      ** the buffer is a no-op if it is empty.  
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>==</operator><name>UNQLITE_DEMOVFS_BUFFERSZ</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufferOfst</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>!=</operator><name>i</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>demoFlushBuffer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufferOfst</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iBufferOfst</name></name> <operator>=</operator> <name>i</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>;</expr_stmt>

      <comment type="block">/* Copy as much data as possible into the buffer. */</comment>
      <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <name>UNQLITE_DEMOVFS_BUFFERSZ</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCopy</name><operator>&gt;</operator><name>n</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>n</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>demoDirectWrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate a file. This is a no-op for this VFS (see header comments at
** the top of the file).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoTruncate</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>unqlite_int64</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ftruncate</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>DemoFile</name> <operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sync the contents of the file to the persistent media.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoSync</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>demoFlushBuffer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>UNQLITE_OK</name></expr> </then><else>: <expr><name>UNQLITE_IOERR</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write the size of the file in bytes to *pSize.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoFileSize</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>unqlite_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code from fstat() call */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>              <comment type="block">/* Output of fstat() call */</comment>

  <comment type="block">/* Flush the contents of the buffer to disk. As with the flush in the
  ** demoRead() method, it would be possible to avoid this and save a write
  ** here and there. But in practice this comes up so infrequently it is
  ** not worth the trouble.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>demoFlushBuffer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <name><name>sStat</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Locking functions. The xLock() and xUnlock() methods are both no-ops.
** The xCheckReservedLock() always indicates that no other process holds
** a reserved lock on the database file. This ensures that if a hot-journal
** file is found in the file-system it is rolled back.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoLock</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoUnlock</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The xSectorSize() function.
** This may return special values allowing UnQlite to optimize file-system 
** access to some extent. But we simply return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoSectorSize</name><parameter_list>(<parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
** Open a file handle.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoOpen</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,              <comment type="block">/* VFS */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* File to open, or 0 for a temp file */</comment>
  <parameter><decl><type><name>unqlite_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,            <comment type="block">/* Pointer to DemoFile struct to populate */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>                      <comment type="block">/* Input UNQLITE_OPEN_XXX flags, Input flags to control the opening */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unqlite_io_methods</name></type> <name>demoio</name> <init>= <expr><block>{
    <expr><literal type="number">1</literal></expr>,                            <comment type="block">/* iVersion */</comment>
    <expr><name>demoClose</name></expr>,                    <comment type="block">/* xClose */</comment>
    <expr><name>demoRead</name></expr>,                     <comment type="block">/* xRead */</comment>
    <expr><name>demoWrite</name></expr>,                    <comment type="block">/* xWrite */</comment>
    <expr><name>demoTruncate</name></expr>,                 <comment type="block">/* xTruncate */</comment>
    <expr><name>demoSync</name></expr>,                     <comment type="block">/* xSync */</comment>
    <expr><name>demoFileSize</name></expr>,                 <comment type="block">/* xFileSize */</comment>
    <expr><name>demoLock</name></expr>,                     <comment type="block">/* xLock */</comment>
    <expr><name>demoUnlock</name></expr>,                   <comment type="block">/* xUnlock */</comment>
    <expr><name>demoCheckReservedLock</name></expr>,        <comment type="block">/* xCheckReservedLock */</comment>
    <expr><name>demoSectorSize</name></expr>,               <comment type="block">/* xSectorSize */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>DemoFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DemoFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Populate this structure */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* File descriptor returned by open() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>openFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Flags to pass to open() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Function Return Code */</comment>
  
  <decl_stmt><decl><type><name>int</name></type> <name>isExclusive</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_EXCLUSIVE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isDelete</name>     <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_TEMP_DB</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isCreate</name>     <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_CREATE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadonly</name>   <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_READONLY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadWrite</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNQLITE_OPEN_READWRITE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  
  
  
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>aBuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>unqlite_malloc</name><argument_list>(<argument><expr><name>UNQLITE_DEMOVFS_BUFFERSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aBuf</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>UNQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Determine the value of the flags parameter passed to POSIX function
  ** open(). These must be calculated even if open() is not called, as
  ** they may be stored as part of the file handle and used by the 
  ** 'conch file' locking functions later on.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isExclusive</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_EXCL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isReadonly</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_RDONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isReadWrite</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_RDWR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isCreate</name></expr> )</condition><block type="pseudo"><block_content>    <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_CREAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DemoFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>unqlite_free</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>UNQLITE_CANTOPEN</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>isDelete</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name> <operator>=</operator> <name>aBuf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>uvfs</name></name> <operator>=</operator> <name>pVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>demoio</name></expr>;</expr_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete the file identified by argument zPath. If the dirSync parameter
** is non-zero, then ensure the file-system modification to delete the
** file has been synced to disk before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoDelete</name><parameter_list>(<parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dirSync</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>UNQLITE_OK</name></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>errno</name><operator>!=</operator><name>ENOENT</name></expr> )</condition><block>{<block_content>
	  <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dirSync</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>dfd</name></decl>;</decl_stmt>                      <comment type="block">/* File descriptor open on directory */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Iterator variable */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zDir</name><index>[<expr><name>MAXPATHNAME</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* Name of directory containing file zPath */</comment>

    <comment type="block">/* Figure out the directory name from the path of the file deleted. */</comment>
    <expr_stmt><expr><name><name>zDir</name><index>[<expr><name>MAXPATHNAME</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zDir</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>zDir</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/* Open a file-descriptor on the directory. Sync. Close. */</comment>
    <expr_stmt><expr><name>dfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>dfd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><name>dfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>dfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>UNQLITE_OK</name></expr> </then><else>: <expr><name>UNQLITE_IOERR</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>F_OK</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>F_OK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>R_OK</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>R_OK</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>W_OK</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>W_OK</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Query the file-system to see if the named file exists, is readable or
** is both readable and writable.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoAccess</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* access() return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eAccess</name> <init>= <expr><name>F_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Second argument to access() */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><name>UNQLITE_ACCESS_EXISTS</name>       <comment type="block">/* access(zPath, F_OK) */</comment>
       <operator>||</operator> <name>flags</name><operator>==</operator><name>UNQLITE_ACCESS_READ</name>         <comment type="block">/* access(zPath, R_OK) */</comment>
       <operator>||</operator> <name>flags</name><operator>==</operator><name>UNQLITE_ACCESS_READWRITE</name></expr></argument>    <comment type="block">/* access(zPath, R_OK|W_OK) */</comment>
  )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>==</operator><name>UNQLITE_ACCESS_READWRITE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eAccess</name> <operator>=</operator> <name>R_OK</name><operator>|</operator><name>W_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>==</operator><name>UNQLITE_ACCESS_READ</name></expr> )</condition><block type="pseudo"><block_content>      <expr_stmt><expr><name>eAccess</name> <operator>=</operator> <name>R_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* we could do just  this */</comment>
  <comment type="line">//  rc = access(zPath, eAccess);</comment>
  <comment type="line">//  *pResOut = (rc==0);</comment>
  
  <comment type="block">/* taken from unqlite unixAccess function */</comment>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <operator>(</operator><call><name>access</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>eAccess</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>==</operator><name>UNQLITE_ACCESS_EXISTS</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pResOut</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>stat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>.</operator><name>st_size</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
** Argument zPath points to a null-terminated string containing a file path.
** If zPath is an absolute path, then it is copied as is into the output 
** buffer. Otherwise, if it is a relative path, then the equivalent full
** path is written to the output buffer.
**
** This function assumes that paths are UNIX style. Specifically, that:
**
**   1. Path components are separated by a '/'. and 
**   2. Full paths begin with a '/' character.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoFullPathname</name><parameter_list>(
  <parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,              <comment type="block">/* VFS */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,              <comment type="block">/* Input path (possibly a relative path) */</comment>
  <parameter><decl><type><name>int</name></type> <name>nPathOut</name></decl></parameter>,                   <comment type="block">/* Size of output buffer in bytes */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zPathOut</name></decl></parameter>                  <comment type="block">/* Pointer to output buffer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zDir</name><index>[<expr><name>MAXPATHNAME</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>zDir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>getcwd</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zDir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>UNQLITE_IOERR</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>zDir</name><index>[<expr><name>MAXPATHNAME</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <comment type="block">/* FIXME: Remove snprintf, try to avoid dependencies on &lt;stdio.h&gt; for pure vfs; use strcpy? */</comment> 
  <expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>zPathOut</name></expr></argument>, <argument><expr><name>nPathOut</name></expr></argument>,<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,<argument><expr><name>zDir</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zPathOut</name><index>[<expr><name>nPathOut</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>




<comment type="block">/*
** Sleep for at least nMicro microseconds. Return the (approximate) number 
** of microseconds slept for.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoSleep</name><parameter_list>(<parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMicro</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>seconds</name> <init>= <expr><operator>(</operator><name>nMicro</name><operator>+</operator><literal type="number">999999</literal><operator>)</operator><operator>/</operator><literal type="number">1000000</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/* if we have at least sleep function */</comment>
  <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>seconds</name><operator>*</operator><literal type="number">1000000</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set *pTime to the current UTC time expressed as a Julian day. Return
** UNQLITE_OK if successful, or an error code otherwise.
**
**   http://en.wikipedia.org/wiki/Julian_day
**
** This implementation is not very good. The current time is rounded to
** an integer number of seconds. Also, assuming time_t is a signed 32-bit 
** value, it will stop working some time in the year 2038 AD (the so-called
** "year 2038" problem that afflicts systems that store time this way). 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>demoCurrentTime</name><parameter_list>(<parameter><decl><type><name>unqlite_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>Sytm</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>pTm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type> <name>tt</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pTm</name> <operator>=</operator> <call><name>gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>pTm</name></expr> )</condition><block>{<block_content> <comment type="block">/* Yes, it can fail */</comment>
		<expr_stmt><expr><call><name>STRUCT_TM_TO_SYTM</name><argument_list>(<argument><expr><name>pTm</name></expr></argument>,<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>UNQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function returns a pointer to the VFS implemented in this file.
** To make the VFS available to UnQLite
**
**   unqlite_lib_config(UNQLITE_LIB_CONFIG_VFS, unqliteExportDemoVfs());
**	
** As for initialization, the sequence I use is as follows:
** -unqlite_lib_config(UNQLITE_LIB_CONFIG_VFS, pVfs)
** -unqlite_lib_config(UNQLITE_LIB_CONFIG_PAGE_SIZE, 512)
** -unqlite_open() (it automatically initialize the library without calling unqlite_lib_init() function)
*/</comment>
<function><type><specifier>const</specifier> <name>unqlite_vfs</name> <modifier>*</modifier></type><name>unqliteExportDemoVfs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unqlite_vfs</name></type> <name>demovfs</name> <init>= <expr><block>{
    <expr><literal type="string">"unqlite_demo_vfs"</literal></expr>,           <comment type="block">/* zName - Name of this virtual file system [i.e: Windows, UNIX, etc.] */</comment>
	<expr><literal type="number">1</literal></expr>,                            <comment type="block">/* iVersion - Structure version number (currently 1) */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>DemoFile</name></expr></argument>)</argument_list></sizeof></expr>,             <comment type="block">/* szOsFile - Size of subclassed unqlite_file */</comment>
	<expr><name>MAXPATHNAME</name></expr>,                  <comment type="block">/* mxPathname -Maximum file pathname length */</comment>
    <expr><name>demoOpen</name></expr>,                     <comment type="block">/* xOpen */</comment>
    <expr><name>demoDelete</name></expr>,                   <comment type="block">/* xDelete */</comment>
    <expr><name>demoAccess</name></expr>,                   <comment type="block">/* xAccess */</comment>
    <expr><name>demoFullPathname</name></expr>,             <comment type="block">/* xFullPathname */</comment>
	<expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xTmpDir */</comment>
    <expr><name>demoSleep</name></expr>,                    <comment type="block">/* xSleep */</comment>
    <expr><name>demoCurrentTime</name></expr>,              <comment type="block">/* xCurrentTime */</comment>
	<expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xGetLastError */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>&amp;</operator><name>demovfs</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*  !defined(UNQLITE_TEST) */</comment>



<comment type="block" format="doxygen">/****************************************************************************************************/</comment>
<comment type="block" format="doxygen">/****************************************************************************************************/</comment>
<comment type="block">/*  END OF VFS - Below we provide a function which registers this VFS and set PAGE_SIZE. 
/*  Up to the user calling the unqlite_open() and do the job. */</comment>
<comment type="block" format="doxygen">/****************************************************************************************************/</comment>
<comment type="block" format="doxygen">/****************************************************************************************************/</comment>



<comment type="block">/*
** This function is an unqlite add-on to launch unqlite registering VFS implemented in this file.
** To initialize unqlite with this VFS you just do:
** unqlite_start();
** unqlite_open();
**	
** To make the VFS available to unqlite:
**
**   unqlite_lib_config(UNQLITE_LIB_CONFIG_VFS, unqliteExportDemoVfs());
**	
** As for initialization, the sequence I use here is as follows:
** -unqlite_lib_config(UNQLITE_LIB_CONFIG_VFS, pVfs)
** -unqlite_lib_config(UNQLITE_LIB_CONFIG_PAGE_SIZE, 512)
**
** The user just need to call this function and then:
** -unqlite_open() (it automatically initialize the library without calling unqlite_lib_init() function)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unqlite_start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>failVfsMsg</name> <init>= <expr><literal type="string">"Error in VFS configuration"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>failPageSzMsg</name> <init>= <expr><literal type="string">"Error in setting PageSize"</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/* configure this vfs as the current one (unqlite supports just one VFS at a time) */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_lib_config</name><argument_list>(<argument><expr><name>UNQLITE_LIB_CONFIG_VFS</name></expr></argument>, <argument><expr><call><name>unqliteExportDemoVfs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name>failVfsMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* set the page size */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_lib_config</name><argument_list>(<argument><expr><name>UNQLITE_LIB_CONFIG_PAGE_SIZE</name></expr></argument>, <argument><expr><name>UNQLITE_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name>failPageSzMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
</block_content>}</block></function>



<comment type="block">/*
**	Here we put other functions just to start the db and show how to use this vfs
*/</comment>

<comment type="block">/*
 * Banner.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zBanner</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"============================================================\n"</literal>
	<literal type="string">"UnQLite VFS DemoFile Functions                              \n"</literal>
	<literal type="string">"                                         http://unqlite.org/\n"</literal>
	<literal type="string">"============================================================\n"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Extract the database error log and exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>Fatal</name><parameter_list>(<parameter><decl><type><name>unqlite</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>( <expr><name>pDb</name></expr> )</condition><block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>iLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Stupid cc warning */</comment>

		<comment type="block">/* Extract the database error log */</comment>
		<expr_stmt><expr><call><name>unqlite_config</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><name>UNQLITE_CONFIG_ERR_LOG</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>iLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>iLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
			<comment type="block">/* Output the DB error log */</comment>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Always null terminated */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if><else>else<block>{<block_content>
		<if_stmt><if>if<condition>( <expr><name>zMsg</name></expr> )</condition><block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Manually shutdown the library */</comment>
	<expr_stmt><expr><call><name>unqlite_lib_shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Exit immediately */</comment>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unqlite</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>       <comment type="block">/* Database handle */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	
	<comment type="block">/* Print Banner */</comment>
	<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name>zBanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"Starting vfs set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	<comment type="block">/* Configure with our own vfs and page size */</comment>
	<expr_stmt><expr><call><name>unqlite_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"Successfully vfs set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	
	<comment type="block">/* Open our database */</comment>
	<comment type="block">/* Pass a real db file to test the this vfs*/</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_open</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>,<argument><expr><ternary><condition><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> <comment type="block">/* On-disk DB */</comment> </then><else>: <expr><literal type="string">":mem:"</literal></expr></else></ternary></expr></argument> <comment type="block">/* In-mem DB */</comment>,<argument><expr><name>UNQLITE_OPEN_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>Fatal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="string">"Out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Taken from 1.c, just store some values as example */</comment>
	<comment type="block">/* Store 20 random records.*/</comment>
	<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">20</literal></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr> )</control><block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>zKey</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Random generated key */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>zData</name><index>[<expr><literal type="number">34</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Dummy data */</comment>
		
		<comment type="block">/* Generate the random key */</comment>
		<expr_stmt><expr><call><name>unqlite_util_random_string</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><name>zKey</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<comment type="block">/* Perform the insertion */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_kv_store</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><name>zKey</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zData</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"Key Successfully stored"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
		<comment type="block">/* Insertion fail, rollback the transaction  */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unqlite_rollback</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"Rollback OK, even if it wasn't expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>UNQLITE_OK</name></expr> )</condition><block>{<block_content>
			<comment type="block">/* Extract database error log and exit */</comment>
			<expr_stmt><expr><call><name>Fatal</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/* Auto-commit the transaction and close our handle */</comment>
	<expr_stmt><expr><call><name>unqlite_close</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"AutoCommit and Close"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function></unit>
