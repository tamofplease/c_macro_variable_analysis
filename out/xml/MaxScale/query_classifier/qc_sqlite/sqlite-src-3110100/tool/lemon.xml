<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/tool/lemon.c"><comment type="block">/*
** This file contains all sources (including headers) to the LEMON
** LALR(1) parser generator.  The sources have been combined into a
** single file to make it easy to include LEMON in the source tree
** and Makefile of another program.
**
** The author of this program disclaims copyright.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISSPACE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isspace((unsigned char)(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISDIGIT</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isdigit((unsigned char)(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISALNUM</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isalnum((unsigned char)(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISALPHA</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isalpha((unsigned char)(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISUPPER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isupper((unsigned char)(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISLOWER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>islower((unsigned char)(X))</cpp:value></cpp:define>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__WIN32__</name></cpp:ifndef>
<cpp:if>#   <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#       <cpp:directive>define</cpp:directive> <cpp:macro><name>__WIN32__</name></cpp:macro></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WIN32__</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>access</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
</block_content>}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* #define PRIVATE static */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRIVATE</name></cpp:macro></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEST</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXRHS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>       <comment type="block">/* Set low to exercise exception code */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXRHS</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>showPrecedenceConflict</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>msort</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>,<parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Compilers are getting increasingly pedantic about type conversions
** as C evolves ever closer to Ada....  To work around the latest problems
** we have to define the following variant of strlen().
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lemonStrlen</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>((int)strlen(X))</cpp:value></cpp:define>

<comment type="block">/*
** Compilers are starting to complain about the use of sprintf() and strcpy(),
** saying they are unsafe.  So we define our own versions of those routines too.
**
** There are three routines here:  lemon_sprintf(), lemon_vsprintf(), and
** lemon_addtext(). The first two are replacements for sprintf() and vsprintf().
** The third is a helper routine for vsnprintf() that adds texts to the end of a
** buffer, making sure the buffer is always zero-terminated.
**
** The string formatter is a minimal subset of stdlib sprintf() supporting only
** a few simply conversions:
**
**   %d
**   %s
**   %.*s
**
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lemon_addtext</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>,           <comment type="block">/* The buffer to which text is added */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnUsed</name></decl></parameter>,          <comment type="block">/* Slots of the buffer used so far */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>,      <comment type="block">/* Text to add */</comment>
  <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>,              <comment type="block">/* Bytes of text to add.  -1 to use strlen() */</comment>
  <parameter><decl><type><name>int</name></type> <name>iWidth</name></decl></parameter>            <comment type="block">/* Field width.  Negative to left justify */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <for>for<control>(<init><expr><name>nIn</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zIn</name><index>[<expr><name>nIn</name></expr>]</index></name></expr>;</condition> <incr><expr><name>nIn</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name>iWidth</name><operator>&gt;</operator><name>nIn</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name><name>zBuf</name><index>[<expr><operator>(</operator><operator>*</operator><name>pnUsed</name><operator>)</operator><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt> <expr_stmt><expr><name>iWidth</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><operator>*</operator><name>pnUsed</name></expr>]</index></name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnUsed</name> <operator>+=</operator> <name>nIn</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><operator>-</operator><name>iWidth</name><operator>)</operator><operator>&gt;</operator><name>nIn</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name><name>zBuf</name><index>[<expr><operator>(</operator><operator>*</operator><name>pnUsed</name><operator>)</operator><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt> <expr_stmt><expr><name>iWidth</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <expr_stmt><expr><name><name>zBuf</name><index>[<expr><operator>*</operator><name>pnUsed</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lemon_vsprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nUsed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTemp</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zFormat</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iWidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lemon_addtext</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nUsed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zFormat</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name><operator>-</operator><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zFormat</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ISDIGIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <call><name>ISDIGIT</name><argument_list>(<argument><expr><name><name>zFormat</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <while>while<condition>( <expr><call><name>ISDIGIT</name><argument_list>(<argument><expr><name><name>zFormat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iWidth</name> <operator>=</operator> <name>iWidth</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name><name>zFormat</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iWidth</name> <operator>=</operator> <operator>-</operator><name>iWidth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zFormat</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'d'</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>lemon_addtext</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nUsed</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>-</operator><name>v</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>lemon_addtext</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nUsed</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>v</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>zTemp</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></sizeof><operator>-</operator><name>k</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>%</operator><literal type="number">10</literal><operator>)</operator> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>v</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>lemon_addtext</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nUsed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zTemp</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></sizeof><operator>-</operator><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>iWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lemon_addtext</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nUsed</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zFormat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">".*s"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lemon_addtext</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nUsed</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>iWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lemon_addtext</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nUsed</name></expr></argument>, <argument><expr><literal type="string">"%"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"illegal format\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lemon_addtext</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nUsed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zFormat</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name><operator>-</operator><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nUsed</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lemon_sprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lemon_vsprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lemon_strcpy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>dest</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>src</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content/>}</block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lemon_strcat</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><operator>*</operator><name>dest</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dest</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>lemon_strcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* a few forward declarations... */</comment>
<struct_decl>struct <name>rule</name>;</struct_decl>
<struct_decl>struct <name>lemon</name>;</struct_decl>
<struct_decl>struct <name>action</name>;</struct_decl>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>Action_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>Action_sort</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/********** From the file "build.h" ************************************/</comment>
<function_decl><type><name>void</name></type> <name>FindRulePrecedences</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>FindFirstSets</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>FindStates</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>FindLinks</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>FindFollowSets</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>FindActions</name><parameter_list>()</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/********* From the file "configlist.h" *********************************/</comment>
<function_decl><type><name>void</name></type> <name>Configlist_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>Configlist_add</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>Configlist_addbasis</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Configlist_closure</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Configlist_sort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Configlist_sortbasis</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>Configlist_return</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>Configlist_basis</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Configlist_eat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Configlist_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/********* From the file "error.h" ***************************************/</comment>
<function_decl><type><name>void</name></type> <name>ErrorMsg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/****** From the file "option.h" ******************************************/</comment>
<enum>enum <name>option_type</name> <block>{ <decl><name>OPT_FLAG</name><init>=<expr><literal type="number">1</literal></expr></init></decl>,  <decl><name>OPT_INT</name></decl>,  <decl><name>OPT_DBL</name></decl>,  <decl><name>OPT_STR</name></decl>,
         <decl><name>OPT_FFLAG</name></decl>, <decl><name>OPT_FINT</name></decl>, <decl><name>OPT_FDBL</name></decl>, <decl><name>OPT_FSTR</name></decl>}</block>;</enum>
<struct>struct <name>s_options</name> <block>{
  <decl_stmt><decl><type><name><name>enum</name> <name>option_type</name></name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl>;</decl_stmt>
}</block>;</struct>
<function_decl><type><name>int</name></type>    <name>OptInit</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name><name>struct</name> <name>s_options</name></name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>FILE</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>    <name>OptNArgs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>char</name>  <modifier>*</modifier></type><name>OptArg</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>   <name>OptErr</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>   <name>OptPrint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/******** From the file "parse.h" *****************************************/</comment>
<function_decl><type><name>void</name></type> <name>Parse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/********* From the file "plink.h" ***************************************/</comment>
<function_decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>Plink_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Plink_add</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Plink_copy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Plink_delete</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/********** From the file "report.h" *************************************/</comment>
<function_decl><type><name>void</name></type> <name>Reprint</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ReportOutput</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ReportTable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ReportHeader</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CompressTables</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ResortStates</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/********** From the file "set.h" ****************************************/</comment>
<function_decl><type><name>void</name></type>  <name>SetSize</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>             <comment type="block">/* All sets will be of size N */</comment>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>SetNew</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>               <comment type="block">/* A new set for element 0..N */</comment>
<function_decl><type><name>void</name></type>  <name>SetFree</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>             <comment type="block">/* Deallocate a set */</comment>
<function_decl><type><name>int</name></type> <name>SetAdd</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>            <comment type="block">/* Add element to a set */</comment>
<function_decl><type><name>int</name></type> <name>SetUnion</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>    <comment type="block">/* A &lt;- A U B, thru element N */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SetFind</name><parameter_list>(<parameter><type><name>X</name></type></parameter>,<parameter><type><name>Y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(X[Y])</cpp:value></cpp:define>       <comment type="block">/* True if Y is in set X */</comment>

<comment type="block" format="doxygen">/********** From the file "struct.h" *************************************/</comment>
<comment type="block">/*
** Principal data structures for the LEMON parser generator.
*/</comment>

<typedef>typedef <type><enum>enum <block>{<decl><name>LEMON_FALSE</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><name>LEMON_TRUE</name></decl>}</block></enum></type> <name>Boolean</name>;</typedef>

<comment type="block">/* Symbols (terminals and nonterminals) of the grammar are stored
** in the following: */</comment>
<enum>enum <name>symbol_type</name> <block>{
  <decl><name>TERMINAL</name></decl>,
  <decl><name>NONTERMINAL</name></decl>,
  <decl><name>MULTITERMINAL</name></decl>
}</block>;</enum>
<enum>enum <name>e_assoc</name> <block>{
    <decl><name>LEFT</name></decl>,
    <decl><name>RIGHT</name></decl>,
    <decl><name>NONE</name></decl>,
    <decl><name>UNK</name></decl>
}</block>;</enum>
<struct>struct <name>symbol</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>        <comment type="block">/* Name of the symbol */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>               <comment type="block">/* Index number for this symbol */</comment>
  <decl_stmt><decl><type><name><name>enum</name> <name>symbol_type</name></name></type> <name>type</name></decl>;</decl_stmt>   <comment type="block">/* Symbols are all either TERMINALS or NTs */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rule</name></decl>;</decl_stmt>       <comment type="block">/* Linked list of rules of this (if an NT) */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>fallback</name></decl>;</decl_stmt> <comment type="block">/* fallback token in case this token doesn't parse */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>prec</name></decl>;</decl_stmt>                <comment type="block">/* Precedence if defined (-1 otherwise) */</comment>
  <decl_stmt><decl><type><name><name>enum</name> <name>e_assoc</name></name></type> <name>assoc</name></decl>;</decl_stmt>      <comment type="block">/* Associativity if precedence is defined */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>firstset</name></decl>;</decl_stmt>          <comment type="block">/* First-set for all rules of this symbol */</comment>
  <decl_stmt><decl><type><name>Boolean</name></type> <name>lambda</name></decl>;</decl_stmt>          <comment type="block">/* True if NT and can generate an empty string */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>useCnt</name></decl>;</decl_stmt>              <comment type="block">/* Number of times used */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>destructor</name></decl>;</decl_stmt>        <comment type="block">/* Code which executes whenever this symbol is
                           ** popped from the stack during error processing */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>destLineno</name></decl>;</decl_stmt>          <comment type="block">/* Line number for start of destructor */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>datatype</name></decl>;</decl_stmt>          <comment type="block">/* The data type of information held by this
                           ** object. Only used if type==NONTERMINAL */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>dtnum</name></decl>;</decl_stmt>               <comment type="block">/* The data type number.  In the parser, the value
                           ** stack is a union.  The .yy%d element of this
                           ** union is the correct data type for this object */</comment>
  <comment type="block">/* The following fields are used by MULTITERMINALs only */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nsubsym</name></decl>;</decl_stmt>             <comment type="block">/* Number of constituent symbols in the MULTI */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>subsym</name></decl>;</decl_stmt>  <comment type="block">/* Array of constituent symbols */</comment>
}</block>;</struct>

<comment type="block">/* Each production rule in the grammar is stored in the following
** structure.  */</comment>
<struct>struct <name>rule</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>lhs</name></decl>;</decl_stmt>      <comment type="block">/* Left-hand side of the rule */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lhsalias</name></decl>;</decl_stmt>    <comment type="block">/* Alias for the LHS (NULL if none) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>lhsStart</name></decl>;</decl_stmt>            <comment type="block">/* True if left-hand side is the start symbol */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ruleline</name></decl>;</decl_stmt>            <comment type="block">/* Line number for the rule */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nrhs</name></decl>;</decl_stmt>                <comment type="block">/* Number of RHS symbols */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>rhs</name></decl>;</decl_stmt>     <comment type="block">/* The RHS symbols */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>rhsalias</name></decl>;</decl_stmt>   <comment type="block">/* An alias for each RHS symbol (NULL if none) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>                <comment type="block">/* Line number at which code begins */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>code</name></decl>;</decl_stmt>        <comment type="block">/* The code executed when this rule is reduced */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>precsym</name></decl>;</decl_stmt>  <comment type="block">/* Precedence symbol for this rule */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>               <comment type="block">/* An index number for this rule */</comment>
  <decl_stmt><decl><type><name>Boolean</name></type> <name>canReduce</name></decl>;</decl_stmt>       <comment type="block">/* True if this rule is ever reduced */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>nextlhs</name></decl>;</decl_stmt>    <comment type="block">/* Next rule with the same LHS */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>       <comment type="block">/* Next rule in the global list */</comment>
}</block>;</struct>

<comment type="block">/* A configuration is a production rule of the grammar together with
** a mark (dot) showing how much of that rule has been processed so far.
** Configurations also contain a follow-set which is a list of terminal
** symbols which are allowed to immediately follow the end of the rule.
** Every configuration is recorded as an instance of the following: */</comment>
<enum>enum <name>cfgstatus</name> <block>{
  <decl><name>COMPLETE</name></decl>,
  <decl><name>INCOMPLETE</name></decl>
}</block>;</enum>
<struct>struct <name>config</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>         <comment type="block">/* The rule upon which the configuration is based */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>dot</name></decl>;</decl_stmt>                 <comment type="block">/* The parse point */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fws</name></decl>;</decl_stmt>               <comment type="block">/* Follow-set for this configuration only */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>fplp</name></decl>;</decl_stmt>      <comment type="block">/* Follow-set forward propagation links */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>bplp</name></decl>;</decl_stmt>      <comment type="block">/* Follow-set backwards propagation links */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>       <comment type="block">/* Pointer to state which contains this */</comment>
  <decl_stmt><decl><type><name><name>enum</name> <name>cfgstatus</name></name></type> <name>status</name></decl>;</decl_stmt>   <comment type="block">/* used during followset and shift computations */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>     <comment type="block">/* Next configuration in the state */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>       <comment type="block">/* The next basis configuration */</comment>
}</block>;</struct>

<enum>enum <name>e_action</name> <block>{
  <decl><name>SHIFT</name></decl>,
  <decl><name>ACCEPT</name></decl>,
  <decl><name>REDUCE</name></decl>,
  <decl><name>ERROR</name></decl>,
  <decl><name>SSCONFLICT</name></decl>,              <comment type="block">/* A shift/shift conflict */</comment>
  <decl><name>SRCONFLICT</name></decl>,              <comment type="block">/* Was a reduce, but part of a conflict */</comment>
  <decl><name>RRCONFLICT</name></decl>,              <comment type="block">/* Was a reduce, but part of a conflict */</comment>
  <decl><name>SH_RESOLVED</name></decl>,             <comment type="block">/* Was a shift.  Precedence resolved conflict */</comment>
  <decl><name>RD_RESOLVED</name></decl>,             <comment type="block">/* Was reduce.  Precedence resolved conflict */</comment>
  <decl><name>NOT_USED</name></decl>,                <comment type="block">/* Deleted by compression */</comment>
  <decl><name>SHIFTREDUCE</name></decl>              <comment type="block">/* Shift first, then reduce */</comment>
}</block>;</enum>

<comment type="block">/* Every shift or reduce operation is stored as one of the following */</comment>
<struct>struct <name>action</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>       <comment type="block">/* The look-ahead symbol */</comment>
  <decl_stmt><decl><type><name><name>enum</name> <name>e_action</name></name></type> <name>type</name></decl>;</decl_stmt>
  <union>union <block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>     <comment type="block">/* The new state, if a shift */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>       <comment type="block">/* The rule, if a reduce */</comment>
  }</block> <decl><name>x</name></decl>;</union>
  <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>     <comment type="block">/* Next action for this state */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>collide</name></decl>;</decl_stmt>  <comment type="block">/* Next action with the same hash */</comment>
}</block>;</struct>

<comment type="block">/* Each state of the generated parser's finite state machine
** is encoded as an instance of the following structure. */</comment>
<struct>struct <name>state</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>       <comment type="block">/* The basis configurations for this state */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>      <comment type="block">/* All configurations in this set */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>statenum</name></decl>;</decl_stmt>            <comment type="block">/* Sequential number for this state */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>       <comment type="block">/* Array of actions for this state */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTknAct</name></decl>, <decl><type ref="prev"/><name>nNtAct</name></decl>;</decl_stmt>     <comment type="block">/* Number of actions on terminals and nonterminals */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTknOfst</name></decl>, <decl><type ref="prev"/><name>iNtOfst</name></decl>;</decl_stmt>   <comment type="block">/* yy_action[] offset for terminals and nonterms */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDfltReduce</name></decl>;</decl_stmt>         <comment type="block">/* Default action is to REDUCE by this rule */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>pDfltReduce</name></decl>;</decl_stmt><comment type="block">/* The default REDUCE rule. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>autoReduce</name></decl>;</decl_stmt>          <comment type="block">/* True if this is an auto-reduce state */</comment>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_OFFSET</name></cpp:macro> <cpp:value>(-2147483647)</cpp:value></cpp:define>

<comment type="block">/* A followset propagation link indicates that the contents of one
** configuration followset should be propagated to another whenever
** the first changes. */</comment>
<struct>struct <name>plink</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>      <comment type="block">/* The configuration to which linked */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>      <comment type="block">/* The next propagate link */</comment>
}</block>;</struct>

<comment type="block">/* The state vector for the entire parser generator is recorded as
** follows.  (LEMON uses no global variables and makes little use of
** static variables.  Fields in the following structure can be thought
** of as begin global variables in the program.) */</comment>
<struct>struct <name>lemon</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>sorted</name></decl>;</decl_stmt>   <comment type="block">/* Table of states sorted by state number */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rule</name></decl>;</decl_stmt>       <comment type="block">/* List of all rules */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nstate</name></decl>;</decl_stmt>              <comment type="block">/* Number of states */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nxstate</name></decl>;</decl_stmt>             <comment type="block">/* nstate with tail degenerate states removed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nrule</name></decl>;</decl_stmt>               <comment type="block">/* Number of rules */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nsymbol</name></decl>;</decl_stmt>             <comment type="block">/* Number of terminal and nonterminal symbols */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nterminal</name></decl>;</decl_stmt>           <comment type="block">/* Number of terminal symbols */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>symbols</name></decl>;</decl_stmt> <comment type="block">/* Sorted array of pointers to symbols */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>errorcnt</name></decl>;</decl_stmt>            <comment type="block">/* Number of errors */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>errsym</name></decl>;</decl_stmt>   <comment type="block">/* The error symbol */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>wildcard</name></decl>;</decl_stmt> <comment type="block">/* Token that matches anything */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>              <comment type="block">/* Name of the generated parser */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>               <comment type="block">/* Declaration of the 3th argument to parser */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tokentype</name></decl>;</decl_stmt>         <comment type="block">/* Type of terminal symbols in the parser stack */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vartype</name></decl>;</decl_stmt>           <comment type="block">/* The default type of non-terminal symbols */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>             <comment type="block">/* Name of the start symbol for the grammar */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>stacksize</name></decl>;</decl_stmt>         <comment type="block">/* Size of the parser stack */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>include</name></decl>;</decl_stmt>           <comment type="block">/* Code to put at the start of the C file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error</name></decl>;</decl_stmt>             <comment type="block">/* Code to execute when an error is seen */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>overflow</name></decl>;</decl_stmt>          <comment type="block">/* Code to execute on a stack overflow */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>failure</name></decl>;</decl_stmt>           <comment type="block">/* Code to execute on parser failure */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>accept</name></decl>;</decl_stmt>            <comment type="block">/* Code to execute when the parser excepts */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extracode</name></decl>;</decl_stmt>         <comment type="block">/* Code appended to the generated file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tokendest</name></decl>;</decl_stmt>         <comment type="block">/* Code to execute to destroy token data */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vardest</name></decl>;</decl_stmt>           <comment type="block">/* Code for the default non-terminal destructor */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>          <comment type="block">/* Name of the input file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>outname</name></decl>;</decl_stmt>           <comment type="block">/* Name of the current output file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tokenprefix</name></decl>;</decl_stmt>       <comment type="block">/* A prefix added to token names in the .h file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nconflict</name></decl>;</decl_stmt>           <comment type="block">/* Number of parsing conflicts */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nactiontab</name></decl>;</decl_stmt>          <comment type="block">/* Number of entries in the yy_action[] table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tablesize</name></decl>;</decl_stmt>           <comment type="block">/* Total table size of all tables in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>basisflag</name></decl>;</decl_stmt>           <comment type="block">/* Print only basis configurations */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>has_fallback</name></decl>;</decl_stmt>        <comment type="block">/* True if any %fallback is seen in the grammar */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nolinenosflag</name></decl>;</decl_stmt>       <comment type="block">/* True if #line statements should not be printed */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argv0</name></decl>;</decl_stmt>             <comment type="block">/* Name of the program */</comment>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MemoryCheck</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if((X)==0){ \
  extern void memory_error(); \
  memory_error(); \
}</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**************** From the file "table.h" *********************************/</comment>
<comment type="block">/*
** All code in this file has been automatically generated
** from a specification in the file
**              "table.q"
** by the associative array code building program "aagen".
** Do not edit this file!  Instead, edit the specification
** file, then rerun aagen.
*/</comment>
<comment type="block">/*
** Code for processing tables in the LEMON parser generator.
*/</comment>
<comment type="block">/* Routines for handling a strings */</comment>

<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Strsafe</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>Strsafe_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>Strsafe_insert</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Strsafe_find</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Routines for handling symbols of the grammar */</comment>

<function_decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>Symbol_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>Symbolcmpp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Symbol_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>Symbol_insert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>Symbol_find</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>Symbol_Nth</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>Symbol_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>Symbol_arrayof</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Routines to manage the state table */</comment>

<function_decl><type><name>int</name></type> <name>Configcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>State_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>State_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>State_insert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>State_find</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>State_arrayof</name><parameter_list>(<comment type="block">/*  */</comment>)</parameter_list>;</function_decl>

<comment type="block">/* Routines used for efficiency in Configlist_add */</comment>

<function_decl><type><name>void</name></type> <name>Configtable_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>Configtable_insert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>Configtable_find</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Configtable_clear</name><parameter_list>(<parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/****************** From the file "action.c" *******************************/</comment>
<comment type="block">/*
** Routines processing parser actions in the LEMON parser generator.
*/</comment>

<comment type="block">/* Allocate a new parser action */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>Action_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>freelist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>newaction</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>freelist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>amt</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>freelist</name> <operator>=</operator> <operator>(</operator>struct <name>action</name> <operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><name>amt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>action</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>freelist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Unable to allocate memory for a new parser action."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>amt</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>freelist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <operator>&amp;</operator><name><name>freelist</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>freelist</name><index>[<expr><name>amt</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>newaction</name> <operator>=</operator> <name>freelist</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>freelist</name> <operator>=</operator> <name><name>freelist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  <return>return <expr><name>newaction</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare two actions for sorting purposes.  Return negative, zero, or
** positive if the first action is less than, equal to, or greater than
** the first
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>actioncmp</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap1</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>ap1</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>index</name></name> <operator>-</operator> <name><name>ap2</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>ap1</name><operator>-&gt;</operator><name>type</name></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>ap2</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ap1</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>REDUCE</name> <operator>||</operator> <name><name>ap1</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SHIFTREDUCE</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>ap1</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name> <operator>-</operator> <name><name>ap2</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>ap2</name> <operator>-</operator> <name>ap1</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Sort parser actions */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>Action_sort</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>ap</name> <operator>=</operator> <operator>(</operator>struct <name>action</name> <operator>*</operator><operator>)</operator><call><name>msort</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ap</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></argument>,
                              <argument><expr><operator>(</operator><call><call><name>int</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>,<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>actioncmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ap</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Action_add</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>app</name></decl></parameter>,
  <parameter><decl><type><name><name>enum</name> <name>e_action</name></name></type> <name>type</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>newaction</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>newaction</name> <operator>=</operator> <call><name>Action_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newaction</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>app</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>app</name> <operator>=</operator> <name>newaction</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newaction</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newaction</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>type</name><operator>==</operator><name>SHIFT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>newaction</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>stp</name></name> <operator>=</operator> <operator>(</operator>struct <name>state</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>newaction</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name></name> <operator>=</operator> <operator>(</operator>struct <name>rule</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<comment type="block" format="doxygen">/********************** New code to implement the "acttab" module ***********/</comment>
<comment type="block">/*
** This module implements routines use to construct the yy_action[] table.
*/</comment>

<comment type="block">/*
** The state of the yy_action table under construction is an instance of
** the following structure.
**
** The yy_action table maps the pair (state_number, lookahead) into an
** action_number.  The table is an array of integers pairs.  The state_number
** determines an initial offset into the yy_action array.  The lookahead
** value is then added to this initial offset to get an index X into the
** yy_action array. If the aAction[X].lookahead equals the value of the
** of the lookahead input, then the value of the action_number output is
** aAction[X].action.  If the lookaheads do not match then the
** default action for the state_number is returned.
**
** All actions associated with a single state_number are first entered
** into aLookahead[] using multiple calls to acttab_action().  Then the 
** actions for that single state_number are placed into the aAction[] 
** array with a single call to acttab_insert().  The acttab_insert() call
** also resets the aLookahead[] array in preparation for the next
** state number.
*/</comment>
<struct>struct <name>lookahead_action</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>lookahead</name></decl>;</decl_stmt>             <comment type="block">/* Value of the lookahead token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>action</name></decl>;</decl_stmt>                <comment type="block">/* Action to take on the given lookahead */</comment>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>acttab</name></name></type> <name>acttab</name>;</typedef>
<struct>struct <name>acttab</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nAction</name></decl>;</decl_stmt>                 <comment type="block">/* Number of used slots in aAction[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nActionAlloc</name></decl>;</decl_stmt>            <comment type="block">/* Slots allocated for aAction[] */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>lookahead_action</name></name>
    <modifier>*</modifier></type><name>aAction</name></decl>,                  <comment type="block">/* The yy_action[] table under construction */</comment>
    <decl><type ref="prev"><modifier>*</modifier></type><name>aLookahead</name></decl>;</decl_stmt>               <comment type="block">/* A single new transaction set */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mnLookahead</name></decl>;</decl_stmt>             <comment type="block">/* Minimum aLookahead[].lookahead */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mnAction</name></decl>;</decl_stmt>                <comment type="block">/* Action associated with mnLookahead */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxLookahead</name></decl>;</decl_stmt>             <comment type="block">/* Maximum aLookahead[].lookahead */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLookahead</name></decl>;</decl_stmt>              <comment type="block">/* Used slots in aLookahead[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLookaheadAlloc</name></decl>;</decl_stmt>         <comment type="block">/* Slots allocated in aLookahead[] */</comment>
}</block>;</struct>

<comment type="block">/* Return the number of entries in the yy_action table */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>acttab_size</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((X)-&gt;nAction)</cpp:value></cpp:define>

<comment type="block">/* The value for the N-th entry in yy_action */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>acttab_yyaction</name><parameter_list>(<parameter><type><name>X</name></type></parameter>,<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((X)-&gt;aAction[N].action)</cpp:value></cpp:define>

<comment type="block">/* The value for the N-th entry in yy_lookahead */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>acttab_yylookahead</name><parameter_list>(<parameter><type><name>X</name></type></parameter>,<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((X)-&gt;aAction[N].lookahead)</cpp:value></cpp:define>

<comment type="block">/* Free all memory associated with the given acttab */</comment>
<function><type><name>void</name></type> <name>acttab_free</name><parameter_list>(<parameter><decl><type><name>acttab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLookahead</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Allocate a new acttab structure */</comment>
<function><type><name>acttab</name> <modifier>*</modifier></type><name>acttab_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>acttab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>acttab</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>( <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Unable to allocate memory for a new acttab."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a new action to the current transaction set.  
**
** This routine is called once for each lookahead for a particular
** state.
*/</comment>
<function><type><name>void</name></type> <name>acttab_action</name><parameter_list>(<parameter><decl><type><name>acttab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lookahead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nLookaheadAlloc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLookaheadAlloc</name></name> <operator>+=</operator> <literal type="number">25</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLookahead</name></name> <operator>=</operator> <operator>(</operator>struct <name>lookahead_action</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLookahead</name></name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLookahead</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nLookaheadAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aLookahead</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"malloc failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mxLookahead</name></name> <operator>=</operator> <name>lookahead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mnLookahead</name></name> <operator>=</operator> <name>lookahead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mnAction</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mxLookahead</name></name><operator>&lt;</operator><name>lookahead</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mxLookahead</name></name> <operator>=</operator> <name>lookahead</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mnLookahead</name></name><operator>&gt;</operator><name>lookahead</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mnLookahead</name></name> <operator>=</operator> <name>lookahead</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mnAction</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLookahead</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name></expr>]</index></name><operator>.</operator><name>lookahead</name> <operator>=</operator> <name>lookahead</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLookahead</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name></expr>]</index></name><operator>.</operator><name>action</name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add the transaction set built up with prior calls to acttab_action()
** into the current action table.  Then reset the transaction set back
** to an empty set in preparation for a new round of acttab_action() calls.
**
** Return the offset into the action table of the new transaction.
*/</comment>
<function><type><name>int</name></type> <name>acttab_insert</name><parameter_list>(<parameter><decl><type><name>acttab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure we have enough space to hold the expanded action table
  ** in the worst case.  The worst case occurs if the transaction set
  ** must be appended to the current action table
  */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>mxLookahead</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nAction</name></name> <operator>+</operator> <name>n</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nActionAlloc</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>oldAlloc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nActionAlloc</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nActionAlloc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAction</name></name> <operator>+</operator> <name>n</name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nActionAlloc</name></name> <operator>+</operator> <literal type="number">20</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name></name> <operator>=</operator> <operator>(</operator>struct <name>lookahead_action</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name></name></expr></argument>,
                          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nActionAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"malloc failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>oldAlloc</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nActionAlloc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lookahead</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>action</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Scan the existing action table looking for an offset that is a 
  ** duplicate of the current transaction set.  Fall out of the loop
  ** if and when the duplicate is found.
  **
  ** i is the index in p-&gt;aAction[] where p-&gt;mnLookahead is inserted.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nAction</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lookahead</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>mnLookahead</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* All lookaheads and actions in the aLookahead[] transaction
      ** must match against the candidate aAction[i] entry. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>action</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>mnAction</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aLookahead</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>lookahead</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>mnLookahead</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>k</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>k</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAction</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aLookahead</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>lookahead</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>lookahead</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aLookahead</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>action</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>action</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

      <comment type="block">/* No possible lookahead value that is not in the aLookahead[]
      ** transaction is allowed to match aAction[i] */</comment>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAction</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>lookahead</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>lookahead</name><operator>==</operator><name>j</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>mnLookahead</name></name><operator>-</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name></expr> )</condition><block>{<block_content>
        <break>break;</break>  <comment type="block">/* An exact match is found at offset i */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If no existing offsets exactly match the current transaction, find an
  ** an empty offset in the aAction[] table in which we can add the
  ** aLookahead[] transaction.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Look for holes in the aAction[] table that fit the current
    ** aLookahead[] transaction.  Leave i set to the offset of the hole.
    ** If no holes are found, i is left at p-&gt;nAction, which means the
    ** transaction will be appended. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nActionAlloc</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>mxLookahead</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lookahead</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aLookahead</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>lookahead</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>mnLookahead</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>k</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>lookahead</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAction</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>lookahead</name><operator>==</operator><name>j</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>mnLookahead</name></name><operator>-</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nAction</name></name></expr> )</condition><block>{<block_content>
          <break>break;</break>  <comment type="block">/* Fits in empty slots */</comment>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Insert transaction set at index i. */</comment>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aLookahead</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>lookahead</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>mnLookahead</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aAction</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aLookahead</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>k</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAction</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAction</name></name> <operator>=</operator> <name>k</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLookahead</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Return the offset that is added to the lookahead in order to get the
  ** index into yy_action of the action */</comment>
  <return>return <expr><name>i</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>mnLookahead</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/********************** From the file "build.c" *****************************/</comment>
<comment type="block">/*
** Routines to construction the finite state machine for the LEMON
** parser generator.
*/</comment>

<comment type="block">/* Find a precedence symbol of every rule in the grammar.
** 
** Those rules which have a precedence symbol coded in the input
** grammar using the "[symbol]" construct will already have the
** rp-&gt;precsym field filled.  Other rules take as their precedence
** symbol the first RHS symbol with a defined precedence.  If there
** are not RHS symbols with a defined precedence, the precedence
** symbol field is left blank.
*/</comment>
<function><type><name>void</name></type> <name>FindRulePrecedences</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>xp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>xp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>precsym</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>precsym</name></name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>MULTITERMINAL</name></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>sp</name><operator>-&gt;</operator><name>nsubsym</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>prec</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>precsym</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>prec</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>precsym</name></name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Find all nonterminals which will generate the empty string.
** Then go back and compute the first sets of every nonterminal.
** The first set is the set of all terminal symbols which can begin
** a string generated by that nonterminal.
*/</comment>
<function><type><name>void</name></type> <name>FindFirstSets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>progress</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>lambda</name> <operator>=</operator> <name>LEMON_FALSE</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>firstset</name> <operator>=</operator> <call><name>SetNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* First compute all lambdas */</comment>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>lambda</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>NONTERMINAL</name> <operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>lambda</name></name><operator>==</operator><name>LEMON_FALSE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>lambda</name></name><operator>==</operator><name>LEMON_FALSE</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>lambda</name></name> <operator>=</operator> <name>LEMON_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block>while<condition>( <expr><name>progress</name></expr> )</condition>;</do>

  <comment type="block">/* Now compute all first sets */</comment>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>s1</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>s2</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>s2</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>TERMINAL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>progress</name> <operator>+=</operator> <call><name>SetAdd</name><argument_list>(<argument><expr><name><name>s1</name><operator>-&gt;</operator><name>firstset</name></name></expr></argument>,<argument><expr><name><name>s2</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>s2</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>MULTITERMINAL</name></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>s2</name><operator>-&gt;</operator><name>nsubsym</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name>progress</name> <operator>+=</operator> <call><name>SetAdd</name><argument_list>(<argument><expr><name><name>s1</name><operator>-&gt;</operator><name>firstset</name></name></expr></argument>,<argument><expr><name><name>s2</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
          <break>break;</break>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>s1</name><operator>==</operator><name>s2</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>s1</name><operator>-&gt;</operator><name>lambda</name></name><operator>==</operator><name>LEMON_FALSE</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>progress</name> <operator>+=</operator> <call><name>SetUnion</name><argument_list>(<argument><expr><name><name>s1</name><operator>-&gt;</operator><name>firstset</name></name></expr></argument>,<argument><expr><name><name>s2</name><operator>-&gt;</operator><name>firstset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>s2</name><operator>-&gt;</operator><name>lambda</name></name><operator>==</operator><name>LEMON_FALSE</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
  </block_content>}</block>while<condition>( <expr><name>progress</name></expr> )</condition>;</do>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Compute all LR(0) states for the grammar.  Links
** are added to between some states so that the LR(1) follow sets
** can be computed later.
*/</comment>
<function_decl><type><name>PRIVATE</name> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>getstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>  <comment type="block">/* forward reference */</comment>
<function><type><name>void</name></type> <name>FindStates</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>Configlist_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Find the start symbol */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>start</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>Symbol_find</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>sp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><literal type="string">"The specified start symbol \"%s\" is not \
in a nonterminal of the grammar.  \"%s\" will be used as the start \
symbol instead."</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>start</name></name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>rule</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>rule</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>rule</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Make sure the start symbol doesn't occur on the right-hand side of
  ** any rule.  Report an error if it does.  (YACC would generate a new
  ** start symbol in this case.) */</comment>
  <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>sp</name></expr> )</condition><block>{<block_content>   <comment type="block">/* FIX ME:  Deal with multiterminals */</comment>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><literal type="string">"The start symbol \"%s\" occurs on the \
right-hand side of a rule. This will result in a parser which \
does not work properly."</literal></expr></argument>,<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <comment type="block">/* The basis configuration set for the first state
  ** is all rules which have the start symbol as their
  ** left-hand side */</comment>
  <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>sp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>nextlhs</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>newcfp</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>lhsStart</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>newcfp</name> <operator>=</operator> <call><name>Configlist_addbasis</name><argument_list>(<argument><expr><name>rp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetAdd</name><argument_list>(<argument><expr><name><name>newcfp</name><operator>-&gt;</operator><name>fws</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Compute the first state.  All other states will be
  ** computed automatically during the computation of the first one.
  ** The returned pointer to the first state is not used. */</comment>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>getstate</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Return a pointer to a state which is described by the configuration
** list which has been built from calls to Configlist_add.
*/</comment>
<function_decl><type><name>PRIVATE</name> <name>void</name></type> <name>buildshifts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* Forwd ref */</comment>
<function><type><name>PRIVATE</name> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>getstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>

  <comment type="block">/* Extract the sorted basis of the new state.  The basis was constructed
  ** by prior calls to "Configlist_addbasis()". */</comment>
  <expr_stmt><expr><call><name>Configlist_sortbasis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bp</name> <operator>=</operator> <call><name>Configlist_basis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get a state with the same basis */</comment>
  <expr_stmt><expr><name>stp</name> <operator>=</operator> <call><name>State_find</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>stp</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* A state with the same basis already exists!  Copy all the follow-set
    ** propagation links from the state under construction into the
    ** preexisting state, then return a pointer to the preexisting state */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>x</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>y</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>x</name><operator>=</operator><name>bp</name></expr><operator>,</operator> <expr><name>y</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>bp</name></name></expr>;</init> <condition><expr><name>x</name> <operator>&amp;&amp;</operator> <name>y</name></expr>;</condition> <incr><expr><name>x</name><operator>=</operator><name><name>x</name><operator>-&gt;</operator><name>bp</name></name></expr><operator>,</operator> <expr><name>y</name><operator>=</operator><name><name>y</name><operator>-&gt;</operator><name>bp</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>Plink_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>y</name><operator>-&gt;</operator><name>bplp</name></name></expr></argument>,<argument><expr><name><name>x</name><operator>-&gt;</operator><name>bplp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Plink_delete</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>fplp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>fplp</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>bplp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>Configlist_return</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Configlist_eat</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* This really is a new state.  Construct all the details */</comment>
    <expr_stmt><expr><call><name>Configlist_closure</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* Compute the configuration closure */</comment>
    <expr_stmt><expr><call><name>Configlist_sort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>           <comment type="block">/* Sort the configuration closure */</comment>
    <expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>Configlist_return</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Get a pointer to the config list */</comment>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <call><name>State_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>           <comment type="block">/* A new state structure */</comment>
    <expr_stmt><expr><call><name>MemoryCheck</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>bp</name></name> <operator>=</operator> <name>bp</name></expr>;</expr_stmt>                <comment type="block">/* Remember the configuration basis */</comment>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>cfp</name></name> <operator>=</operator> <name>cfp</name></expr>;</expr_stmt>              <comment type="block">/* Remember the configuration closure */</comment>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>statenum</name></name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Every state gets a sequence number */</comment>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                 <comment type="block">/* No actions, yet. */</comment>
    <expr_stmt><expr><call><name>State_insert</name><argument_list>(<argument><expr><name>stp</name></expr></argument>,<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Add to the state table */</comment>
    <expr_stmt><expr><call><name>buildshifts</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>,<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* Recursively compute successor states */</comment>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>stp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if two symbols are the same.
*/</comment>
<function><type><name>int</name></type> <name>same_symbol</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><name>b</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name><operator>!=</operator><name>MULTITERMINAL</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>b</name><operator>-&gt;</operator><name>type</name></name><operator>!=</operator><name>MULTITERMINAL</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>nsubsym</name></name><operator>!=</operator><name><name>b</name><operator>-&gt;</operator><name>nsubsym</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>a</name><operator>-&gt;</operator><name>nsubsym</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>b</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Construct all successor states to the given state.  A "successor"
** state is any state which can be reached by a shift action.
*/</comment>
<function><type><name>PRIVATE</name> <name>void</name></type> <name>buildshifts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>  <comment type="block">/* For looping thru the config closure of "stp" */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>bcfp</name></decl>;</decl_stmt> <comment type="block">/* For the inner loop on config closure of "stp" */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>newcfg</name></decl>;</decl_stmt>  <comment type="block">/* */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>   <comment type="block">/* Symbol following the dot in configuration "cfp" */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>bsp</name></decl>;</decl_stmt>  <comment type="block">/* Symbol following the dot in configuration "bcfp" */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>newstp</name></decl>;</decl_stmt> <comment type="block">/* A pointer to a successor state */</comment>

  <comment type="block">/* Each configuration becomes complete after it contibutes to a successor
  ** state.  Initially, all configurations are incomplete */</comment>
  <for>for<control>(<init><expr><name>cfp</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</init> <condition><expr><name>cfp</name></expr>;</condition> <incr><expr><name>cfp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>INCOMPLETE</name></expr>;</expr_stmt></block_content></block></for>

  <comment type="block">/* Loop through all configurations of the state "stp" */</comment>
  <for>for<control>(<init><expr><name>cfp</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</init> <condition><expr><name>cfp</name></expr>;</condition> <incr><expr><name>cfp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>cfp</name><operator>-&gt;</operator><name>status</name></name><operator>==</operator><name>COMPLETE</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* Already used by inner loop */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>cfp</name><operator>-&gt;</operator><name>dot</name></name><operator>&gt;=</operator><name><name>cfp</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Can't shift this config */</comment>
    <expr_stmt><expr><call><name>Configlist_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>                      <comment type="block">/* Reset the new config set */</comment>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name><name>cfp</name><operator>-&gt;</operator><name>dot</name></name></expr>]</index></name></expr>;</expr_stmt>             <comment type="block">/* Symbol after the dot */</comment>

    <comment type="block">/* For every configuration in the state "stp" which has the symbol "sp"
    ** following its dot, add the same configuration to the basis set under
    ** construction but with the dot shifted one symbol to the right. */</comment>
    <for>for<control>(<init><expr><name>bcfp</name><operator>=</operator><name>cfp</name></expr>;</init> <condition><expr><name>bcfp</name></expr>;</condition> <incr><expr><name>bcfp</name><operator>=</operator><name><name>bcfp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>bcfp</name><operator>-&gt;</operator><name>status</name></name><operator>==</operator><name>COMPLETE</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* Already used */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>bcfp</name><operator>-&gt;</operator><name>dot</name></name><operator>&gt;=</operator><name><name>bcfp</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* Can't shift this one */</comment>
      <expr_stmt><expr><name>bsp</name> <operator>=</operator> <name><name>bcfp</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name><name>bcfp</name><operator>-&gt;</operator><name>dot</name></name></expr>]</index></name></expr>;</expr_stmt>           <comment type="block">/* Get symbol after dot */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>same_symbol</name><argument_list>(<argument><expr><name>bsp</name></expr></argument>,<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>      <comment type="block">/* Must be same as for "cfp" */</comment>
      <expr_stmt><expr><name><name>bcfp</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>COMPLETE</name></expr>;</expr_stmt>                  <comment type="block">/* Mark this config as used */</comment>
      <expr_stmt><expr><name>newcfg</name> <operator>=</operator> <call><name>Configlist_addbasis</name><argument_list>(<argument><expr><name><name>bcfp</name><operator>-&gt;</operator><name>rp</name></name></expr></argument>,<argument><expr><name><name>bcfp</name><operator>-&gt;</operator><name>dot</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Plink_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newcfg</name><operator>-&gt;</operator><name>bplp</name></name></expr></argument>,<argument><expr><name>bcfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Get a pointer to the state described by the basis configuration set
    ** constructed in the preceding loop */</comment>
    <expr_stmt><expr><name>newstp</name> <operator>=</operator> <call><name>getstate</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The state "newstp" is reached from the state "stp" by a shift action
    ** on the symbol "sp" */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>MULTITERMINAL</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>sp</name><operator>-&gt;</operator><name>nsubsym</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>Action_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr></argument>,<argument><expr><name>SHIFT</name></expr></argument>,<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>newstp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>Action_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr></argument>,<argument><expr><name>SHIFT</name></expr></argument>,<argument><expr><name>sp</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>newstp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Construct the propagation links
*/</comment>
<function><type><name>void</name></type> <name>FindLinks</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>plp</name></decl>;</decl_stmt>

  <comment type="block">/* Housekeeping detail:
  ** Add to every propagate link a pointer back to the state to
  ** which the link is attached. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>cfp</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</init> <condition><expr><name>cfp</name></expr>;</condition> <incr><expr><name>cfp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>stp</name></name> <operator>=</operator> <name>stp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <comment type="block">/* Convert all backlinks into forward links.  Only the forward
  ** links are used in the follow-set computation. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>cfp</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</init> <condition><expr><name>cfp</name></expr>;</condition> <incr><expr><name>cfp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>plp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>bplp</name></name></expr>;</init> <condition><expr><name>plp</name></expr>;</condition> <incr><expr><name>plp</name><operator>=</operator><name><name>plp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>other</name> <operator>=</operator> <name><name>plp</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Plink_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>other</name><operator>-&gt;</operator><name>fplp</name></name></expr></argument>,<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Compute all followsets.
**
** A followset is the set of all symbols which can come immediately
** after a configuration.
*/</comment>
<function><type><name>void</name></type> <name>FindFollowSets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>plp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>progress</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>change</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <for>for<control>(<init><expr><name>cfp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>cfp</name></expr>;</init> <condition><expr><name>cfp</name></expr>;</condition> <incr><expr><name>cfp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>INCOMPLETE</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>cfp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>cfp</name></expr>;</init> <condition><expr><name>cfp</name></expr>;</condition> <incr><expr><name>cfp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>cfp</name><operator>-&gt;</operator><name>status</name></name><operator>==</operator><name>COMPLETE</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <for>for<control>(<init><expr><name>plp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>fplp</name></name></expr>;</init> <condition><expr><name>plp</name></expr>;</condition> <incr><expr><name>plp</name><operator>=</operator><name><name>plp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>SetUnion</name><argument_list>(<argument><expr><name><name>plp</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>fws</name></name></expr></argument>,<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>fws</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>change</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>plp</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>INCOMPLETE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>COMPLETE</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
  </block_content>}</block>while<condition>( <expr><name>progress</name></expr> )</condition>;</do>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>resolve_conflict</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compute the reduce actions, and resolve conflicts.
*/</comment>
<function><type><name>void</name></type> <name>FindActions</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

  <comment type="block">/* Add all of the reduce actions 
  ** A reduce action is added for each element of the followset of
  ** a configuration which has its dot at the extreme right.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>   <comment type="block">/* Loop over all states */</comment>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>cfp</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</init> <condition><expr><name>cfp</name></expr>;</condition> <incr><expr><name>cfp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>  <comment type="block">/* Loop over all configurations */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>cfp</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>==</operator><name><name>cfp</name><operator>-&gt;</operator><name>dot</name></name></expr> )</condition><block>{<block_content>        <comment type="block">/* Is dot at extreme right? */</comment>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>SetFind</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>fws</name></name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <comment type="block">/* Add a reduce action to the state "stp" which will reduce by the
            ** rule "cfp-&gt;rp" if the lookahead symbol is "lemp-&gt;symbols[j]" */</comment>
            <expr_stmt><expr><call><name>Action_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr></argument>,<argument><expr><name>REDUCE</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>cfp</name><operator>-&gt;</operator><name>rp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <comment type="block">/* Add the accepting token */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>start</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>Symbol_find</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>sp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>rule</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>rule</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Add to the first state (which is always the starting state of the
  ** finite state machine) an action to ACCEPT if the lookahead is the
  ** start nonterminal.  */</comment>
  <expr_stmt><expr><call><name>Action_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ap</name></expr></argument>,<argument><expr><name>ACCEPT</name></expr></argument>,<argument><expr><name>sp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Resolve conflicts */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nap</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <comment type="block">/* assert( stp-&gt;ap ); */</comment>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name> <operator>=</operator> <call><name>Action_sort</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr>;</init> <condition><expr><name>ap</name> <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>nap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>nap</name> <operator>&amp;&amp;</operator> <name><name>nap</name><operator>-&gt;</operator><name>sp</name></name><operator>==</operator><name><name>ap</name><operator>-&gt;</operator><name>sp</name></name></expr>;</condition> <incr><expr><name>nap</name><operator>=</operator><name><name>nap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
         <comment type="block">/* The two actions "ap" and "nap" have the same lookahead.
         ** Figure out which one should be used */</comment>
         <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>nconflict</name></name> <operator>+=</operator> <call><name>resolve_conflict</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>nap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <comment type="block">/* Report an error for each rule that can never be reduced. */</comment>
  <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>canReduce</name></name> <operator>=</operator> <name>LEMON_FALSE</name></expr>;</expr_stmt></block_content></block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ap</name></expr>;</init> <condition><expr><name>ap</name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>REDUCE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name><operator>-&gt;</operator><name>canReduce</name></name> <operator>=</operator> <name>LEMON_TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>canReduce</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ruleline</name></name></expr></argument>,<argument><expr><literal type="string">"This rule can not be reduced.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Resolve a conflict between the two given actions.  If the
** conflict can't be resolved, return non-zero.
**
** NO LONGER TRUE:
**   To resolve a conflict, first look to see if either action
**   is on an error rule.  In that case, take the action which
**   is not associated with the error rule.  If neither or both
**   actions are associated with an error rule, then try to
**   use precedence to resolve the conflict.
**
** If either action is a SHIFT, then it must be apx.  This
** function won't work if apx-&gt;type==REDUCE and apy-&gt;type==SHIFT.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolve_conflict</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>apx</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>apy</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>spx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>spy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>apx</name><operator>-&gt;</operator><name>sp</name></name><operator>==</operator><name><name>apy</name><operator>-&gt;</operator><name>sp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Otherwise there would be no conflict */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>apx</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SHIFT</name> <operator>&amp;&amp;</operator> <name><name>apy</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SHIFT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>apy</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SSCONFLICT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>errcnt</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>apx</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SHIFT</name> <operator>&amp;&amp;</operator> <name><name>apy</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>REDUCE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>spx</name> <operator>=</operator> <name><name>apx</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>spy</name> <operator>=</operator> <name><name>apy</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name><operator>-&gt;</operator><name>precsym</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>spy</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>spx</name><operator>-&gt;</operator><name>prec</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>spy</name><operator>-&gt;</operator><name>prec</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Not enough precedence information. */</comment>
      <expr_stmt><expr><name><name>apy</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SRCONFLICT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>errcnt</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>spx</name><operator>-&gt;</operator><name>prec</name></name><operator>&gt;</operator><name><name>spy</name><operator>-&gt;</operator><name>prec</name></name></expr> )</condition><block>{<block_content>    <comment type="block">/* higher precedence wins */</comment>
      <expr_stmt><expr><name><name>apy</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>RD_RESOLVED</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>spx</name><operator>-&gt;</operator><name>prec</name></name><operator>&lt;</operator><name><name>spy</name><operator>-&gt;</operator><name>prec</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>apx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SH_RESOLVED</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>spx</name><operator>-&gt;</operator><name>prec</name></name><operator>==</operator><name><name>spy</name><operator>-&gt;</operator><name>prec</name></name> <operator>&amp;&amp;</operator> <name><name>spx</name><operator>-&gt;</operator><name>assoc</name></name><operator>==</operator><name>RIGHT</name></expr> )</condition><block>{<block_content> <comment type="block">/* Use operator */</comment>
      <expr_stmt><expr><name><name>apy</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>RD_RESOLVED</name></expr>;</expr_stmt>                             <comment type="block">/* associativity */</comment>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>spx</name><operator>-&gt;</operator><name>prec</name></name><operator>==</operator><name><name>spy</name><operator>-&gt;</operator><name>prec</name></name> <operator>&amp;&amp;</operator> <name><name>spx</name><operator>-&gt;</operator><name>assoc</name></name><operator>==</operator><name>LEFT</name></expr> )</condition><block>{<block_content>  <comment type="block">/* to break tie */</comment>
      <expr_stmt><expr><name><name>apx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SH_RESOLVED</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>spx</name><operator>-&gt;</operator><name>prec</name></name><operator>==</operator><name><name>spy</name><operator>-&gt;</operator><name>prec</name></name> <operator>&amp;&amp;</operator> <name><name>spx</name><operator>-&gt;</operator><name>assoc</name></name><operator>==</operator><name>NONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>apx</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>REDUCE</name> <operator>&amp;&amp;</operator> <name><name>apy</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>REDUCE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>spx</name> <operator>=</operator> <name><name>apx</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name><operator>-&gt;</operator><name>precsym</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>spy</name> <operator>=</operator> <name><name>apy</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name><operator>-&gt;</operator><name>precsym</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>spx</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>spy</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>spx</name><operator>-&gt;</operator><name>prec</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator>
    <name><name>spy</name><operator>-&gt;</operator><name>prec</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>spx</name><operator>-&gt;</operator><name>prec</name></name><operator>==</operator><name><name>spy</name><operator>-&gt;</operator><name>prec</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>apy</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>RRCONFLICT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>errcnt</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>spx</name><operator>-&gt;</operator><name>prec</name></name><operator>&gt;</operator><name><name>spy</name><operator>-&gt;</operator><name>prec</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>apy</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>RD_RESOLVED</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>spx</name><operator>-&gt;</operator><name>prec</name></name><operator>&lt;</operator><name><name>spy</name><operator>-&gt;</operator><name>prec</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>apx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>RD_RESOLVED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( 
      <argument><expr><name><name>apx</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SH_RESOLVED</name> <operator>||</operator>
      <name><name>apx</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>RD_RESOLVED</name> <operator>||</operator>
      <name><name>apx</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SSCONFLICT</name> <operator>||</operator>
      <name><name>apx</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SRCONFLICT</name> <operator>||</operator>
      <name><name>apx</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>RRCONFLICT</name> <operator>||</operator>
      <name><name>apy</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SH_RESOLVED</name> <operator>||</operator>
      <name><name>apy</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>RD_RESOLVED</name> <operator>||</operator>
      <name><name>apy</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SSCONFLICT</name> <operator>||</operator>
      <name><name>apy</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SRCONFLICT</name> <operator>||</operator>
      <name><name>apy</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>RRCONFLICT</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The REDUCE/SHIFT case cannot happen because SHIFTs come before
    ** REDUCEs on the list.  If we reach this point it must be because
    ** the parser conflict had already been resolved. */</comment>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>errcnt</name></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/********************* From the file "configlist.c" *************************/</comment>
<comment type="block">/*
** Routines to processing a configuration list and building a state
** in the LEMON parser generator.
*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>freelist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* List of free configurations */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>current</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Top of list of configurations */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>currentend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Last on list of configs */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>basis</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Top of list of basis configs */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>basisend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* End of list of basis configs */</comment>

<comment type="block">/* Return a pointer to a new configuration */</comment>
<function><type><name>PRIVATE</name> <name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>newconfig</name><parameter_list>()</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>newcfg</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>freelist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>amt</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>freelist</name> <operator>=</operator> <operator>(</operator>struct <name>config</name> <operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>( <argument><expr><name>amt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>freelist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Unable to allocate memory for a new configuration."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>amt</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>freelist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <operator>&amp;</operator><name><name>freelist</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>freelist</name><index>[<expr><name>amt</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>newcfg</name> <operator>=</operator> <name>freelist</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>freelist</name> <operator>=</operator> <name><name>freelist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  <return>return <expr><name>newcfg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The configuration "old" is no longer used */</comment>
<function><type><name>PRIVATE</name> <name>void</name></type> <name>deleteconfig</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>old</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>old</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>freelist</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>freelist</name> <operator>=</operator> <name>old</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialized the configuration list builder */</comment>
<function><type><name>void</name></type> <name>Configlist_init</name><parameter_list>()</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>current</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>currentend</name> <operator>=</operator> <operator>&amp;</operator><name>current</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>basis</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>basisend</name> <operator>=</operator> <operator>&amp;</operator><name>basis</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Configtable_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Initialized the configuration list builder */</comment>
<function><type><name>void</name></type> <name>Configlist_reset</name><parameter_list>()</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>current</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>currentend</name> <operator>=</operator> <operator>&amp;</operator><name>current</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>basis</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>basisend</name> <operator>=</operator> <operator>&amp;</operator><name>basis</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Configtable_clear</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Add another configuration to the configuration list */</comment>
<function><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>Configlist_add</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>,    <comment type="block">/* The rule */</comment>
  <parameter><decl><type><name>int</name></type> <name>dot</name></decl></parameter>             <comment type="block">/* Index into the RHS of the rule where the dot goes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>, <decl><type ref="prev"/><name>model</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>currentend</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>model</name><operator>.</operator><name>rp</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>model</name><operator>.</operator><name>dot</name></name> <operator>=</operator> <name>dot</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>Configtable_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>cfp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>newconfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>rp</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>dot</name></name> <operator>=</operator> <name>dot</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>fws</name></name> <operator>=</operator> <call><name>SetNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>stp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>fplp</name></name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>bplp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>bp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>currentend</name> <operator>=</operator> <name>cfp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentend</name> <operator>=</operator> <operator>&amp;</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Configtable_insert</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>cfp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a basis configuration to the configuration list */</comment>
<function><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>Configlist_addbasis</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>, <decl><type ref="prev"/><name>model</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>basisend</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>currentend</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>model</name><operator>.</operator><name>rp</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>model</name><operator>.</operator><name>dot</name></name> <operator>=</operator> <name>dot</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>Configtable_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>cfp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>newconfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>rp</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>dot</name></name> <operator>=</operator> <name>dot</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>fws</name></name> <operator>=</operator> <call><name>SetNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>stp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>fplp</name></name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>bplp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>bp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>currentend</name> <operator>=</operator> <name>cfp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentend</name> <operator>=</operator> <operator>&amp;</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>basisend</name> <operator>=</operator> <name>cfp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>basisend</name> <operator>=</operator> <operator>&amp;</operator><name><name>cfp</name><operator>-&gt;</operator><name>bp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Configtable_insert</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>cfp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute the closure of the configuration list */</comment>
<function><type><name>void</name></type> <name>Configlist_closure</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newcfp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newrp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xsp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>dot</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>currentend</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>cfp</name><operator>=</operator><name>current</name></expr>;</init> <condition><expr><name>cfp</name></expr>;</condition> <incr><expr><name>cfp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>rp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dot</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>dot</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>dot</name><operator>&gt;=</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>dot</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>NONTERMINAL</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>rule</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sp</name><operator>!=</operator><name><name>lemp</name><operator>-&gt;</operator><name>errsym</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>line</name></name></expr></argument>,<argument><expr><literal type="string">"Nonterminal \"%s\" has no rules."</literal></expr></argument>,
          <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>newrp</name><operator>=</operator><name><name>sp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>newrp</name></expr>;</condition> <incr><expr><name>newrp</name><operator>=</operator><name><name>newrp</name><operator>-&gt;</operator><name>nextlhs</name></name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>newcfp</name> <operator>=</operator> <call><name>Configlist_add</name><argument_list>(<argument><expr><name>newrp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>dot</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>xsp</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>xsp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>TERMINAL</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>SetAdd</name><argument_list>(<argument><expr><name><name>newcfp</name><operator>-&gt;</operator><name>fws</name></name></expr></argument>,<argument><expr><name><name>xsp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>xsp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>MULTITERMINAL</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>xsp</name><operator>-&gt;</operator><name>nsubsym</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <expr_stmt><expr><call><name>SetAdd</name><argument_list>(<argument><expr><name><name>newcfp</name><operator>-&gt;</operator><name>fws</name></name></expr></argument>, <argument><expr><name><name>xsp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name>k</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <break>break;</break>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>SetUnion</name><argument_list>(<argument><expr><name><name>newcfp</name><operator>-&gt;</operator><name>fws</name></name></expr></argument>,<argument><expr><name><name>xsp</name><operator>-&gt;</operator><name>firstset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>xsp</name><operator>-&gt;</operator><name>lambda</name></name><operator>==</operator><name>LEMON_FALSE</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Plink_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cfp</name><operator>-&gt;</operator><name>fplp</name></name></expr></argument>,<argument><expr><name>newcfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Sort the configuration list */</comment>
<function><type><name>void</name></type> <name>Configlist_sort</name><parameter_list>()</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>current</name> <operator>=</operator> <operator>(</operator>struct <name>config</name><operator>*</operator><operator>)</operator><call><name>msort</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>current</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>current</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr></argument>,
                                  <argument><expr><name>Configcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>currentend</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Sort the basis configuration list */</comment>
<function><type><name>void</name></type> <name>Configlist_sortbasis</name><parameter_list>()</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>basis</name> <operator>=</operator> <operator>(</operator>struct <name>config</name><operator>*</operator><operator>)</operator><call><name>msort</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>current</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>current</name><operator>-&gt;</operator><name>bp</name></name><operator>)</operator></expr></argument>,
                                <argument><expr><name>Configcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>basisend</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Return a pointer to the head of the configuration list and
** reset the list */</comment>
<function><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>Configlist_return</name><parameter_list>()</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>old</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>old</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>current</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>currentend</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a pointer to the head of the configuration list and
** reset the list */</comment>
<function><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>Configlist_basis</name><parameter_list>()</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>old</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>old</name> <operator>=</operator> <name>basis</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>basis</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>basisend</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free all elements of the given configuration list */</comment>
<function><type><name>void</name></type> <name>Configlist_eat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>nextcfp</name></decl>;</decl_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>cfp</name></expr>;</condition> <incr><expr><name>cfp</name><operator>=</operator><name>nextcfp</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nextcfp</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>fplp</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>bplp</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>cfp</name><operator>-&gt;</operator><name>fws</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SetFree</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>fws</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>deleteconfig</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/***************** From the file "error.c" *********************************/</comment>
<comment type="block">/*
** Code for printing error message.
*/</comment>

<function><type><name>void</name></type> <name>ErrorMsg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: "</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><name>format</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block" format="doxygen">/**************** From the file "main.c" ************************************/</comment>
<comment type="block">/*
** Main program file for the LEMON parser generator.
*/</comment>

<comment type="block">/* Report an out-of-memory condition and abort.  This function
** is used mostly by the "MemoryCheck" macro in struct.h
*/</comment>
<function><type><name>void</name></type> <name>memory_error</name><parameter_list>()</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Out of memory.  Aborting...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nDefine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Number of -D options on the command line */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azDefine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Name of the -D macros */</comment>

<comment type="block">/* This routine is called with the argument to each -D command-line option.
** Add the macro defined to the azDefine array.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_D_option</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paz</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>nDefine</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>azDefine</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>azDefine</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>azDefine</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nDefine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>azDefine</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>paz</name> <operator>=</operator> <operator>&amp;</operator><name><name>azDefine</name><index>[<expr><name>nDefine</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>paz</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>( <argument><expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>paz</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lemon_strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>paz</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>z</name><operator>=</operator><operator>*</operator><name>paz</name></expr>;</init> <condition><expr><operator>*</operator><name>z</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>z</name><operator>!=</operator><literal type="char">'='</literal></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>user_templatename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_T_option</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>user_templatename</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>( <argument><expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>user_templatename</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memory_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lemon_strcpy</name><argument_list>(<argument><expr><name>user_templatename</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* forward reference */</comment>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>minimum_size_type</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lwr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>upr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnByte</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Print a single line of the "Parser Stats" output
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stats_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLabel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iValue</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nLabel</name> <init>= <expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name>zLabel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  %s%.*s %5d\n"</literal></expr></argument>, <argument><expr><name>zLabel</name></expr></argument>,
         <argument><expr><literal type="number">35</literal><operator>-</operator><name>nLabel</name></expr></argument>, <argument><expr><literal type="string">"................................"</literal></expr></argument>,
         <argument><expr><name>iValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* The main program.  Parse the command line and do it... */</comment>
<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>version</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>rpflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>basisflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>compress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>quiet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>statistics</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>mhflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nolinenosflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>noResort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>s_options</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><name>OPT_FLAG</name></expr>, <expr><literal type="string">"b"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>basisflag</name></expr>, <expr><literal type="string">"Print only the basis in report."</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FLAG</name></expr>, <expr><literal type="string">"c"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>compress</name></expr>, <expr><literal type="string">"Don't compress the action table."</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FSTR</name></expr>, <expr><literal type="string">"D"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>handle_D_option</name></expr>, <expr><literal type="string">"Define an %ifdef macro."</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FSTR</name></expr>, <expr><literal type="string">"f"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"Ignored.  (Placeholder for -f compiler options.)"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FLAG</name></expr>, <expr><literal type="string">"g"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rpflag</name></expr>, <expr><literal type="string">"Print grammar without actions."</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FSTR</name></expr>, <expr><literal type="string">"I"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"Ignored.  (Placeholder for '-I' compiler options.)"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FLAG</name></expr>, <expr><literal type="string">"m"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>mhflag</name></expr>, <expr><literal type="string">"Output a makeheaders compatible file."</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FLAG</name></expr>, <expr><literal type="string">"l"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nolinenosflag</name></expr>, <expr><literal type="string">"Do not print #line statements."</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FSTR</name></expr>, <expr><literal type="string">"O"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"Ignored.  (Placeholder for '-O' compiler options.)"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FLAG</name></expr>, <expr><literal type="string">"p"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>showPrecedenceConflict</name></expr>,
                    <expr><literal type="string">"Show conflicts resolved by precedence rules"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FLAG</name></expr>, <expr><literal type="string">"q"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>quiet</name></expr>, <expr><literal type="string">"(Quiet) Don't print the report file."</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FLAG</name></expr>, <expr><literal type="string">"r"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>noResort</name></expr>, <expr><literal type="string">"Do not sort or renumber states"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FLAG</name></expr>, <expr><literal type="string">"s"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>statistics</name></expr>,
                                   <expr><literal type="string">"Print parser stats to standard output."</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FLAG</name></expr>, <expr><literal type="string">"x"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>version</name></expr>, <expr><literal type="string">"Print the version number."</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FSTR</name></expr>, <expr><literal type="string">"T"</literal></expr>, <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>handle_T_option</name></expr>, <expr><literal type="string">"Specify a template file."</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FSTR</name></expr>, <expr><literal type="string">"W"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"Ignored.  (Placeholder for '-W' compiler options.)"</literal></expr>}</block></expr>,
    <expr><block>{<expr><name>OPT_FLAG</name></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>exitcode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>lemon</name></name></type> <name>lem</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>OptInit</name><argument_list>(<argument><expr><name>argv</name></expr></argument>,<argument><expr><name>options</name></expr></argument>,<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>version</name></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Lemon version 1.0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>OptNArgs</name><argument_list>()</argument_list></call><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Exactly one filename argument is required.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>errorcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Initialize the machine */</comment>
  <expr_stmt><expr><call><name>Strsafe_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Symbol_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>State_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>argv0</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>filename</name></name> <operator>=</operator> <call><name>OptArg</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>basisflag</name></name> <operator>=</operator> <name>basisflag</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>nolinenosflag</name></name> <operator>=</operator> <name>nolinenosflag</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Symbol_new</name><argument_list>(<argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>errsym</name></name> <operator>=</operator> <call><name>Symbol_new</name><argument_list>(<argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>errsym</name><operator>-&gt;</operator><name>useCnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Parse the input file */</comment>
  <expr_stmt><expr><call><name>Parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>lem</name><operator>.</operator><name>errorcnt</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name><name>lem</name><operator>.</operator><name>errorcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>lem</name><operator>.</operator><name>nrule</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Empty grammar.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Count and index the symbols of the grammar */</comment>
  <expr_stmt><expr><call><name>Symbol_new</name><argument_list>(<argument><expr><literal type="string">"{default}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>nsymbol</name></name> <operator>=</operator> <call><name>Symbol_count</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>symbols</name></name> <operator>=</operator> <call><name>Symbol_arrayof</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lem</name><operator>.</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>lem</name><operator>.</operator><name>symbols</name></name></expr></argument>,<argument><expr><name><name>lem</name><operator>.</operator><name>nsymbol</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>symbol</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>Symbolcmpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lem</name><operator>.</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
  <while>while<condition>( <expr><name><name>lem</name><operator>.</operator><name>symbols</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>type</name><operator>==</operator><name>MULTITERMINAL</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>lem</name><operator>.</operator><name>symbols</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,<argument><expr><literal type="string">"{default}"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>nsymbol</name></name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><call><name>ISUPPER</name><argument_list>(<argument><expr><name><name>lem</name><operator>.</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>nterminal</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

  <comment type="block">/* Generate a reprint of the grammar, if requested on the command line */</comment>
  <if_stmt><if>if<condition>( <expr><name>rpflag</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Reprint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Initialize the size for all follow and first sets */</comment>
    <expr_stmt><expr><call><name>SetSize</name><argument_list>(<argument><expr><name><name>lem</name><operator>.</operator><name>nterminal</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find the precedence for every production rule (that has one) */</comment>
    <expr_stmt><expr><call><name>FindRulePrecedences</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute the lambda-nonterminals and the first-sets for every
    ** nonterminal */</comment>
    <expr_stmt><expr><call><name>FindFirstSets</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute all LR(0) states.  Also record follow-set propagation
    ** links so that the follow-set can be computed later */</comment>
    <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>nstate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FindStates</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lem</name><operator>.</operator><name>sorted</name></name> <operator>=</operator> <call><name>State_arrayof</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Tie up loose ends on the propagation links */</comment>
    <expr_stmt><expr><call><name>FindLinks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute the follow set of every reducible configuration */</comment>
    <expr_stmt><expr><call><name>FindFollowSets</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute the action tables */</comment>
    <expr_stmt><expr><call><name>FindActions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compress the action tables */</comment>
    <if_stmt><if>if<condition>( <expr><name>compress</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CompressTables</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Reorder and renumber the states so that states with fewer choices
    ** occur at the end.  This is an optimization that helps make the
    ** generated parser tables smaller. */</comment>
    <if_stmt><if>if<condition>( <expr><name>noResort</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ResortStates</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Generate a report of the parser generated.  (the "y.output" file) */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>quiet</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ReportOutput</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Generate the source code for the parser */</comment>
    <expr_stmt><expr><call><name>ReportTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>, <argument><expr><name>mhflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Produce a header file for use by the scanner.  (This step is
    ** omitted if the "-m" option is used because makeheaders will
    ** generate the file for us.) */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>mhflag</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ReportHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>statistics</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Parser statistics:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stats_line</name><argument_list>(<argument><expr><literal type="string">"terminal symbols"</literal></expr></argument>, <argument><expr><name><name>lem</name><operator>.</operator><name>nterminal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stats_line</name><argument_list>(<argument><expr><literal type="string">"non-terminal symbols"</literal></expr></argument>, <argument><expr><name><name>lem</name><operator>.</operator><name>nsymbol</name></name> <operator>-</operator> <name><name>lem</name><operator>.</operator><name>nterminal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stats_line</name><argument_list>(<argument><expr><literal type="string">"total symbols"</literal></expr></argument>, <argument><expr><name><name>lem</name><operator>.</operator><name>nsymbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stats_line</name><argument_list>(<argument><expr><literal type="string">"rules"</literal></expr></argument>, <argument><expr><name><name>lem</name><operator>.</operator><name>nrule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stats_line</name><argument_list>(<argument><expr><literal type="string">"states"</literal></expr></argument>, <argument><expr><name><name>lem</name><operator>.</operator><name>nxstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stats_line</name><argument_list>(<argument><expr><literal type="string">"conflicts"</literal></expr></argument>, <argument><expr><name><name>lem</name><operator>.</operator><name>nconflict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stats_line</name><argument_list>(<argument><expr><literal type="string">"action table entries"</literal></expr></argument>, <argument><expr><name><name>lem</name><operator>.</operator><name>nactiontab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stats_line</name><argument_list>(<argument><expr><literal type="string">"total table size (bytes)"</literal></expr></argument>, <argument><expr><name><name>lem</name><operator>.</operator><name>tablesize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>lem</name><operator>.</operator><name>nconflict</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"%d parsing conflicts.\n"</literal></expr></argument>,<argument><expr><name><name>lem</name><operator>.</operator><name>nconflict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* return 0 on success, 1 on failure. */</comment>
  <expr_stmt><expr><name>exitcode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>lem</name><operator>.</operator><name>errorcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>lem</name><operator>.</operator><name>nconflict</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exitcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>exitcode</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/******************** From the file "msort.c" *******************************/</comment>
<comment type="block">/*
** A generic merge-sort program.
**
** USAGE:
** Let "ptr" be a pointer to some structure which is at the head of
** a null-terminated list.  Then to sort the list call:
**
**     ptr = msort(ptr,&amp;(ptr-&gt;next),cmpfnc);
**
** In the above, "cmpfnc" is a pointer to a function which compares
** two instances of the structure and returns an integer, as in
** strcmp.  The second argument is a pointer to the pointer to the
** second element of the linked list.  This address is used to compute
** the offset to the "next" field within the structure.  The offset to
** the "next" field must be constant for all structures in the list.
**
** The function returns a new pointer which is the head of the list
** after sorting.
**
** ALGORITHM:
** Merge-sort.
*/</comment>

<comment type="block">/*
** Return a pointer to the next structure in the linked list.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(char**)(((char*)A)+offset))</cpp:value></cpp:define>

<comment type="block">/*
** Inputs:
**   a:       A sorted, null-terminated linked list.  (May be null).
**   b:       A sorted, null-terminated linked list.  (May be null).
**   cmp:     A pointer to the comparison function.
**   offset:  Offset in the structure to the "next" field.
**
** Return Value:
**   A pointer to the head of a sorted list containing the elements
**   of both a and b.
**
** Side effects:
**   The "next" pointers for elements in the lists a and b are
**   changed.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>merge</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>head</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>b</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>head</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call>(<modifier>*</modifier><name>cmp</name>)<argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>NEXT</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>head</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>a</name> <operator>&amp;&amp;</operator> <name>b</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call>(<modifier>*</modifier><name>cmp</name>)<argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>NEXT</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>NEXT</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>NEXT</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>a</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>NEXT</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>a</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>    <expr_stmt><expr><call><name>NEXT</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>b</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>head</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Inputs:
**   list:      Pointer to a singly-linked list of structures.
**   next:      Pointer to pointer to the second element of the list.
**   cmp:       A comparison function.
**
** Return Value:
**   A pointer to the head of a sorted list containing the elements
**   orginally in list.
**
** Side effects:
**   The "next" pointers for elements in list are changed.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LISTSIZE</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>msort</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>list</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>next</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>set</name><index>[<expr><name>LISTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>next</name> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>list</name><operator>)</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>LISTSIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
  <while>while<condition>( <expr><name>list</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>ep</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>NEXT</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NEXT</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>LISTSIZE</name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>set</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>merge</name><argument_list>(<argument><expr><name>ep</name></expr></argument>,<argument><expr><name><name>set</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>cmp</name></expr></argument>,<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ep</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>ep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>LISTSIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><name><name>set</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>merge</name><argument_list>(<argument><expr><name><name>set</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>ep</name></expr></argument>,<argument><expr><name>cmp</name></expr></argument>,<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
  <return>return <expr><name>ep</name></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/************************ From the file "option.c" **************************/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>s_options</name></name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>errstream</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISOPT</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((X)[0]=='-'||(X)[0]=='+'||strchr((X),'=')!=0)</cpp:value></cpp:define>

<comment type="block">/*
** Print the command line with a carrot pointing to the k-th character
** of the n-th field.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>errline</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>spcnt</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>spcnt</name> <operator>=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">" %s"</literal></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>spcnt</name> <operator>+=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>spcnt</name> <operator>+=</operator> <name>k</name></expr>;</expr_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">" %s"</literal></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <if_stmt><if>if<condition>( <expr><name>spcnt</name><operator>&lt;</operator><literal type="number">20</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"\n%*s^-- here\n"</literal></expr></argument>,<argument><expr><name>spcnt</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"\n%*shere --^\n"</literal></expr></argument>,<argument><expr><name>spcnt</name><operator>-</operator><literal type="number">7</literal></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the index of the N-th non-switch argument.  Return -1
** if N is out of range.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>argindex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>dashdash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argv</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>argv</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>dashdash</name> <operator>||</operator> <operator>!</operator><call><name>ISOPT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dashdash</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>emsg</name><index>[]</index></name> <init>= <expr><literal type="string">"Command line syntax error: "</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Process a flag command line argument.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>handleflags</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>label</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>,<argument><expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <ternary><condition><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>label</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>err</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"%sundefined option.\n"</literal></expr></argument>,<argument><expr><name>emsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>errline</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>errcnt</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>arg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Ignore this option */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name><operator>==</operator><name>OPT_FLAG</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>arg</name><operator>)</operator> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name><operator>==</operator><name>OPT_FFLAG</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>arg</name><operator>)</operator><operator>)</operator><operator>(</operator><name>v</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name><operator>==</operator><name>OPT_FSTR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>arg</name><operator>)</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>err</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"%smissing argument on switch.\n"</literal></expr></argument>,<argument><expr><name>emsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>errline</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>errcnt</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>errcnt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Process a command line switch which has an argument.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>handleswitch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>lv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>dv</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cp</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>label</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'='</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>label</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>err</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"%sundefined option.\n"</literal></expr></argument>,<argument><expr><name>emsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>errline</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>errcnt</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OPT_FLAG</name></expr>:</case>
      <case>case <expr><name>OPT_FFLAG</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>err</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"%soption requires an argument.\n"</literal></expr></argument>,<argument><expr><name>emsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>errline</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>errcnt</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_DBL</name></expr>:</case>
      <case>case <expr><name>OPT_FDBL</name></expr>:</case>
        <expr_stmt><expr><name>dv</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>end</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>err</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
               <argument><expr><literal type="string">"%sillegal character in floating-point argument.\n"</literal></expr></argument>,<argument><expr><name>emsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>errline</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>end</name><operator>-</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>errcnt</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_INT</name></expr>:</case>
      <case>case <expr><name>OPT_FINT</name></expr>:</case>
        <expr_stmt><expr><name>lv</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>end</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>err</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"%sillegal character in integer argument.\n"</literal></expr></argument>,<argument><expr><name>emsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>errline</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>end</name><operator>-</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>errcnt</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_STR</name></expr>:</case>
      <case>case <expr><name>OPT_FSTR</name></expr>:</case>
        <expr_stmt><expr><name>sv</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
    <switch>switch<condition>( <expr><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OPT_FLAG</name></expr>:</case>
      <case>case <expr><name>OPT_FFLAG</name></expr>:</case>
        <break>break;</break>
      <case>case <expr><name>OPT_DBL</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>arg</name><operator>)</operator> <operator>=</operator> <name>dv</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_FDBL</name></expr>:</case>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>arg</name><operator>)</operator><operator>)</operator><operator>(</operator><name>dv</name><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_INT</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>arg</name><operator>)</operator> <operator>=</operator> <name>lv</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_FINT</name></expr>:</case>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>arg</name><operator>)</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>lv</name><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_STR</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>arg</name><operator>)</operator> <operator>=</operator> <name>sv</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_FSTR</name></expr>:</case>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name><name>op</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>arg</name><operator>)</operator><operator>)</operator><operator>(</operator><name>sv</name><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>errcnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>OptInit</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>s_options</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>errcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>argv</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>errstream</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>argv</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>argv</name> <operator>&amp;&amp;</operator> <name>op</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'+'</literal> <operator>||</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>errcnt</name> <operator>+=</operator> <call><name>handleflags</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>errcnt</name> <operator>+=</operator> <call><name>handleswitch</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>errcnt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,<argument><expr><literal type="string">"Valid command line options for \"%s\" are:\n"</literal></expr></argument>,<argument><expr><operator>*</operator><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OptPrint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>OptNArgs</name><parameter_list>()</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>dashdash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argv</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>dashdash</name> <operator>||</operator> <operator>!</operator><call><name>ISOPT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dashdash</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>OptArg</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>argindex</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>OptErr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>argindex</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>errline</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>errstream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>OptPrint</name><parameter_list>()</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OPT_FLAG</name></expr>:</case>
      <case>case <expr><name>OPT_FFLAG</name></expr>:</case>
        <break>break;</break>
      <case>case <expr><name>OPT_INT</name></expr>:</case>
      <case>case <expr><name>OPT_FINT</name></expr>:</case>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">9</literal></expr>;</expr_stmt>       <comment type="block">/* length of "&lt;integer&gt;" */</comment>
        <break>break;</break>
      <case>case <expr><name>OPT_DBL</name></expr>:</case>
      <case>case <expr><name>OPT_FDBL</name></expr>:</case>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>       <comment type="block">/* length of "&lt;real&gt;" */</comment>
        <break>break;</break>
      <case>case <expr><name>OPT_STR</name></expr>:</case>
      <case>case <expr><name>OPT_FSTR</name></expr>:</case>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>       <comment type="block">/* length of "&lt;string&gt;" */</comment>
        <break>break;</break>
    </block_content>}</block></switch>
    <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><name>max</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <switch>switch<condition>( <expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OPT_FLAG</name></expr>:</case>
      <case>case <expr><name>OPT_FFLAG</name></expr>:</case>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>errstream</name></expr></argument>,<argument><expr><literal type="string">"  -%-*s  %s\n"</literal></expr></argument>,<argument><expr><name>max</name></expr></argument>,<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>,<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_INT</name></expr>:</case>
      <case>case <expr><name>OPT_FINT</name></expr>:</case>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>errstream</name></expr></argument>,<argument><expr><literal type="string">"  -%s&lt;integer&gt;%*s  %s\n"</literal></expr></argument>,<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>,
          <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>max</name><operator>-</operator><call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">9</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_DBL</name></expr>:</case>
      <case>case <expr><name>OPT_FDBL</name></expr>:</case>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>errstream</name></expr></argument>,<argument><expr><literal type="string">"  -%s&lt;real&gt;%*s  %s\n"</literal></expr></argument>,<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>,
          <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>max</name><operator>-</operator><call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">6</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OPT_STR</name></expr>:</case>
      <case>case <expr><name>OPT_FSTR</name></expr>:</case>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>errstream</name></expr></argument>,<argument><expr><literal type="string">"  -%s&lt;string&gt;%*s  %s\n"</literal></expr></argument>,<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>,
          <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>max</name><operator>-</operator><call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">8</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>
<comment type="block" format="doxygen">/*********************** From the file "parse.c" ****************************/</comment>
<comment type="block">/*
** Input file parser for the LEMON parser generator.
*/</comment>

<comment type="block">/* The state of the parser */</comment>
<enum>enum <name>e_state</name> <block>{
  <decl><name>INITIALIZE</name></decl>,
  <decl><name>WAITING_FOR_DECL_OR_RULE</name></decl>,
  <decl><name>WAITING_FOR_DECL_KEYWORD</name></decl>,
  <decl><name>WAITING_FOR_DECL_ARG</name></decl>,
  <decl><name>WAITING_FOR_PRECEDENCE_SYMBOL</name></decl>,
  <decl><name>WAITING_FOR_ARROW</name></decl>,
  <decl><name>IN_RHS</name></decl>,
  <decl><name>LHS_ALIAS_1</name></decl>,
  <decl><name>LHS_ALIAS_2</name></decl>,
  <decl><name>LHS_ALIAS_3</name></decl>,
  <decl><name>RHS_ALIAS_1</name></decl>,
  <decl><name>RHS_ALIAS_2</name></decl>,
  <decl><name>PRECEDENCE_MARK_1</name></decl>,
  <decl><name>PRECEDENCE_MARK_2</name></decl>,
  <decl><name>RESYNC_AFTER_RULE_ERROR</name></decl>,
  <decl><name>RESYNC_AFTER_DECL_ERROR</name></decl>,
  <decl><name>WAITING_FOR_DESTRUCTOR_SYMBOL</name></decl>,
  <decl><name>WAITING_FOR_DATATYPE_SYMBOL</name></decl>,
  <decl><name>WAITING_FOR_FALLBACK_ID</name></decl>,
  <decl><name>WAITING_FOR_WILDCARD_ID</name></decl>,
  <decl><name>WAITING_FOR_CLASS_ID</name></decl>,
  <decl><name>WAITING_FOR_CLASS_TOKEN</name></decl>
}</block>;</enum>
<struct>struct <name>pstate</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>       <comment type="block">/* Name of the input file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tokenlineno</name></decl>;</decl_stmt>      <comment type="block">/* Linenumber at which current token starts */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>errorcnt</name></decl>;</decl_stmt>         <comment type="block">/* Number of errors so far */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tokenstart</name></decl>;</decl_stmt>     <comment type="block">/* Text of current token */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>gp</name></decl>;</decl_stmt>     <comment type="block">/* Global state vector */</comment>
  <decl_stmt><decl><type><name><name>enum</name> <name>e_state</name></name></type> <name>state</name></decl>;</decl_stmt>        <comment type="block">/* The state of the parser */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>fallback</name></decl>;</decl_stmt>   <comment type="block">/* The fallback token */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>tkclass</name></decl>;</decl_stmt>    <comment type="block">/* Token class symbol */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>lhs</name></decl>;</decl_stmt>        <comment type="block">/* Left-hand side of current rule */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lhsalias</name></decl>;</decl_stmt>      <comment type="block">/* Alias for the LHS */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nrhs</name></decl>;</decl_stmt>                  <comment type="block">/* Number of right-hand side symbols seen */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name><name>rhs</name><index>[<expr><name>MAXRHS</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* RHS symbols */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>alias</name><index>[<expr><name>MAXRHS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Aliases for each RHS symbol (or NULL) */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>prevrule</name></decl>;</decl_stmt>     <comment type="block">/* Previous rule parsed */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>declkeyword</name></decl>;</decl_stmt>   <comment type="block">/* Keyword of a declaration */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>declargslot</name></decl>;</decl_stmt>        <comment type="block">/* Where the declaration argument should be put */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>insertLineMacro</name></decl>;</decl_stmt>       <comment type="block">/* Add #line before declaration insert */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>decllinenoslot</name></decl>;</decl_stmt>       <comment type="block">/* Where to write declaration line number */</comment>
  <decl_stmt><decl><type><name><name>enum</name> <name>e_assoc</name></name></type> <name>declassoc</name></decl>;</decl_stmt>    <comment type="block">/* Assign this association to decl arguments */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>preccounter</name></decl>;</decl_stmt>           <comment type="block">/* Assign this precedence to decl arguments */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>firstrule</name></decl>;</decl_stmt>    <comment type="block">/* Pointer to first rule in the grammar */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>lastrule</name></decl>;</decl_stmt>     <comment type="block">/* Pointer to the most recently parsed rule */</comment>
}</block>;</struct>

<comment type="block">/* Parse a single token */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parseonetoken</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pstate</name></name> <modifier>*</modifier></type><name>psp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>Strsafe</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* Save the token permanently */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  printf("%s:%d: Token=[%s] state=%d\n",psp-&gt;filename,psp-&gt;tokenlineno,
    x,psp-&gt;state);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <switch>switch<condition>( <expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>INITIALIZE</name></expr>:</case>
      <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>prevrule</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>preccounter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>firstrule</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>lastrule</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>nrule</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <comment type="block">/* Fall thru to next case */</comment>
    <case>case <expr><name>WAITING_FOR_DECL_OR_RULE</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_KEYWORD</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ISLOWER</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>lhs</name></name> <operator>=</operator> <call><name>Symbol_new</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>lhsalias</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_ARROW</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'{'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>psp</name><operator>-&gt;</operator><name>prevrule</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
<argument><expr><literal type="string">"There is no prior rule upon which to attach the code \
fragment which begins on this line."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>psp</name><operator>-&gt;</operator><name>prevrule</name><operator>-&gt;</operator><name>code</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
<argument><expr><literal type="string">"Code fragment beginning on this line is not the first \
to follow the previous rule."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>prevrule</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>prevrule</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>PRECEDENCE_MARK_1</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Token \"%s\" should be either \"%%\" or a nonterminal name."</literal></expr></argument>,
          <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>PRECEDENCE_MARK_1</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ISUPPER</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"The precedence symbol must be a terminal."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>psp</name><operator>-&gt;</operator><name>prevrule</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"There is no prior rule to assign precedence \"[%s]\"."</literal></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>psp</name><operator>-&gt;</operator><name>prevrule</name><operator>-&gt;</operator><name>precsym</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
<argument><expr><literal type="string">"Precedence mark on this line is not the first \
to follow the previous rule."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>prevrule</name><operator>-&gt;</operator><name>precsym</name></name> <operator>=</operator> <call><name>Symbol_new</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>PRECEDENCE_MARK_2</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>PRECEDENCE_MARK_2</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Missing \"]\" on precedence mark."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_OR_RULE</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>WAITING_FOR_ARROW</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'='</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>IN_RHS</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'('</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>LHS_ALIAS_1</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Expected to see a \":\" following the LHS symbol \"%s\"."</literal></expr></argument>,
          <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_RULE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>LHS_ALIAS_1</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><call><name>ISALPHA</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>lhsalias</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>LHS_ALIAS_2</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"\"%s\" is not a valid alias for the LHS \"%s\"\n"</literal></expr></argument>,
          <argument><expr><name>x</name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_RULE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>LHS_ALIAS_2</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">')'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>LHS_ALIAS_3</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Missing \")\" following LHS alias name \"%s\"."</literal></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>lhsalias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_RULE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>LHS_ALIAS_3</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'='</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>IN_RHS</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Missing \"-&gt;\" following: \"%s(%s)\"."</literal></expr></argument>,
           <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>lhsalias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_RULE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>IN_RHS</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>(</operator>struct <name>rule</name> <operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rule</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> 
             <sizeof>sizeof<argument_list>(<argument><expr>struct <name>symbol</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
            <argument><expr><literal type="string">"Can't allocate enough memory for this rule."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>prevrule</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>ruleline</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>rhs</name></name> <operator>=</operator> <operator>(</operator>struct <name>symbol</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>rp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>rhsalias</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>rhsalias</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>alias</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>lhs</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>lhs</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>lhsalias</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>lhsalias</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>precsym</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>nrule</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>nextlhs</name></name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>rule</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>rule</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>psp</name><operator>-&gt;</operator><name>firstrule</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>firstrule</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>lastrule</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>lastrule</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>lastrule</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>prevrule</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_OR_RULE</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ISALPHA</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>&gt;=</operator><name>MAXRHS</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
            <argument><expr><literal type="string">"Too many symbols on RHS of rule beginning at \"%s\"."</literal></expr></argument>,
            <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_RULE_ERROR</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>]</index></name> <operator>=</operator> <call><name>Symbol_new</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>alias</name><index>[<expr><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'|'</literal> <operator>||</operator> <name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>msp</name> <init>= <expr><name><name>psp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>msp</name><operator>-&gt;</operator><name>type</name></name><operator>!=</operator><name>MULTITERMINAL</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>origsp</name> <init>= <expr><name>msp</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>msp</name> <operator>=</operator> <operator>(</operator>struct <name>symbol</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>msp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>msp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>msp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>MULTITERMINAL</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>nsubsym</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>subsym</name></name> <operator>=</operator> <operator>(</operator>struct <name>symbol</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>symbol</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>origsp</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>origsp</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>msp</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>nsubsym</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>subsym</name></name> <operator>=</operator> <operator>(</operator>struct <name>symbol</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>msp</name><operator>-&gt;</operator><name>subsym</name></name></expr></argument>,
          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>symbol</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>msp</name><operator>-&gt;</operator><name>nsubsym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name><name>msp</name><operator>-&gt;</operator><name>nsubsym</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Symbol_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>ISLOWER</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ISLOWER</name><argument_list>(<argument><expr><name><name>msp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
            <argument><expr><literal type="string">"Cannot form a compound containing a non-terminal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'('</literal> <operator>&amp;&amp;</operator> <name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RHS_ALIAS_1</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Illegal character on RHS of rule: \"%s\"."</literal></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_RULE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>RHS_ALIAS_1</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><call><name>ISALPHA</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>alias</name><index>[<expr><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RHS_ALIAS_2</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"\"%s\" is not a valid alias for the RHS symbol \"%s\"\n"</literal></expr></argument>,
          <argument><expr><name>x</name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name><name>psp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_RULE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>RHS_ALIAS_2</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">')'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>IN_RHS</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Missing \")\" following LHS alias name \"%s\"."</literal></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>lhsalias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_RULE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>WAITING_FOR_DECL_KEYWORD</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><call><name>ISALPHA</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declkeyword</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>decllinenoslot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_ARG</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"include"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>include</name></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"code"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>extracode</name></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"token_destructor"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>tokendest</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"default_destructor"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>vardest</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"token_prefix"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>tokenprefix</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"syntax_error"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>error</name></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"parse_accept"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>accept</name></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"parse_failure"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>failure</name></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"stack_overflow"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>overflow</name></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"extra_argument"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>arg</name></name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"token_type"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>tokentype</name></name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"default_type"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>vartype</name></name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"stack_size"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>stacksize</name></name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"start_symbol"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"left"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>preccounter</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declassoc</name></name> <operator>=</operator> <name>LEFT</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_PRECEDENCE_SYMBOL</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"right"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>preccounter</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declassoc</name></name> <operator>=</operator> <name>RIGHT</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_PRECEDENCE_SYMBOL</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"nonassoc"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>preccounter</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declassoc</name></name> <operator>=</operator> <name>NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_PRECEDENCE_SYMBOL</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"destructor"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DESTRUCTOR_SYMBOL</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DATATYPE_SYMBOL</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"fallback"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>fallback</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_FALLBACK_ID</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"wildcard"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_WILDCARD_ID</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="string">"token_class"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_CLASS_ID</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
            <argument><expr><literal type="string">"Unknown declaration keyword: \"%%%s\"."</literal></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_DECL_ERROR</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Illegal declaration keyword: \"%s\"."</literal></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_DECL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>WAITING_FOR_DESTRUCTOR_SYMBOL</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ISALPHA</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Symbol name missing after %%destructor keyword"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_DECL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>Symbol_new</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>destructor</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>decllinenoslot</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>destLineno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_ARG</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>WAITING_FOR_DATATYPE_SYMBOL</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ISALPHA</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Symbol name missing after %%type keyword"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_DECL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>Symbol_find</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name>sp</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>datatype</name></name><operator>)</operator></expr>)</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
            <argument><expr><literal type="string">"Symbol %%type \"%s\" already defined"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_DECL_ERROR</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sp</name></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>Symbol_new</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>datatype</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_ARG</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>WAITING_FOR_PRECEDENCE_SYMBOL</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_OR_RULE</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ISUPPER</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>Symbol_new</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>prec</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
            <argument><expr><literal type="string">"Symbol \"%s\" has already be given a precedence."</literal></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>prec</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>preccounter</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>assoc</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>declassoc</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Can't assign a precedence to \"%s\"."</literal></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>WAITING_FOR_DECL_ARG</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'{'</literal> <operator>||</operator> <name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\"'</literal> <operator>||</operator> <call><name>ISALNUM</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOld</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nOld</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>nLine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nNew</name></decl>, <decl><type ref="prev"/><name>nBack</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>addLineMacro</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>zLine</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name>zNew</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>zNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name><name>zNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'{'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zNew</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>nNew</name> <operator>=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zOld</name> <operator>=</operator> <operator>*</operator><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>zOld</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>nOld</name> <operator>=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name>nOld</name> <operator>+</operator> <name>nNew</name> <operator>+</operator> <literal type="number">20</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>addLineMacro</name> <operator>=</operator> <operator>!</operator><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>nolinenosflag</name></name> <operator>&amp;&amp;</operator> <name><name>psp</name><operator>-&gt;</operator><name>insertLineMacro</name></name> <operator>&amp;&amp;</operator>
                        <operator>(</operator><name><name>psp</name><operator>-&gt;</operator><name>decllinenoslot</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>psp</name><operator>-&gt;</operator><name>decllinenoslot</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>addLineMacro</name></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>z</name><operator>=</operator><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr><operator>,</operator> <expr><name>nBack</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>z</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBack</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><call><name>lemon_sprintf</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><literal type="string">"#line %d "</literal></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>nLine</name> <operator>=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>nLine</name> <operator>+</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nBack</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><operator>*</operator><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <operator>*</operator><name><name>psp</name><operator>-&gt;</operator><name>declargslot</name></name> <operator>+</operator> <name>nOld</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>addLineMacro</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>nOld</name> <operator>&amp;&amp;</operator> <name><name>zBuf</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>nLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zBuf</name> <operator>+=</operator> <name>nLine</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>z</name><operator>=</operator><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr>;</init> <condition><expr><operator>*</operator><name>z</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>*</operator><name>z</name></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zBuf</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>psp</name><operator>-&gt;</operator><name>decllinenoslot</name></name> <operator>&amp;&amp;</operator> <name><name>psp</name><operator>-&gt;</operator><name>decllinenoslot</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>decllinenoslot</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zBuf</name> <operator>+=</operator> <name>nNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>zBuf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_OR_RULE</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Illegal argument to %%%s: %s"</literal></expr></argument>,<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>declkeyword</name></name></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_DECL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>WAITING_FOR_FALLBACK_ID</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_OR_RULE</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>ISUPPER</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"%%fallback argument \"%s\" should be a token"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>Symbol_new</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>psp</name><operator>-&gt;</operator><name>fallback</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>fallback</name></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>fallback</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
            <argument><expr><literal type="string">"More than one fallback assigned to token %s"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>fallback</name></name> <operator>=</operator> <name><name>psp</name><operator>-&gt;</operator><name>fallback</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>has_fallback</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>WAITING_FOR_WILDCARD_ID</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_OR_RULE</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>ISUPPER</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"%%wildcard argument \"%s\" should be a token"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>Symbol_new</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>wildcard</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>gp</name><operator>-&gt;</operator><name>wildcard</name></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
            <argument><expr><literal type="string">"Extra wildcard to token: %s"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>WAITING_FOR_CLASS_ID</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ISLOWER</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"%%token_class must be followed by an identifier: "</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_DECL_ERROR</name></expr>;</expr_stmt>
     </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>Symbol_find</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"Symbol \"%s\" already used"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_DECL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>tkclass</name></name> <operator>=</operator> <call><name>Symbol_new</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>tkclass</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>MULTITERMINAL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_CLASS_TOKEN</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>WAITING_FOR_CLASS_TOKEN</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_OR_RULE</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ISUPPER</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'|'</literal> <operator>||</operator> <name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>ISUPPER</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>msp</name> <init>= <expr><name><name>psp</name><operator>-&gt;</operator><name>tkclass</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>nsubsym</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>subsym</name></name> <operator>=</operator> <operator>(</operator>struct <name>symbol</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>msp</name><operator>-&gt;</operator><name>subsym</name></name></expr></argument>,
          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>symbol</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>msp</name><operator>-&gt;</operator><name>nsubsym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ISUPPER</name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>x</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name><name>msp</name><operator>-&gt;</operator><name>nsubsym</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Symbol_new</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>tokenlineno</name></name></expr></argument>,
          <argument><expr><literal type="string">"%%token_class argument \"%s\" should be a token"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>RESYNC_AFTER_DECL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>RESYNC_AFTER_RULE_ERROR</name></expr>:</case>
<comment type="block">/*      if( x[0]=='.' ) psp-&gt;state = WAITING_FOR_DECL_OR_RULE;
**      break; */</comment>
    <case>case <expr><name>RESYNC_AFTER_DECL_ERROR</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_OR_RULE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'%'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>psp</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITING_FOR_DECL_KEYWORD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Run the preprocessor over the input file text.  The global variables
** azDefine[0] through azDefine[nDefine-1] contains the names of all defined
** macros.  This routine looks for "%ifdef" and "%ifndef" and "%endif" and
** comments them out.  Text in between is also commented out as appropriate.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>preprocess_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>exclude</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>lineno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>start_lineno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'%'</literal> <operator>||</operator> <operator>(</operator><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\n'</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"%endif"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>exclude</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>exclude</name><operator>--</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>exclude</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>start</name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="char">'\n'</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"%ifdef"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator>
          <operator>||</operator> <operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"%ifndef"</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>exclude</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>exclude</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">7</literal></expr>;</init> <condition><expr><call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
        <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>j</name><operator>+</operator><name>n</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>j</name><operator>+</operator><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
        <expr_stmt><expr><name>exclude</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>nDefine</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>azDefine</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>azDefine</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>n</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>exclude</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>exclude</name> <operator>=</operator> <operator>!</operator><name>exclude</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>exclude</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>start</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>start_lineno</name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="char">'\n'</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>exclude</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"unterminated %%ifdef starting on line %d\n"</literal></expr></argument>, <argument><expr><name>start_lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* In spite of its name, this function is really a scanner.  It read
** in the entire input file (all at once) then tokenizes it.  Each
** token is passed to the function "parseonetoken" which builds all
** the appropriate data structures in the global state vector "gp".
*/</comment>
<function><type><name>void</name></type> <name>Parse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>gp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>pstate</name></name></type> <name>ps</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filebuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>filesize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>lineno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextcp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>startline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ps</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>gp</name></name> <operator>=</operator> <name>gp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>filename</name></name> <operator>=</operator> <name><name>gp</name><operator>-&gt;</operator><name>filename</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>errorcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>INITIALIZE</name></expr>;</expr_stmt>

  <comment type="block">/* Begin by reading the input file */</comment>
  <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>filename</name></name></expr></argument>,<argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>fp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>filename</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="string">"Can't open this file for reading."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>filesize</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>filebuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><name>filesize</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>filesize</name><operator>&gt;</operator><literal type="number">100000000</literal> <operator>||</operator> <name>filebuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>filename</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="string">"Input file too large."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fread</name><argument_list>(<argument><expr><name>filebuf</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>filesize</name></expr></argument>,<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>!=</operator><name>filesize</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>filename</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="string">"Can't read in all %d bytes of this file."</literal></expr></argument>,
      <argument><expr><name>filesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>filebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>filebuf</name><index>[<expr><name>filesize</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Make an initial pass through the file to handle %ifdef and %ifndef */</comment>
  <expr_stmt><expr><call><name>preprocess_input</name><argument_list>(<argument><expr><name>filebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now scan the text of the input file */</comment>
  <expr_stmt><expr><name>lineno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>cp</name><operator>=</operator><name>filebuf</name></expr>;</init> <condition><expr><operator>(</operator><name>c</name><operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr/>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>              <comment type="block">/* Keep track of the line number */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>ISSPACE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>  <comment type="block">/* Skip all white space */</comment>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>          <comment type="block">/* Skip C++ style comments */</comment>
      <expr_stmt><expr><name>cp</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>          <comment type="block">/* Skip C style comments */</comment>
      <expr_stmt><expr><name>cp</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>!=</operator><literal type="char">'/'</literal> <operator>||</operator> <name><name>cp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'*'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>tokenstart</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>                <comment type="block">/* Mark the beginning of the token */</comment>
    <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>tokenlineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>           <comment type="block">/* Linenumber on which token begins */</comment>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\"'</literal></expr> )</condition><block>{<block_content>                     <comment type="block">/* String literals */</comment>
      <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\"'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>filename</name></name></expr></argument>,<argument><expr><name>startline</name></expr></argument>,
<argument><expr><literal type="string">"String starting on this line is not terminated before the end of the file."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>nextcp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nextcp</name> <operator>=</operator> <name>cp</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'{'</literal></expr> )</condition><block>{<block_content>               <comment type="block">/* A block of C code */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>level</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name><operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>level</name><operator>&gt;</operator><literal type="number">1</literal> <operator>||</operator> <name>c</name><operator>!=</operator><literal type="char">'}'</literal><operator>)</operator></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'{'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'}'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>  <comment type="block">/* Skip comments */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>prevc</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>&amp;</operator><name><name>cp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>prevc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>!=</operator><literal type="char">'/'</literal> <operator>||</operator> <name>prevc</name><operator>!=</operator><literal type="char">'*'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>prevc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>  <comment type="block">/* Skip C++ style comments too */</comment>
          <expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>&amp;</operator><name><name>cp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
          <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\''</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\"'</literal></expr> )</condition><block>{<block_content>    <comment type="block">/* String a character literals */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>startchar</name></decl>, <decl><type ref="prev"/><name>prevc</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>startchar</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>prevc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>cp</name><operator>++</operator></expr>;</init> <condition><expr><operator>(</operator><name>c</name><operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>!=</operator><name>startchar</name> <operator>||</operator> <name>prevc</name><operator>==</operator><literal type="char">'\\'</literal><operator>)</operator></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>prevc</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prevc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>              <expr_stmt><expr><name>prevc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>ps</name><operator>.</operator><name>tokenlineno</name></name></expr></argument>,
<argument><expr><literal type="string">"C code starting on this line is not terminated before the end of the file."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>nextcp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nextcp</name> <operator>=</operator> <name>cp</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ISALNUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>          <comment type="block">/* Identifiers */</comment>
      <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ISALNUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'_'</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><name>nextcp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'='</literal></expr> )</condition><block>{<block_content> <comment type="block">/* The operator "::=" */</comment>
      <expr_stmt><expr><name>cp</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nextcp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>c</name><operator>==</operator><literal type="char">'/'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'|'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>ISALPHA</name><argument_list>(<argument><expr><name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>cp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ISALNUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'_'</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><name>nextcp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>                          <comment type="block">/* All other (one character) operators */</comment>
      <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>nextcp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cp</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                        <comment type="block">/* Null terminate the token */</comment>
    <expr_stmt><expr><call><name>parseonetoken</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="block">/* Parse the token */</comment>
    <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>                  <comment type="block">/* Restore the buffer */</comment>
    <expr_stmt><expr><name>cp</name> <operator>=</operator> <name>nextcp</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>filebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="block">/* Release the buffer after parsing */</comment>
  <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>rule</name></name> <operator>=</operator> <name><name>ps</name><operator>.</operator><name>firstrule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>errorcnt</name></name> <operator>=</operator> <name><name>ps</name><operator>.</operator><name>errorcnt</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block" format="doxygen">/*************************** From the file "plink.c" *********************/</comment>
<comment type="block">/*
** Routines processing configuration follow-set propagation links
** in the LEMON parser generator.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>plink_freelist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Allocate a new plink */</comment>
<function><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>Plink_new</name><parameter_list>()</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>newlink</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>plink_freelist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>amt</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>plink_freelist</name> <operator>=</operator> <operator>(</operator>struct <name>plink</name> <operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>( <argument><expr><name>amt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>plink</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>plink_freelist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
      <argument><expr><literal type="string">"Unable to allocate memory for a new follow-set propagation link.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>amt</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>plink_freelist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <operator>&amp;</operator><name><name>plink_freelist</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>plink_freelist</name><index>[<expr><name>amt</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>newlink</name> <operator>=</operator> <name>plink_freelist</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>plink_freelist</name> <operator>=</operator> <name><name>plink_freelist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  <return>return <expr><name>newlink</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a plink to a plink list */</comment>
<function><type><name>void</name></type> <name>Plink_add</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>plpp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>newlink</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>newlink</name> <operator>=</operator> <call><name>Plink_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newlink</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>plpp</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>plpp</name> <operator>=</operator> <name>newlink</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newlink</name><operator>-&gt;</operator><name>cfp</name></name> <operator>=</operator> <name>cfp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Transfer every plink on the list "from" to the list "to" */</comment>
<function><type><name>void</name></type> <name>Plink_copy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>nextpl</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>from</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nextpl</name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>to</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>from</name> <operator>=</operator> <name>nextpl</name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Delete every plink on the list */</comment>
<function><type><name>void</name></type> <name>Plink_delete</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>plp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>plink</name></name> <modifier>*</modifier></type><name>nextpl</name></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>plp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nextpl</name> <operator>=</operator> <name><name>plp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>plink_freelist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>plink_freelist</name> <operator>=</operator> <name>plp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>plp</name> <operator>=</operator> <name>nextpl</name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>
<comment type="block" format="doxygen">/*********************** From the file "report.c" **************************/</comment>
<comment type="block">/*
** Procedures for generating reports and tables in the LEMON parser generator.
*/</comment>

<comment type="block">/* Generate a filename with the given suffix.  Space to hold the
** name comes from malloc() and must be freed by the calling
** function.
*/</comment>
<function><type><name>PRIVATE</name> <name>char</name> <modifier>*</modifier></type><name>file_makename</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>name</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Can't allocate space for a filename.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lemon_strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>cp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lemon_strcat</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Open a file with a name based on the name of the input file,
** but with a different (specified) suffix, and return a pointer
** to the stream */</comment>
<function><type><name>PRIVATE</name> <name>FILE</name> <modifier>*</modifier></type><name>file_open</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>outname</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>outname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>outname</name></name> <operator>=</operator> <call><name>file_makename</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>outname</name></name></expr></argument>,<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>fp</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>mode</name><operator>==</operator><literal type="char">'w'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Can't open file \"%s\".\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>outname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>fp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Duplicate the input file without comments and without actions 
** on rules */</comment>
<function><type><name>void</name></type> <name>Reprint</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>maxlen</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>ncolumns</name></decl>, <decl><type ref="prev"/><name>skip</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"// Reprint of input file \"%s\".\n// Symbols:\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>maxlen</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><name>maxlen</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <literal type="number">76</literal><operator>/</operator><operator>(</operator><name>maxlen</name><operator>+</operator><literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>ncolumns</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>skip</name> <operator>=</operator> <operator>(</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name> <operator>+</operator> <name>ncolumns</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name>ncolumns</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>skip</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"//"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>+=</operator><name>skip</name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>index</name></name><operator>==</operator><name>j</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %3d %-*.*s"</literal></expr></argument>,<argument><expr><name>j</name></expr></argument>,<argument><expr><name>maxlen</name></expr></argument>,<argument><expr><name>maxlen</name></expr></argument>,<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*    if( rp-&gt;lhsalias ) printf("(%s)",rp-&gt;lhsalias); */</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" ::="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>MULTITERMINAL</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>sp</name><operator>-&gt;</operator><name>nsubsym</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"|%s"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <comment type="block">/* if( rp-&gt;rhsalias[i] ) printf("(%s)",rp-&gt;rhsalias[i]); */</comment>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>precsym</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%s]"</literal></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>precsym</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* if( rp-&gt;code ) printf("\n    %s",rp-&gt;code); */</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Print a single rule.
*/</comment>
<function><type><name>void</name></type> <name>RulePrint</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"%s ::="</literal></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>iCursor</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">" *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>MULTITERMINAL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>sp</name><operator>-&gt;</operator><name>nsubsym</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"|%s"</literal></expr></argument>,<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Print the rule for a configuration.
*/</comment>
<function><type><name>void</name></type> <name>ConfigPrint</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RulePrint</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>rp</name></name></expr></argument>, <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>dot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* #define TEST */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* Print a set */</comment>
PRIVATE void SetPrint(out,set,lemp)
FILE *out;
char *set;
struct lemon *lemp;
{
  int i;
  char *spacer;
  spacer = "";
  fprintf(out,"%12s[","");
  for(i=0; i&lt;lemp-&gt;nterminal; i++){
    if( SetFind(set,i) ){
      fprintf(out,"%s%s",spacer,lemp-&gt;symbols[i]-&gt;name);
      spacer = " ";
    }
  }
  fprintf(out,"]\n");
}

<comment type="block">/* Print a plink chain */</comment>
PRIVATE void PlinkPrint(out,plp,tag)
FILE *out;
struct plink *plp;
char *tag;
{
  while( plp ){
    fprintf(out,"%12s%s (state %2d) ","",tag,plp-&gt;cfp-&gt;stp-&gt;statenum);
    ConfigPrint(out,plp-&gt;cfp);
    fprintf(out,"\n");
    plp = plp-&gt;next;
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Print an action to the given file descriptor.  Return FALSE if
** nothing was actually printed.
*/</comment>
<function><type><name>int</name></type> <name>PrintAction</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap</name></decl></parameter>,          <comment type="block">/* The action to print */</comment>
  <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>,                   <comment type="block">/* Print the action here */</comment>
  <parameter><decl><type><name>int</name></type> <name>indent</name></decl></parameter>                  <comment type="block">/* Indent by this amount */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SHIFT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name> <init>= <expr><name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>stp</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"%*s shift        %-7d"</literal></expr></argument>,<argument><expr><name>indent</name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>statenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>REDUCE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name> <init>= <expr><name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"%*s reduce       %-7d"</literal></expr></argument>,<argument><expr><name>indent</name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RulePrint</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SHIFTREDUCE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name> <init>= <expr><name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"%*s shift-reduce %-7d"</literal></expr></argument>,<argument><expr><name>indent</name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RulePrint</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>ACCEPT</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"%*s accept"</literal></expr></argument>,<argument><expr><name>indent</name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>ERROR</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"%*s error"</literal></expr></argument>,<argument><expr><name>indent</name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SRCONFLICT</name></expr>:</case>
    <case>case <expr><name>RRCONFLICT</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"%*s reduce       %-7d ** Parsing conflict **"</literal></expr></argument>,
        <argument><expr><name>indent</name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SSCONFLICT</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"%*s shift        %-7d ** Parsing conflict **"</literal></expr></argument>, 
        <argument><expr><name>indent</name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>stp</name><operator>-&gt;</operator><name>statenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SH_RESOLVED</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name>showPrecedenceConflict</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"%*s shift        %-7d -- dropped by precedence"</literal></expr></argument>,
                <argument><expr><name>indent</name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>stp</name><operator>-&gt;</operator><name>statenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>RD_RESOLVED</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name>showPrecedenceConflict</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"%*s reduce %-7d -- dropped by precedence"</literal></expr></argument>,
                <argument><expr><name>indent</name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>NOT_USED</name></expr>:</case>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate the "*.out" log file */</comment>
<function><type><name>void</name></type> <name>ReportOutput</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>file_open</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>,<argument><expr><literal type="string">".out"</literal></expr></argument>,<argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>fp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"State %d:\n"</literal></expr></argument>,<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>statenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>basisflag</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cfp</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>bp</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>                  <expr_stmt><expr><name>cfp</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <while>while<condition>( <expr><name>cfp</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>cfp</name><operator>-&gt;</operator><name>dot</name></name><operator>==</operator><name><name>cfp</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lemon_sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"(%d)"</literal></expr></argument>,<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"    %5s "</literal></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"          "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>ConfigPrint</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
      SetPrint(fp,cfp-&gt;fws,lemp);
      PlinkPrint(fp,cfp-&gt;fplp,"To  ");
      PlinkPrint(fp,cfp-&gt;bplp,"From");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>basisflag</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cfp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>bp</name></name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>                  <expr_stmt><expr><name>cfp</name><operator>=</operator><name><name>cfp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr>;</init> <condition><expr><name>ap</name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>PrintAction</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"----------------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"Symbols:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"  %3d: %s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>NONTERMINAL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>lambda</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" &lt;lambda&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>firstset</name></name> <operator>&amp;&amp;</operator> <call><name>SetFind</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>firstset</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Search for the file "name" which is in the same directory as
** the exacutable */</comment>
<function><type><name>PRIVATE</name> <name>char</name> <modifier>*</modifier></type><name>pathsearch</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>modemask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathlist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pathbufptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pathbuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WIN32__</name></cpp:ifdef>
  <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>,<argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>,<argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>cp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cp</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>path</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lemon_sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,<argument><expr><name>argv0</name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pathlist</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pathlist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pathlist</name> <operator>=</operator> <literal type="string">".:/bin:/usr/bin"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pathbuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>( <argument><expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name>pathlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name>pathlist</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>lemonStrlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pathbuf</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>path</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pathbufptr</name> <operator>=</operator> <name>pathbuf</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lemon_strcpy</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>*</operator><name>pathbuf</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>,<argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>cp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>&amp;</operator><name><name>pathbuf</name><index>[<expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cp</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lemon_sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,<argument><expr><name>pathbuf</name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pathbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>pathbuf</name> <operator>=</operator> <operator>&amp;</operator><name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>,<argument><expr><name>modemask</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pathbufptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Given an action, compute the integer value for that action
** which is to be put in the action table of the generated machine.
** Return negative if no action should be generated.
*/</comment>
<function><type><name>PRIVATE</name> <name>int</name></type> <name>compute_action</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>act</name></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SHIFT</name></expr>:</case>  <expr_stmt><expr><name>act</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>stp</name><operator>-&gt;</operator><name>statenum</name></name></expr>;</expr_stmt>                        <break>break;</break>
    <case>case <expr><name>SHIFTREDUCE</name></expr>:</case> <expr_stmt><expr><name>act</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name> <operator>+</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</expr_stmt>        <break>break;</break>
    <case>case <expr><name>REDUCE</name></expr>:</case> <expr_stmt><expr><name>act</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name> <operator>+</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name><operator>+</operator><name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>ERROR</name></expr>:</case>  <expr_stmt><expr><name>act</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name> <operator>+</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>               <break>break;</break>
    <case>case <expr><name>ACCEPT</name></expr>:</case> <expr_stmt><expr><name>act</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name> <operator>+</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>           <break>break;</break>
    <default>default:</default>     <expr_stmt><expr><name>act</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>act</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LINESIZE</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<comment type="block">/* The next cluster of routines are for reading the template file
** and writing the results to the generated parser */</comment>
<comment type="block">/* The first function transfers data from "in" to "out" until
** a line is seen which begins with "%%".  The line number is
** tracked.
**
** if name!=0, then any word that begin with "Parse" is changed to
** begin with *name instead.
*/</comment>
<function><type><name>PRIVATE</name> <name>void</name></type> <name>tplt_xfer</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lineno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>iStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>LINESIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <while>while<condition>( <expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><name>LINESIZE</name></expr></argument>,<argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'%'</literal> <operator>||</operator> <name><name>line</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'%'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>name</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>line</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>line</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'P'</literal> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>line</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"Parse"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
          <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ISALPHA</name><argument_list>(<argument><expr><name><name>line</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>iStart</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"%.*s"</literal></expr></argument>,<argument><expr><name>i</name><operator>-</operator><name>iStart</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>line</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>line</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* The next function finds the template file and opens it, returning
** a pointer to the opened file. */</comment>
<function><type><name>PRIVATE</name> <name>FILE</name> <modifier>*</modifier></type><name>tplt_open</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>templatename</name><index>[]</index></name> <init>= <expr><literal type="string">"lempar.c"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tpltname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

  <comment type="block">/* first, see if user specified a template filename on the command line. */</comment>
  <if_stmt><if>if <condition>(<expr><name>user_templatename</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>access</name><argument_list>(<argument><expr><name>user_templatename</name></expr></argument>,<argument><expr><literal type="number">004</literal></expr></argument>)</argument_list></call><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Can't find the parser driver template file \"%s\".\n"</literal></expr></argument>,
        <argument><expr><name>user_templatename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>user_templatename</name></expr></argument>,<argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>in</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Can't open the template file \"%s\".\n"</literal></expr></argument>,
              <argument><expr><name>user_templatename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>in</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>cp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lemon_sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%.*s.lt"</literal></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>cp</name><operator>-</operator><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name><operator>)</operator></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>lemon_sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%s.lt"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>access</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">004</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>tpltname</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>access</name><argument_list>(<argument><expr><name>templatename</name></expr></argument>,<argument><expr><literal type="number">004</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>tpltname</name> <operator>=</operator> <name>templatename</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>tpltname</name> <operator>=</operator> <call><name>pathsearch</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>argv0</name></name></expr></argument>,<argument><expr><name>templatename</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>tpltname</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Can't find the parser driver template file \"%s\".\n"</literal></expr></argument>,
    <argument><expr><name>templatename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>tpltname</name></expr></argument>,<argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>in</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Can't open the template file \"%s\".\n"</literal></expr></argument>,<argument><expr><name>templatename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>in</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Print a #line directive line to the output file. */</comment>
<function><type><name>PRIVATE</name> <name>void</name></type> <name>tplt_linedir</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#line %d \""</literal></expr></argument>,<argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>filename</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>filename</name> <operator>==</operator> <literal type="char">'\\'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>,<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>*</operator><name>filename</name></expr></argument>,<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>filename</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Print a string to the file and keep the linenumber up to date */</comment>
<function><type><name>PRIVATE</name> <name>void</name></type> <name>tplt_print</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lineno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>str</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>str</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>,<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>str</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>str</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>,<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lemp</name><operator>-&gt;</operator><name>nolinenosflag</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><call><name>tplt_linedir</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>*</operator><name>lineno</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>outname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  </block_content>}</block></if></if_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following routine emits code for the destructor for the
** symbol sp
*/</comment>
<function><type><name>void</name></type> <name>emit_destructor_code</name><parameter_list>(
  <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lineno</name></decl></parameter>
)</parameter_list><block>{<block_content>
 <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

 <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>TERMINAL</name></expr> )</condition><block>{<block_content>
   <expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>tokendest</name></name></expr>;</expr_stmt>
   <if_stmt><if>if<condition>( <expr><name>cp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
   <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"{\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
 </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>destructor</name></name></expr> )</condition><block>{<block_content>
   <expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>destructor</name></name></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"{\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
   <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>lemp</name><operator>-&gt;</operator><name>nolinenosflag</name></name></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>tplt_linedir</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>destLineno</name></name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
 </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>vardest</name></name></expr> )</condition><block>{<block_content>
   <expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>vardest</name></name></expr>;</expr_stmt>
   <if_stmt><if>if<condition>( <expr><name>cp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
   <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"{\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
 </block_content>}</block></if><else>else<block>{<block_content>
   <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Cannot happen */</comment>
 </block_content>}</block></else></if_stmt>
 <for>for<control>(<init>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
   <if_stmt><if>if<condition>( <expr><operator>*</operator><name>cp</name><operator>==</operator><literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'$'</literal></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"(yypminor-&gt;yy%d)"</literal></expr></argument>,<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>dtnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
     <continue>continue;</continue>
   </block_content>}</block></if></if_stmt>
   <if_stmt><if>if<condition>( <expr><operator>*</operator><name>cp</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
   <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>,<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 </block_content>}</block></for>
 <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
 <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lemp</name><operator>-&gt;</operator><name>nolinenosflag</name></name></expr>)</condition> <block>{<block_content> 
   <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><call><name>tplt_linedir</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>*</operator><name>lineno</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>outname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
 </block_content>}</block></if></if_stmt>
 <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
 <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE (non-zero) if the given symbol has a destructor.
*/</comment>
<function><type><name>int</name></type> <name>has_destructor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>TERMINAL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>tokendest</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>vardest</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>destructor</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append text to a dynamically allocated string.  If zText is 0 then
** reset the string to be empty again.  Always return the complete text
** of the string (which is overwritten with each call).
**
** n bytes of zText are stored.  If n==0 then all of zText up to the first
** \000 terminator is stored.  zText can contain up to two instances of
** %d.  The values of p1 and p2 are written into the first and second
** %d.
**
** If n==-1, then the previous character is overwritten.
*/</comment>
<function><type><name>PRIVATE</name> <name>char</name> <modifier>*</modifier></type><name>append_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>empty</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>alloced</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zInt</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zText</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>used</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>z</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>used</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>used</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name>zText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>n</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zInt</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal><operator>+</operator><name>used</name><operator>)</operator> <operator>&gt;=</operator> <name>alloced</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>alloced</name> <operator>=</operator> <name>n</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>zInt</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <name>used</name> <operator>+</operator> <literal type="number">200</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>z</name></expr></argument>,  <argument><expr><name>alloced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>empty</name></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zText</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'%'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'d'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lemon_sprintf</name><argument_list>(<argument><expr><name>zInt</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lemon_strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>used</name></expr>]</index></name></expr></argument>, <argument><expr><name>zInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>used</name> <operator>+=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>used</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zText</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>used</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>used</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** zCode is a string that is the action associated with a rule.  Expand
** the symbols in this string so that the refer to elements of the parser
** stack.
*/</comment>
<function><type><name>PRIVATE</name> <name>void</name></type> <name>translate_code</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>lhsused</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* True if the LHS element has been used */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>used</name><index>[<expr><name>MAXRHS</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* True for each RHS element which is used */</comment>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>used</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name>lhsused</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>code</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>newlinestr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="char">'\n'</literal></expr>, <expr><literal type="char">'\0'</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>newlinestr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>ruleline</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>append_str</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This const cast is wrong but harmless, if we're careful. */</comment>
  <for>for<control>(<init><expr><name>cp</name><operator>=</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>rp</name><operator>-&gt;</operator><name>code</name></name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>ISALPHA</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>cp</name><operator>==</operator><name><name>rp</name><operator>-&gt;</operator><name>code</name></name> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>ISALNUM</name><argument_list>(<argument><expr><name><name>cp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'_'</literal><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name>saved</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>xp</name><operator>=</operator> <operator>&amp;</operator><name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><call><name>ISALNUM</name><argument_list>(<argument><expr><operator>*</operator><name>xp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>xp</name><operator>==</operator><literal type="char">'_'</literal></expr>;</condition> <incr><expr><name>xp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <expr_stmt><expr><name>saved</name> <operator>=</operator> <operator>*</operator><name>xp</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>xp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>lhsalias</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>lhsalias</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>append_str</name><argument_list>(<argument><expr><literal type="string">"yygotominor.yy%d"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>dtnum</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cp</name> <operator>=</operator> <name>xp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lhsused</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>rhsalias</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>rhsalias</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>cp</name><operator>!=</operator><name><name>rp</name><operator>-&gt;</operator><name>code</name></name> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'@'</literal></expr> )</condition><block>{<block_content>
              <comment type="block">/* If the argument is of the form @X then substituted
              ** the token number of X, not the value of X */</comment>
              <expr_stmt><expr><call><name>append_str</name><argument_list>(<argument><expr><literal type="string">"yymsp[%d].major"</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name><operator>-</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>int</name></type> <name>dtnum</name></decl>;</decl_stmt>
              <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>MULTITERMINAL</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>dtnum</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>dtnum</name></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <expr_stmt><expr><name>dtnum</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>dtnum</name></name></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
              <expr_stmt><expr><call><name>append_str</name><argument_list>(<argument><expr><literal type="string">"yymsp[%d].minor.yy%d"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>i</name><operator>-</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>dtnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>cp</name> <operator>=</operator> <name>xp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>used</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>xp</name> <operator>=</operator> <name>saved</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>append_str</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for> <comment type="block">/* End loop */</comment>

  <comment type="block">/* Check to make sure the LHS has been used */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>lhsalias</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>lhsused</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ruleline</name></name></expr></argument>,
      <argument><expr><literal type="string">"Label \"%s\" for \"%s(%s)\" is never used."</literal></expr></argument>,
        <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>lhsalias</name></name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>lhsalias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Generate destructor code for RHS symbols which are not used in the
  ** reduce code */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>rhsalias</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>used</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ErrorMsg</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ruleline</name></name></expr></argument>,
        <argument><expr><literal type="string">"Label %s for \"%s(%s)\" is never used."</literal></expr></argument>,
        <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>rhsalias</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>rhsalias</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>errorcnt</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>rhsalias</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>has_destructor</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>append_str</name><argument_list>(<argument><expr><literal type="string">"  yy_destructor(yypParser,%d,&amp;yymsp[%d].minor);\n"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
           <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr></argument>,<argument><expr><name>i</name><operator>-</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* No destructor defined for this term */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>code</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>append_str</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <call><name>Strsafe</name><argument_list>(<argument><expr><ternary><condition><expr><name>cp</name></expr>?</condition><then><expr><name>cp</name></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Generate code which executes when the rule "rp" is reduced.  Write
** the code to "out".  Make sure lineno stays up-to-date.
*/</comment>
<function><type><name>PRIVATE</name> <name>void</name></type> <name>emit_code</name><parameter_list>(
  <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lineno</name></decl></parameter>
)</parameter_list><block>{<block_content>
 <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

 <comment type="block">/* Generate code to do the reduce action */</comment>
 <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>code</name></name></expr> )</condition><block>{<block_content>
   <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>lemp</name><operator>-&gt;</operator><name>nolinenosflag</name></name></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>tplt_linedir</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>line</name></name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
   <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"{%s"</literal></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for<control>(<init><expr><name>cp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>code</name></name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
     <if_stmt><if>if<condition>( <expr><operator>*</operator><name>cp</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
   </block_content>}</block></for> <comment type="block">/* End loop */</comment>
   <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
   <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>lemp</name><operator>-&gt;</operator><name>nolinenosflag</name></name></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>tplt_linedir</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>*</operator><name>lineno</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>outname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
 </block_content>}</block></if></if_stmt> <comment type="block">/* End if( rp-&gt;code ) */</comment>

 <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Print the definition of the union used for the parser's data stack.
** This union contains fields for every possible data type for tokens
** and nonterminals.  In the process of computing and printing this
** union, also set the ".dtnum" field of every terminal and nonterminal
** symbol.
*/</comment>
<function><type><name>void</name></type> <name>print_stack_union</name><parameter_list>(
  <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>,                  <comment type="block">/* The output stream */</comment>
  <parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>,         <comment type="block">/* The main info structure for this parser */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>plineno</name></decl></parameter>,               <comment type="block">/* Pointer to the line number */</comment>
  <parameter><decl><type><name>int</name></type> <name>mhflag</name></decl></parameter>                  <comment type="block">/* True if generating makeheaders output */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>lineno</name> <init>= <expr><operator>*</operator><name>plineno</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* The line number of the output */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>             <comment type="block">/* A hash table of datatypes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>arraysize</name></decl>;</decl_stmt>            <comment type="block">/* Size of the "types" array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>maxdtlength</name></decl>;</decl_stmt>          <comment type="block">/* Maximum length of any ".datatype" field. */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>stddt</name></decl>;</decl_stmt>              <comment type="block">/* Standardized name for a datatype */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                  <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>hash</name></decl>;</decl_stmt>            <comment type="block">/* For hashing the name of a type */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>         <comment type="block">/* Name of the parser */</comment>

  <comment type="block">/* Allocate and initialize types[] and allocate stddt[] */</comment>
  <expr_stmt><expr><name>arraysize</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>types</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>( <argument><expr><name>arraysize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>types</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Out of memory.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>arraysize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name>maxdtlength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>vartype</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>maxdtlength</name> <operator>=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>datatype</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><name>maxdtlength</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxdtlength</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>stddt</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><name>maxdtlength</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>stddt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Out of memory.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Build a hash table of datatypes. The ".dtnum" field of each symbol
  ** is filled in with the hash index plus 1.  A ".dtnum" value of 0 is
  ** used for terminal symbols.  If there is no %default_type defined then
  ** 0 is also used as the .dtnum value for nonterminals which do not specify
  ** a datatype using the %type directive.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>sp</name><operator>==</operator><name><name>lemp</name><operator>-&gt;</operator><name>errsym</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>dtnum</name></name> <operator>=</operator> <name>arraysize</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>!=</operator><name>NONTERMINAL</name> <operator>||</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>datatype</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>lemp</name><operator>-&gt;</operator><name>vartype</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>dtnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>datatype</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>cp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><call><name>ISSPACE</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <while>while<condition>( <expr><operator>*</operator><name>cp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>stddt</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <while>while<condition>( <expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>stddt</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name><name>stddt</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>tokentype</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>stddt</name></expr></argument>, <argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>tokentype</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>dtnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>hash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>stddt</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>hash</name> <operator>=</operator> <name>hash</name><operator>*</operator><literal type="number">53</literal> <operator>+</operator> <name><name>stddt</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>hash</name> <operator>=</operator> <operator>(</operator><name>hash</name> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal><operator>)</operator><operator>%</operator><name>arraysize</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>types</name><index>[<expr><name>hash</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>types</name><index>[<expr><name>hash</name></expr>]</index></name></expr></argument>,<argument><expr><name>stddt</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>dtnum</name></name> <operator>=</operator> <name>hash</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>hash</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>hash</name><operator>&gt;=</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>arraysize</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name><name>types</name><index>[<expr><name>hash</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>dtnum</name></name> <operator>=</operator> <name>hash</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>types</name><index>[<expr><name>hash</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name>stddt</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>types</name><index>[<expr><name>hash</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Out of memory.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>lemon_strcpy</name><argument_list>(<argument><expr><name><name>types</name><index>[<expr><name>hash</name></expr>]</index></name></expr></argument>,<argument><expr><name>stddt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Print out the definition of YYTOKENTYPE and YYMINORTYPE */</comment>
  <expr_stmt><expr><name>name</name> <operator>=</operator> <ternary><condition><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"Parse"</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>lineno</name> <operator>=</operator> <operator>*</operator><name>plineno</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>mhflag</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#if INTERFACE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %sTOKENTYPE %s\n"</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>,
    <argument><expr><ternary><condition><expr><name><name>lemp</name><operator>-&gt;</operator><name>tokentype</name></name></expr>?</condition><then><expr><name><name>lemp</name><operator>-&gt;</operator><name>tokentype</name></name></expr></then><else>:<expr><literal type="string">"void*"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>mhflag</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"typedef union {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"  int yyinit;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"  %sTOKENTYPE yy0;\n"</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>arraysize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"  %s yy%d;\n"</literal></expr></argument>,<argument><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>errsym</name><operator>-&gt;</operator><name>useCnt</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"  int yy%d;\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>errsym</name><operator>-&gt;</operator><name>dtnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>stddt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"} YYMINORTYPE;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>plineno</name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the name of a C datatype able to represent values between
** lwr and upr, inclusive.  If pnByte!=NULL then also write the sizeof
** for that type (1, 2, or 4) into *pnByte.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>minimum_size_type</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lwr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>upr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name> <init>= <expr><literal type="string">"int"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>lwr</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>upr</name><operator>&lt;=</operator><literal type="number">255</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"unsigned char"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>upr</name><operator>&lt;</operator><literal type="number">65535</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"unsigned short int"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"unsigned int"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>lwr</name><operator>&gt;=</operator><operator>-</operator><literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>upr</name><operator>&lt;=</operator><literal type="number">127</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"signed char"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>lwr</name><operator>&gt;=</operator><operator>-</operator><literal type="number">32767</literal> <operator>&amp;&amp;</operator> <name>upr</name><operator>&lt;</operator><literal type="number">32767</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"short"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnByte</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnByte</name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>zType</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Each state contains a set of token transaction and a set of
** nonterminal transactions.  Each of these sets makes an instance
** of the following structure.  An array of these structures is used
** to order the creation of entries in the yy_action[] table.
*/</comment>
<struct>struct <name>axset</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>   <comment type="block">/* A pointer to a state */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isTkn</name></decl>;</decl_stmt>           <comment type="block">/* True to use tokens.  False for non-terminals */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAction</name></decl>;</decl_stmt>         <comment type="block">/* Number of actions */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOrder</name></decl>;</decl_stmt>          <comment type="block">/* Original order of action sets */</comment>
}</block>;</struct>

<comment type="block">/*
** Compare to axset structures for sorting purposes
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>axset_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>axset</name></name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>(</operator>struct <name>axset</name><operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>axset</name></name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>(</operator>struct <name>axset</name><operator>*</operator><operator>)</operator><name>b</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>nAction</name></name> <operator>-</operator> <name><name>p1</name><operator>-&gt;</operator><name>nAction</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>iOrder</name></name> <operator>-</operator> <name><name>p2</name><operator>-&gt;</operator><name>iOrder</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>c</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>p1</name><operator>==</operator><name>p2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write text on "out" that describes the rule "rp".
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>writeRuleText</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"%s ::="</literal></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>rhs</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>!=</operator><name>MULTITERMINAL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>sp</name><operator>-&gt;</operator><name>nsubsym</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"|%s"</literal></expr></argument>,<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>subsym</name><index>[<expr><name>k</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/* Generate C source code for the parser */</comment>
<function><type><name>void</name></type> <name>ReportTable</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>mhflag</name></decl></parameter>     <comment type="block">/* Output in makeheaders format if true */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>LINESIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>  <name>lineno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>acttab</name></name> <modifier>*</modifier></type><name>pActtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>szActionType</name></decl>;</decl_stmt>     <comment type="block">/* sizeof(YYACTIONTYPE) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szCodeType</name></decl>;</decl_stmt>       <comment type="block">/* sizeof(YYCODETYPE)   */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mnTknOfst</name></decl>, <decl><type ref="prev"/><name>mxTknOfst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mnNtOfst</name></decl>, <decl><type ref="prev"/><name>mxNtOfst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>axset</name></name> <modifier>*</modifier></type><name>ax</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>tplt_open</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>in</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>file_open</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>,<argument><expr><literal type="string">".c"</literal></expr></argument>,<argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>out</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>lineno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate the include code, if any */</comment>
  <expr_stmt><expr><call><name>tplt_print</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>include</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>mhflag</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>incName</name> <init>= <expr><call><name>file_makename</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>, <argument><expr><literal type="string">".h"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#include \"%s\"\n"</literal></expr></argument>, <argument><expr><name>incName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>incName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate #defines for all tokens */</comment>
  <if_stmt><if>if<condition>( <expr><name>mhflag</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#if INTERFACE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>tokenprefix</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prefix</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>tokenprefix</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>                    <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %s%-30s %2d\n"</literal></expr></argument>,<argument><expr><name>prefix</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate the defines */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYCODETYPE %s\n"</literal></expr></argument>,
    <argument><expr><call><name>minimum_size_type</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>szCodeType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYNOCODE %d\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYACTIONTYPE %s\n"</literal></expr></argument>,
    <argument><expr><call><name>minimum_size_type</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name><operator>+</operator><name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">5</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>szActionType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>wildcard</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYWILDCARD %d\n"</literal></expr></argument>,
       <argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>wildcard</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>print_stack_union</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>,<argument><expr><name>mhflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"#ifndef YYSTACKDEPTH\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>stacksize</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYSTACKDEPTH %s\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>stacksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYSTACKDEPTH 100\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>mhflag</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#if INTERFACE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>name</name> <operator>=</operator> <ternary><condition><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"Parse"</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <name><name>lemp</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>lemonStrlen</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>ISSPACE</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <while>while<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ISALNUM</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>lemp</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'_'</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %sARG_SDECL %s;\n"</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %sARG_PDECL ,%s\n"</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %sARG_FETCH %s = yypParser-&gt;%s\n"</literal></expr></argument>,
                 <argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>lemp</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %sARG_STORE yypParser-&gt;%s = %s\n"</literal></expr></argument>,
                 <argument><expr><name>name</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>lemp</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>lemp</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %sARG_SDECL\n"</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %sARG_PDECL\n"</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %sARG_FETCH\n"</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %sARG_STORE\n"</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>mhflag</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>errsym</name><operator>-&gt;</operator><name>useCnt</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYERRORSYMBOL %d\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>errsym</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYERRSYMDT yy%d\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>errsym</name><operator>-&gt;</operator><name>dtnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>has_fallback</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYFALLBACK 1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compute the action table, but do not output it yet.  The action
  ** table must be computed before generating the YYNSTATE macro because
  ** we need to know how many states can be eliminated.
  */</comment>
  <expr_stmt><expr><name>ax</name> <operator>=</operator> <operator>(</operator>struct <name>axset</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ax</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>ax</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"malloc failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ax</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>stp</name> <operator>=</operator> <name>stp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ax</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isTkn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ax</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>nAction</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>nTknAct</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ax</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>stp</name> <operator>=</operator> <name>stp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ax</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isTkn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ax</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nAction</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>nNtAct</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>mxTknOfst</name> <operator>=</operator> <name>mnTknOfst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxNtOfst</name> <operator>=</operator> <name>mnNtOfst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* In an effort to minimize the action table size, use the heuristic
  ** of placing the largest action sets first */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name><operator>*</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iOrder</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>ax</name></expr></argument>, <argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ax</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>axset_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pActtab</name> <operator>=</operator> <call><name>acttab_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name><operator>*</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>ax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nAction</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>ax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>stp</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>ax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isTkn</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr>;</init> <condition><expr><name>ap</name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>action</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>index</name></name><operator>&gt;=</operator><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>compute_action</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>action</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>acttab_action</name><argument_list>(<argument><expr><name>pActtab</name></expr></argument>, <argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>iTknOfst</name></name> <operator>=</operator> <call><name>acttab_insert</name><argument_list>(<argument><expr><name>pActtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>stp</name><operator>-&gt;</operator><name>iTknOfst</name></name><operator>&lt;</operator><name>mnTknOfst</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mnTknOfst</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>iTknOfst</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>stp</name><operator>-&gt;</operator><name>iTknOfst</name></name><operator>&gt;</operator><name>mxTknOfst</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mxTknOfst</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>iTknOfst</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr>;</init> <condition><expr><name>ap</name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>action</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>index</name></name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>index</name></name><operator>==</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>compute_action</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>action</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>acttab_action</name><argument_list>(<argument><expr><name>pActtab</name></expr></argument>, <argument><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>iNtOfst</name></name> <operator>=</operator> <call><name>acttab_insert</name><argument_list>(<argument><expr><name>pActtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>stp</name><operator>-&gt;</operator><name>iNtOfst</name></name><operator>&lt;</operator><name>mnNtOfst</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mnNtOfst</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>iNtOfst</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>stp</name><operator>-&gt;</operator><name>iNtOfst</name></name><operator>&gt;</operator><name>mxNtOfst</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mxNtOfst</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>iNtOfst</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>  <comment type="block">/* Uncomment for a trace of how the yy_action[] table fills out */</comment>
    { int jj, nn;
      for(jj=nn=0; jj&lt;pActtab-&gt;nAction; jj++){
        if( pActtab-&gt;aAction[jj].action&lt;0 ) nn++;
      }
      printf("%4d: State %3d %s n: %2d size: %5d freespace: %d\n",
             i, stp-&gt;statenum, ax[i].isTkn ? "Token" : "Var  ",
             ax[i].nAction, pActtab-&gt;nAction, nn);
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Finish rendering the constants now that the action table has
  ** been computed */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYNSTATE             %d\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YYNRULE              %d\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YY_MAX_SHIFT         %d\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YY_MIN_SHIFTREDUCE   %d\n"</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name> <operator>+</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YY_MAX_SHIFTREDUCE   %d\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YY_MIN_REDUCE        %d\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name> <operator>+</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YY_MAX_REDUCE        %d\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YY_ERROR_ACTION      %d\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YY_ACCEPT_ACTION     %d\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YY_NO_ACTION         %d\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now output the action table and its associates:
  **
  **  yy_action[]        A single table containing all actions.
  **  yy_lookahead[]     A table containing the lookahead for each entry in
  **                     yy_action.  Used to detect hash collisions.
  **  yy_shift_ofst[]    For each state, the offset into yy_action for
  **                     shifting terminals.
  **  yy_reduce_ofst[]   For each state, the offset into yy_action for
  **                     shifting non-terminals after a reduce.
  **  yy_default[]       Default action for each state.
  */</comment>

  <comment type="block">/* Output the yy_action table */</comment>
  <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>nactiontab</name></name> <operator>=</operator> <name>n</name> <operator>=</operator> <call><name>acttab_size</name><argument_list>(<argument><expr><name>pActtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>tablesize</name></name> <operator>+=</operator> <name>n</name><operator>*</operator><name>szActionType</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define YY_ACTTAB_COUNT (%d)\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"static const YYACTIONTYPE yy_action[] = {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>action</name> <init>= <expr><call><name>acttab_yyaction</name><argument_list>(<argument><expr><name>pActtab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>action</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>action</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name> <operator>+</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">" /* %5d */ "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %4d,"</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">9</literal> <operator>||</operator> <name>i</name><operator>==</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"};\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>

  <comment type="block">/* Output the yy_lookahead table */</comment>
  <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>tablesize</name></name> <operator>+=</operator> <name>n</name><operator>*</operator><name>szCodeType</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"static const YYCODETYPE yy_lookahead[] = {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>la</name> <init>= <expr><call><name>acttab_yylookahead</name><argument_list>(<argument><expr><name>pActtab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>la</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>la</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">" /* %5d */ "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %4d,"</literal></expr></argument>, <argument><expr><name>la</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">9</literal> <operator>||</operator> <name>i</name><operator>==</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"};\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>

  <comment type="block">/* Output the yy_shift_ofst[] table */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"#define YY_SHIFT_USE_DFLT (%d)\n"</literal></expr></argument>, <argument><expr><name>mnTknOfst</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>iTknOfst</name><operator>==</operator><name>NO_OFFSET</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"#define YY_SHIFT_COUNT (%d)\n"</literal></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"#define YY_SHIFT_MIN   (%d)\n"</literal></expr></argument>, <argument><expr><name>mnTknOfst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"#define YY_SHIFT_MAX   (%d)\n"</literal></expr></argument>, <argument><expr><name>mxTknOfst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"static const %s yy_shift_ofst[] = {\n"</literal></expr></argument>, 
          <argument><expr><call><name>minimum_size_type</name><argument_list>(<argument><expr><name>mnTknOfst</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>mxTknOfst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>tablesize</name></name> <operator>+=</operator> <name>n</name><operator>*</operator><name>sz</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ofst</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ofst</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>iTknOfst</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>ofst</name><operator>==</operator><name>NO_OFFSET</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ofst</name> <operator>=</operator> <name>mnTknOfst</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">" /* %5d */ "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %4d,"</literal></expr></argument>, <argument><expr><name>ofst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">9</literal> <operator>||</operator> <name>i</name><operator>==</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"};\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>

  <comment type="block">/* Output the yy_reduce_ofst[] table */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"#define YY_REDUCE_USE_DFLT (%d)\n"</literal></expr></argument>, <argument><expr><name>mnNtOfst</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>iNtOfst</name><operator>==</operator><name>NO_OFFSET</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"#define YY_REDUCE_COUNT (%d)\n"</literal></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"#define YY_REDUCE_MIN   (%d)\n"</literal></expr></argument>, <argument><expr><name>mnNtOfst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"#define YY_REDUCE_MAX   (%d)\n"</literal></expr></argument>, <argument><expr><name>mxNtOfst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"static const %s yy_reduce_ofst[] = {\n"</literal></expr></argument>, 
          <argument><expr><call><name>minimum_size_type</name><argument_list>(<argument><expr><name>mnNtOfst</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>mxNtOfst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>tablesize</name></name> <operator>+=</operator> <name>n</name><operator>*</operator><name>sz</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ofst</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ofst</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>iNtOfst</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>ofst</name><operator>==</operator><name>NO_OFFSET</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ofst</name> <operator>=</operator> <name>mnNtOfst</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">" /* %5d */ "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %4d,"</literal></expr></argument>, <argument><expr><name>ofst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">9</literal> <operator>||</operator> <name>i</name><operator>==</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"};\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>

  <comment type="block">/* Output the default action table */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"static const YYACTIONTYPE yy_default[] = {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>tablesize</name></name> <operator>+=</operator> <name>n</name><operator>*</operator><name>szActionType</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">" /* %5d */ "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %4d,"</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>iDfltReduce</name></name><operator>+</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name><operator>+</operator><name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">9</literal> <operator>||</operator> <name>i</name><operator>==</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"};\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate the table of fallback tokens.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>has_fallback</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>mx</name> <init>= <expr><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>mx</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>mx</name></expr>]</index></name><operator>-&gt;</operator><name>fallback</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>mx</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
    <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>tablesize</name></name> <operator>+=</operator> <operator>(</operator><name>mx</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>szCodeType</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>mx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>fallback</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"    0,  /* %10s =&gt; nothing */\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"  %3d,  /* %10s =&gt; %s */\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>fallback</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>fallback</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate a table containing the symbolic name of every symbol
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>lemon_sprintf</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><literal type="string">"\"%s\","</literal></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"  %-15s"</literal></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate a table containing a text string that describes every
  ** rule in the rule set of the grammar.  This information is used
  ** when tracing REDUCE actions.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>index</name></name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">" /* %3d */ \""</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>writeRuleText</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\",\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate code which executes every time a symbol is popped from
  ** the stack while processing errors or while destroying the parser. 
  ** (In other words, generate the %destructor actions)
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>tokendest</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>once</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>sp</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>!=</operator><name>TERMINAL</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>once</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"      /* TERMINAL Destructor */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>once</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"    case %d: /* %s */\n"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name> <operator>&amp;&amp;</operator> <name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>type</name><operator>!=</operator><name>TERMINAL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>emit_destructor_code</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"      break;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>vardest</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>dflt_sp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>once</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>sp</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>TERMINAL</name> <operator>||</operator>
          <name><name>sp</name><operator>-&gt;</operator><name>index</name></name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>destructor</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>once</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"      /* Default NON-TERMINAL Destructor */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>once</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"    case %d: /* %s */\n"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>dflt_sp</name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>dflt_sp</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>emit_destructor_code</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>dflt_sp</name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"      break;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>sp</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>TERMINAL</name> <operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>destructor</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"    case %d: /* %s */\n"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Combine duplicate destructors into a single case */</comment>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp2</name> <init>= <expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>sp2</name> <operator>&amp;&amp;</operator> <name><name>sp2</name><operator>-&gt;</operator><name>type</name></name><operator>!=</operator><name>TERMINAL</name> <operator>&amp;&amp;</operator> <name><name>sp2</name><operator>-&gt;</operator><name>destructor</name></name>
          <operator>&amp;&amp;</operator> <name><name>sp2</name><operator>-&gt;</operator><name>dtnum</name></name><operator>==</operator><name><name>sp</name><operator>-&gt;</operator><name>dtnum</name></name>
          <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>destructor</name></name></expr></argument>,<argument><expr><name><name>sp2</name><operator>-&gt;</operator><name>destructor</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
         <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"    case %d: /* %s */\n"</literal></expr></argument>,
                 <argument><expr><name><name>sp2</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>sp2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
         <expr_stmt><expr><name><name>sp2</name><operator>-&gt;</operator><name>destructor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>emit_destructor_code</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"      break;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate code which executes whenever the parser stack overflows */</comment>
  <expr_stmt><expr><call><name>tplt_print</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>overflow</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate the table of rule information 
  **
  ** Note: This code depends on the fact that rules are number
  ** sequentually beginning with 0.
  */</comment>
  <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"  { %d, %d },\n"</literal></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>lhs</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>nrhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate code which execution during each REDUCE action */</comment>
  <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>translate_code</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <comment type="block">/* First output rules other than the default: rule */</comment>
  <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp2</name></decl>;</decl_stmt>               <comment type="block">/* Other rules with the same action */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>code</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* Will be default: */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"      case %d: /* "</literal></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>writeRuleText</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>rp2</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>rp2</name></expr>;</condition> <incr><expr><name>rp2</name><operator>=</operator><name><name>rp2</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>rp2</name><operator>-&gt;</operator><name>code</name></name><operator>==</operator><name><name>rp</name><operator>-&gt;</operator><name>code</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"      case %d: /* "</literal></expr></argument>, <argument><expr><name><name>rp2</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>writeRuleText</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>rp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">" */ yytestcase(yyruleno==%d);\n"</literal></expr></argument>, <argument><expr><name><name>rp2</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rp2</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>emit_code</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>rp</name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"        break;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <comment type="block">/* Finally, output the default: rule.  We choose as the default: all
  ** empty actions. */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"      default:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>rp</name><operator>=</operator><name><name>lemp</name><operator>-&gt;</operator><name>rule</name></name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>=</operator><name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>code</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"      /* (%d) "</literal></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>writeRuleText</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" */ yytestcase(yyruleno==%d);\n"</literal></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"        break;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate code which executes if a parse fails */</comment>
  <expr_stmt><expr><call><name>tplt_print</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>failure</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate code which executes when a syntax error occurs */</comment>
  <expr_stmt><expr><call><name>tplt_print</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>error</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate code which executes when the parser accepts its input */</comment>
  <expr_stmt><expr><call><name>tplt_print</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>accept</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tplt_xfer</name><argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><name>in</name></expr></argument>,<argument><expr><name>out</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Append any addition code the user desires */</comment>
  <expr_stmt><expr><call><name>tplt_print</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>lemp</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>extracode</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Generate a header file for the parser */</comment>
<function><type><name>void</name></type> <name>ReportHeader</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>LINESIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>pattern</name><index>[<expr><name>LINESIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>tokenprefix</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prefix</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>tokenprefix</name></name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>                    <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>file_open</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>,<argument><expr><literal type="string">".h"</literal></expr></argument>,<argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>in</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nextChar</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name> <operator>&amp;&amp;</operator> <call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><name>LINESIZE</name></expr></argument>,<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>lemon_sprintf</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>,<argument><expr><literal type="string">"#define %s%-30s %3d\n"</literal></expr></argument>,
                    <argument><expr><name>prefix</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>,<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>nextChar</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name> <operator>&amp;&amp;</operator> <name>nextChar</name><operator>==</operator><name>EOF</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* No change in the file.  Don't rewrite it. */</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>file_open</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>,<argument><expr><literal type="string">".h"</literal></expr></argument>,<argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>out</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"#define %s%-30s %3d\n"</literal></expr></argument>,<argument><expr><name>prefix</name></expr></argument>,<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
  </block_content>}</block></if></if_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Reduce the size of the action tables, if possible, by making use
** of defaults.
**
** In this version, we take the most frequent REDUCE action and make
** it the default.  Except, there is no default if the wildcard token
** is a possible look-ahead.
*/</comment>
<function><type><name>void</name></type> <name>CompressTables</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ap2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rp2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rbest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nbest</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>usesWildcard</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rbest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>usesWildcard</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr>;</init> <condition><expr><name>ap</name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SHIFT</name> <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>sp</name></name><operator>==</operator><name><name>lemp</name><operator>-&gt;</operator><name>wildcard</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>usesWildcard</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name><operator>!=</operator><name>REDUCE</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>rp</name><operator>-&gt;</operator><name>lhsStart</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rp</name><operator>==</operator><name>rbest</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>ap2</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>ap2</name></expr>;</condition> <incr><expr><name>ap2</name><operator>=</operator><name><name>ap2</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>ap2</name><operator>-&gt;</operator><name>type</name></name><operator>!=</operator><name>REDUCE</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rp2</name> <operator>=</operator> <name><name>ap2</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rp2</name><operator>==</operator><name>rbest</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rp2</name><operator>==</operator><name>rp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name>nbest</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nbest</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rbest</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
 
    <comment type="block">/* Do not make a default if the number of rules to default
    ** is not at least 1 or if the wildcard token is a possible
    ** lookahead.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>nbest</name><operator>&lt;</operator><literal type="number">1</literal> <operator>||</operator> <name>usesWildcard</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>


    <comment type="block">/* Combine matching REDUCE actions into a single default */</comment>
    <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr>;</init> <condition><expr><name>ap</name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>REDUCE</name> <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name></name><operator>==</operator><name>rbest</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>ap</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <call><name>Symbol_new</name><argument_list>(<argument><expr><literal type="string">"{default}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>ap</name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>REDUCE</name> <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name></name><operator>==</operator><name>rbest</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NOT_USED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name> <operator>=</operator> <call><name>Action_sort</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr>;</init> <condition><expr><name>ap</name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>SHIFT</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>REDUCE</name> <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name></name><operator>!=</operator><name>rbest</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>ap</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>autoReduce</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>pDfltReduce</name></name> <operator>=</operator> <name>rbest</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Make a second pass over all states and actions.  Convert
  ** every action that is a SHIFT to an autoReduce state into
  ** a SHIFTREDUCE action.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr>;</init> <condition><expr><name>ap</name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>pNextState</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name><operator>!=</operator><name>SHIFT</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pNextState</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>stp</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNextState</name><operator>-&gt;</operator><name>autoReduce</name></name> <operator>&amp;&amp;</operator> <name><name>pNextState</name><operator>-&gt;</operator><name>pDfltReduce</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SHIFTREDUCE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name></name> <operator>=</operator> <name><name>pNextState</name><operator>-&gt;</operator><name>pDfltReduce</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** Compare two states for sorting purposes.  The smaller state is the
** one with the most non-terminal actions.  If they have the same number
** of non-terminal actions, then the smaller is the one with the most
** token actions.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>stateResortCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> struct <name>state</name><operator>*</operator><operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>pB</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> struct <name>state</name><operator>*</operator><operator>*</operator><operator>)</operator><name>b</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>nNtAct</name></name> <operator>-</operator> <name><name>pA</name><operator>-&gt;</operator><name>nNtAct</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>nTknAct</name></name> <operator>-</operator> <name><name>pA</name><operator>-&gt;</operator><name>nTknAct</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>statenum</name></name> <operator>-</operator> <name><name>pA</name><operator>-&gt;</operator><name>statenum</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Renumber and resort states so that states with fewer choices
** occur at the end.  Except, keep state 0 as the first state.
*/</comment>
<function><type><name>void</name></type> <name>ResortStates</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lemon</name></name> <modifier>*</modifier></type><name>lemp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>stp</name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>nTknAct</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>nNtAct</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>iDfltReduce</name></name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name></expr>;</expr_stmt>  <comment type="block">/* Init dflt action to "syntax error" */</comment>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>iTknOfst</name></name> <operator>=</operator> <name>NO_OFFSET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>iNtOfst</name></name> <operator>=</operator> <name>NO_OFFSET</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ap</name><operator>=</operator><name><name>stp</name><operator>-&gt;</operator><name>ap</name></name></expr>;</init> <condition><expr><name>ap</name></expr>;</condition> <incr><expr><name>ap</name><operator>=</operator><name><name>ap</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iAction</name> <init>= <expr><call><name>compute_action</name><argument_list>(<argument><expr><name>lemp</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iAction</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>index</name></name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nterminal</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>nTknAct</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>ap</name><operator>-&gt;</operator><name>sp</name><operator>-&gt;</operator><name>index</name></name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nsymbol</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>nNtAct</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>autoReduce</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>stp</name><operator>-&gt;</operator><name>pDfltReduce</name></name><operator>==</operator><name><name>ap</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>rp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>iDfltReduce</name></name> <operator>=</operator> <name>iAction</name> <operator>-</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name> <operator>-</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nrule</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
        <argument><expr><name>stateResortCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>statenum</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name> <operator>=</operator> <name><name>lemp</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>lemp</name><operator>-&gt;</operator><name>sorted</name><index>[<expr><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>autoReduce</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>lemp</name><operator>-&gt;</operator><name>nxstate</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***************** From the file "set.c" ************************************/</comment>
<comment type="block">/*
** Set manipulation routines for the LEMON parser generator.
*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Set the set size */</comment>
<function><type><name>void</name></type> <name>SetSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>size</name> <operator>=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Allocate a new set */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>SetNew</name><parameter_list>()</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>( <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>s</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>memory_error</name><parameter_list>()</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>memory_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Deallocate a set */</comment>
<function><type><name>void</name></type> <name>SetFree</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a new element to the set.  Return TRUE if the element was added
** and FALSE if it was already there. */</comment>
<function><type><name>int</name></type> <name>SetAdd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>e</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>e</name><operator>&lt;</operator><name>size</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rv</name> <operator>=</operator> <name><name>s</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><index>[<expr><name>e</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><operator>!</operator><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add every element of s2 to s1.  Return TRUE if s1 changes. */</comment>
<function><type><name>int</name></type> <name>SetUnion</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>progress</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>s2</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>s1</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>s1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>progress</name></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/********************** From the file "table.c" ****************************/</comment>
<comment type="block">/*
** All code in this file has been automatically generated
** from a specification in the file
**              "table.q"
** by the associative array code building program "aagen".
** Do not edit this file!  Instead, edit the specification
** file, then rerun aagen.
*/</comment>
<comment type="block">/*
** Code for processing tables in the LEMON parser generator.
*/</comment>

<function><type><name>PRIVATE</name> <name>unsigned</name></type> <name>strhash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>x</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>h</name> <operator>=</operator> <name>h</name><operator>*</operator><literal type="number">13</literal> <operator>+</operator> <operator>*</operator><operator>(</operator><name>x</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Works like strdup, sort of.  Save a string in malloced memory, but
** keep strings in a table so that the same string is not in more
** than one place.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Strsafe</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cpy</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>y</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>Strsafe_find</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>cpy</name><operator>=</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><call><name>lemonStrlen</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lemon_strcpy</name><argument_list>(<argument><expr><name>cpy</name></expr></argument>,<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name>cpy</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Strsafe_insert</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>MemoryCheck</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* There is one instance of the following structure for each
** associative array of type "x1".
*/</comment>
<struct>struct <name>s_x1</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>               <comment type="block">/* The number of available slots. */</comment>
                          <comment type="block">/*   Must be a power of 2 greater than or */</comment>
                          <comment type="block">/*   equal to 1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>              <comment type="block">/* Number of currently slots filled */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x1node</name></name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>  <comment type="block">/* The data stored here */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x1node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>  <comment type="block">/* Hash table for lookups */</comment>
}</block>;</struct>

<comment type="block">/* There is one instance of this structure for every data element
** in an associative array of type "x1".
*/</comment>
<typedef>typedef <type><struct>struct <name>s_x1node</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>        <comment type="block">/* The data */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x1node</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>   <comment type="block">/* Next entry with the same hash */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x1node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>  <comment type="block">/* Previous link */</comment>
}</block></struct></type> <name>x1node</name>;</typedef>

<comment type="block">/* There is only one instance of the array, which is the following */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>s_x1</name></name> <modifier>*</modifier></type><name>x1a</name></decl>;</decl_stmt>

<comment type="block">/* Allocate a new associative array */</comment>
<function><type><name>void</name></type> <name>Strsafe_init</name><parameter_list>()</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>x1a</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>x1a</name> <operator>=</operator> <operator>(</operator>struct <name>s_x1</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>s_x1</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x1a</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x1a</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x1a</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x1a</name><operator>-&gt;</operator><name>tbl</name></name> <operator>=</operator> <operator>(</operator><name>x1node</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x1node</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>x1node</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x1a</name><operator>-&gt;</operator><name>tbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>x1a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x1a</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>x1a</name><operator>-&gt;</operator><name>ht</name></name> <operator>=</operator> <operator>(</operator><name>x1node</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>x1a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">1024</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x1a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/* Insert a new record into the array.  Return TRUE if successful.
** Prior data with the same key is NOT overwritten */</comment>
<function><type><name>int</name></type> <name>Strsafe_insert</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>x1node</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>ph</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>x1a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ph</name> <operator>=</operator> <call><name>strhash</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>ph</name> <operator>&amp;</operator> <operator>(</operator><name><name>x1a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>x1a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>np</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* An existing entry with the same key is found. */</comment>
      <comment type="block">/* Fail because overwrite is not allows. */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>x1a</name><operator>-&gt;</operator><name>count</name></name><operator>&gt;=</operator><name><name>x1a</name><operator>-&gt;</operator><name>size</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Need to make the hash table bigger */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>arrSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>s_x1</name></name></type> <name>array</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>arrSize</name> <operator>=</operator> <name><name>x1a</name><operator>-&gt;</operator><name>size</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>count</name></name> <operator>=</operator> <name><name>x1a</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>tbl</name></name> <operator>=</operator> <operator>(</operator><name>x1node</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><name>arrSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x1node</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>x1node</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>array</name><operator>.</operator><name>tbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Fail due to malloc failure */</comment>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name></name> <operator>=</operator> <operator>(</operator><name>x1node</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>tbl</name><index>[<expr><name>arrSize</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>arrSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>x1a</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>x1node</name> <modifier>*</modifier></type><name>oldnp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newnp</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>oldnp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x1a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>strhash</name><argument_list>(<argument><expr><name><name>oldnp</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>arrSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>newnp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>-&gt;</operator><name>from</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>newnp</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>oldnp</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>newnp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>x1a</name><operator>-&gt;</operator><name>tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>x1a</name> <operator>=</operator> <name>array</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Insert the new data */</comment>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>ph</name> <operator>&amp;</operator> <operator>(</operator><name><name>x1a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x1a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name><name>x1a</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>x1a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x1a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>-&gt;</operator><name>from</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>np</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>x1a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x1a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x1a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a pointer to data assigned to the given key.  Return NULL
** if no such key. */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Strsafe_find</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>x1node</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>x1a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>strhash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name><name>x1a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>x1a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>np</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><ternary><condition><expr><name>np</name></expr> ?</condition><then> <expr><name><name>np</name><operator>-&gt;</operator><name>data</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a pointer to the (terminal or nonterminal) symbol "x".
** Create a new symbol if this is the first time "x" has been seen.
*/</comment>
<function><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>Symbol_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>Symbol_find</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>sp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>(</operator>struct <name>symbol</name> <operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>symbol</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryCheck</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>Strsafe</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><call><name>ISUPPER</name><argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>TERMINAL</name></expr> </then><else>: <expr><name>NONTERMINAL</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>rule</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>fallback</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>prec</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>assoc</name></name> <operator>=</operator> <name>UNK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>firstset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>lambda</name></name> <operator>=</operator> <name>LEMON_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>destructor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>destLineno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>datatype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>useCnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Symbol_insert</name><argument_list>(<argument><expr><name>sp</name></expr></argument>,<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>useCnt</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>sp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare two symbols for sorting purposes.  Return negative,
** zero, or positive if a is less then, equal to, or greater
** than b.
**
** Symbols that begin with upper case letters (terminals or tokens)
** must sort before symbols that begin with lower case letters
** (non-terminals).  And MULTITERMINAL symbols (created using the
** %token_class directive) must sort at the very end. Other than
** that, the order does not matter.
**
** We find experimentally that leaving the symbols in their original
** order (the order they appeared in the grammar file) gives the
** smallest parser tables in SQLite.
*/</comment>
<function><type><name>int</name></type> <name>Symbolcmpp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> struct <name>symbol</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>_a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> struct <name>symbol</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>_b</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i1</name> <init>= <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>MULTITERMINAL</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;</operator><literal type="char">'Z'</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i2</name> <init>= <expr><ternary><condition><expr><name><name>b</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>MULTITERMINAL</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><ternary><condition><expr><name><name>b</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;</operator><literal type="char">'Z'</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>i1</name><operator>==</operator><name>i2</name></expr> ?</condition><then> <expr><name><name>a</name><operator>-&gt;</operator><name>index</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>index</name></name></expr> </then><else>: <expr><name>i1</name> <operator>-</operator> <name>i2</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* There is one instance of the following structure for each
** associative array of type "x2".
*/</comment>
<struct>struct <name>s_x2</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>               <comment type="block">/* The number of available slots. */</comment>
                          <comment type="block">/*   Must be a power of 2 greater than or */</comment>
                          <comment type="block">/*   equal to 1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>              <comment type="block">/* Number of currently slots filled */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x2node</name></name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>  <comment type="block">/* The data stored here */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x2node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>  <comment type="block">/* Hash table for lookups */</comment>
}</block>;</struct>

<comment type="block">/* There is one instance of this structure for every data element
** in an associative array of type "x2".
*/</comment>
<typedef>typedef <type><struct>struct <name>s_x2node</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>     <comment type="block">/* The data */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>         <comment type="block">/* The key */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x2node</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>   <comment type="block">/* Next entry with the same hash */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x2node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>  <comment type="block">/* Previous link */</comment>
}</block></struct></type> <name>x2node</name>;</typedef>

<comment type="block">/* There is only one instance of the array, which is the following */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>s_x2</name></name> <modifier>*</modifier></type><name>x2a</name></decl>;</decl_stmt>

<comment type="block">/* Allocate a new associative array */</comment>
<function><type><name>void</name></type> <name>Symbol_init</name><parameter_list>()</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>x2a</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>x2a</name> <operator>=</operator> <operator>(</operator>struct <name>s_x2</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>s_x2</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x2a</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x2a</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x2a</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x2a</name><operator>-&gt;</operator><name>tbl</name></name> <operator>=</operator> <operator>(</operator><name>x2node</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x2node</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>x2node</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x2a</name><operator>-&gt;</operator><name>tbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>x2a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x2a</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>x2a</name><operator>-&gt;</operator><name>ht</name></name> <operator>=</operator> <operator>(</operator><name>x2node</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>x2a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><literal type="number">128</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">128</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x2a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/* Insert a new record into the array.  Return TRUE if successful.
** Prior data with the same key is NOT overwritten */</comment>
<function><type><name>int</name></type> <name>Symbol_insert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>x2node</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>ph</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>x2a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ph</name> <operator>=</operator> <call><name>strhash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>ph</name> <operator>&amp;</operator> <operator>(</operator><name><name>x2a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>x2a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>np</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* An existing entry with the same key is found. */</comment>
      <comment type="block">/* Fail because overwrite is not allows. */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>x2a</name><operator>-&gt;</operator><name>count</name></name><operator>&gt;=</operator><name><name>x2a</name><operator>-&gt;</operator><name>size</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Need to make the hash table bigger */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>arrSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>s_x2</name></name></type> <name>array</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>arrSize</name> <operator>=</operator> <name><name>x2a</name><operator>-&gt;</operator><name>size</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>count</name></name> <operator>=</operator> <name><name>x2a</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>tbl</name></name> <operator>=</operator> <operator>(</operator><name>x2node</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><name>arrSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x2node</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>x2node</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>array</name><operator>.</operator><name>tbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Fail due to malloc failure */</comment>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name></name> <operator>=</operator> <operator>(</operator><name>x2node</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>tbl</name><index>[<expr><name>arrSize</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>arrSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>x2a</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>x2node</name> <modifier>*</modifier></type><name>oldnp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newnp</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>oldnp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x2a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>strhash</name><argument_list>(<argument><expr><name><name>oldnp</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>arrSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>newnp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>-&gt;</operator><name>from</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>newnp</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>oldnp</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>oldnp</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>newnp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>x2a</name><operator>-&gt;</operator><name>tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>x2a</name> <operator>=</operator> <name>array</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Insert the new data */</comment>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>ph</name> <operator>&amp;</operator> <operator>(</operator><name><name>x2a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x2a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name><name>x2a</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>x2a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x2a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>-&gt;</operator><name>from</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>np</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>x2a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x2a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x2a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a pointer to data assigned to the given key.  Return NULL
** if no such key. */</comment>
<function><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>Symbol_find</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>x2node</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>x2a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>strhash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name><name>x2a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>x2a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>np</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><ternary><condition><expr><name>np</name></expr> ?</condition><then> <expr><name><name>np</name><operator>-&gt;</operator><name>data</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the n-th data.  Return NULL if n is out of range. */</comment>
<function><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>Symbol_Nth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x2a</name> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;=</operator><name><name>x2a</name><operator>-&gt;</operator><name>count</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>x2a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>data</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the size of the array */</comment>
<function><type><name>int</name></type> <name>Symbol_count</name><parameter_list>()</parameter_list>
<block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>x2a</name></expr> ?</condition><then> <expr><name><name>x2a</name><operator>-&gt;</operator><name>count</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return an array of pointers to all data in the table.
** The array is obtained from malloc.  Return NULL if memory allocation
** problems, or if the array is empty. */</comment>
<function><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>Symbol_arrayof</name><parameter_list>()</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>symbol</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>arrSize</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x2a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>arrSize</name> <operator>=</operator> <name><name>x2a</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>array</name> <operator>=</operator> <operator>(</operator>struct <name>symbol</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><name>arrSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>symbol</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>array</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>arrSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>x2a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>array</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare two configurations */</comment>
<function><type><name>int</name></type> <name>Configcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator>struct <name>config</name> <operator>*</operator><operator>)</operator> <name>_a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator>struct <name>config</name> <operator>*</operator><operator>)</operator> <name>_b</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>dot</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>dot</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare two states */</comment>
<function><type><name>PRIVATE</name> <name>int</name></type> <name>statecmp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>rc</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>a</name> <operator>&amp;&amp;</operator> <name>b</name></expr>;</condition>  <incr><expr><name>a</name><operator>=</operator><name><name>a</name><operator>-&gt;</operator><name>bp</name></name></expr><operator>,</operator> <expr><name>b</name><operator>=</operator><name><name>b</name><operator>-&gt;</operator><name>bp</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>dot</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>dot</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>a</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>b</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Hash a state */</comment>
<function><type><name>PRIVATE</name> <name>unsigned</name></type> <name>statehash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>h</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>a</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <name>h</name><operator>*</operator><literal type="number">571</literal> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name><operator>*</operator><literal type="number">37</literal> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>dot</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>bp</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate a new state structure */</comment>
<function><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>State_new</name><parameter_list>()</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>newstate</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>newstate</name> <operator>=</operator> <operator>(</operator>struct <name>state</name> <operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>state</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemoryCheck</name><argument_list>(<argument><expr><name>newstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>newstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* There is one instance of the following structure for each
** associative array of type "x3".
*/</comment>
<struct>struct <name>s_x3</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>               <comment type="block">/* The number of available slots. */</comment>
                          <comment type="block">/*   Must be a power of 2 greater than or */</comment>
                          <comment type="block">/*   equal to 1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>              <comment type="block">/* Number of currently slots filled */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x3node</name></name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>  <comment type="block">/* The data stored here */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x3node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>  <comment type="block">/* Hash table for lookups */</comment>
}</block>;</struct>

<comment type="block">/* There is one instance of this structure for every data element
** in an associative array of type "x3".
*/</comment>
<typedef>typedef <type><struct>struct <name>s_x3node</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>                  <comment type="block">/* The data */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>                   <comment type="block">/* The key */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x3node</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>   <comment type="block">/* Next entry with the same hash */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x3node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>  <comment type="block">/* Previous link */</comment>
}</block></struct></type> <name>x3node</name>;</typedef>

<comment type="block">/* There is only one instance of the array, which is the following */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>s_x3</name></name> <modifier>*</modifier></type><name>x3a</name></decl>;</decl_stmt>

<comment type="block">/* Allocate a new associative array */</comment>
<function><type><name>void</name></type> <name>State_init</name><parameter_list>()</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>x3a</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>x3a</name> <operator>=</operator> <operator>(</operator>struct <name>s_x3</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>s_x3</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x3a</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x3a</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x3a</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x3a</name><operator>-&gt;</operator><name>tbl</name></name> <operator>=</operator> <operator>(</operator><name>x3node</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x3node</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>x3node</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x3a</name><operator>-&gt;</operator><name>tbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>x3a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x3a</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>x3a</name><operator>-&gt;</operator><name>ht</name></name> <operator>=</operator> <operator>(</operator><name>x3node</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>x3a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><literal type="number">128</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">128</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x3a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/* Insert a new record into the array.  Return TRUE if successful.
** Prior data with the same key is NOT overwritten */</comment>
<function><type><name>int</name></type> <name>State_insert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>x3node</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>ph</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>x3a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ph</name> <operator>=</operator> <call><name>statehash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>ph</name> <operator>&amp;</operator> <operator>(</operator><name><name>x3a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>x3a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>np</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>statecmp</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* An existing entry with the same key is found. */</comment>
      <comment type="block">/* Fail because overwrite is not allows. */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>x3a</name><operator>-&gt;</operator><name>count</name></name><operator>&gt;=</operator><name><name>x3a</name><operator>-&gt;</operator><name>size</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Need to make the hash table bigger */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>arrSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>s_x3</name></name></type> <name>array</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>arrSize</name> <operator>=</operator> <name><name>x3a</name><operator>-&gt;</operator><name>size</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>count</name></name> <operator>=</operator> <name><name>x3a</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>tbl</name></name> <operator>=</operator> <operator>(</operator><name>x3node</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><name>arrSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x3node</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>x3node</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>array</name><operator>.</operator><name>tbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Fail due to malloc failure */</comment>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name></name> <operator>=</operator> <operator>(</operator><name>x3node</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>tbl</name><index>[<expr><name>arrSize</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>arrSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>x3a</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>x3node</name> <modifier>*</modifier></type><name>oldnp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newnp</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>oldnp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x3a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>statehash</name><argument_list>(<argument><expr><name><name>oldnp</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>arrSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>newnp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>-&gt;</operator><name>from</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>newnp</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>oldnp</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>oldnp</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>newnp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>x3a</name><operator>-&gt;</operator><name>tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>x3a</name> <operator>=</operator> <name>array</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Insert the new data */</comment>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>ph</name> <operator>&amp;</operator> <operator>(</operator><name><name>x3a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x3a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name><name>x3a</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>x3a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x3a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>-&gt;</operator><name>from</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>np</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>x3a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x3a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x3a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a pointer to data assigned to the given key.  Return NULL
** if no such key. */</comment>
<function><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>State_find</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>x3node</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>x3a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>statehash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name><name>x3a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>x3a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>np</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>statecmp</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><ternary><condition><expr><name>np</name></expr> ?</condition><then> <expr><name><name>np</name><operator>-&gt;</operator><name>data</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return an array of pointers to all data in the table.
** The array is obtained from malloc.  Return NULL if memory allocation
** problems, or if the array is empty. */</comment>
<function><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>State_arrayof</name><parameter_list>()</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>arrSize</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x3a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>arrSize</name> <operator>=</operator> <name><name>x3a</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>array</name> <operator>=</operator> <operator>(</operator>struct <name>state</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><name>arrSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>state</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>array</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>arrSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>x3a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>array</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Hash a configuration */</comment>
<function><type><name>PRIVATE</name> <name>unsigned</name></type> <name>confighash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>h</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>h</name><operator>*</operator><literal type="number">571</literal> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>rp</name><operator>-&gt;</operator><name>index</name></name><operator>*</operator><literal type="number">37</literal> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>dot</name></name></expr>;</expr_stmt>
  <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* There is one instance of the following structure for each
** associative array of type "x4".
*/</comment>
<struct>struct <name>s_x4</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>               <comment type="block">/* The number of available slots. */</comment>
                          <comment type="block">/*   Must be a power of 2 greater than or */</comment>
                          <comment type="block">/*   equal to 1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>              <comment type="block">/* Number of currently slots filled */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x4node</name></name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>  <comment type="block">/* The data stored here */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x4node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>  <comment type="block">/* Hash table for lookups */</comment>
}</block>;</struct>

<comment type="block">/* There is one instance of this structure for every data element
** in an associative array of type "x4".
*/</comment>
<typedef>typedef <type><struct>struct <name>s_x4node</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>                  <comment type="block">/* The data */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x4node</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>   <comment type="block">/* Next entry with the same hash */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>s_x4node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>  <comment type="block">/* Previous link */</comment>
}</block></struct></type> <name>x4node</name>;</typedef>

<comment type="block">/* There is only one instance of the array, which is the following */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>s_x4</name></name> <modifier>*</modifier></type><name>x4a</name></decl>;</decl_stmt>

<comment type="block">/* Allocate a new associative array */</comment>
<function><type><name>void</name></type> <name>Configtable_init</name><parameter_list>()</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>x4a</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>x4a</name> <operator>=</operator> <operator>(</operator>struct <name>s_x4</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>s_x4</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x4a</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x4a</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x4a</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x4a</name><operator>-&gt;</operator><name>tbl</name></name> <operator>=</operator> <operator>(</operator><name>x4node</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x4node</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>x4node</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x4a</name><operator>-&gt;</operator><name>tbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>x4a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x4a</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>x4a</name><operator>-&gt;</operator><name>ht</name></name> <operator>=</operator> <operator>(</operator><name>x4node</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>x4a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><literal type="number">64</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">64</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x4a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/* Insert a new record into the array.  Return TRUE if successful.
** Prior data with the same key is NOT overwritten */</comment>
<function><type><name>int</name></type> <name>Configtable_insert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>x4node</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>ph</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>x4a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ph</name> <operator>=</operator> <call><name>confighash</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>ph</name> <operator>&amp;</operator> <operator>(</operator><name><name>x4a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>x4a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>np</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>Configcmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>np</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* An existing entry with the same key is found. */</comment>
      <comment type="block">/* Fail because overwrite is not allows. */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>x4a</name><operator>-&gt;</operator><name>count</name></name><operator>&gt;=</operator><name><name>x4a</name><operator>-&gt;</operator><name>size</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Need to make the hash table bigger */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>arrSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>s_x4</name></name></type> <name>array</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>arrSize</name> <operator>=</operator> <name><name>x4a</name><operator>-&gt;</operator><name>size</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>count</name></name> <operator>=</operator> <name><name>x4a</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>tbl</name></name> <operator>=</operator> <operator>(</operator><name>x4node</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><name>arrSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x4node</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>x4node</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>array</name><operator>.</operator><name>tbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Fail due to malloc failure */</comment>
    <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name></name> <operator>=</operator> <operator>(</operator><name>x4node</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>tbl</name><index>[<expr><name>arrSize</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>arrSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>x4a</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>x4node</name> <modifier>*</modifier></type><name>oldnp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newnp</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>oldnp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x4a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>confighash</name><argument_list>(<argument><expr><name><name>oldnp</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>arrSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>newnp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>-&gt;</operator><name>from</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>newnp</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>oldnp</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newnp</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>array</name><operator>.</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>newnp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>x4a</name><operator>-&gt;</operator><name>tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>x4a</name> <operator>=</operator> <name>array</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Insert the new data */</comment>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>ph</name> <operator>&amp;</operator> <operator>(</operator><name><name>x4a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x4a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name><name>x4a</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>x4a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x4a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>-&gt;</operator><name>from</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>np</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>x4a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x4a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>x4a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a pointer to data assigned to the given key.  Return NULL
** if no such key. */</comment>
<function><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>Configtable_find</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>x4node</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>x4a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>confighash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name><name>x4a</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>x4a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>np</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>Configcmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>np</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><ternary><condition><expr><name>np</name></expr> ?</condition><then> <expr><name><name>np</name><operator>-&gt;</operator><name>data</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove all data from the table.  Pass each data to the function "f"
** as it is removed.  ("f" may be null to avoid this step.) */</comment>
<function><type><name>void</name></type> <name>Configtable_clear</name><parameter_list>(<parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x4a</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>x4a</name><operator>-&gt;</operator><name>count</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>f</name></expr> )</condition><block type="pseudo"><block_content> <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>x4a</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name><name>x4a</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>x4a</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x4a</name><operator>-&gt;</operator><name>ht</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name><name>x4a</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>
</unit>
