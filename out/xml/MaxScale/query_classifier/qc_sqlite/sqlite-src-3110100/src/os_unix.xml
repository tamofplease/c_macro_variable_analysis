<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/os_unix.c"><comment type="block">/*
** 2004 May 22
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file contains the VFS implementation for unix-like operating systems
** include Linux, MacOSX, *BSD, QNX, VxWorks, AIX, HPUX, and others.
**
** There are actually several different VFS implementations in this file.
** The differences are in the way that file locking is done.  The default
** implementation uses Posix Advisory Locks.  Alternative implementations
** use flock(), dot-files, various proprietary locking schemas, or simply
** skip locking all together.
**
** This source file is organized into divisions where the logic for various
** subfunctions is contained within the appropriate division.  PLEASE
** KEEP THE STRUCTURE OF THIS FILE INTACT.  New code should be placed
** in the correct division and should be clearly labeled.
**
** The layout of divisions is as follows:
**
**   *  General-purpose declarations and utility functions.
**   *  Unique file ID logic used by VxWorks.
**   *  Various locking primitive implementations (all except proxy locking):
**      + for Posix Advisory Locks
**      + for no-op locks
**      + for dot-file locks
**      + for flock() locking
**      + for named semaphore locks (VxWorks only)
**      + for AFP filesystem locks (MacOSX only)
**   *  sqlite3_file methods not associated with locking.
**   *  Definitions of sqlite3_io_methods objects for all locking
**      methods plus "finder" functions for each locking method.
**   *  sqlite3_vfs method implementations.
**   *  Locking primitives for the proxy uber-locking-method. (MacOSX only)
**   *  Definitions of sqlite3_vfs objects for all locking methods
**      plus implementations of sqlite3_os_init() and sqlite3_os_end().
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_UNIX</name></expr></cpp:if>              <comment type="block">/* This file is used on unix only */</comment>

<comment type="block">/*
** There are various methods for file locking used for concurrency
** control:
**
**   1. POSIX locking (the default),
**   2. No locking,
**   3. Dot-file locking,
**   4. flock() locking,
**   5. AFP locking (OSX only),
**   6. Named POSIX semaphores (VXWorks only),
**   7. proxy locking. (OSX only)
**
** Styles 4, 5, and 7 are only available of SQLITE_ENABLE_LOCKING_STYLE
** is defined to 1.  The SQLITE_ENABLE_LOCKING_STYLE also enables automatic
** selection of the appropriate locking style based on the filesystem
** where the database is located.  
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_LOCKING_STYLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_ENABLE_LOCKING_STYLE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** standard include files.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_WAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_LOCKING_STYLE */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>__MAC_OS_X_VERSION_MIN_REQUIRED</name> <operator>&gt;</operator> <literal type="number">1050</literal><operator>)</operator> <operator>||</operator> \
                           <operator>(</operator><name>__IPHONE_OS_VERSION_MIN_REQUIRED</name> <operator>&gt;</operator> <literal type="number">2000</literal><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TARGET_OS_EMBEDDED</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>TARGET_OS_EMBEDDED</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator> \
       <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TARGET_IPHONE_SIMULATOR</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>TARGET_IPHONE_SIMULATOR</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETHOSTUUID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:warning>#    <cpp:directive>warning</cpp:directive> <cpp:literal>"gethostuuid() is disabled."</cpp:literal></cpp:warning>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;semaphore.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OS_VXWORKS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mount.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIME</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Allowed values of unixFile.fsFlags
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_FSFLAGS_IS_MSDOS</name></cpp:macro>     <cpp:value>0x1</cpp:value></cpp:define>

<comment type="block">/*
** If we are to be thread-safe, include the pthreads header and define
** the SQLITE_UNIX_THREADS macro.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_UNIX_THREADS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Default permissions when creating a new file
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEFAULT_FILE_PERMISSIONS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DEFAULT_FILE_PERMISSIONS</name></cpp:macro> <cpp:value>0644</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Default permissions when creating auto proxy dir
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEFAULT_PROXYDIR_PERMISSIONS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DEFAULT_PROXYDIR_PERMISSIONS</name></cpp:macro> <cpp:value>0755</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Maximum supported path-length.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PATHNAME</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>

<comment type="block">/*
** Maximum supported symbolic links
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_MAX_SYMLINKS</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<comment type="block">/* Always cast the getpid() return type for compatibility with
** kernel modules in VxWorks. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osGetpid</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(pid_t)getpid()</cpp:value></cpp:define>

<comment type="block">/*
** Only set the lastErrno if the error code is a real error and not 
** a normal expected return code of SQLITE_BUSY or SQLITE_OK
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LOCK_ERROR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((x != SQLITE_OK) &amp;&amp; (x != SQLITE_BUSY))</cpp:value></cpp:define>

<comment type="block">/* Forward references */</comment>
<typedef>typedef <type><name><name>struct</name> <name>unixShm</name></name></type> <name>unixShm</name>;</typedef>               <comment type="block">/* Connection shared memory */</comment>
<typedef>typedef <type><name><name>struct</name> <name>unixShmNode</name></name></type> <name>unixShmNode</name>;</typedef>       <comment type="block">/* Shared memory instance */</comment>
<typedef>typedef <type><name><name>struct</name> <name>unixInodeInfo</name></name></type> <name>unixInodeInfo</name>;</typedef>   <comment type="block">/* An i-node */</comment>
<typedef>typedef <type><name><name>struct</name> <name>UnixUnusedFd</name></name></type> <name>UnixUnusedFd</name>;</typedef>     <comment type="block">/* An unused file descriptor */</comment>

<comment type="block">/*
** Sometimes, after a file handle is closed by SQLite, the file descriptor
** cannot be closed immediately. In these cases, instances of the following
** structure are used to store the file descriptor while waiting for an
** opportunity to either close or reuse it.
*/</comment>
<struct>struct <name>UnixUnusedFd</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>                   <comment type="block">/* File descriptor to close */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                <comment type="block">/* Flags this file descriptor was opened with */</comment>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>      <comment type="block">/* Next unused file descriptor on same file */</comment>
}</block>;</struct>

<comment type="block">/*
** The unixFile structure is subclass of sqlite3_file specific to the unix
** VFS implementations.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>unixFile</name></name></type> <name>unixFile</name>;</typedef>
<struct>struct <name>unixFile</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_io_methods</name> <specifier>const</specifier> <modifier>*</modifier></type><name>pMethod</name></decl>;</decl_stmt>  <comment type="block">/* Always the first entry */</comment>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl>;</decl_stmt>                  <comment type="block">/* The VFS that created this unixFile */</comment>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name></decl>;</decl_stmt>              <comment type="block">/* Info about locks on this inode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>                              <comment type="block">/* The file descriptor */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>eFileLock</name></decl>;</decl_stmt>            <comment type="block">/* The type of lock held on this fd */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>ctrlFlags</name></decl>;</decl_stmt>       <comment type="block">/* Behavioral bits.  UNIXFILE_* flags */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>lastErrno</name></decl>;</decl_stmt>                      <comment type="block">/* The unix errno from last I/O error */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>lockingContext</name></decl>;</decl_stmt>               <comment type="block">/* Locking style specific state */</comment>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pUnused</name></decl>;</decl_stmt>              <comment type="block">/* Pre-allocated UnixUnusedFd */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>                  <comment type="block">/* Name of the file */</comment>
  <decl_stmt><decl><type><name>unixShm</name> <modifier>*</modifier></type><name>pShm</name></decl>;</decl_stmt>                      <comment type="block">/* Shared memory segment information */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szChunk</name></decl>;</decl_stmt>                        <comment type="block">/* Configured by FCNTL_CHUNK_SIZE */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>nFetchOut</name></decl>;</decl_stmt>                      <comment type="block">/* Number of outstanding xFetch refs */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>mmapSize</name></decl>;</decl_stmt>             <comment type="block">/* Usable size of mapping at pMapRegion */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>mmapSizeActual</name></decl>;</decl_stmt>       <comment type="block">/* Actual size of mapping at pMapRegion */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>mmapSizeMax</name></decl>;</decl_stmt>          <comment type="block">/* Configured FCNTL_MMAP_SIZE value */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pMapRegion</name></decl>;</decl_stmt>                   <comment type="block">/* Memory mapped region */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__QNXNTO__</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>sectorSize</name></decl>;</decl_stmt>                     <comment type="block">/* Device sector size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>deviceCharacteristics</name></decl>;</decl_stmt>          <comment type="block">/* Precomputed device characteristics */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>openFlags</name></decl>;</decl_stmt>                      <comment type="block">/* The flags specified at open() */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>fsFlags</name></decl>;</decl_stmt>                   <comment type="block">/* cached details from statfs() */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>vxworksFileId</name></name> <modifier>*</modifier></type><name>pId</name></decl>;</decl_stmt>          <comment type="block">/* Unique file ID */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* The next group of variables are used to track whether or not the
  ** transaction counter in bytes 24-27 of database files are updated
  ** whenever any part of the database changes.  An assertion fault will
  ** occur if a file is updated without also updating the transaction
  ** counter.  This test is made to avoid new problems similar to the
  ** one described by ticket #3584. 
  */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>transCntrChng</name></decl>;</decl_stmt>   <comment type="block">/* True if the transaction counter changed */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>dbUpdate</name></decl>;</decl_stmt>        <comment type="block">/* True if any part of database file changed */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>inNormalWrite</name></decl>;</decl_stmt>   <comment type="block">/* True if in a normal write operation */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <comment type="block">/* In test mode, increase the size of this structure a bit so that 
  ** it is larger than the struct CrashFile defined in test6.c.
  */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aPadding</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/* This variable holds the process id (pid) from when the xRandomness()
** method was called.  If xOpen() is called from a different process id,
** indicating that a fork() has occurred, the PRNG will be reset.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>randomnessPid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Allowed values for the unixFile.ctrlFlags bitmask:
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIXFILE_EXCL</name></cpp:macro>        <cpp:value>0x01</cpp:value></cpp:define>     <comment type="block">/* Connections from one process only */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIXFILE_RDONLY</name></cpp:macro>      <cpp:value>0x02</cpp:value></cpp:define>     <comment type="block">/* Connection is read only */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIXFILE_PERSIST_WAL</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>     <comment type="block">/* Persistent WAL mode */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_DIRSYNC</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UNIXFILE_DIRSYNC</name></cpp:macro>    <cpp:value>0x08</cpp:value></cpp:define>     <comment type="block">/* Directory sync needed */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UNIXFILE_DIRSYNC</name></cpp:macro>    <cpp:value>0x00</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIXFILE_PSOW</name></cpp:macro>        <cpp:value>0x10</cpp:value></cpp:define>     <comment type="block">/* SQLITE_IOCAP_POWERSAFE_OVERWRITE */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIXFILE_DELETE</name></cpp:macro>      <cpp:value>0x20</cpp:value></cpp:define>     <comment type="block">/* Delete on close */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIXFILE_URI</name></cpp:macro>         <cpp:value>0x40</cpp:value></cpp:define>     <comment type="block">/* Filename might have query parameters */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIXFILE_NOLOCK</name></cpp:macro>      <cpp:value>0x80</cpp:value></cpp:define>     <comment type="block">/* Do no file locking */</comment>

<comment type="block">/*
** Include code that is common to all os_*.c files
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os_common.h"</cpp:file></cpp:include>

<comment type="block">/*
** Define various macros that are missing from some systems.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_LARGEFILE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>O_LARGEFILE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DISABLE_LFS</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>O_LARGEFILE</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>O_LARGEFILE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_NOFOLLOW</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>O_NOFOLLOW</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_BINARY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>O_BINARY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The threadid macro resolves to the thread-id or to 0.  Used for
** testing and debugging only.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>threadid</name></cpp:macro> <cpp:value>pthread_self()</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>threadid</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** HAVE_MREMAP defaults to true on Linux and false everywhere else.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MREMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_GNU_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MREMAP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MREMAP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Explicitly call the 64-bit version of lseek() on Android. Otherwise, lseek()
** is the 32-bit version, even if _FILE_OFFSET_BITS=64 is defined.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__ANDROID__</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>lseek</name></cpp:macro> <cpp:value>lseek64</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Different Unix systems declare open() in different ways.  Same use
** open(const char*,int,mode_t).  Others use open(const char*,int,...).
** The difference is important when using a pointer to the function.
**
** The safest way to deal with the problem is to always use this wrapper
** which always has the same well-defined interface.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>posixOpen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>open</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward reference */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>openDirectory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>unixGetpagesize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Many system calls are accessed through pointer-to-functions so that
** they may be overridden at runtime to facilitate fault injection during
** testing and sandboxing.  The following array holds the names and pointers
** to all overrideable system calls.
*/</comment>
<struct><specifier>static</specifier> struct <name>unix_syscall</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>            <comment type="block">/* Name of the system call */</comment>
  <decl_stmt><decl><type><name>sqlite3_syscall_ptr</name></type> <name>pCurrent</name></decl>;</decl_stmt> <comment type="block">/* Current value of the system call */</comment>
  <decl_stmt><decl><type><name>sqlite3_syscall_ptr</name></type> <name>pDefault</name></decl>;</decl_stmt> <comment type="block">/* Default value */</comment>
}</block> <decl><name><name>aSyscall</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><literal type="string">"open"</literal></expr>,         <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>posixOpen</name></expr>,  <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osOpen</name></cpp:macro>      <cpp:value>((int(*)(const char*,int,int))aSyscall[0].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"close"</literal></expr>,        <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>close</name></expr>,      <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osClose</name></cpp:macro>     <cpp:value>((int(*)(int))aSyscall[1].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"access"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>access</name></expr>,     <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osAccess</name></cpp:macro>    <cpp:value>((int(*)(const char*,int))aSyscall[2].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"getcwd"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>getcwd</name></expr>,     <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osGetcwd</name></cpp:macro>    <cpp:value>((char*(*)(char*,size_t))aSyscall[3].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"stat"</literal></expr>,         <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>stat</name></expr>,       <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osStat</name></cpp:macro>      <cpp:value>((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)</cpp:value></cpp:define>

<comment type="block">/*
** The DJGPP compiler environment looks mostly like Unix, but it
** lacks the fcntl() system call.  So redefine fcntl() to be something
** that always succeeds.  This means that locking does not occur under
** DJGPP.  But it is DOS - what did you expect?
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__DJGPP__</name></cpp:ifdef>
  <expr><block>{ <expr><literal type="string">"fstat"</literal></expr>,        <expr><literal type="number">0</literal></expr>,                 <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osFstat</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>     
  <expr><block>{ <expr><literal type="string">"fstat"</literal></expr>,        <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>fstat</name></expr>,      <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osFstat</name></cpp:macro>     <cpp:value>((int(*)(int,struct stat*))aSyscall[5].pCurrent)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr><block>{ <expr><literal type="string">"ftruncate"</literal></expr>,    <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>ftruncate</name></expr>,  <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osFtruncate</name></cpp:macro> <cpp:value>((int(*)(int,off_t))aSyscall[6].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"fcntl"</literal></expr>,        <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>fcntl</name></expr>,      <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osFcntl</name></cpp:macro>     <cpp:value>((int(*)(int,int,...))aSyscall[7].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"read"</literal></expr>,         <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>read</name></expr>,       <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osRead</name></cpp:macro>      <cpp:value>((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"pread"</literal></expr>,        <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>pread</name></expr>,      <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"pread"</literal></expr>,        <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,          <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osPread</name></cpp:macro>     <cpp:value>((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"pread64"</literal></expr>,      <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>pread64</name></expr>,    <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"pread64"</literal></expr>,      <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,          <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osPread64</name></cpp:macro>   <cpp:value>((ssize_t(*)(int,void*,size_t,off_t))aSyscall[10].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"write"</literal></expr>,        <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>write</name></expr>,      <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osWrite</name></cpp:macro>     <cpp:value>((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"pwrite"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>pwrite</name></expr>,     <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"pwrite"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,          <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osPwrite</name></cpp:macro>    <cpp:value>((ssize_t(*)(int,const void*,size_t,off_t))\
                    aSyscall[12].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"pwrite64"</literal></expr>,     <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>pwrite64</name></expr>,   <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"pwrite64"</literal></expr>,     <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,          <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osPwrite64</name></cpp:macro>  <cpp:value>((ssize_t(*)(int,const void*,size_t,off_t))\
                    aSyscall[13].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"fchmod"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>fchmod</name></expr>,          <expr><literal type="number">0</literal></expr>  }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osFchmod</name></cpp:macro>    <cpp:value>((int(*)(int,mode_t))aSyscall[14].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POSIX_FALLOCATE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_POSIX_FALLOCATE</name></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"fallocate"</literal></expr>,    <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>posix_fallocate</name></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"fallocate"</literal></expr>,    <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,                <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osFallocate</name></cpp:macro> <cpp:value>((int(*)(int,off_t,off_t))aSyscall[15].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"unlink"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>unlink</name></expr>,           <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osUnlink</name></cpp:macro>    <cpp:value>((int(*)(const char*))aSyscall[16].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"openDirectory"</literal></expr>,    <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>openDirectory</name></expr>,      <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osOpenDirectory</name></cpp:macro> <cpp:value>((int(*)(const char*,int*))aSyscall[17].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"mkdir"</literal></expr>,        <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>mkdir</name></expr>,           <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osMkdir</name></cpp:macro>     <cpp:value>((int(*)(const char*,mode_t))aSyscall[18].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"rmdir"</literal></expr>,        <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>rmdir</name></expr>,           <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osRmdir</name></cpp:macro>     <cpp:value>((int(*)(const char*))aSyscall[19].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"fchown"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>fchown</name></expr>,          <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"fchown"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,               <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osFchown</name></cpp:macro>    <cpp:value>((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent)</cpp:value></cpp:define>

  <expr><block>{ <expr><literal type="string">"geteuid"</literal></expr>,      <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>geteuid</name></expr>,         <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osGeteuid</name></cpp:macro>   <cpp:value>((uid_t(*)(void))aSyscall[21].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_WAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"mmap"</literal></expr>,         <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>mmap</name></expr>,            <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"mmap"</literal></expr>,         <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,               <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osMmap</name></cpp:macro> <cpp:value>((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_WAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"munmap"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>munmap</name></expr>,          <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"munmap"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,               <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osMunmap</name></cpp:macro> <cpp:value>((void*(*)(void*,size_t))aSyscall[23].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MREMAP</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_WAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"mremap"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>mremap</name></expr>,          <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"mremap"</literal></expr>,       <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,               <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osMremap</name></cpp:macro> <cpp:value>((void*(*)(void*,size_t,size_t,int,...))aSyscall[24].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_WAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"getpagesize"</literal></expr>,  <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>unixGetpagesize</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"getpagesize"</literal></expr>,  <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,               <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osGetpagesize</name></cpp:macro> <cpp:value>((int(*)(void))aSyscall[25].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"readlink"</literal></expr>,     <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>readlink</name></expr>,        <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"readlink"</literal></expr>,     <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,               <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osReadlink</name></cpp:macro> <cpp:value>((ssize_t(*)(const char*,char*,size_t))aSyscall[26].pCurrent)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><block>{ <expr><literal type="string">"lstat"</literal></expr>,         <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><name>lstat</name></expr>,          <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><literal type="string">"lstat"</literal></expr>,         <expr><operator>(</operator><name>sqlite3_syscall_ptr</name><operator>)</operator><literal type="number">0</literal></expr>,              <expr><literal type="number">0</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osLstat</name></cpp:macro>      <cpp:value>((int(*)(const char*,struct stat*))aSyscall[27].pCurrent)</cpp:value></cpp:define>

}</block></expr></init></decl>;</struct> <comment type="block">/* End of the overrideable system calls */</comment>


<comment type="block">/*
** On some systems, calls to fchown() will trigger a message in a security
** log if they come from non-root processes.  So avoid calling fchown() if
** we are not running as root.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>robustFchown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>uid_t</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>gid_t</name></type> <name>gid</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHOWN</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
  <return>return <expr><ternary><condition><expr><call><name>osGeteuid</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>osFchown</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>uid</name></expr></argument>,<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** This is the xSetSystemCall() method of sqlite3_vfs for all of the
** "unix" VFSes.  Return SQLITE_OK opon successfully updating the
** system call pointer, or SQLITE_NOTFOUND if there is no configurable
** system call named zName.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixSetSystemCall</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pNotUsed</name></decl></parameter>,        <comment type="block">/* The VFS pointer.  Not used */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,            <comment type="block">/* Name of system call to override */</comment>
  <parameter><decl><type><name>sqlite3_syscall_ptr</name></type> <name>pNewFunc</name></decl></parameter>  <comment type="block">/* Pointer to new system call value */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_NOTFOUND</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pNotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If no zName is given, restore all system calls to their default
    ** settings and return NULL
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aSyscall</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aSyscall</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pDefault</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCurrent</name> <operator>=</operator> <name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pDefault</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If zName is specified, operate on only the one system call
    ** specified.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aSyscall</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aSyscall</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pDefault</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pDefault</name> <operator>=</operator> <name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCurrent</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pNewFunc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pNewFunc</name> <operator>=</operator> <name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pDefault</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCurrent</name> <operator>=</operator> <name>pNewFunc</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the value of a system call.  Return NULL if zName is not a
** recognized system call name.  NULL is also returned if the system call
** is currently undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_syscall_ptr</name></type> <name>unixGetSystemCall</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pNotUsed</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pNotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aSyscall</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aSyscall</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCurrent</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the name of the first system call after zName.  If zName==NULL
** then return the name of the first system call.  Return NULL if zName
** is the last system call or if zName is not the name of a valid
** system call.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unixNextSystemCall</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aSyscall</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>++</operator></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aSyscall</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCurrent</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>aSyscall</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do not accept any file descriptor less than this value, in order to avoid
** opening database file using file descriptors that are commonly used for 
** standard input, output, and error.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_MINIMUM_FILE_DESCRIPTOR</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_MINIMUM_FILE_DESCRIPTOR</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Invoke open().  Do so multiple times, until it either succeeds or
** fails for some reason other than EINTR.
**
** If the file creation mode "m" is 0 then set it to the default for
** SQLite.  The default is SQLITE_DEFAULT_FILE_PERMISSIONS (normally
** 0644) as modified by the system umask.  If m is not 0, then
** make the file creation mode be exactly m ignoring the umask.
**
** The m parameter will be non-zero only when creating -wal, -journal,
** and -shm files.  We want those files to have *exactly* the same
** permissions as their original database, unadulterated by the umask.
** In that way, if a database file is -rw-rw-rw or -rw-rw-r-, and a
** transaction crashes and leaves behind hot journals, then any
** process that is able to write to the database will also be able to
** recover the hot journals.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>robust_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>m</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mode_t</name></type> <name>m2</name> <init>= <expr><ternary><condition><expr><name>m</name></expr> ?</condition><then> <expr><name>m</name></expr> </then><else>: <expr><name>SQLITE_DEFAULT_FILE_PERMISSIONS</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>osOpen</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><name>f</name><operator>|</operator><name>O_CLOEXEC</name></expr></argument>,<argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>osOpen</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>errno</name><operator>==</operator><name>EINTR</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&gt;=</operator><name>SQLITE_MINIMUM_FILE_DESCRIPTOR</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>osClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_WARNING</name></expr></argument>, 
                <argument><expr><literal type="string">"attempt to open \"%s\" as file descriptor %d"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>osOpen</name><argument_list>(<argument><expr><literal type="string">"/dev/null"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>m</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>osFstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> 
       <operator>&amp;&amp;</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name><operator>&amp;</operator><literal type="number">0777</literal><operator>)</operator><operator>!=</operator><name>m</name></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>osFchmod</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>O_CLOEXEC</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name>osFcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><call><name>osFcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>|</operator> <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Helper functions to obtain and relinquish the global mutex. The
** global mutex is used to protect the unixInodeInfo and
** vxworksFileId objects used by this file, all of which may be 
** shared by multiple threads.
**
** Function unixMutexHeld() is used to assert() that the global mutex 
** is held when required. This function is only used as part of assert() 
** statements. e.g.
**
**   unixEnterMutex()
**     assert( unixMutexHeld() );
**   unixEnterLeave()
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixEnterMutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_VFS1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixLeaveMutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_VFS1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixMutexHeld</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_VFS1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAVE_OS_TRACE</name></cpp:ifdef>
<comment type="block">/*
** Helper function for printing out trace information from debugging
** binaries. This returns the string representation of the supplied
** integer lock-type.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>azFileLock</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name>eFileLock</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>NO_LOCK</name></expr>:</case> <return>return <expr><literal type="string">"NONE"</literal></expr>;</return>
    <case>case <expr><name>SHARED_LOCK</name></expr>:</case> <return>return <expr><literal type="string">"SHARED"</literal></expr>;</return>
    <case>case <expr><name>RESERVED_LOCK</name></expr>:</case> <return>return <expr><literal type="string">"RESERVED"</literal></expr>;</return>
    <case>case <expr><name>PENDING_LOCK</name></expr>:</case> <return>return <expr><literal type="string">"PENDING"</literal></expr>;</return>
    <case>case <expr><name>EXCLUSIVE_LOCK</name></expr>:</case> <return>return <expr><literal type="string">"EXCLUSIVE"</literal></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><literal type="string">"ERROR"</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_LOCK_TRACE</name></cpp:ifdef>
<comment type="block">/*
** Print out information about all locking operations.
**
** This routine is used for troubleshooting locks on multithreaded
** platforms.  Enable by compiling with the -DSQLITE_LOCK_TRACE
** command-line option on the compiler.  This code is normally
** turned off.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lockTrace</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>flock</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOpName</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>savedErrno</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>F_GETLK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zOpName</name> <operator>=</operator> <literal type="string">"GETLK"</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>F_SETLK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zOpName</name> <operator>=</operator> <literal type="string">"SETLK"</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>osFcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"fcntl unknown %d %d %d\n"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>s</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>l_type</name></name><operator>==</operator><name>F_RDLCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"RDLCK"</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>l_type</name></name><operator>==</operator><name>F_WRLCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"WRLCK"</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>l_type</name></name><operator>==</operator><name>F_UNLCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"UNLCK"</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>l_whence</name></name><operator>==</operator><name>SEEK_SET</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>osFcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>savedErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"fcntl %d %d %s %s %d %d %d %d\n"</literal></expr></argument>,
     <argument><expr><name>threadid</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>zOpName</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>l_start</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>l_len</name></name></expr></argument>,
     <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>l_pid</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>s</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>F_SETLK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l_type</name></name><operator>==</operator><name>F_RDLCK</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>l_type</name></name><operator>==</operator><name>F_WRLCK</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>l2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>l2</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>osFcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>l2</name><operator>.</operator><name>l_type</name></name><operator>==</operator><name>F_RDLCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"RDLCK"</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>l2</name><operator>.</operator><name>l_type</name></name><operator>==</operator><name>F_WRLCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"WRLCK"</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>l2</name><operator>.</operator><name>l_type</name></name><operator>==</operator><name>F_UNLCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"UNLCK"</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"fcntl-failure-reason: %s %d %d %d\n"</literal></expr></argument>,
       <argument><expr><name>zType</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>l2</name><operator>.</operator><name>l_start</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>l2</name><operator>.</operator><name>l_len</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>l2</name><operator>.</operator><name>l_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>savedErrno</name></expr>;</expr_stmt>
  <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>osFcntl</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>osFcntl</name></cpp:macro> <cpp:value>lockTrace</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_LOCK_TRACE */</comment>

<comment type="block">/*
** Retry ftruncate() calls that fail due to EINTR
**
** All calls to ftruncate() within this file should be made through
** this wrapper.  On the Android platform, bypassing the logic below
** could lead to a corrupt database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>robust_ftruncate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>sz</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__ANDROID__</name></cpp:ifdef>
  <comment type="block">/* On Android, ftruncate() always uses 32-bit offsets, even if 
  ** _FILE_OFFSET_BITS=64 is defined. This means it is unsafe to attempt to
  ** truncate a file to any size larger than 2GiB. Silently ignore any
  ** such attempts.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&gt;</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">0x7FFFFFFF</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <do>do<block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFtruncate</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>EINTR</name></expr> )</condition>;</do></block_content></block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine translates a standard POSIX errno code into something
** useful to the clients of the sqlite3 functions.  Specifically, it is
** intended to translate a variety of "try again" errors into SQLITE_BUSY
** and a variety of "please close the file descriptor NOW" errors into 
** SQLITE_IOERR
** 
** Errors during initialization of locks, or file system support for locks,
** should handle ENOLCK, ENOTSUP, EOPNOTSUPP separately.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqliteErrorFromPosixError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>posixError</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sqliteIOErr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>sqliteIOErr</name> <operator>==</operator> <name>SQLITE_IOERR_LOCK</name><operator>)</operator> <operator>||</operator> 
          <operator>(</operator><name>sqliteIOErr</name> <operator>==</operator> <name>SQLITE_IOERR_UNLOCK</name><operator>)</operator> <operator>||</operator> 
          <operator>(</operator><name>sqliteIOErr</name> <operator>==</operator> <name>SQLITE_IOERR_RDLOCK</name><operator>)</operator> <operator>||</operator>
          <operator>(</operator><name>sqliteIOErr</name> <operator>==</operator> <name>SQLITE_IOERR_CHECKRESERVEDLOCK</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>posixError</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>EACCES</name></expr>:</case> 
  <case>case <expr><name>EAGAIN</name></expr>:</case>
  <case>case <expr><name>ETIMEDOUT</name></expr>:</case>
  <case>case <expr><name>EBUSY</name></expr>:</case>
  <case>case <expr><name>EINTR</name></expr>:</case>
  <case>case <expr><name>ENOLCK</name></expr>:</case>  
    <comment type="block">/* random NFS retry error, unless during file system support 
     * introspection, in which it actually means what it says */</comment>
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
    
  <case>case <expr><name>EPERM</name></expr>:</case> 
    <return>return <expr><name>SQLITE_PERM</name></expr>;</return>
    
  <default>default:</default> 
    <return>return <expr><name>sqliteIOErr</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block" format="doxygen">/******************************************************************************
****************** Begin Unique File ID Utility Used By VxWorks ***************
**
** On most versions of unix, we can get a unique ID for a file by concatenating
** the device number and the inode number.  But this does not work on VxWorks.
** On VxWorks, a unique file id must be based on the canonical filename.
**
** A pointer to an instance of the following structure can be used as a
** unique file ID in VxWorks.  Each instance of this structure contains
** a copy of the canonical filename.  There is also a reference count.  
** The structure is reclaimed when the number of pointers to it drops to
** zero.
**
** There are never very many files open at one time and lookups are not
** a performance-critical path, so it is sufficient to put these
** structures on a linked list.
*/</comment>
<struct>struct <name>vxworksFileId</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>vxworksFileId</name></name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>  <comment type="block">/* Next in a list of them all */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                     <comment type="block">/* Number of references to this one */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                    <comment type="block">/* Length of the zCanonicalName[] string */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCanonicalName</name></decl>;</decl_stmt>         <comment type="block">/* Canonical filename */</comment>
}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
<comment type="block">/* 
** All unique filenames are held on a linked list headed by this
** variable:
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>vxworksFileId</name></name> <modifier>*</modifier></type><name>vxworksFileList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Simplify a filename into its canonical form
** by making the following changes:
**
**  * removing any trailing and duplicate /
**  * convert /./ into just /
**  * convert /A/../ where A is any simple name into just /
**
** Changes are made in-place.  Return the new name length.
**
** The original filename is in z[0..n-1].  Return the number of
** characters in the simplified name.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vxworksSimplifyName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">2</literal><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">3</literal><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>j</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Find a unique file ID for the given absolute pathname.  Return
** a pointer to the vxworksFileId object.  This pointer is the unique
** file ID.
**
** The nRef field of the vxworksFileId object is incremented before
** the object is returned.  A new vxworksFileId object is created
** and added to the global list if necessary.
**
** If a memory allocation error occurs, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>vxworksFileId</name></name> <modifier>*</modifier></type><name>vxworksFindFileId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAbsoluteName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>vxworksFileId</name></name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>         <comment type="block">/* search key and new file ID */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>vxworksFileId</name></name> <modifier>*</modifier></type><name>pCandidate</name></decl>;</decl_stmt>   <comment type="block">/* For looping over existing file IDs */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                              <comment type="block">/* Length of zAbsoluteName string */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zAbsoluteName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zAbsoluteName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zCanonicalName</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zCanonicalName</name></name></expr></argument>, <argument><expr><name>zAbsoluteName</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vxworksSimplifyName</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zCanonicalName</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Search for an existing entry that matching the canonical name.
  ** If found, increment the reference count and return a pointer to
  ** the existing file ID.
  */</comment>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pCandidate</name><operator>=</operator><name>vxworksFileList</name></expr>;</init> <condition><expr><name>pCandidate</name></expr>;</condition> <incr><expr><name>pCandidate</name><operator>=</operator><name><name>pCandidate</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCandidate</name><operator>-&gt;</operator><name>nName</name></name><operator>==</operator><name>n</name> 
     <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pCandidate</name><operator>-&gt;</operator><name>zCanonicalName</name></name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zCanonicalName</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name><name>pCandidate</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <return>return <expr><name>pCandidate</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* No match was found.  We will make a new file ID */</comment>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nName</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>vxworksFileList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>vxworksFileList</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decrement the reference count on a vxworksFileId object.  Free
** the object when the reference count reaches zero.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vxworksReleaseFileId</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vxworksFileId</name></name> <modifier>*</modifier></type><name>pId</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pId</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pId</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pId</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>vxworksFileId</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name>vxworksFileList</name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pp</name><operator>!=</operator><name>pId</name></expr>;</condition> <incr><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pp</name><operator>==</operator><name>pId</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pId</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OS_VXWORKS */</comment>
<comment type="block" format="doxygen">/*************** End of Unique File ID Utility Used By VxWorks ****************
******************************************************************************/</comment>


<comment type="block" format="doxygen">/******************************************************************************
*************************** Posix Advisory Locking ****************************
**
** POSIX advisory locks are broken by design.  ANSI STD 1003.1 (1996)
** section 6.5.2.2 lines 483 through 490 specify that when a process
** sets or clears a lock, that operation overrides any prior locks set
** by the same process.  It does not explicitly say so, but this implies
** that it overrides locks set by the same process using a different
** file descriptor.  Consider this test case:
**
**       int fd1 = open("./file1", O_RDWR|O_CREAT, 0644);
**       int fd2 = open("./file2", O_RDWR|O_CREAT, 0644);
**
** Suppose ./file1 and ./file2 are really the same file (because
** one is a hard or symbolic link to the other) then if you set
** an exclusive lock on fd1, then try to get an exclusive lock
** on fd2, it works.  I would have expected the second lock to
** fail since there was already a lock on the file due to fd1.
** But not so.  Since both locks came from the same process, the
** second overrides the first, even though they were on different
** file descriptors opened on different file names.
**
** This means that we cannot use POSIX locks to synchronize file access
** among competing threads of the same process.  POSIX locks will work fine
** to synchronize access for threads in separate processes, but not
** threads within the same process.
**
** To work around the problem, SQLite has to manage file locks internally
** on its own.  Whenever a new database is opened, we have to find the
** specific inode of the database file (the inode is determined by the
** st_dev and st_ino fields of the stat structure that fstat() fills in)
** and check for locks already existing on that inode.  When locks are
** created or removed, we have to look at our own internal record of the
** locks to see if another thread has previously set a lock on that same
** inode.
**
** (Aside: The use of inode numbers as unique IDs does not work on VxWorks.
** For VxWorks, we have to use the alternative unique ID system based on
** canonical filename and implemented in the previous division.)
**
** The sqlite3_file structure for POSIX is no longer just an integer file
** descriptor.  It is now a structure that holds the integer file
** descriptor and a pointer to a structure that describes the internal
** locks on the corresponding inode.  There is one locking structure
** per inode, so if the same inode is opened twice, both unixFile structures
** point to the same locking structure.  The locking structure keeps
** a reference count (so we will know when to delete it) and a "cnt"
** field that tells us its internal lock status.  cnt==0 means the
** file is unlocked.  cnt==-1 means the file has an exclusive lock.
** cnt&gt;0 means there are cnt shared locks on the file.
**
** Any attempt to lock or unlock a file first checks the locking
** structure.  The fcntl() system call is only invoked to set a 
** POSIX lock if the internal lock structure transitions between
** a locked and an unlocked state.
**
** But wait:  there are yet more problems with POSIX advisory locks.
**
** If you close a file descriptor that points to a file that has locks,
** all locks on that file that are owned by the current process are
** released.  To work around this problem, each unixInodeInfo object
** maintains a count of the number of pending locks on tha inode.
** When an attempt is made to close an unixFile, if there are
** other unixFile open on the same inode that are holding locks, the call
** to close() the file descriptor is deferred until all of the locks clear.
** The unixInodeInfo structure keeps a list of file descriptors that need to
** be closed and that list is walked (and cleared) when the last lock
** clears.
**
** Yet another problem:  LinuxThreads do not play well with posix locks.
**
** Many older versions of linux use the LinuxThreads library which is
** not posix compliant.  Under LinuxThreads, a lock created by thread
** A cannot be modified or overridden by a different thread B.
** Only thread A can modify the lock.  Locking behavior is correct
** if the appliation uses the newer Native Posix Thread Library (NPTL)
** on linux - with NPTL a lock created by thread A can override locks
** in thread B.  But there is no way to know at compile-time which
** threading library is being used.  So there is no way to know at
** compile-time whether or not thread A can override locks on thread B.
** One has to do a run-time check to discover the behavior of the
** current process.
**
** SQLite used to support LinuxThreads.  But support for LinuxThreads
** was dropped beginning with version 3.7.0.  SQLite will still work with
** LinuxThreads provided that (1) there is no more than one connection 
** per database file in the same process and (2) database connections
** do not move across threads.
*/</comment>

<comment type="block">/*
** An instance of the following structure serves as the key used
** to locate a particular unixInodeInfo object.
*/</comment>
<struct>struct <name>unixFileId</name> <block>{
  <decl_stmt><decl><type><name>dev_t</name></type> <name>dev</name></decl>;</decl_stmt>                  <comment type="block">/* Device number */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>vxworksFileId</name></name> <modifier>*</modifier></type><name>pId</name></decl>;</decl_stmt>  <comment type="block">/* Unique file ID for vxworks. */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>ino_t</name></type> <name>ino</name></decl>;</decl_stmt>                  <comment type="block">/* Inode number */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** An instance of the following structure is allocated for each open
** inode.  Or, on LinuxThreads, there is one of these structures for
** each inode opened by each thread.
**
** A single inode can have multiple file descriptors, so each unixFile
** structure contains a pointer to an instance of this object and this
** object keeps a count of the number of unixFile pointing to it.
*/</comment>
<struct>struct <name>unixInodeInfo</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>unixFileId</name></name></type> <name>fileId</name></decl>;</decl_stmt>       <comment type="block">/* The lookup key */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nShared</name></decl>;</decl_stmt>                    <comment type="block">/* Number of SHARED locks held */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>eFileLock</name></decl>;</decl_stmt>        <comment type="block">/* One of SHARED_LOCK, RESERVED_LOCK etc. */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>bProcessLock</name></decl>;</decl_stmt>     <comment type="block">/* An exclusive process lock is held */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                       <comment type="block">/* Number of pointers to this structure */</comment>
  <decl_stmt><decl><type><name>unixShmNode</name> <modifier>*</modifier></type><name>pShmNode</name></decl>;</decl_stmt>          <comment type="block">/* Shared memory associated with this inode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLock</name></decl>;</decl_stmt>                      <comment type="block">/* Number of outstanding file locks */</comment>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pUnused</name></decl>;</decl_stmt>          <comment type="block">/* Unused file descriptors to close */</comment>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>           <comment type="block">/* List of all unixInodeInfo objects */</comment>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pPrev</name></decl>;</decl_stmt>           <comment type="block">/*    .... doubly linked */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>sharedByte</name></decl>;</decl_stmt>  <comment type="block">/* for AFP simulated shared lock */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <decl_stmt><decl><type><name>sem_t</name> <modifier>*</modifier></type><name>pSem</name></decl>;</decl_stmt>                    <comment type="block">/* Named POSIX semaphore */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aSemName</name><index>[<expr><name>MAX_PATHNAME</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Name of that semaphore */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** A lists of all unixInodeInfo objects.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unixInodeInfo</name> <modifier>*</modifier></type><name>inodeList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
**
** This function - unixLogErrorAtLine(), is only ever called via the macro
** unixLogError().
**
** It is invoked after an error occurs in an OS function and errno has been
** set. It logs a message using sqlite3_log() containing the current value of
** errno and, if possible, the human-readable equivalent from strerror() or
** strerror_r().
**
** The first argument passed to the macro should be the error code that
** will be returned to SQLite (e.g. SQLITE_IOERR_DELETE, SQLITE_CANTOPEN). 
** The two subsequent arguments should be the name of the OS function that
** failed (e.g. "unlink", "open") and the associated file-system path,
** if any.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unixLogError</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>unixLogErrorAtLine(a,b,c,__LINE__)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixLogErrorAtLine</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>,                    <comment type="block">/* SQLite error code */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>,              <comment type="block">/* Name of OS function that failed */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,              <comment type="block">/* File path associated with error */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLine</name></decl></parameter>                       <comment type="block">/* Source line number where error occurred */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>                     <comment type="block">/* Message from strerror() or equivalent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iErrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Saved syscall error number */</comment>

  <comment type="block">/* If this is not a threadsafe build (SQLITE_THREADSAFE==0), then use
  ** the strerror() function to obtain the human-readable error message
  ** equivalent to errno. Otherwise, use strerror_r().
  */</comment> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRERROR_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aErr</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aErr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aErr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <name>aErr</name></expr>;</expr_stmt>

  <comment type="block">/* If STRERROR_R_CHAR_P (set by autoconf scripts) or __USE_GNU is defined,
  ** assume that the system provides the GNU version of strerror_r() that
  ** returns a pointer to a buffer containing the error message. That pointer 
  ** may point to aErr[], or it may point to some static storage somewhere. 
  ** Otherwise, assume that the system provides the POSIX version of 
  ** strerror_r(), which always writes an error message into aErr[].
  **
  ** If the code incorrectly assumes that it is the POSIX version that is
  ** available, the error message will often be an empty string. Not a
  ** huge problem. Incorrectly concluding that the GNU version is available 
  ** could lead to a segfault though.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STRERROR_R_CHAR_P</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__USE_GNU</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> 
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
  <call><name>strerror_r</name><argument_list>(<argument><expr><name>iErrno</name></expr></argument>, <argument><expr><name>aErr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aErr</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:elif>
  <comment type="block">/* This is a threadsafe build, but strerror_r() is not available. */</comment>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* Non-threadsafe build, use strerror(). */</comment>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>strerror</name><argument_list>(<argument><expr><name>iErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>zPath</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zPath</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>,
      <argument><expr><literal type="string">"os_unix.c:%d: (%d) %s(%s) - %s"</literal></expr></argument>,
      <argument><expr><name>iLine</name></expr></argument>, <argument><expr><name>iErrno</name></expr></argument>, <argument><expr><name>zFunc</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>errcode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a file descriptor.
**
** We assume that close() almost always works, since it is only in a
** very sick application or on a very sick platform that it might fail.
** If it does fail, simply leak the file descriptor, but do log the
** error.
**
** Note that it is not safe to retry close() after EINTR since the
** file descriptor might have already been reused by another thread.
** So we don't even try to recover from an EINTR.  Just log the error
** and move on.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>robust_close</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>osClose</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>unixLogErrorAtLine</name><argument_list>(<argument><expr><name>SQLITE_IOERR_CLOSE</name></expr></argument>, <argument><expr><literal type="string">"close"</literal></expr></argument>,
                       <argument><expr><ternary><condition><expr><name>pFile</name></expr> ?</condition><then> <expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the pFile-&gt;lastErrno.  Do this in a subroutine as that provides
** a convenient place to set a breakpoint.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>storeLastErrno</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close all file descriptors accumuated in the unixInodeInfo-&gt;pUnused list.
*/</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> <name>closePendingFds</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pInode</name><operator>-&gt;</operator><name>pUnused</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pUnused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Release a unixInodeInfo structure previously allocated by findInodeInfo().
**
** The mutex entered using the unixEnterMutex() function must be held
** when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>releaseInodeInfo</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>unixMutexHeld</name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pInode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>pShmNode</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>closePendingFds</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>pPrev</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><name>pInode</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>inodeList</name><operator>==</operator><name>pInode</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inodeList</name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pPrev</name></name><operator>==</operator><name>pInode</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pInode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Given a file descriptor, locate the unixInodeInfo object that
** describes that file descriptor.  Create a new one if necessary.  The
** return value might be uninitialized if an error occurs.
**
** The mutex entered using the unixEnterMutex() function must be held
** when this function is called.
**
** Return an appropriate error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>findInodeInfo</name><parameter_list>(
  <parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,               <comment type="block">/* Unix file with file desc used in the key */</comment>
  <parameter><decl><type><name>unixInodeInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppInode</name></decl></parameter>        <comment type="block">/* Return the unixInodeInfo object here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                        <comment type="block">/* System call return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>                        <comment type="block">/* The file descriptor for pFile */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>unixFileId</name></name></type> <name>fileId</name></decl>;</decl_stmt>      <comment type="block">/* Lookup key for the unixInodeInfo */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>           <comment type="block">/* Low-level file information */</comment>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Candidate unixInodeInfo object */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>unixMutexHeld</name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get low-level information about the file that we can used to
  ** create a unique name for the file.
  */</comment>
  <expr_stmt><expr><name>fd</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EOVERFLOW</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DISABLE_LFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name><operator>==</operator><name>EOVERFLOW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOLFS</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
  <comment type="block">/* On OS X on an msdos filesystem, the inode number is reported
  ** incorrectly for zero-size files.  See ticket #3260.  To work
  ** around this problem (we consider it a bug in OS X, not SQLite)
  ** we always increase the file size to 1 by writing a single byte
  ** prior to accessing the inode number.  The one byte written is
  ** an ASCII 'S' character which also happens to be the first byte
  ** in the header of every SQLite database.  In this way, if there
  ** is a race condition such that another thread has already populated
  ** the first page of the database, no damage is done.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>fsFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FSFLAGS_IS_MSDOS</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <do>do<block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osWrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"S"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>EINTR</name></expr> )</condition>;</do>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fileId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fileId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fileId</name><operator>.</operator><name>dev</name></name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_dev</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <expr_stmt><expr><name><name>fileId</name><operator>.</operator><name>pId</name></name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pId</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>fileId</name><operator>.</operator><name>ino</name></name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_ino</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name>inodeList</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pInode</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fileId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInode</name><operator>-&gt;</operator><name>fileId</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fileId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pInode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pInode</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pInode</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pInode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pInode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pInode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInode</name><operator>-&gt;</operator><name>fileId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileId</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fileId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>inodeList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>inodeList</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>inodeList</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pInode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>inodeList</name> <operator>=</operator> <name>pInode</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppInode</name> <operator>=</operator> <name>pInode</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if pFile has been renamed or unlinked since it was first opened.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fileHasMoved</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <return>return <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pId</name></name><operator>!=</operator><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>fileId</name><operator>.</operator><name>pId</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
  <return>return <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <operator>(</operator><call><name>osStat</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>buf</name><operator>.</operator><name>st_ino</name></name><operator>!=</operator><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>fileId</name><operator>.</operator><name>ino</name></name><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
** Check a unixFile that is a database.  Verify the following:
**
** (1) There is exactly one hard link on the file
** (2) The file is not a symbolic link
** (3) The file has not been renamed or unlinked
**
** Issue sqlite3_log(SQLITE_WARNING,...) messages if anything is not right.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>verifyDbFile</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFstat</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_WARNING</name></expr></argument>, <argument><expr><literal type="string">"cannot fstat db file %s"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>buf</name><operator>.</operator><name>st_nlink</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>UNIXFILE_DELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_WARNING</name></expr></argument>, <argument><expr><literal type="string">"file unlinked while open: %s"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>buf</name><operator>.</operator><name>st_nlink</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_WARNING</name></expr></argument>, <argument><expr><literal type="string">"multiple links to file: %s"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fileHasMoved</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_WARNING</name></expr></argument>, <argument><expr><literal type="string">"file renamed while open: %s"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>

  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&lt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Because pFile-&gt;pInode is shared across threads */</comment>

  <comment type="block">/* Check if a thread in this process holds such a lock */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>reserved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Otherwise see if some other process holds it.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__DJGPP__</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>reserved</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>bProcessLock</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>lock</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>RESERVED_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_WRLCK</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>osFcntl</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_GETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_CHECKRESERVEDLOCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if<condition>( <expr><name><name>lock</name><operator>.</operator><name>l_type</name></name><operator>!=</operator><name>F_UNLCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>reserved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEST WR-LOCK %d %d %d (unix)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>rc</name><operator>,</operator> <name>reserved</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to set a system-lock on the file pFile.  The lock is 
** described by pLock.
**
** If the pFile was opened read/write from unix-excl, then the only lock
** ever obtained is an exclusive lock, and it is obtained exactly once
** the first time any lock is attempted.  All subsequent system locking
** operations become no-ops.  Locking operations still happen internally,
** in order to coordinate access between separate database connections
** within this process, but all of that is handled in memory and the
** operating system does not participate.
**
** This function is a pass-through to fcntl(F_SETLK) if pFile is using
** any VFS other than "unix-excl" or if pFile is opened on "unix-excl"
** and is read-only.
**
** Zero is returned if the call completes successfully, or -1 if a call
** to fcntl() fails. In this case, errno is set appropriately (by fcntl()).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixFileLock</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>flock</name></name> <modifier>*</modifier></type><name>pLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>unixMutexHeld</name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pInode</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>UNIXFILE_EXCL</name><operator>|</operator><name>UNIXFILE_RDONLY</name><operator>)</operator><operator>)</operator><operator>==</operator><name>UNIXFILE_EXCL</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>bProcessLock</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>lock</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>SHARED_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_WRLCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFcntl</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>bProcessLock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFcntl</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* The following describes the implementation of the various locks and
  ** lock transitions in terms of the POSIX advisory shared and exclusive
  ** lock primitives (called read-locks and write-locks below, to avoid
  ** confusion with SQLite lock names). The algorithms are complicated
  ** slightly in order to be compatible with windows systems simultaneously
  ** accessing the same database file, in case that is ever required.
  **
  ** Symbols defined in os.h indentify the 'pending byte' and the 'reserved
  ** byte', each single bytes at well known offsets, and the 'shared byte
  ** range', a range of 510 bytes at a well known offset.
  **
  ** To obtain a SHARED lock, a read-lock is obtained on the 'pending
  ** byte'.  If this is successful, a random byte from the 'shared byte
  ** range' is read-locked and the lock on the 'pending byte' released.
  **
  ** A process may only obtain a RESERVED lock after it has a SHARED lock.
  ** A RESERVED lock is implemented by grabbing a write-lock on the
  ** 'reserved byte'. 
  **
  ** A process may only obtain a PENDING lock after it has obtained a
  ** SHARED lock. A PENDING lock is implemented by obtaining a write-lock
  ** on the 'pending byte'. This ensures that no new SHARED locks can be
  ** obtained, but existing SHARED locks are allowed to persist. A process
  ** does not have to obtain a RESERVED lock on the way to a PENDING lock.
  ** This property is used by the algorithm for rolling back a journal file
  ** after a crash.
  **
  ** An EXCLUSIVE lock, obtained after a PENDING lock is held, is
  ** implemented by obtaining a write-lock on the entire 'shared byte
  ** range'. Since all other locks require a read-lock on one of the bytes
  ** within this range, this ensures that no other locks are held on the
  ** database. 
  **
  ** The reason a single byte cannot be used instead of the 'shared byte
  ** range' is that some versions of windows do not support read-locks. By
  ** locking a random byte from a range, concurrent SHARED locks may exist
  ** even if the locking primitive used is always a write-lock.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK    %d %s was %s(%s,%d) pid=%d (unix)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator>
      <call><name>azFileLock</name><argument_list>(<argument><expr><name>eFileLock</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>azFileLock</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name></expr></argument>)</argument_list></call><operator>,</operator>
      <call><name>azFileLock</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name></expr></argument>)</argument_list></call><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>,</operator>
      <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is already a lock of this type or more restrictive on the
  ** unixFile, do nothing. Don't use the end_lock: exit path, as
  ** unixEnterMutex() hasn't been called yet.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;=</operator><name>eFileLock</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK    %d %s ok (already held) (unix)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator>
            <call><name>azFileLock</name><argument_list>(<argument><expr><name>eFileLock</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure the locking sequence is correct.
  **  (1) We never move from unlocked to anything higher than shared lock.
  **  (2) SQLite never explicitly requests a pendig lock.
  **  (3) A shared lock is always held when a reserve lock is requested.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>!=</operator><name>NO_LOCK</name> <operator>||</operator> <name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>!=</operator><name>PENDING_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>!=</operator><name>RESERVED_LOCK</name> <operator>||</operator> <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This mutex is needed because pFile-&gt;pInode is shared across threads
  */</comment>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr>;</expr_stmt>

  <comment type="block">/* If some thread using this PID has a lock via a different unixFile*
  ** handle that precludes the requested lock, return BUSY.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>!=</operator><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>&amp;&amp;</operator> 
          <operator>(</operator><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;=</operator><name>PENDING_LOCK</name> <operator>||</operator> <name>eFileLock</name><operator>&gt;</operator><name>SHARED_LOCK</name><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>end_lock</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If a SHARED lock is requested, and some thread using this PID already
  ** has a SHARED or RESERVED lock, then increment reference counts and
  ** return SQLITE_OK.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name> <operator>&amp;&amp;</operator> 
      <operator>(</operator><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>SHARED_LOCK</name> <operator>||</operator> <name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>RESERVED_LOCK</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>end_lock</name>;</goto>
  </block_content>}</block></if></if_stmt>


  <comment type="block">/* A PENDING lock is needed before acquiring a SHARED lock and before
  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will
  ** be released.
  */</comment>
  <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">1L</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name> 
      <operator>||</operator> <operator>(</operator><name>eFileLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&lt;</operator><name>PENDING_LOCK</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr>?</condition><then><expr><name>F_RDLCK</name></expr></then><else>:<expr><name>F_WRLCK</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>unixFileLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>end_lock</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>


  <comment type="block">/* If control gets to this point, then actually go ahead and make
  ** operating system calls for the specified lock.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now get the read-lock */</comment>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>SHARED_SIZE</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>unixFileLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Drop the temporary PENDING lock */</comment>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">1L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_UNLCK</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>unixFileLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This could happen with a network mount */</comment>
      <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_UNLOCK</name></expr>;</expr_stmt> 
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>end_lock</name>;</goto>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name> <operator>&amp;&amp;</operator> <name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* We are trying for an exclusive lock but another thread in this
    ** same process is still holding a shared lock. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The request was for a RESERVED or EXCLUSIVE lock.  It is
    ** assumed that there is a SHARED or greater lock on the file
    ** already.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>!=</operator><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_WRLCK</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>==</operator><name>RESERVED_LOCK</name> <operator>||</operator> <name>eFileLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>RESERVED_LOCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>RESERVED_BYTE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">1L</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>SHARED_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>unixFileLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Set up the transaction-counter change checking flags when
  ** transitioning from a SHARED to a RESERVED lock.  The change
  ** from SHARED to RESERVED marks the beginning of a normal
  ** write operation (not a hot journal rollback).
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name>
   <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&lt;=</operator><name>SHARED_LOCK</name>
   <operator>&amp;&amp;</operator> <name>eFileLock</name><operator>==</operator><name>RESERVED_LOCK</name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>transCntrChng</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>dbUpdate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>inNormalWrite</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>PENDING_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>PENDING_LOCK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>end_lock</name>:</label>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK    %d %s %s (unix)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <call><name>azFileLock</name><argument_list>(<argument><expr><name>eFileLock</name></expr></argument>)</argument_list></call><operator>,</operator> 
      <ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add the file descriptor used by file handle pFile to the corresponding
** pUnused list.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setPendingFd</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pUnused</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pUnused</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>pUnused</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pUnused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
** 
** If handleNFSUnlock is true, then on downgrading an EXCLUSIVE_LOCK to SHARED
** the byte range is divided into 2 parts and the first part is unlocked then
** set to a read lock, then the other part is simply unlocked.  This works 
** around a bug in BSD NFS lockd (also seen on MacOSX 10.3+) that fails to 
** remove the write lock on a region when a read lock is set.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>posixUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>handleNFSUnlock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNLOCK  %d %d was %d(%d,%d) pid=%d (unix)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>eFileLock</name><operator>,</operator>
      <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>,</operator>
      <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>&lt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&lt;=</operator><name>eFileLock</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <comment type="block">/* When reducing a lock such that other processes can start
    ** reading the database file again, make sure that the
    ** transaction counter was updated if any part of the database
    ** file changed.  If the transaction counter is not updated,
    ** other connections to the same file might not realize that
    ** the file has changed and hence might not know to flush their
    ** cache.  The use of a stale cache can lead to database corruption.
    */</comment>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>inNormalWrite</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* downgrading to a shared lock on NFS involves clearing the write lock
    ** before establishing the readlock - to avoid a race condition we downgrade
    ** the lock in 2 blocks, so that part of the range will be covered by a 
    ** write lock until the rest is covered by a read lock:
    **  1:   [WWWWW]
    **  2:   [....W]
    **  3:   [RRRRW]
    **  4:   [RRRR.]
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>handleNFSUnlock</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>handleNFSUnlock</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
      <if_stmt><if>if<condition>( <expr><name>handleNFSUnlock</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name></decl>;</decl_stmt>               <comment type="block">/* Error code from system call errors */</comment>
        <decl_stmt><decl><type><name>off_t</name></type> <name>divSize</name> <init>= <expr><name>SHARED_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_UNLCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>divSize</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>unixFileLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_UNLOCK</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>end_unlock</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_RDLCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>divSize</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>unixFileLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_RDLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <goto>goto <name>end_unlock</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_UNLCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name><operator>+</operator><name>divSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>SHARED_SIZE</name><operator>-</operator><name>divSize</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>unixFileLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>tErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_UNLOCK</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>end_unlock</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__APPLE__) &amp;&amp; SQLITE_ENABLE_LOCKING_STYLE */</comment>
      <block>{<block_content>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_RDLCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>SHARED_FIRST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>SHARED_SIZE</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>unixFileLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <comment type="block">/* In theory, the call to unixFileLock() cannot fail because another
          ** process is holding an incompatible lock. If it does, this 
          ** indicates that the other process is not following the locking
          ** protocol. If this happens, return SQLITE_IOERR_RDLOCK. Returning
          ** SQLITE_BUSY would confuse the upper layer (in practice it causes 
          ** an assert to fail). */</comment> 
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_RDLOCK</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>end_unlock</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_UNLCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">2L</literal></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PENDING_BYTE</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>RESERVED_BYTE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>unixFileLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_UNLOCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>end_unlock</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>NO_LOCK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Decrement the shared lock counter.  Release the lock using an
    ** OS call only when all threads in this same process have released
    ** the lock.
    */</comment>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_UNLCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name><name>lock</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>unixFileLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_UNLOCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Decrement the count of locks against this same file.  When the
    ** count reaches zero, close any other file descriptors whose close
    ** was deferred because of outstanding locks.
    */</comment>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>closePendingFds</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>end_unlock</name>:</label>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name> <operator>||</operator> <operator>(</operator><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>nFetchOut</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>posixUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>eFileLock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>unixMapfile</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unixUnmapfile</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function performs the parts of the "close file" operation 
** common to all locking schemes. It closes the directory and file
** handles, if they are valid, and sets all fields of the unixFile
** structure to 0.
**
** It is *not* necessary to hold the mutex when this routine is called,
** even on VxWorks.  A mutex will be acquired on VxWorks by the
** vxworksReleaseFileId() routine.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closeUnixFile</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>unixUnmapfile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pId</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>UNIXFILE_DELETE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>osUnlink</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pId</name><operator>-&gt;</operator><name>zCanonicalName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>vxworksReleaseFileId</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_UNLINK_AFTER_CLOSE</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>UNIXFILE_DELETE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>osUnlink</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"CLOSE   %-3d\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OpenCounter</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pUnused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unixFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>verifyDbFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* unixFile.pInode is always valid here. Otherwise, a different close
  ** routine (e.g. nolockClose()) would be called instead.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>bProcessLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there are outstanding locks, do not actually close the file just
    ** yet because that would clear those locks.  Instead, add the file
    ** descriptor to pInode-&gt;pUnused list.  It will be automatically closed 
    ** when the last lock is cleared.
    */</comment>
    <expr_stmt><expr><call><name>setPendingFd</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>releaseInodeInfo</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************** End of the posix advisory lock implementation *****************
******************************************************************************/</comment>

<comment type="block" format="doxygen">/******************************************************************************
****************************** No-op Locking **********************************
**
** Of the various locking implementations available, this is by far the
** simplest:  locking is ignored.  No attempt is made to lock the database
** file for reading or writing.
**
** This locking mode is appropriate for use on read-only databases
** (ex: databases that are burned into CD-ROM, for example.)  It can
** also be used if the application employs some external mechanism to
** prevent simultaneous access of the same database by two or more
** database connections.  But there is a serious risk of database
** corruption if this locking mode is used in situations where multiple
** database connections are accessing the same database file at the same
** time and one or more of those connections are writing.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>nolockCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nolockLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>NotUsed2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nolockUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>NotUsed2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close the file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nolockClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************* End of the no-op lock implementation *********************
******************************************************************************/</comment>

<comment type="block" format="doxygen">/******************************************************************************
************************* Begin dot-file Locking ******************************
**
** The dotfile locking implementation uses the existence of separate lock
** files (really a directory) to control access to the database.  This works
** on just about every filesystem imaginable.  But there are serious downsides:
**
**    (1)  There is zero concurrency.  A single reader blocks all other
**         connections from reading or writing the database.
**
**    (2)  An application crash or power loss can leave stale lock files
**         sitting around that need to be cleared manually.
**
** Nevertheless, a dotlock is an appropriate locking mode for use if no
** other locking strategy is available.
**
** Dotfile locking works by creating a subdirectory in the same directory as
** the database and with the same name but with a ".lock" extension added.
** The existence of a lock directory implies an EXCLUSIVE lock.  All other
** lock types (SHARED, RESERVED, PENDING) are mapped into EXCLUSIVE.
*/</comment>

<comment type="block">/*
** The file suffix added to the data base filename in order to create the
** lock directory.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOTLOCK_SUFFIX</name></cpp:macro> <cpp:value>".lock"</cpp:value></cpp:define>

<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
**
** In dotfile locking, either a lock exists or it does not.  So in this
** variation of CheckReservedLock(), *pResOut is set to true if any lock
** is held on the file and false if the file is unlocked.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dotlockCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>

  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>reserved</name> <operator>=</operator> <call><name>osAccess</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEST WR-LOCK %d %d %d (dotlock)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>rc</name><operator>,</operator> <name>reserved</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
**
** With dotfile locking, we really only support state (4): EXCLUSIVE.
** But we track the other locking levels internally.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dotlockLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLockFile</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>


  <comment type="block">/* If we have any lock, then the lock file already exists.  All we have
  ** to do is adjust our internal record of the lock level.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>&gt;</operator> <name>NO_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
    <comment type="block">/* Always update the timestamp on the old file */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIME</name></cpp:ifdef>
    <expr_stmt><expr><call><name>utime</name><argument_list>(<argument><expr><name>zLockFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>utimes</name><argument_list>(<argument><expr><name>zLockFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* grab an exclusive lock */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osMkdir</name><argument_list>(<argument><expr><name>zLockFile</name></expr></argument>, <argument><expr><literal type="number">0777</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* failed to open/create the lock directory */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>EEXIST</name> <operator>==</operator> <name>tErrno</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt> 
  
  <comment type="block">/* got it, set the type and return ok */</comment>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
**
** When the locking level reaches NO_LOCK, delete the lock file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dotlockUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLockFile</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNLOCK  %d %d was %d pid=%d (dotlock)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>eFileLock</name><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>,</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>&lt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* no-op if possible */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>eFileLock</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* To downgrade to shared, simply update our internal notion of the
  ** lock state.  No need to mess with the file on disk.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* To fully unlock the database, delete the lock file */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>==</operator><name>NO_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osRmdir</name><argument_list>(<argument><expr><name>zLockFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>tErrno</name><operator>==</operator><name>ENOENT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_UNLOCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a file.  Make sure the lock has been released before closing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dotlockClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dotlockUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/****************** End of the dot-file lock implementation *******************
******************************************************************************/</comment>

<comment type="block" format="doxygen">/******************************************************************************
************************** Begin flock Locking ********************************
**
** Use the flock() system call to do file locking.
**
** flock() locking is like dot-file locking in that the various
** fine-grain locking levels supported by SQLite are collapsed into
** a single exclusive lock.  In other words, SHARED, RESERVED, and
** PENDING locks are the same thing as an EXCLUSIVE lock.  SQLite
** still works when you do this, but concurrency is reduced since
** only a single process can be reading the database at a time.
**
** Omit this section if SQLITE_ENABLE_LOCKING_STYLE is turned off
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>

<comment type="block">/*
** Retry flock() calls that fail with EINTR
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EINTR</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>robust_flock</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <do>do<block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>flock</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>EINTR</name></expr> )</condition>;</do>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>robust_flock</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>flock(a,b)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
     

<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>flockCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check if a thread in this process holds such a lock */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>reserved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Otherwise see if some other process holds it. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>reserved</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* attempt to get the lock */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lrc</name> <init>= <expr><call><name>robust_flock</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>LOCK_EX</name> <operator>|</operator> <name>LOCK_NB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>lrc</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* got the lock, unlock it */</comment>
      <expr_stmt><expr><name>lrc</name> <operator>=</operator> <call><name>robust_flock</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>LOCK_UN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>( <expr><name>lrc</name></expr> )</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* unlock failed with an error */</comment>
        <expr_stmt><expr><name>lrc</name> <operator>=</operator> <name>SQLITE_IOERR_UNLOCK</name></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>lrc</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>reserved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <comment type="block">/* someone else might have it reserved */</comment>
      <expr_stmt><expr><name>lrc</name> <operator>=</operator> <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>lrc</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEST WR-LOCK %d %d %d (flock)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>rc</name><operator>,</operator> <name>reserved</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_IGNORE_FLOCK_LOCK_ERRORS</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>&amp;</operator> <name>SQLITE_IOERR</name><operator>)</operator> <operator>==</operator> <name>SQLITE_IOERR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reserved</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */</comment>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** flock() only really support EXCLUSIVE locks.  We track intermediate
** lock states in the sqlite3_file structure, but all locks SHARED or
** above are really EXCLUSIVE locks and exclude all other processes from
** access the file.
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>flockLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* if we already have a lock, it is exclusive.  
  ** Just adjust level and punt on outta here. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>&gt;</operator> <name>NO_LOCK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* grab an exclusive lock */</comment>
  
  <if_stmt><if>if <condition>(<expr><call><name>robust_flock</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>LOCK_EX</name> <operator>|</operator> <name>LOCK_NB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* didn't get, must be busy */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* got it, set the type and return ok */</comment>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK    %d %s %s (flock)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <call><name>azFileLock</name><argument_list>(<argument><expr><name>eFileLock</name></expr></argument>)</argument_list></call><operator>,</operator> 
           <ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_IGNORE_FLOCK_LOCK_ERRORS</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>&amp;</operator> <name>SQLITE_IOERR</name><operator>)</operator> <operator>==</operator> <name>SQLITE_IOERR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>flockUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNLOCK  %d %d was %d pid=%d (flock)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>eFileLock</name><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>,</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>&lt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* no-op if possible */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>eFileLock</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* shared can just be set because we always have an exclusive */</comment>
  <if_stmt><if>if <condition>(<expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* no, really, unlock. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>robust_flock</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>LOCK_UN</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_IGNORE_FLOCK_LOCK_ERRORS</name></cpp:ifdef>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */</comment>
    <return>return <expr><name>SQLITE_IOERR_UNLOCK</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>flockClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>flockUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_LOCKING_STYLE &amp;&amp; !OS_VXWORK */</comment>

<comment type="block" format="doxygen">/******************* End of the flock lock implementation *********************
******************************************************************************/</comment>

<comment type="block" format="doxygen">/******************************************************************************
************************ Begin Named Semaphore Locking ************************
**
** Named semaphore locking is only supported on VxWorks.
**
** Semaphore locking is like dot-lock and flock in that it really only
** supports EXCLUSIVE locking.  Only a single process can read or write
** the database file at a time.  This reduces potential concurrency, but
** makes the lock implementation much easier.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>

<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>semXCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>

  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check if a thread in this process holds such a lock */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>reserved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Otherwise see if some other process holds it. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>reserved</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sem_t</name> <modifier>*</modifier></type><name>pSem</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pSem</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>sem_trywait</name><argument_list>(<argument><expr><name>pSem</name></expr></argument>)</argument_list></call><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>EAGAIN</name> <operator>!=</operator> <name>tErrno</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_CHECKRESERVEDLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* someone else has the lock when we are in NO_LOCK */</comment>
        <expr_stmt><expr><name>reserved</name> <operator>=</operator> <operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>&lt;</operator> <name>SHARED_LOCK</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* we could have it if we want it */</comment>
      <expr_stmt><expr><call><name>sem_post</name><argument_list>(<argument><expr><name>pSem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEST WR-LOCK %d %d %d (sem)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>rc</name><operator>,</operator> <name>reserved</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** Semaphore locks only really support EXCLUSIVE locks.  We track intermediate
** lock states in the sqlite3_file structure, but all locks SHARED or
** above are really EXCLUSIVE locks and exclude all other processes from
** access the file.
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>semXLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sem_t</name> <modifier>*</modifier></type><name>pSem</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pSem</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* if we already have a lock, it is exclusive.  
  ** Just adjust level and punt on outta here. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>&gt;</operator> <name>NO_LOCK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <goto>goto <name>sem_end_lock</name>;</goto>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* lock semaphore now but bail out when already locked. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sem_trywait</name><argument_list>(<argument><expr><name>pSem</name></expr></argument>)</argument_list></call><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>sem_end_lock</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* got it, set the type and return ok */</comment>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>

 <label><name>sem_end_lock</name>:</label>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>semXUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sem_t</name> <modifier>*</modifier></type><name>pSem</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pSem</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNLOCK  %d %d was %d pid=%d (sem)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>eFileLock</name><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>,</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>&lt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* no-op if possible */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>eFileLock</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* shared can just be set because we always have an exclusive */</comment>
  <if_stmt><if>if <condition>(<expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* no, really unlock. */</comment>
  <if_stmt><if>if <condition>( <expr><call><name>sem_post</name><argument_list>(<argument><expr><name>pSem</name></expr></argument>)</argument_list></call><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>tErrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 ** Close a file.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>semXClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>id</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>semXUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releaseInodeInfo</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OS_VXWORKS */</comment>
<comment type="block">/*
** Named semaphore locking is only available on VxWorks.
**
*************** End of the named semaphore lock implementation ****************
******************************************************************************/</comment>


<comment type="block" format="doxygen">/******************************************************************************
*************************** Begin AFP Locking *********************************
**
** AFP is the Apple Filing Protocol.  AFP is a network filesystem found
** on Apple Macintosh computers - both OS9 and OSX.
**
** Third-party implementations of AFP are available.  But this code here
** only works on OSX.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<comment type="block">/*
** The afpLockingContext structure contains all afp lock specific state
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>afpLockingContext</name></name></type> <name>afpLockingContext</name>;</typedef>
<struct>struct <name>afpLockingContext</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbPath</name></decl>;</decl_stmt>             <comment type="block">/* Name of the open file */</comment>
}</block>;</struct>

<struct>struct <name>ByteRangeLockPB2</name>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>offset</name></decl>;</decl_stmt>        <comment type="block">/* offset to first byte to lock */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>length</name></decl>;</decl_stmt>        <comment type="block">/* nbr of bytes to lock */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>retRangeStart</name></decl>;</decl_stmt> <comment type="block">/* nbr of 1st byte locked if successful */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>unLockFlag</name></decl>;</decl_stmt>         <comment type="block">/* 1 = unlock, 0 = lock */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>startEndFlag</name></decl>;</decl_stmt>       <comment type="block">/* 1=rel to end of fork, 0=rel to start */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>                           <comment type="block">/* file desc to assoc this lock with */</comment>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>afpfsByteRangeLock2FSCTL</name></cpp:macro>        <cpp:value>_IOWR('z', 23, struct ByteRangeLockPB2)</cpp:value></cpp:define>

<comment type="block">/*
** This is a utility for setting or clearing a bit-range lock on an
** AFP filesystem.
** 
** Return SQLITE_OK on success, SQLITE_BUSY on failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>afpSetLock</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,              <comment type="block">/* Name of the file to be locked or unlocked */</comment>
  <parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,               <comment type="block">/* Open file descriptor on path */</comment>
  <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>offset</name></decl></parameter>,     <comment type="block">/* First byte to be locked */</comment>
  <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>length</name></decl></parameter>,     <comment type="block">/* Number of bytes to lock */</comment>
  <parameter><decl><type><name>int</name></type> <name>setLockFlag</name></decl></parameter>                <comment type="block">/* True to set lock.  False to clear lock */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ByteRangeLockPB2</name></name></type> <name>pb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name><name>pb</name><operator>.</operator><name>unLockFlag</name></name> <operator>=</operator> <ternary><condition><expr><name>setLockFlag</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pb</name><operator>.</operator><name>startEndFlag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pb</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pb</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>length</name></expr>;</expr_stmt> 
  <expr_stmt><expr><name><name>pb</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"AFPSETLOCK [%s] for %d%s in range %llx:%llx\n"</literal><operator>,</operator> 
    <operator>(</operator><ternary><condition><expr><name>setLockFlag</name></expr>?</condition><then><expr><literal type="string">"ON"</literal></expr></then><else>:<expr><literal type="string">"OFF"</literal></expr></else></ternary><operator>)</operator><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <operator>(</operator><ternary><condition><expr><name><name>pb</name><operator>.</operator><name>fd</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr>?</condition><then><expr><literal type="string">"[testval-1]"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator><operator>,</operator>
    <name>offset</name><operator>,</operator> <name>length</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>fsctl</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>afpfsByteRangeLock2FSCTL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>( <expr><name>err</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"AFPSETLOCK failed to fsctl() '%s' %d %s\n"</literal><operator>,</operator>
             <name>path</name><operator>,</operator> <name>tErrno</name><operator>,</operator> <call><name>strerror</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_IGNORE_AFP_LOCK_ERRORS</name></cpp:ifdef>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>,
                    <argument><expr><ternary><condition><expr><name>setLockFlag</name></expr> ?</condition><then> <expr><name>SQLITE_IOERR_LOCK</name></expr> </then><else>: <expr><name>SQLITE_IOERR_UNLOCK</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_IGNORE_AFP_LOCK_ERRORS */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>afpCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>afpLockingContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
  
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>context</name> <operator>=</operator> <operator>(</operator><name>afpLockingContext</name> <operator>*</operator><operator>)</operator> <name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>context</name><operator>-&gt;</operator><name>reserved</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Because pFile-&gt;pInode is shared across threads */</comment>
  
  <comment type="block">/* Check if a thread in this process holds such a lock */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>reserved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Otherwise see if some other process holds it.
   */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>reserved</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* lock the RESERVED byte */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lrc</name> <init>= <expr><call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>lrc</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* if we succeeded in taking the reserved lock, unlock it to restore
      ** the original state */</comment>
      <expr_stmt><expr><name>lrc</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* if we failed to get the lock then someone else must have it */</comment>
      <expr_stmt><expr><name>reserved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name><operator>=</operator><name>lrc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEST WR-LOCK %d %d %d (afp)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>rc</name><operator>,</operator> <name>reserved</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>afpLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>afpLockingContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>(</operator><name>afpLockingContext</name> <operator>*</operator><operator>)</operator> <name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK    %d %s was %s(%s,%d) pid=%d (afp)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator>
           <call><name>azFileLock</name><argument_list>(<argument><expr><name>eFileLock</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>azFileLock</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name></expr></argument>)</argument_list></call><operator>,</operator>
           <call><name>azFileLock</name><argument_list>(<argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name></expr></argument>)</argument_list></call><operator>,</operator> <name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name> <operator>,</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is already a lock of this type or more restrictive on the
  ** unixFile, do nothing. Don't use the afp_end_lock: exit path, as
  ** unixEnterMutex() hasn't been called yet.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;=</operator><name>eFileLock</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK    %d %s ok (already held) (afp)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator>
           <call><name>azFileLock</name><argument_list>(<argument><expr><name>eFileLock</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure the locking sequence is correct
  **  (1) We never move from unlocked to anything higher than shared lock.
  **  (2) SQLite never explicitly requests a pendig lock.
  **  (3) A shared lock is always held when a reserve lock is requested.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>!=</operator><name>NO_LOCK</name> <operator>||</operator> <name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>!=</operator><name>PENDING_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>!=</operator><name>RESERVED_LOCK</name> <operator>||</operator> <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* This mutex is needed because pFile-&gt;pInode is shared across threads
  */</comment>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr>;</expr_stmt>

  <comment type="block">/* If some thread using this PID has a lock via a different unixFile*
  ** handle that precludes the requested lock, return BUSY.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>!=</operator><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>&amp;&amp;</operator> 
       <operator>(</operator><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;=</operator><name>PENDING_LOCK</name> <operator>||</operator> <name>eFileLock</name><operator>&gt;</operator><name>SHARED_LOCK</name><operator>)</operator><operator>)</operator></expr>
     )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>afp_end_lock</name>;</goto>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* If a SHARED lock is requested, and some thread using this PID already
  ** has a SHARED or RESERVED lock, then increment reference counts and
  ** return SQLITE_OK.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name> <operator>&amp;&amp;</operator> 
     <operator>(</operator><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>SHARED_LOCK</name> <operator>||</operator> <name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>RESERVED_LOCK</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>afp_end_lock</name>;</goto>
  </block_content>}</block></if></if_stmt>
    
  <comment type="block">/* A PENDING lock is needed before acquiring a SHARED lock and before
  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will
  ** be released.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name> 
      <operator>||</operator> <operator>(</operator><name>eFileLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&lt;</operator><name>PENDING_LOCK</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>failed</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>failed</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>failed</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>failed</name></expr>;</expr_stmt>
      <goto>goto <name>afp_end_lock</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* If control gets to this point, then actually go ahead and make
  ** operating system calls for the specified lock.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>lrc1</name></decl>, <decl><type ref="prev"/><name>lrc2</name></decl>, <decl><type ref="prev"/><name>lrc1Errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>lk</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        
    <expr_stmt><expr><name>mask</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal><operator>)</operator></expr> ?</condition><then> <expr><name>LARGEST_INT64</name></expr> </then><else>: <expr><literal type="number">0x7fffffff</literal></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* Now get the read-lock SHARED_LOCK */</comment>
    <comment type="block">/* note that the quality of the randomness doesn't matter that much */</comment>
    <expr_stmt><expr><name>lk</name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>sharedByte</name></name> <operator>=</operator> <operator>(</operator><name>lk</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>%</operator><operator>(</operator><name>SHARED_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>lrc1</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, 
          <argument><expr><name>SHARED_FIRST</name><operator>+</operator><name><name>pInode</name><operator>-&gt;</operator><name>sharedByte</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc1</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>lrc1Errno</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Drop the temporary PENDING lock */</comment>
    <expr_stmt><expr><name>lrc2</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc1</name></expr></argument>)</argument_list></call></expr> )</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>lrc1Errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>lrc1</name></expr>;</expr_stmt>
      <goto>goto <name>afp_end_lock</name>;</goto>
    </block_content>}</block></if> <if type="elseif">else if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>lrc2</name></expr>;</expr_stmt>
      <goto>goto <name>afp_end_lock</name>;</goto>
    </block_content>}</block></if> <if type="elseif">else if<condition>( <expr><name>lrc1</name> <operator>!=</operator> <name>SQLITE_OK</name></expr> )</condition> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>lrc1</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name> <operator>&amp;&amp;</operator> <name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* We are trying for an exclusive lock but another thread in this
     ** same process is still holding a shared lock. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The request was for a RESERVED or EXCLUSIVE lock.  It is
    ** assumed that there is a SHARED or greater lock on the file
    ** already.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>failed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>!=</operator><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>eFileLock</name> <operator>&gt;=</operator> <name>RESERVED_LOCK</name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>&lt;</operator> <name>RESERVED_LOCK</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Acquire a RESERVED lock */</comment>
        <expr_stmt><expr><name>failed</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>failed</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>failed</name> <operator>&amp;&amp;</operator> <name>eFileLock</name> <operator>==</operator> <name>EXCLUSIVE_LOCK</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Acquire an EXCLUSIVE lock */</comment>
        
      <comment type="block">/* Remove the shared lock before trying the range.  we'll need to 
      ** reestablish the shared lock if we can't get the  afpUnlock
      */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name>failed</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>SHARED_FIRST</name> <operator>+</operator>
                         <name><name>pInode</name><operator>-&gt;</operator><name>sharedByte</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>failed2</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* now attemmpt to get the exclusive lock range */</comment>
        <expr_stmt><expr><name>failed</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, 
                               <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>failed</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>failed2</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, 
                       <argument><expr><name>SHARED_FIRST</name> <operator>+</operator> <name><name>pInode</name><operator>-&gt;</operator><name>sharedByte</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
          <comment type="block">/* Can't reestablish the shared lock.  Sqlite can't deal, this is
          ** a critical I/O error
          */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>failed</name> <operator>&amp;</operator> <name>SQLITE_IOERR</name><operator>)</operator> <operator>==</operator> <name>SQLITE_IOERR</name><operator>)</operator></expr> ?</condition><then> <expr><name>failed2</name></expr> </then><else>: 
               <expr><name>SQLITE_IOERR_LOCK</name></expr></else></ternary></expr>;</expr_stmt>
          <goto>goto <name>afp_end_lock</name>;</goto>
        </block_content>}</block></if></if_stmt> 
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>failed</name></expr>;</expr_stmt> 
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>failed</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>failed</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eFileLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>PENDING_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>PENDING_LOCK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
<label><name>afp_end_lock</name>:</label>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK    %d %s %s (afp)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <call><name>azFileLock</name><argument_list>(<argument><expr><name>eFileLock</name></expr></argument>)</argument_list></call><operator>,</operator> 
         <ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>afpUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>afpLockingContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>(</operator><name>afpLockingContext</name> <operator>*</operator><operator>)</operator> <name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>skipShared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNLOCK  %d %d was %d(%d,%d) pid=%d (afp)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>eFileLock</name><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>,</operator>
           <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eFileLock</name><operator>&lt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&lt;=</operator><name>eFileLock</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>SimulateIOError</name><argument_list>( <argument>h=(-<literal type="number">1</literal>)</argument> )</argument_list></macro>
    <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <comment type="block">/* When reducing a lock such that other processes can start
    ** reading the database file again, make sure that the
    ** transaction counter was updated if any part of the database
    ** file changed.  If the transaction counter is not updated,
    ** other connections to the same file might not realize that
    ** the file has changed and hence might not know to flush their
    ** cache.  The use of a stale cache can lead to database corruption.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>inNormalWrite</name></name><operator>==</operator><literal type="number">0</literal>
           <operator>||</operator> <name><name>pFile</name><operator>-&gt;</operator><name>dbUpdate</name></name><operator>==</operator><literal type="number">0</literal>
           <operator>||</operator> <name><name>pFile</name><operator>-&gt;</operator><name>transCntrChng</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>inNormalWrite</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name> <operator>||</operator> <name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <comment type="block">/* only re-establish the shared lock if necessary */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>sharedLockByte</name> <init>= <expr><name>SHARED_FIRST</name><operator>+</operator><name><name>pInode</name><operator>-&gt;</operator><name>sharedByte</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>sharedLockByte</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>skipShared</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;=</operator><name>PENDING_LOCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt> 
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>&gt;=</operator><name>RESERVED_LOCK</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>reserved</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>rc</name></expr> )</condition><block>{<block_content> 
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>eFileLock</name><operator>==</operator><name>SHARED_LOCK</name> <operator>||</operator> <name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>eFileLock</name><operator>==</operator><name>NO_LOCK</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* Decrement the shared lock counter.  Release the lock using an
    ** OS call only when all threads in this same process have released
    ** the lock.
    */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>sharedLockByte</name> <init>= <expr><name>SHARED_FIRST</name><operator>+</operator><name><name>pInode</name><operator>-&gt;</operator><name>sharedByte</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <macro><name>SimulateIOError</name><argument_list>( <argument>h=(-<literal type="number">1</literal>)</argument> )</argument_list></macro>
      <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>skipShared</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>afpSetLock</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>sharedLockByte</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>NO_LOCK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>closePendingFds</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name>eFileLock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a file &amp; cleanup AFP specific locking context 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>afpClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>afpUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pInode</name></name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>nLock</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there are outstanding locks, do not actually close the file just
    ** yet because that would clear those locks.  Instead, add the file
    ** descriptor to pInode-&gt;aPending.  It will be automatically closed when
    ** the last lock is cleared.
    */</comment>
    <expr_stmt><expr><call><name>setPendingFd</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>releaseInodeInfo</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__APPLE__) &amp;&amp; SQLITE_ENABLE_LOCKING_STYLE */</comment>
<comment type="block">/*
** The code above is the AFP lock implementation.  The code is specific
** to MacOSX and does not work on other unix platforms.  No alternative
** is available.  If you don't compile for a mac, then the "unix-afp"
** VFS is not available.
**
********************* End of the AFP lock implementation **********************
******************************************************************************/</comment>

<comment type="block" format="doxygen">/******************************************************************************
*************************** Begin NFS Locking ********************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<comment type="block">/*
 ** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
 ** must be either NO_LOCK or SHARED_LOCK.
 **
 ** If the locking level of the file descriptor is already at or below
 ** the requested locking level, this routine is a no-op.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nfsUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>posixUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>eFileLock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__APPLE__) &amp;&amp; SQLITE_ENABLE_LOCKING_STYLE */</comment>
<comment type="block">/*
** The code above is the NFS lock implementation.  The code is specific
** to MacOSX and does not work on other unix platforms.  No alternative
** is available.  
**
********************* End of the NFS lock implementation **********************
******************************************************************************/</comment>

<comment type="block" format="doxygen">/******************************************************************************
**************** Non-locking sqlite3_file methods *****************************
**
** The next division contains implementations for all methods of the 
** sqlite3_file object other than the locking methods.  The locking
** methods were defined in divisions above (one locking method per
** division).  Those methods that are common to all locking modes
** are gather together into this division.
*/</comment>

<comment type="block">/*
** Seek to the offset passed as the second argument, then read cnt 
** bytes into pBuf. Return the number of bytes actually read.
**
** NB:  If you define USE_PREAD or USE_PREAD64, then it might also
** be necessary to define _XOPEN_SOURCE to be 500.  This varies from
** one system to another.  Since SQLite does not define USE_PREAD
** in any form by default, we will not attempt to define _XOPEN_SOURCE.
** See tickets #2741 and #2681.
**
** To avoid stomping the errno value on a failed read the lastErrno value
** is set before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seekAndRead</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>got</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>prior</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
  <decl_stmt><decl><type><name>i64</name></type> <name>newOffset</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>TIMER_START</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cnt</name><operator>==</operator><operator>(</operator><name>cnt</name><operator>&amp;</operator><literal type="number">0x1ffff</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>osPread</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>got</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>osPread64</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>got</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>newOffset</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>newOffset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>newOffset</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>osRead</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name>got</name><operator>==</operator><name>cnt</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>got</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>errno</name><operator>==</operator><name>EINTR</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>got</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>prior</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></argument>,  <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>got</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>cnt</name> <operator>-=</operator> <name>got</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>got</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>prior</name> <operator>+=</operator> <name>got</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>got</name> <operator>+</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>while<condition>( <expr><name>got</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <expr_stmt><expr><name>TIMER_END</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ    %-3d %5d %7lld %llu\n"</literal><operator>,</operator>
            <name><name>id</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>got</name><operator>+</operator><name>prior</name><operator>,</operator> <name>offset</name><operator>-</operator><name>prior</name><operator>,</operator> <name>TIMER_ELAPSED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>got</name><operator>+</operator><name>prior</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read data from a file into a buffer.  Return SQLITE_OK if all
** bytes were read successfully and SQLITE_IOERR if anything goes
** wrong.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixRead</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>amt</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>offset</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>got</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>amt</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a database file (not a journal, master-journal or temp
  ** file), the bytes in the locking range should never be read or written. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  assert( pFile-&gt;pUnused==0
       || offset&gt;=PENDING_BYTE+512
       || offset+amt&lt;=PENDING_BYTE 
  );
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <comment type="block">/* Deal with as much of this read request as possible by transfering
  ** data from the memory mapping using memcpy().  */</comment>
  <if_stmt><if>if<condition>( <expr><name>offset</name><operator>&lt;</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>offset</name><operator>+</operator><name>amt</name> <operator>&lt;=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>-</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>nCopy</name></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name>amt</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>seekAndRead</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>got</name><operator>==</operator><name>amt</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>got</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* lastErrno set by seekAndRead */</comment>
    <return>return <expr><name>SQLITE_IOERR_READ</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* not a system error */</comment>
    <comment type="block">/* Unread parts of the buffer must be zero-filled */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>got</name></expr>]</index></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>amt</name><operator>-</operator><name>got</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to seek the file-descriptor passed as the first argument to
** absolute offset iOff, then attempt to write nBuf bytes of data from
** pBuf to it. If an error occurs, return -1 and set *piErrno. Otherwise, 
** return the actual number of bytes written (which may be less than
** nBuf).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seekAndWriteFd</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>,                         <comment type="block">/* File descriptor to write to */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>,                       <comment type="block">/* File offset to begin writing at */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,               <comment type="block">/* Copy data from this buffer to the file */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>,                       <comment type="block">/* Size of buffer pBuf in bytes */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piErrno</name></decl></parameter>                    <comment type="block">/* OUT: Error number if error occurs */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Value returned by system call */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nBuf</name><operator>==</operator><operator>(</operator><name>nBuf</name><operator>&amp;</operator><literal type="number">0x1ffff</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>fd</name><operator>&gt;</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>piErrno</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nBuf</name> <operator>&amp;=</operator> <literal type="number">0x1ffff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>TIMER_START</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <do>do<block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>osPwrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>EINTR</name></expr> )</condition>;</do>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <do>do<block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>osPwrite64</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block>while<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>EINTR</name></expr>)</condition>;</do>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iSeek</name> <init>= <expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>iSeek</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iSeek</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osWrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>EINTR</name></expr> )</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>TIMER_END</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WRITE   %-3d %5d %7lld %llu\n"</literal><operator>,</operator> <name>fd</name><operator>,</operator> <name>rc</name><operator>,</operator> <name>iOff</name><operator>,</operator> <name>TIMER_ELAPSED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piErrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Seek to the offset in id-&gt;offset then read cnt bytes into pBuf.
** Return the number of bytes actually read.  Update the offset.
**
** To avoid stomping the errno value on a failed write the lastErrno value
** is set before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seekAndWrite</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>seekAndWriteFd</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>id</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Write data from a buffer into a file.  Return SQLITE_OK on success
** or some other error code on failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixWrite</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>amt</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>offset</name></decl></parameter> 
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wrote</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>amt</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a database file (not a journal, master-journal or temp
  ** file), the bytes in the locking range should never be read or written. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  assert( pFile-&gt;pUnused==0
       || offset&gt;=PENDING_BYTE+512
       || offset+amt&lt;=PENDING_BYTE 
  );
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* If we are doing a normal write to a database file (as opposed to
  ** doing a hot-journal rollback or a write to some file other than a
  ** normal database file) then record the fact that the database
  ** has changed.  If the transaction counter is modified, record that
  ** fact too.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>inNormalWrite</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>dbUpdate</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* The database has been modified */</comment>
    <if_stmt><if>if<condition>( <expr><name>offset</name><operator>&lt;=</operator><literal type="number">24</literal> <operator>&amp;&amp;</operator> <name>offset</name><operator>+</operator><name>amt</name><operator>&gt;=</operator><literal type="number">27</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>oldCntr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>seekAndRead</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><name>oldCntr</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">4</literal> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>oldCntr</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><literal type="number">24</literal><operator>-</operator><name>offset</name></expr>]</index></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>transCntrChng</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* The transaction counter has changed */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_MMAP_READWRITE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <comment type="block">/* Deal with as much of this write request as possible by transfering
  ** data from the memory mapping using memcpy().  */</comment>
  <if_stmt><if>if<condition>( <expr><name>offset</name><operator>&lt;</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>offset</name><operator>+</operator><name>amt</name> <operator>&lt;=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>-</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>nCopy</name></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name>amt</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
 
  <while>while<condition>( <expr><operator>(</operator><name>wrote</name> <operator>=</operator> <call><name>seekAndWrite</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&lt;</operator><name>amt</name> <operator>&amp;&amp;</operator> <name>wrote</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>amt</name> <operator>-=</operator> <name>wrote</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>wrote</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>wrote</name></expr>]</index></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>(<argument><expr><operator>(</operator> <name>wrote</name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>,</operator> <name>amt</name><operator>=</operator><literal type="number">1</literal> <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SimulateDiskfullError</name><argument_list>(<argument><expr><operator>(</operator> <name>wrote</name><operator>=</operator><literal type="number">0</literal><operator>,</operator> <name>amt</name><operator>=</operator><literal type="number">1</literal> <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>amt</name><operator>&gt;</operator><name>wrote</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>wrote</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name><operator>!=</operator><name>ENOSPC</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* lastErrno set by seekAndWrite */</comment>
      <return>return <expr><name>SQLITE_IOERR_WRITE</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* not a system error */</comment>
      <return>return <expr><name>SQLITE_FULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** Count the number of fullsyncs and normal syncs.  This is used to test
** that syncs and fullsyncs are occurring at the right times.
*/</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_sync_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_fullsync_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** We do not trust systems to provide a working fdatasync().  Some do.
** Others do no.  To be safe, we will stick with the (slightly slower)
** fsync(). If you know that your system does support fdatasync() correctly,
** then simply compile with -Dfdatasync=fdatasync or -DHAVE_FDATASYNC
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>fdatasync</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAVE_FDATASYNC</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>fdatasync</name></cpp:macro> <cpp:value>fsync</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Define HAVE_FULLFSYNC to 0 or 1 depending on whether or not
** the F_FULLFSYNC macro is defined.  F_FULLFSYNC is currently
** only available on Mac OS X.  But that could change.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_FULLFSYNC</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FULLFSYNC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FULLFSYNC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** The fsync() system call does not work as advertised on many
** unix systems.  The following procedure is an attempt to make
** it work better.
**
** The SQLITE_NO_SYNC macro disables all fsync()s.  This is useful
** for testing when we want to run through the test suite quickly.
** You are strongly advised *not* to deploy with SQLITE_NO_SYNC
** enabled, however, since with SQLITE_NO_SYNC enabled, an OS crash
** or power failure will likely corrupt the database file.
**
** SQLite sets the dataOnly flag if the size of the file is unchanged.
** The idea behind dataOnly is that it should only write the file content
** to disk, not the inode.  We only set dataOnly if the file size is 
** unchanged since the file size is part of the inode.  However, 
** Ted Ts'o tells us that fdatasync() will also write the inode if the
** file size has changed.  The only real difference between fdatasync()
** and fsync(), Ted tells us, is that fdatasync() will not flush the
** inode if the mtime or owner or other inode attributes have changed.
** We only care about the file size, not the other file attributes, so
** as far as SQLite is concerned, an fdatasync() is always adequate.
** So, we always use fdatasync() if it is available, regardless of
** the value of the dataOnly flag.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>full_fsync</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fullSync</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dataOnly</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* The following "ifdef/elif/else/" block has the same structure as
  ** the one below. It is replicated here solely to avoid cluttering 
  ** up the real code with the UNUSED_PARAMETER() macros.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_NO_SYNC</name></cpp:ifdef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>fullSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>dataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_FULLFSYNC</name></expr></cpp:elif>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>dataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>fullSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>dataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Record the number of times that we do a normal fsync() and 
  ** FULLSYNC.  This is used during testing to verify that this procedure
  ** gets called with the correct arguments.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>fullSync</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sqlite3_fullsync_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>sqlite3_sync_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a
  ** no-op.  But go ahead and call fstat() to validate the file
  ** descriptor as we need a method to provoke a failure during
  ** coverate testing.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_NO_SYNC</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_FULLFSYNC</name></expr></cpp:elif>
  <if_stmt><if>if<condition>( <expr><name>fullSync</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_FULLFSYNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* If the FULLFSYNC failed, fall back to attempting an fsync().
  ** It shouldn't be possible for fullfsync to fail on the local 
  ** file system (on OSX), so failure indicates that FULLFSYNC
  ** isn't supported for this file system. So, attempt an fsync 
  ** and (for now) ignore the overhead of a superfluous fcntl call.  
  ** It'd be better to detect fullfsync support once and avoid 
  ** the fcntl call every time sync is called.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <comment type="block">/* fdatasync() on HFS+ doesn't yet flush the file size if it changed correctly
  ** so currently we default to the macro that redefines fdatasync to fsync
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fdatasync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>ENOTSUP</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OS_VXWORKS */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifdef SQLITE_NO_SYNC elif HAVE_FULLFSYNC */</comment>

  <if_stmt><if>if<condition>( <expr><name>OS_VXWORKS</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a file descriptor to the directory containing file zFilename.
** If successful, *pFd is set to the opened file descriptor and
** SQLITE_OK is returned. If an error occurs, either SQLITE_NOMEM
** or SQLITE_CANTOPEN is returned and *pFd is set to an undefined
** value.
**
** The directory file descriptor is used for only one thing - to
** fsync() a directory to make sure file creation and deletion events
** are flushed to disk.  Such fsyncs are not needed on newer
** journaling filesystems, but are required on older filesystems.
**
** This routine can be overridden using the xSetSysCall interface.
** The ability to override this routine was added in support of the
** chromium sandbox.  Opening a directory is a security risk (we are
** told) so making it overrideable allows the chromium sandbox to
** replace this routine with a harmless no-op.  To make this routine
** a no-op, replace it with a stub that returns SQLITE_OK but leaves
** *pFd set to a negative number.
**
** If SQLITE_OK is returned, the caller is responsible for closing
** the file descriptor *pFd using close().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>openDirectory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zDirname</name><index>[<expr><name>MAX_PATHNAME</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>MAX_PATHNAME</name></expr></argument>, <argument><expr><name>zDirname</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zDirname</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ii</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zDirname</name><index>[<expr><name>ii</name></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr>;</condition> <incr><expr><name>ii</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <if_stmt><if>if<condition>( <expr><name>ii</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>zDirname</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>zDirname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zDirname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>zDirname</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>robust_open</name><argument_list>(<argument><expr><name>zDirname</name></expr></argument>, <argument><expr><name>O_RDONLY</name><operator>|</operator><name>O_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPENDIR %-3d %s\n"</literal><operator>,</operator> <name>fd</name><operator>,</operator> <name>zDirname</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pFd</name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_BKPT</name></expr></argument>, <argument><expr><literal type="string">"openDirectory"</literal></expr></argument>, <argument><expr><name>zDirname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Make sure all writes to a particular file are committed to disk.
**
** If dataOnly==0 then both the file itself and its metadata (file
** size, access time, etc) are synced.  If dataOnly!=0 then only the
** file data is synced.
**
** Under Unix, also make sure that the directory entry for the file
** has been created by fsync-ing the directory that contains the file.
** If we do not do this and we encounter a power failure, the directory
** entry for the journal might not exist after we reboot.  The next
** SQLite to access the file will not know that the journal exists (because
** the directory entry for the journal was never created) and the transaction
** will not roll back - possibly leading to database corruption.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>isDataOnly</name> <init>= <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><name>SQLITE_SYNC_DATAONLY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isFullsync</name> <init>= <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">0x0F</literal><operator>)</operator><operator>==</operator><name>SQLITE_SYNC_FULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">0x0F</literal><operator>)</operator><operator>==</operator><name>SQLITE_SYNC_NORMAL</name>
      <operator>||</operator> <operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">0x0F</literal><operator>)</operator><operator>==</operator><name>SQLITE_SYNC_FULL</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Unix cannot, but some systems may return SQLITE_FULL from here. This
  ** line is to test that doing so does not cause any problems.
  */</comment>
  <macro><name>SimulateDiskfullError</name><argument_list>( <argument>return SQLITE_FULL</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SYNC    %-3d\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>full_fsync</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>isFullsync</name></expr></argument>, <argument><expr><name>isDataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>rc</name><operator>=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_FSYNC</name></expr></argument>, <argument><expr><literal type="string">"full_fsync"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Also fsync the directory containing the file if the DIRSYNC flag
  ** is set.  This is a one-time occurrence.  Many systems (examples: AIX)
  ** are unable to fsync a directory, so ignore errors on the fsync.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>UNIXFILE_DIRSYNC</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>dirfd</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DIRSYNC %s (have_fullfsync=%d fullsync=%d)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name><operator>,</operator>
            <name>HAVE_FULLFSYNC</name><operator>,</operator> <name>isFullsync</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osOpenDirectory</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>full_fsync</name><argument_list>(<argument><expr><name>dirfd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>dirfd</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_CANTOPEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>UNIXFILE_DIRSYNC</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate an open file to a specified size
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_TRUNCATE</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <comment type="block">/* If the user has configured a chunk-size for this file, truncate the
  ** file so that it consists of an integer number of chunks (i.e. the
  ** actual file size after the operation may be larger than the requested
  ** size).
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nByte</name> <operator>+</operator> <name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name><operator>)</operator> <operator>*</operator> <name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>robust_ftruncate</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_TRUNCATE</name></expr></argument>, <argument><expr><literal type="string">"ftruncate"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <comment type="block">/* If we are doing a normal write to a database file (as opposed to
    ** doing a hot-journal rollback or a write to some file other than a
    ** normal database file) and we truncate the file to zero length,
    ** that effectively updates the change counter.  This might happen
    ** when restoring a database using the backup API from a zero-length
    ** source.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>inNormalWrite</name></name> <operator>&amp;&amp;</operator> <name>nByte</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>transCntrChng</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* If the file was just truncated to a size smaller than the currently
    ** mapped region, reduce the effective mapping size as well. SQLite will
    ** use read() and write() to access data beyond this point from now on.  
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Determine the current size of a file in bytes
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFstat</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>rc</name><operator>=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_FSTAT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>

  <comment type="block">/* When opening a zero-size database, the findInodeInfo() procedure
  ** writes a single byte into that file in order to work around a bug
  ** in the OS-X msdos filesystem.  In order to avoid problems with upper
  ** layers, we need to report this file size as zero even though it is
  ** really 1.   Ticket #3260.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pSize</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Handler for proxy-locking file-control verbs.  Defined below in the
** proxying locking division.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>proxyFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* 
** This function is called to handle the SQLITE_FCNTL_SIZE_HINT 
** file-control operation.  Enlarge the database to nBytes in size
** (rounded up to the next chunk-size).  If the database is already
** nBytes or larger, this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fcntlSizeHint</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>nSize</name></decl>;</decl_stmt>                    <comment type="block">/* Required file size */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>              <comment type="block">/* Used to hold return values of fstat() */</comment>
   
    <if_stmt><if>if<condition>( <expr><call><name>osFstat</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_IOERR_FSTAT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nSize</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nByte</name><operator>+</operator><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name><operator>)</operator> <operator>*</operator> <name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&gt;</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>buf</name><operator>.</operator><name>st_size</name></name></expr> )</condition><block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POSIX_FALLOCATE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_POSIX_FALLOCATE</name></expr></cpp:if>
      <comment type="block">/* The code below is handling the return value of osFallocate() 
      ** correctly. posix_fallocate() is defined to "returns zero on success, 
      ** or an error number on  failure". See the manpage for details. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
      <do>do<block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>osFallocate</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name>nSize</name><operator>-</operator><name><name>buf</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><name>err</name><operator>==</operator><name>EINTR</name></expr> )</condition>;</do>
      <if_stmt><if>if<condition>( <expr><name>err</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_IOERR_WRITE</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* If the OS does not have posix_fallocate(), fake it. Write a 
      ** single byte to the last byte in each block that falls entirely
      ** within the extended region. Then, if required, a single byte
      ** at offset (nSize-1), to set the size of the file correctly.
      ** This is a similar technique to that used by glibc on systems
      ** that do not have a real fallocate() call.
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nBlk</name> <init>= <expr><name><name>buf</name><operator>.</operator><name>st_blksize</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* File-system block size */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Number of bytes written by seekAndWrite */</comment>
      <decl_stmt><decl><type><name>i64</name></type> <name>iWrite</name></decl>;</decl_stmt>                 <comment type="block">/* Next offset to write to */</comment>

      <expr_stmt><expr><name>iWrite</name> <operator>=</operator> <operator>(</operator><name><name>buf</name><operator>.</operator><name>st_size</name></name><operator>/</operator><name>nBlk</name><operator>)</operator><operator>*</operator><name>nBlk</name> <operator>+</operator> <name>nBlk</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iWrite</name><operator>&gt;=</operator><name><name>buf</name><operator>.</operator><name>st_size</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>iWrite</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>%</operator><name>nBlk</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<comment type="block">/*no-op*/</comment><init>;</init> <condition><expr><name>iWrite</name><operator>&lt;</operator><name>nSize</name><operator>+</operator><name>nBlk</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>iWrite</name><operator>+=</operator><name>nBlk</name></expr></incr> )</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iWrite</name><operator>&gt;=</operator><name>nSize</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iWrite</name> <operator>=</operator> <name>nSize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <call><name>seekAndWrite</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iWrite</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nWrite</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_IOERR_WRITE</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeMax</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nByte</name><operator>&gt;</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>robust_ftruncate</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_TRUNCATE</name></expr></argument>, <argument><expr><literal type="string">"ftruncate"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixMapfile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If *pArg is initially negative then this is a query.  Set *pArg to
** 1 or 0 depending on whether or not bit mask of pFile-&gt;ctrlFlags is set.
**
** If *pArg is 0 or 1, then clear or set the mask bit of pFile-&gt;ctrlFlags.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixModeBit</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pArg</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pArg</name> <operator>=</operator> <operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><operator>*</operator><name>pArg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>unixGetTempname</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Information and control of an open file handle.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_FCNTL_LOCKSTATE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_LAST_ERRNO</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_CHUNK_SIZE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_SIZE_HINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fcntlSizeHint</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>i64</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_PERSIST_WAL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>unixModeBit</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>UNIXFILE_PERSIST_WAL</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_POWERSAFE_OVERWRITE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>unixModeBit</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>UNIXFILE_PSOW</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_VFSNAME</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pVfs</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_TEMPFILENAME</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTFile</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zTFile</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>unixGetTempname</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>, <argument><expr><name>zTFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name>zTFile</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_HAS_MOVED</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>fileHasMoved</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <case>case <expr><name>SQLITE_FCNTL_MMAP_SIZE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>newLimit</name> <init>= <expr><operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>newLimit</name><operator>&gt;</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mxMmap</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>newLimit</name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mxMmap</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeMax</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>newLimit</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>newLimit</name><operator>!=</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeMax</name></name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeMax</name></name> <operator>=</operator> <name>newLimit</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>unixUnmapfile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixMapfile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <comment type="block">/* The pager calls this method to signal that it has done
    ** a rollback and that the database is therefore unchanged and
    ** it hence it is OK for the transaction change counter to be
    ** unchanged.
    */</comment>
    <case>case <expr><name>SQLITE_FCNTL_DB_UNCHANGED</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name><operator>)</operator><operator>-&gt;</operator><name>dbUpdate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <case>case <expr><name>SQLITE_FCNTL_SET_LOCKPROXYFILE</name></expr>:</case>
    <case>case <expr><name>SQLITE_FCNTL_GET_LOCKPROXYFILE</name></expr>:</case> <block>{<block_content>
      <return>return <expr><call><name>proxyFileControl</name><argument_list>(<argument><expr><name>id</name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_LOCKING_STYLE &amp;&amp; defined(__APPLE__) */</comment>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the sector size in bytes of the underlying block device for
** the specified file. This is almost always 512 bytes, but may be
** larger for some devices.
**
** SQLite code assumes this function cannot fail. It also assumes that
** if two files are created in the same file-system directory (i.e.
** a database and its journal file) that the sector size will be the
** same for both.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__QNXNTO__</name></cpp:ifndef> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_DEFAULT_SECTOR_SIZE</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following version of unixSectorSize() is optimized for QNX.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__QNXNTO__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/dcmd_blk.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/statvfs.h&gt;</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>statvfs</name></name></type> <name>fsInfo</name></decl>;</decl_stmt>
       
    <comment type="block">/* Set defaults for non-supported filesystems */</comment>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <name>SQLITE_DEFAULT_SECTOR_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deviceCharacteristics</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>fstatvfs</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsInfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition> <block>{<block_content>
      <return>return <expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fsInfo</name><operator>.</operator><name>f_basetype</name></name></expr></argument>, <argument><expr><literal type="string">"tmp"</literal></expr></argument>)</argument_list></call></expr> )</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <name><name>fsInfo</name><operator>.</operator><name>f_bsize</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deviceCharacteristics</name></name> <operator>=</operator>
        <name>SQLITE_IOCAP_ATOMIC4K</name> <operator>|</operator>       <comment type="block">/* All ram filesystem writes are atomic */</comment>
        <name>SQLITE_IOCAP_SAFE_APPEND</name> <operator>|</operator>    <comment type="block">/* growing the file does not occur until
                                      ** the write succeeds */</comment>
        <name>SQLITE_IOCAP_SEQUENTIAL</name> <operator>|</operator>     <comment type="block">/* The ram filesystem has no write behind
                                      ** so it is ordered */</comment>
        <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>fsInfo</name><operator>.</operator><name>f_basetype</name></name></expr></argument>, <argument><expr><literal type="string">"etfs"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <name><name>fsInfo</name><operator>.</operator><name>f_bsize</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deviceCharacteristics</name></name> <operator>=</operator>
        <comment type="block">/* etfs cluster size writes are atomic */</comment>
        <operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>/</operator> <literal type="number">512</literal> <operator>*</operator> <name>SQLITE_IOCAP_ATOMIC512</name><operator>)</operator> <operator>|</operator>
        <name>SQLITE_IOCAP_SAFE_APPEND</name> <operator>|</operator>    <comment type="block">/* growing the file does not occur until
                                      ** the write succeeds */</comment>
        <name>SQLITE_IOCAP_SEQUENTIAL</name> <operator>|</operator>     <comment type="block">/* The ram filesystem has no write behind
                                      ** so it is ordered */</comment>
        <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fsInfo</name><operator>.</operator><name>f_basetype</name></name></expr></argument>, <argument><expr><literal type="string">"qnx6"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <name><name>fsInfo</name><operator>.</operator><name>f_bsize</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deviceCharacteristics</name></name> <operator>=</operator>
        <name>SQLITE_IOCAP_ATOMIC</name> <operator>|</operator>         <comment type="block">/* All filesystem writes are atomic */</comment>
        <name>SQLITE_IOCAP_SAFE_APPEND</name> <operator>|</operator>    <comment type="block">/* growing the file does not occur until
                                      ** the write succeeds */</comment>
        <name>SQLITE_IOCAP_SEQUENTIAL</name> <operator>|</operator>     <comment type="block">/* The ram filesystem has no write behind
                                      ** so it is ordered */</comment>
        <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fsInfo</name><operator>.</operator><name>f_basetype</name></name></expr></argument>, <argument><expr><literal type="string">"qnx4"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <name><name>fsInfo</name><operator>.</operator><name>f_bsize</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deviceCharacteristics</name></name> <operator>=</operator>
        <comment type="block">/* full bitset of atomics from max sector size and smaller */</comment>
        <operator>(</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>/</operator> <literal type="number">512</literal> <operator>*</operator> <name>SQLITE_IOCAP_ATOMIC512</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">2</literal> <operator>|</operator>
        <name>SQLITE_IOCAP_SEQUENTIAL</name> <operator>|</operator>     <comment type="block">/* The ram filesystem has no write behind
                                      ** so it is ordered */</comment>
        <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>fsInfo</name><operator>.</operator><name>f_basetype</name></name></expr></argument>, <argument><expr><literal type="string">"dos"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <name><name>fsInfo</name><operator>.</operator><name>f_bsize</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deviceCharacteristics</name></name> <operator>=</operator>
        <comment type="block">/* full bitset of atomics from max sector size and smaller */</comment>
        <operator>(</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>/</operator> <literal type="number">512</literal> <operator>*</operator> <name>SQLITE_IOCAP_ATOMIC512</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">2</literal> <operator>|</operator>
        <name>SQLITE_IOCAP_SEQUENTIAL</name> <operator>|</operator>     <comment type="block">/* The ram filesystem has no write behind
                                      ** so it is ordered */</comment>
        <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deviceCharacteristics</name></name> <operator>=</operator>
        <name>SQLITE_IOCAP_ATOMIC512</name> <operator>|</operator>      <comment type="block">/* blocks are atomic */</comment>
        <name>SQLITE_IOCAP_SAFE_APPEND</name> <operator>|</operator>    <comment type="block">/* growing the file does not occur until
                                      ** the write succeeds */</comment>
        <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Last chance verification.  If the sector size isn't a multiple of 512
  ** then it isn't valid.*/</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>%</operator> <literal type="number">512</literal> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deviceCharacteristics</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <name>SQLITE_DEFAULT_SECTOR_SIZE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pFile</name><operator>-&gt;</operator><name>sectorSize</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __QNXNTO__ */</comment>

<comment type="block">/*
** Return the device characteristics for the file.
**
** This VFS is set up to return SQLITE_IOCAP_POWERSAFE_OVERWRITE by default.
** However, that choice is controversial since technically the underlying
** file system does not always provide powersafe overwrites.  (In other
** words, after a power-loss event, parts of the file that were never
** written might end up being altered.)  However, non-PSOW behavior is very,
** very rare.  And asserting PSOW makes a large reduction in the amount
** of required I/O for journaling, since a lot of padding is eliminated.
**  Hence, while POWERSAFE_OVERWRITE is on by default, there is a file-control
** available to turn it off and URI query parameter available to turn it off.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__QNXNTO__</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sectorSize</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>unixSectorSize</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>deviceCharacteristics</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>UNIXFILE_PSOW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>|=</operator> <name>SQLITE_IOCAP_POWERSAFE_OVERWRITE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_WAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>

<comment type="block">/*
** Return the system page size.
**
** This function should not be called directly by other code in this file. 
** Instead, it should be called via macro osGetpagesize().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixGetpagesize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <return>return <expr><literal type="number">1024</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_BSD_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <return>return <expr><call><name>getpagesize</name><argument_list>()</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE&gt;0 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>

<comment type="block">/*
** Object used to represent an shared memory buffer.  
**
** When multiple threads all reference the same wal-index, each thread
** has its own unixShm object, but they all point to a single instance
** of this unixShmNode object.  In other words, each wal-index is opened
** only once per process.
**
** Each unixShmNode object is connected to a single unixInodeInfo object.
** We could coalesce this object into unixInodeInfo, but that would mean
** every open file that does not use shared memory (in other words, most
** open files) would have to carry around this extra information.  So
** the unixInodeInfo object contains a pointer to this unixShmNode object
** and the unixShmNode object is created only when needed.
**
** unixMutexHeld() must be true when creating or destroying
** this object or while reading or writing the following fields:
**
**      nRef
**
** The following fields are read-only after the object is created:
** 
**      fid
**      zFilename
**
** Either unixShmNode.mutex must be held or unixShmNode.nRef==0 and
** unixMutexHeld() is true when reading or writing any other field
** in this structure.
*/</comment>
<struct>struct <name>unixShmNode</name> <block>{
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name></decl>;</decl_stmt>     <comment type="block">/* unixInodeInfo that owns this SHM node */</comment>
  <decl_stmt><decl><type><name>sqlite3_mutex</name> <modifier>*</modifier></type><name>mutex</name></decl>;</decl_stmt>      <comment type="block">/* Mutex to access this object */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>           <comment type="block">/* Name of the mmapped file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>                     <comment type="block">/* Open file descriptor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szRegion</name></decl>;</decl_stmt>              <comment type="block">/* Size of shared-memory regions */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nRegion</name></decl>;</decl_stmt>               <comment type="block">/* Size of array apRegion */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isReadonly</name></decl>;</decl_stmt>             <comment type="block">/* True if read-only */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>apRegion</name></decl>;</decl_stmt>           <comment type="block">/* Array of mapped shared-memory regions */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                  <comment type="block">/* Number of unixShm objects pointing to this */</comment>
  <decl_stmt><decl><type><name>unixShm</name> <modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>           <comment type="block">/* All unixShm objects pointing to this */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>u8</name></type> <name>exclMask</name></decl>;</decl_stmt>               <comment type="block">/* Mask of exclusive locks held */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>sharedMask</name></decl>;</decl_stmt>             <comment type="block">/* Mask of shared locks held */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nextShmId</name></decl>;</decl_stmt>              <comment type="block">/* Next available unixShm.id value */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** Structure used internally by this VFS to record the state of an
** open shared memory connection.
**
** The following fields are initialized when this object is created and
** are read-only thereafter:
**
**    unixShm.pFile
**    unixShm.id
**
** All other fields are read/write.  The unixShm.pFile-&gt;mutex must be held
** while accessing any read/write fields.
*/</comment>
<struct>struct <name>unixShm</name> <block>{
  <decl_stmt><decl><type><name>unixShmNode</name> <modifier>*</modifier></type><name>pShmNode</name></decl>;</decl_stmt>     <comment type="block">/* The underlying unixShmNode object */</comment>
  <decl_stmt><decl><type><name>unixShm</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>            <comment type="block">/* Next unixShm with the same unixShmNode */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>hasMutex</name></decl>;</decl_stmt>               <comment type="block">/* True if holding the unixShmNode mutex */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>id</name></decl>;</decl_stmt>                     <comment type="block">/* Id of this connection within its unixShmNode */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>sharedMask</name></decl>;</decl_stmt>            <comment type="block">/* Mask of shared locks held */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>exclMask</name></decl>;</decl_stmt>              <comment type="block">/* Mask of exclusive locks held */</comment>
}</block>;</struct>

<comment type="block">/*
** Constants used for locking
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIX_SHM_BASE</name></cpp:macro>   <cpp:value>((22+SQLITE_SHM_NLOCK)*4)</cpp:value></cpp:define>         <comment type="block">/* first lock byte */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIX_SHM_DMS</name></cpp:macro>    <cpp:value>(UNIX_SHM_BASE+SQLITE_SHM_NLOCK)</cpp:value></cpp:define>  <comment type="block">/* deadman switch */</comment>

<comment type="block">/*
** Apply posix advisory locks for all bytes from ofst through ofst+n-1.
**
** Locks block if the mask is exactly UNIX_SHM_C and are non-blocking
** otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixShmSystemLock</name><parameter_list>(
  <parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,       <comment type="block">/* Open connection to the WAL file */</comment>
  <parameter><decl><type><name>int</name></type> <name>lockType</name></decl></parameter>,          <comment type="block">/* F_UNLCK, F_RDLCK, or F_WRLCK */</comment>
  <parameter><decl><type><name>int</name></type> <name>ofst</name></decl></parameter>,              <comment type="block">/* First byte of the locking range */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>                  <comment type="block">/* Number of bytes to lock */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixShmNode</name> <modifier>*</modifier></type><name>pShmNode</name></decl>;</decl_stmt> <comment type="block">/* Apply locks to this open shared-memory segment */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>f</name></decl>;</decl_stmt>        <comment type="block">/* The posix advisory locking structure */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Result code form fcntl() */</comment>

  <comment type="block">/* Access to the unixShmNode object is serialized by the caller */</comment>
  <expr_stmt><expr><name>pShmNode</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pShmNode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Shared locks never span more than one byte */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>lockType</name><operator>!=</operator><name>F_RDLCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Locks are within range */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;=</operator><name>SQLITE_SHM_NLOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Initialize the locking parameters */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>lockType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <name>ofst</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFcntl</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>rc</name><operator>!=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_BUSY</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Update the global lock state and do debug tracing */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <block>{<block_content> <decl_stmt><decl><type><name>u16</name></type> <name>mask</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SHM-LOCK "</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mask</name> <operator>=</operator> <ternary><condition><expr><name>ofst</name><operator>&gt;</operator><literal type="number">31</literal></expr> ?</condition><then> <expr><literal type="number">0xffff</literal></expr> </then><else>: <expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>ofst</name><operator>+</operator><name>n</name><operator>)</operator><operator>)</operator> <operator>-</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ofst</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>lockType</name><operator>==</operator><name>F_UNLCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"unlock %d ok"</literal><operator>,</operator> <name>ofst</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>lockType</name><operator>==</operator><name>F_RDLCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"read-lock %d ok"</literal><operator>,</operator> <name>ofst</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>lockType</name><operator>==</operator><name>F_WRLCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"write-lock %d ok"</literal><operator>,</operator> <name>ofst</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>lockType</name><operator>==</operator><name>F_UNLCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"unlock %d failed"</literal><operator>,</operator> <name>ofst</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>lockType</name><operator>==</operator><name>F_RDLCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"read-lock failed"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>lockType</name><operator>==</operator><name>F_WRLCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"write-lock %d failed"</literal><operator>,</operator> <name>ofst</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">" - afterwards %03x,%03x\n"</literal><operator>,</operator>
           <name><name>pShmNode</name><operator>-&gt;</operator><name>sharedMask</name></name><operator>,</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>exclMask</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>        
</block_content>}</block></function>

<comment type="block">/*
** Return the minimum number of 32KB shm regions that should be mapped at
** a time, assuming that each mapping must be an integer multiple of the
** current system page-size.
**
** Usually, this is 1. The exception seems to be systems that are configured
** to use 64KB pages - in this case each mapping must cover at least two
** shm regions.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixShmRegionPerMap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>shmsz</name> <init>= <expr><literal type="number">32</literal><operator>*</operator><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* SHM region size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pgsz</name> <init>= <expr><call><name>osGetpagesize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* System page size */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>pgsz</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name>pgsz</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Page size must be a power of 2 */</comment>
  <if_stmt><if>if<condition>( <expr><name>pgsz</name><operator>&lt;</operator><name>shmsz</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>pgsz</name><operator>/</operator><name>shmsz</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Purge the unixShmNodeList list of all entries with unixShmNode.nRef==0.
**
** This is not a VFS shared-memory method; it is a utility function called
** by VFS shared-memory methods.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixShmPurge</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixShmNode</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pFd</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pShmNode</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>unixMutexHeld</name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nShmPerMap</name> <init>= <expr><call><name>unixShmRegionPerMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pInode</name></name><operator>==</operator><name><name>pFd</name><operator>-&gt;</operator><name>pInode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nRegion</name></name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>nShmPerMap</name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>osMunmap</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apRegion</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>szRegion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apRegion</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apRegion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pShmNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Open a shared-memory area associated with open database file pDbFd.  
** This particular implementation uses mmapped files.
**
** The file used to implement shared-memory is in the same directory
** as the open database file and has the same name as the open database
** file with the "-shm" suffix added.  For example, if the database file
** is "/home/user1/config.db" then the file that is created and mmapped
** for shared memory will be called "/home/user1/config.db-shm".  
**
** Another approach to is to use files in /dev/shm or /dev/tmp or an
** some other tmpfs mount. But if a file in a different directory
** from the database file is used, then differing access permissions
** or a chroot() might cause two different processes on the same
** database to end up using different files for shared memory - 
** meaning that their memory would not really be shared - resulting
** in database corruption.  Nevertheless, this tmpfs file usage
** can be enabled at compile-time using -DSQLITE_SHM_DIRECTORY="/dev/shm"
** or the equivalent.  The use of the SQLITE_SHM_DIRECTORY compile-time
** option results in an incompatible build of SQLite;  builds of SQLite
** that with differing SQLITE_SHM_DIRECTORY settings attempt to use the
** same database file at the same time, database corruption will likely
** result. The SQLITE_SHM_DIRECTORY compile-time option is considered
** "unsupported" and may go away in a future SQLite release.
**
** When opening a new shared-memory file, if no other instances of that
** file are currently open, in this process or in other processes, then
** the file must be truncated to zero length or have its header cleared.
**
** If the original database file (pDbFd) is using the "unix-excl" VFS
** that means that an exclusive lock is held on the database file and
** that no other processes are able to read or write the database.  In
** that case, we do not really need shared memory.  No shared memory
** file is created.  The shared memory will be simulated with heap memory.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixOpenSharedMemory</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pDbFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>unixShm</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* The connection to be opened */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>unixShmNode</name></name> <modifier>*</modifier></type><name>pShmNode</name></decl>;</decl_stmt>   <comment type="block">/* The underlying mmapped file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Result code */</comment>
  <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name></decl>;</decl_stmt>          <comment type="block">/* The inode of fd */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zShmFilename</name></decl>;</decl_stmt>             <comment type="block">/* Name of the file used for SHM */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nShmFilename</name></decl>;</decl_stmt>               <comment type="block">/* Size of the SHM filename in bytes */</comment>

  <comment type="block">/* Allocate space for the new unixShm object. */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check to see if a unixShmNode object already exists. Reuse an existing
  ** one if present. Create a new one if necessary.
  */</comment>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pShmNode</name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pShmNode</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pShmNode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>                 <comment type="block">/* fstat() info for database file */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHM_DIRECTORY</name></cpp:ifndef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBasePath</name> <init>= <expr><name><name>pDbFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Call fstat() to figure out the permissions on the database file. If
    ** a new *-shm file is created, an attempt will be made to create it
    ** with the same permissions.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>osFstat</name><argument_list>(<argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_FSTAT</name></expr>;</expr_stmt>
      <goto>goto <name>shm_open_err</name>;</goto>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHM_DIRECTORY</name></cpp:ifdef>
    <expr_stmt><expr><name>nShmFilename</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SQLITE_SHM_DIRECTORY</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">31</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>nShmFilename</name> <operator>=</operator> <literal type="number">6</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zBasePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>pShmNode</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pShmNode</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nShmFilename</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pShmNode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>shm_open_err</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pShmNode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pShmNode</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nShmFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zShmFilename</name> <operator>=</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>zFilename</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pShmNode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHM_DIRECTORY</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nShmFilename</name></expr></argument>, <argument><expr><name>zShmFilename</name></expr></argument>, 
                     <argument><expr><name>SQLITE_SHM_DIRECTORY</name> <literal type="string">"/sqlite-shm-%x-%x"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>sStat</name><operator>.</operator><name>st_ino</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>sStat</name><operator>.</operator><name>st_dev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nShmFilename</name></expr></argument>, <argument><expr><name>zShmFilename</name></expr></argument>, <argument><expr><literal type="string">"%s-shm"</literal></expr></argument>, <argument><expr><name>zBasePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3FileSuffix3</name><argument_list>(<argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><name>zShmFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pShmNode</name></name> <operator>=</operator> <name>pShmNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>pInode</name></name> <operator>=</operator> <name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name> <operator>=</operator> <call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_FAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>shm_open_err</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pInode</name><operator>-&gt;</operator><name>bProcessLock</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>openFlags</name> <init>= <expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_uri_boolean</name><argument_list>(<argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><literal type="string">"readonly_shm"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>openFlags</name> <operator>=</operator> <name>O_RDONLY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>isReadonly</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <call><name>robust_open</name><argument_list>(<argument><expr><name>zShmFilename</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><operator>(</operator><name><name>sStat</name><operator>.</operator><name>st_mode</name></name><operator>&amp;</operator><literal type="number">0777</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_BKPT</name></expr></argument>, <argument><expr><literal type="string">"open"</literal></expr></argument>, <argument><expr><name>zShmFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>shm_open_err</name>;</goto>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If this process is running as root, make sure that the SHM file
      ** is owned by the same user that owns the original database.  Otherwise,
      ** the original owner will not be able to connect.
      */</comment>
      <expr_stmt><expr><call><name>robustFchown</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>sStat</name><operator>.</operator><name>st_uid</name></name></expr></argument>, <argument><expr><name><name>sStat</name><operator>.</operator><name>st_gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
      <comment type="block">/* Check to see if another process is holding the dead-man switch.
      ** If not, truncate the file to zero length. 
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>unixShmSystemLock</name><argument_list>(<argument><expr><name>pDbFd</name></expr></argument>, <argument><expr><name>F_WRLCK</name></expr></argument>, <argument><expr><name>UNIX_SHM_DMS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>robust_ftruncate</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMOPEN</name></expr></argument>, <argument><expr><literal type="string">"ftruncate"</literal></expr></argument>, <argument><expr><name>zShmFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixShmSystemLock</name><argument_list>(<argument><expr><name>pDbFd</name></expr></argument>, <argument><expr><name>F_RDLCK</name></expr></argument>, <argument><expr><name>UNIX_SHM_DMS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>shm_open_err</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make the new connection a child of the unixShmNode */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pShmNode</name></name> <operator>=</operator> <name>pShmNode</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>nextShmId</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The reference count on pShmNode has already been incremented under
  ** the cover of the unixEnterMutex() mutex and the pointer from the
  ** new (struct unixShm) object to the pShmNode has been set. All that is
  ** left to do is to link the new object into the linked list starting
  ** at pShmNode-&gt;pFirst. This must be done while holding the pShmNode-&gt;mutex 
  ** mutex.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

  <comment type="block">/* Jump here on any error */</comment>
<label><name>shm_open_err</name>:</label>
  <expr_stmt><expr><call><name>unixShmPurge</name><argument_list>(<argument><expr><name>pDbFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* This call frees pShmNode if required */</comment>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to obtain a pointer to region iRegion of the 
** shared-memory associated with the database file fd. Shared-memory regions 
** are numbered starting from zero. Each shared-memory region is szRegion 
** bytes in size.
**
** If an error occurs, an error code is returned and *pp is set to NULL.
**
** Otherwise, if the bExtend parameter is 0 and the requested shared-memory
** region has not been allocated (by any client, including one running in a
** separate process), then *pp is set to NULL and SQLITE_OK returned. If 
** bExtend is non-zero and the requested shared-memory region has not yet 
** been allocated, it is allocated by this function.
**
** If the shared-memory region has already been allocated or is allocated by
** this call as described above, then it is mapped into this processes 
** address space (if it is not already), *pp is set to point to the mapped 
** memory and SQLITE_OK returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixShmMap</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>,               <comment type="block">/* Handle open on database file */</comment>
  <parameter><decl><type><name>int</name></type> <name>iRegion</name></decl></parameter>,                    <comment type="block">/* Region to retrieve */</comment>
  <parameter><decl><type><name>int</name></type> <name>szRegion</name></decl></parameter>,                   <comment type="block">/* Size of regions */</comment>
  <parameter><decl><type><name>int</name></type> <name>bExtend</name></decl></parameter>,                    <comment type="block">/* True to extend file if necessary */</comment>
  <parameter><decl><type><name>void</name> <specifier>volatile</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>              <comment type="block">/* OUT: Mapped memory */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pDbFd</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>fd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixShm</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixShmNode</name> <modifier>*</modifier></type><name>pShmNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nShmPerMap</name> <init>= <expr><call><name>unixShmRegionPerMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nReqRegion</name></decl>;</decl_stmt>

  <comment type="block">/* If the shared-memory file has not yet been opened, open it now. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixOpenSharedMemory</name><argument_list>(<argument><expr><name>pDbFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pShmNode</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pShmNode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>szRegion</name><operator>==</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>szRegion</name></name> <operator>||</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>pInode</name></name><operator>==</operator><name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>bProcessLock</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>bProcessLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Minimum number of regions required to be mapped. */</comment>
  <expr_stmt><expr><name>nReqRegion</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>iRegion</name><operator>+</operator><name>nShmPerMap</name><operator>)</operator> <operator>/</operator> <name>nShmPerMap</name><operator>)</operator> <operator>*</operator> <name>nShmPerMap</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>&lt;</operator><name>nReqRegion</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>                      <comment type="block">/* New apRegion[] array */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><name>nReqRegion</name><operator>*</operator><name>szRegion</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Minimum required file size */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>                 <comment type="block">/* Used by fstat() */</comment>

    <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>szRegion</name></name> <operator>=</operator> <name>szRegion</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The requested region is not mapped into this processes address space.
      ** Check to see if it has been allocated (i.e. if the wal-index file is
      ** large enough to contain the requested region).
      */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>osFstat</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_SHMSIZE</name></expr>;</expr_stmt>
        <goto>goto <name>shmpage_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
  
      <if_stmt><if>if<condition>( <expr><name><name>sStat</name><operator>.</operator><name>st_size</name></name><operator>&lt;</operator><name>nByte</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The requested memory region does not exist. If bExtend is set to
        ** false, exit early. *pp will be set to NULL and SQLITE_OK returned.
        */</comment>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bExtend</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>shmpage_out</name>;</goto>
        </block_content>}</block></if>

        <comment type="block">/* Alternatively, if bExtend is true, extend the file. Do this by
        ** writing a single byte to the end of each (OS) page being
        ** allocated or extended. Technically, we need only write to the
        ** last page in order to extend the file. But writing to all new
        ** pages forces the OS to allocate them immediately, which reduces
        ** the chances of SIGBUS while accessing the mapped region later on.
        */</comment>
        <else>else<block>{<block_content>
          <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>pgsz</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iPg</name></decl>;</decl_stmt>

          <comment type="block">/* Write to the last byte of each newly allocated or extended page */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>nByte</name> <operator>%</operator> <name>pgsz</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>iPg</name><operator>=</operator><operator>(</operator><name><name>sStat</name><operator>.</operator><name>st_size</name></name><operator>/</operator><name>pgsz</name><operator>)</operator></expr>;</init> <condition><expr><name>iPg</name><operator>&lt;</operator><operator>(</operator><name>nByte</name><operator>/</operator><name>pgsz</name><operator>)</operator></expr>;</condition> <incr><expr><name>iPg</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>seekAndWriteFd</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>iPg</name><operator>*</operator><name>pgsz</name> <operator>+</operator> <name>pgsz</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>zFilename</name></name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMSIZE</name></expr></argument>, <argument><expr><literal type="string">"write"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <goto>goto <name>shmpage_out</name>;</goto>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Map the requested memory region into this processes address space. */</comment>
    <expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc</name><argument_list>(
        <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>apRegion</name></name></expr></argument>, <argument><expr><name>nReqRegion</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>apNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>shmpage_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>apRegion</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>&lt;</operator><name>nReqRegion</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nMap</name> <init>= <expr><name>szRegion</name><operator>*</operator><name>nShmPerMap</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pMem</name> <operator>=</operator> <call><name>osMmap</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nMap</name></expr></argument>,
            <argument><expr><ternary><condition><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>isReadonly</name></name></expr> ?</condition><then> <expr><name>PROT_READ</name></expr> </then><else>: <expr><name>PROT_READ</name><operator>|</operator><name>PROT_WRITE</name></expr></else></ternary></expr></argument>, 
            <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>szRegion</name><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pMem</name><operator>==</operator><name>MAP_FAILED</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMMAP</name></expr></argument>, <argument><expr><literal type="string">"mmap"</literal></expr></argument>, <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>shmpage_out</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pMem</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>szRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pMem</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          <goto>goto <name>shmpage_out</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>szRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nShmPerMap</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>apRegion</name><index>[<expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>+</operator><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pMem</name><operator>)</operator><index>[<expr><name>szRegion</name><operator>*</operator><name>i</name></expr>]</index></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name> <operator>+=</operator> <name>nShmPerMap</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

<label><name>shmpage_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>&gt;</operator><name>iRegion</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>apRegion</name><index>[<expr><name>iRegion</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>isReadonly</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_READONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the lock state for a shared-memory segment.
**
** Note that the relationship between SHAREd and EXCLUSIVE locks is a little
** different here than in posix.  In xShmLock(), one can go from unlocked
** to shared and back or from unlocked to exclusive and back.  But one may
** not go from shared to exclusive or from exclusive to shared.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixShmLock</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>,          <comment type="block">/* Database file holding the shared memory */</comment>
  <parameter><decl><type><name>int</name></type> <name>ofst</name></decl></parameter>,                  <comment type="block">/* First lock to acquire or release */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                     <comment type="block">/* Number of locks to acquire or release */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>                  <comment type="block">/* What to do with the lock */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pDbFd</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>fd</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Connection holding shared memory */</comment>
  <decl_stmt><decl><type><name>unixShm</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* The shared memory being locked */</comment>
  <decl_stmt><decl><type><name>unixShm</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>                          <comment type="block">/* For looping over all siblings */</comment>
  <decl_stmt><decl><type><name>unixShmNode</name> <modifier>*</modifier></type><name>pShmNode</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pShmNode</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The underlying file iNode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Result code */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>mask</name></decl>;</decl_stmt>                             <comment type="block">/* Mask of locks to take or release */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pShmNode</name><operator>==</operator><name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pShmNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>pInode</name></name><operator>==</operator><name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>ofst</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ofst</name><operator>+</operator><name>n</name><operator>&lt;=</operator><name>SQLITE_SHM_NLOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><operator>(</operator><name>SQLITE_SHM_LOCK</name> <operator>|</operator> <name>SQLITE_SHM_SHARED</name><operator>)</operator>
       <operator>||</operator> <name>flags</name><operator>==</operator><operator>(</operator><name>SQLITE_SHM_LOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator>
       <operator>||</operator> <name>flags</name><operator>==</operator><operator>(</operator><name>SQLITE_SHM_UNLOCK</name> <operator>|</operator> <name>SQLITE_SHM_SHARED</name><operator>)</operator>
       <operator>||</operator> <name>flags</name><operator>==</operator><operator>(</operator><name>SQLITE_SHM_UNLOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>bProcessLock</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>bProcessLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>ofst</name><operator>+</operator><name>n</name><operator>)</operator><operator>)</operator> <operator>-</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ofst</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>||</operator> <name>mask</name><operator>==</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ofst</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_SHM_UNLOCK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>allMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Mask of locks held by siblings */</comment>

    <comment type="block">/* See if any siblings hold this same lock */</comment>
    <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pX</name></expr>;</condition> <incr><expr><name>pX</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pX</name><operator>==</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>exclMask</name></name><operator>|</operator><name><name>p</name><operator>-&gt;</operator><name>sharedMask</name></name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>allMask</name> <operator>|=</operator> <name><name>pX</name><operator>-&gt;</operator><name>sharedMask</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Unlock the system-level locks */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mask</name> <operator>&amp;</operator> <name>allMask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixShmSystemLock</name><argument_list>(<argument><expr><name>pDbFd</name></expr></argument>, <argument><expr><name>F_UNLCK</name></expr></argument>, <argument><expr><name>ofst</name><operator>+</operator><name>UNIX_SHM_BASE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Undo the local locks */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt> 
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_SHM_SHARED</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>allShared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Union of locks held by connections other than "p" */</comment>

    <comment type="block">/* Find out which shared locks are already held by sibling connections.
    ** If any sibling already holds an exclusive lock, go ahead and return
    ** SQLITE_BUSY.
    */</comment>
    <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pX</name></expr>;</condition> <incr><expr><name>pX</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>allShared</name> <operator>|=</operator> <name><name>pX</name><operator>-&gt;</operator><name>sharedMask</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Get shared locks at the system level, if necessary */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>allShared</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixShmSystemLock</name><argument_list>(<argument><expr><name>pDbFd</name></expr></argument>, <argument><expr><name>F_RDLCK</name></expr></argument>, <argument><expr><name>ofst</name><operator>+</operator><name>UNIX_SHM_BASE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get the local shared locks */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Make sure no sibling connections hold locks that will block this
    ** lock.  If any do, return SQLITE_BUSY right away.
    */</comment>
    <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pX</name></expr>;</condition> <incr><expr><name>pX</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  
    <comment type="block">/* Get the exclusive locks at the system level.  Then if successful
    ** also mark the local connection as being locked.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixShmSystemLock</name><argument_list>(<argument><expr><name>pDbFd</name></expr></argument>, <argument><expr><name>F_WRLCK</name></expr></argument>, <argument><expr><name>ofst</name><operator>+</operator><name>UNIX_SHM_BASE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SHM-LOCK shmid-%d, pid-%d got %03x,%03x\n"</literal><operator>,</operator>
           <name><name>p</name><operator>-&gt;</operator><name>id</name></name><operator>,</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>sharedMask</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>exclMask</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implement a memory barrier or memory fence on shared memory.  
**
** All loads and stores begun before the barrier must complete before
** any load or store begun after the barrier.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixShmBarrier</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>                <comment type="block">/* Database file holding the shared memory */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3MemoryBarrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* compiler-defined memory barrier */</comment>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>               <comment type="block">/* Also mutex, for redundancy */</comment>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close a connection to shared-memory.  Delete the underlying 
** storage if deleteFlag is true.
**
** If there is no shared memory associated with the connection then this
** routine is a harmless no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixShmUnmap</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>,               <comment type="block">/* The underlying database file */</comment>
  <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>                  <comment type="block">/* Delete shared-memory if true */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixShm</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                     <comment type="block">/* The connection to be closed */</comment>
  <decl_stmt><decl><type><name>unixShmNode</name> <modifier>*</modifier></type><name>pShmNode</name></decl>;</decl_stmt>          <comment type="block">/* The underlying shared-memory file */</comment>
  <decl_stmt><decl><type><name>unixShm</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>                   <comment type="block">/* For looping over sibling connections */</comment>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pDbFd</name></decl>;</decl_stmt>                <comment type="block">/* The underlying database file */</comment>

  <expr_stmt><expr><name>pDbFd</name> <operator>=</operator> <operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>fd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pShmNode</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pShmNode</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pShmNode</name><operator>==</operator><name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pShmNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>pInode</name></name><operator>==</operator><name><name>pDbFd</name><operator>-&gt;</operator><name>pInode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remove connection p from the set of connections associated
  ** with pShmNode */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><name>p</name></expr>;</condition> <incr><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content/>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>

  <comment type="block">/* Free the connection p */</comment>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If pShmNode-&gt;nRef has reached 0, then close the underlying
  ** shared-memory file, too */</comment>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>deleteFlag</name> <operator>&amp;&amp;</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>osUnlink</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>unixShmPurge</name><argument_list>(<argument><expr><name>pDbFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>unixShmMap</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>unixShmLock</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>unixShmBarrier</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>unixShmUnmap</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_WAL */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** If it is currently memory mapped, unmap file pFd.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixUnmapfile</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>osMunmap</name><argument_list>(<argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name></expr></argument>, <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeActual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeActual</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to set the size of the memory mapping maintained by file 
** descriptor pFd to nNew bytes. Any existing mapping is discarded.
**
** If successful, this function sets the following variables:
**
**       unixFile.pMapRegion
**       unixFile.mmapSize
**       unixFile.mmapSizeActual
**
** If unsuccessful, an error message is logged via sqlite3_log() and
** the three variables above are zeroed. In this case SQLite should
** continue accessing the database using the xRead() and xWrite()
** methods.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixRemapfile</name><parameter_list>(
  <parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>,                  <comment type="block">/* File descriptor object */</comment>
  <parameter><decl><type><name>i64</name></type> <name>nNew</name></decl></parameter>                        <comment type="block">/* Required mapping size */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="string">"mmap"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><name><name>pFd</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl>;</decl_stmt>                      <comment type="block">/* File descriptor open on db file */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pOrig</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Pointer to current file mapping */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nOrig</name> <init>= <expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeActual</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Size of pOrig region in bytes */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                        <comment type="block">/* Location of new mapping */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>PROT_READ</name></expr></init></decl>;</decl_stmt>               <comment type="block">/* Flags to pass to mmap() */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nNew</name><operator>&gt;</operator><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nNew</name><operator>&lt;=</operator><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeMax</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nNew</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeActual</name></name><operator>&gt;=</operator><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>MAP_FAILED</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_MMAP_READWRITE</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFd</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>UNIXFILE_RDONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>PROT_WRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>pOrig</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MREMAP</name></expr></cpp:if>
    <decl_stmt><decl><type><name>i64</name></type> <name>nReuse</name> <init>= <expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>szSyspage</name> <init>= <expr><call><name>osGetpagesize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>nReuse</name> <init>= <expr><operator>(</operator><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>szSyspage</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pReq</name> <init>= <expr><operator>&amp;</operator><name><name>pOrig</name><index>[<expr><name>nReuse</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Unmap any pages of the existing mapping that cannot be reused. */</comment>
    <if_stmt><if>if<condition>( <expr><name>nReuse</name><operator>!=</operator><name>nOrig</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>osMunmap</name><argument_list>(<argument><expr><name>pReq</name></expr></argument>, <argument><expr><name>nOrig</name><operator>-</operator><name>nReuse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MREMAP</name></expr></cpp:if>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>osMremap</name><argument_list>(<argument><expr><name>pOrig</name></expr></argument>, <argument><expr><name>nReuse</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>, <argument><expr><name>MREMAP_MAYMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <literal type="string">"mremap"</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>osMmap</name><argument_list>(<argument><expr><name>pReq</name></expr></argument>, <argument><expr><name>nNew</name><operator>-</operator><name>nReuse</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>nReuse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>!=</operator><name>MAP_FAILED</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>!=</operator><name>pReq</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>osMunmap</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>nNew</name> <operator>-</operator> <name>nReuse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name>pOrig</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* The attempt to extend the existing mapping failed. Free it. */</comment>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><name>MAP_FAILED</name> <operator>||</operator> <name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>osMunmap</name><argument_list>(<argument><expr><name>pOrig</name></expr></argument>, <argument><expr><name>nReuse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If pNew is still NULL, try to create an entirely new mapping. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>osMmap</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nNew</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><name>MAP_FAILED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the mmap() above failed, assume that all subsequent mmap() calls
    ** will probably fail too. Fall back to using xRead/xWrite exclusively
    ** in this case.  */</comment>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeMax</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>=</operator> <name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeActual</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Memory map or remap the file opened by file-descriptor pFd (if the file
** is already mapped, the existing mapping is replaced by the new). Or, if 
** there already exists a mapping for this file, and there are still 
** outstanding xFetch() references to it, this function is a no-op.
**
** If parameter nByte is non-negative, then it is the requested size of 
** the mapping to create. Otherwise, if nByte is less than zero, then the 
** requested size is the size of the file on disk. The actual size of the
** created mapping is either the requested size or the value configured 
** using SQLITE_FCNTL_MMAP_LIMIT, whichever is smaller.
**
** SQLITE_OK is returned if no error occurs (even if the mapping is not
** recreated as a result of outstanding references) or an SQLite error
** code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixMapfile</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nMap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nMap</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nMap</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nMap</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>          <comment type="block">/* Low-level file information */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>osFstat</name><argument_list>(<argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_IOERR_FSTAT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nMap</name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nMap</name><operator>&gt;</operator><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeMax</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nMap</name> <operator>=</operator> <name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeMax</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nMap</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nMap</name><operator>!=</operator><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>unixRemapfile</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>nMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_MMAP_SIZE&gt;0 */</comment>

<comment type="block">/*
** If possible, return a pointer to a mapping of file fd starting at offset
** iOff. The mapping must be valid for at least nAmt bytes.
**
** If such a pointer can be obtained, store it in *pp and return SQLITE_OK.
** Or, if one cannot but no error occurs, set *pp to 0 and return SQLITE_OK.
** Finally, if an error does occur, return an SQLite error code. The final
** value of *pp is undefined in this case.
**
** If this function does return a pointer, the caller must eventually 
** release the reference by calling unixUnfetch().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixFetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nAmt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFd</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>fd</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The underlying database file */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeMax</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>unixMapfile</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>&gt;=</operator> <name>iOff</name><operator>+</operator><name>nAmt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><index>[<expr><name>iOff</name></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the third argument is non-NULL, then this function releases a 
** reference obtained by an earlier call to unixFetch(). The second
** argument passed to this function must be the same as the corresponding
** argument that was passed to the unixFetch() invocation. 
**
** Or, if the third argument is NULL, then this function is being called 
** to inform the VFS layer that, according to POSIX, any existing mapping 
** may now be invalid and should be unmapped.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixUnfetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFd</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>fd</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The underlying database file */</comment>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If p==0 (unmap the entire file) then there must be no outstanding 
  ** xFetch references. Or, if p!=0 (meaning it is an xFetch reference),
  ** then there must be at least one outstanding.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>p</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If p!=0, it must match the iOff value. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>p</name><operator>==</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><index>[<expr><name>iOff</name></expr>]</index></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>unixUnmapfile</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Here ends the implementation of all sqlite3_file methods.
**
********************** End sqlite3_file Methods *******************************
******************************************************************************/</comment>

<comment type="block">/*
** This division contains definitions of sqlite3_io_methods objects that
** implement various file locking strategies.  It also contains definitions
** of "finder" functions.  A finder-function is used to locate the appropriate
** sqlite3_io_methods object for a particular database file.  The pAppData
** field of the sqlite3_vfs VFS objects are initialized to be pointers to
** the correct finder-function for that VFS.
**
** Most finder functions return a pointer to a fixed sqlite3_io_methods
** object.  The only interesting finder-function is autolockIoFinder, which
** looks at the filesystem type and tries to guess the best locking
** strategy from that.
**
** For finder-function F, two objects are created:
**
**    (1) The real finder-function named "FImpt()".
**
**    (2) A constant pointer to this function named just "F".
**
**
** A pointer to the F pointer is used as the pAppData value for VFS
** objects.  We have to do this instead of letting pAppData point
** directly at the finder-function since C90 rules prevent a void*
** from be cast into a function pointer.
**
**
** Each instance of this macro generates two objects:
**
**   *  A constant sqlite3_io_methods object call METHOD that has locking
**      methods CLOSE, LOCK, UNLOCK, CKRESLOCK.
**
**   *  An I/O method finder function called FINDER that returns a pointer
**      to the METHOD object in the previous bullet.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOMETHODS</name><parameter_list>(<parameter><type><name>FINDER</name></type></parameter>,<parameter><type><name>METHOD</name></type></parameter>,<parameter><type><name>VERSION</name></type></parameter>,<parameter><type><name>CLOSE</name></type></parameter>,<parameter><type><name>LOCK</name></type></parameter>,<parameter><type><name>UNLOCK</name></type></parameter>,<parameter><type><name>CKLOCK</name></type></parameter>,<parameter><type><name>SHMMAP</name></type></parameter>)</parameter_list></cpp:macro>     \
<cpp:value>static const sqlite3_io_methods METHOD = {                                   \
   VERSION,                    <comment type="block">/* iVersion */</comment>                                \
   CLOSE,                      <comment type="block">/* xClose */</comment>                                  \
   unixRead,                   <comment type="block">/* xRead */</comment>                                   \
   unixWrite,                  <comment type="block">/* xWrite */</comment>                                  \
   unixTruncate,               <comment type="block">/* xTruncate */</comment>                               \
   unixSync,                   <comment type="block">/* xSync */</comment>                                   \
   unixFileSize,               <comment type="block">/* xFileSize */</comment>                               \
   LOCK,                       <comment type="block">/* xLock */</comment>                                   \
   UNLOCK,                     <comment type="block">/* xUnlock */</comment>                                 \
   CKLOCK,                     <comment type="block">/* xCheckReservedLock */</comment>                      \
   unixFileControl,            <comment type="block">/* xFileControl */</comment>                            \
   unixSectorSize,             <comment type="block">/* xSectorSize */</comment>                             \
   unixDeviceCharacteristics,  <comment type="block">/* xDeviceCapabilities */</comment>                     \
   SHMMAP,                     <comment type="block">/* xShmMap */</comment>                                 \
   unixShmLock,                <comment type="block">/* xShmLock */</comment>                                \
   unixShmBarrier,             <comment type="block">/* xShmBarrier */</comment>                             \
   unixShmUnmap,               <comment type="block">/* xShmUnmap */</comment>                               \
   unixFetch,                  <comment type="block">/* xFetch */</comment>                                  \
   unixUnfetch,                <comment type="block">/* xUnfetch */</comment>                                \
};                                                                           \
static const sqlite3_io_methods *FINDER##Impl(const char *z, unixFile *p){   \
  UNUSED_PARAMETER(z); UNUSED_PARAMETER(p);                                  \
  return &amp;METHOD;                                                            \
}                                                                            \
static const sqlite3_io_methods *(*const FINDER)(const char*,unixFile *p)    \
    = FINDER##Impl;</cpp:value></cpp:define>

<comment type="block">/*
** Here are all of the sqlite3_io_methods objects for each of the
** locking strategies.  Functions that return pointers to these methods
** are also created.
*/</comment>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>posixIoFinder</argument>,            <comment type="block">/* Finder function name */</comment>
  <argument>posixIoMethods</argument>,           <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument><literal type="number">3</literal></argument>,                        <comment type="block">/* shared memory and mmap are enabled */</comment>
  <argument>unixClose</argument>,                <comment type="block">/* xClose method */</comment>
  <argument>unixLock</argument>,                 <comment type="block">/* xLock method */</comment>
  <argument>unixUnlock</argument>,               <comment type="block">/* xUnlock method */</comment>
  <argument>unixCheckReservedLock</argument>,    <comment type="block">/* xCheckReservedLock method */</comment>
  <argument>unixShmMap</argument>                <comment type="block">/* xShmMap method */</comment>
)</argument_list></macro>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>nolockIoFinder</argument>,           <comment type="block">/* Finder function name */</comment>
  <argument>nolockIoMethods</argument>,          <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument><literal type="number">3</literal></argument>,                        <comment type="block">/* shared memory is disabled */</comment>
  <argument>nolockClose</argument>,              <comment type="block">/* xClose method */</comment>
  <argument>nolockLock</argument>,               <comment type="block">/* xLock method */</comment>
  <argument>nolockUnlock</argument>,             <comment type="block">/* xUnlock method */</comment>
  <argument>nolockCheckReservedLock</argument>,  <comment type="block">/* xCheckReservedLock method */</comment>
  <argument><literal type="number">0</literal></argument>                         <comment type="block">/* xShmMap method */</comment>
)</argument_list></macro>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>dotlockIoFinder</argument>,          <comment type="block">/* Finder function name */</comment>
  <argument>dotlockIoMethods</argument>,         <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument><literal type="number">1</literal></argument>,                        <comment type="block">/* shared memory is disabled */</comment>
  <argument>dotlockClose</argument>,             <comment type="block">/* xClose method */</comment>
  <argument>dotlockLock</argument>,              <comment type="block">/* xLock method */</comment>
  <argument>dotlockUnlock</argument>,            <comment type="block">/* xUnlock method */</comment>
  <argument>dotlockCheckReservedLock</argument>, <comment type="block">/* xCheckReservedLock method */</comment>
  <argument><literal type="number">0</literal></argument>                         <comment type="block">/* xShmMap method */</comment>
)</argument_list></macro>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>flockIoFinder</argument>,            <comment type="block">/* Finder function name */</comment>
  <argument>flockIoMethods</argument>,           <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument><literal type="number">1</literal></argument>,                        <comment type="block">/* shared memory is disabled */</comment>
  <argument>flockClose</argument>,               <comment type="block">/* xClose method */</comment>
  <argument>flockLock</argument>,                <comment type="block">/* xLock method */</comment>
  <argument>flockUnlock</argument>,              <comment type="block">/* xUnlock method */</comment>
  <argument>flockCheckReservedLock</argument>,   <comment type="block">/* xCheckReservedLock method */</comment>
  <argument><literal type="number">0</literal></argument>                         <comment type="block">/* xShmMap method */</comment>
)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>semIoFinder</argument>,              <comment type="block">/* Finder function name */</comment>
  <argument>semIoMethods</argument>,             <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument><literal type="number">1</literal></argument>,                        <comment type="block">/* shared memory is disabled */</comment>
  <argument>semXClose</argument>,                <comment type="block">/* xClose method */</comment>
  <argument>semXLock</argument>,                 <comment type="block">/* xLock method */</comment>
  <argument>semXUnlock</argument>,               <comment type="block">/* xUnlock method */</comment>
  <argument>semXCheckReservedLock</argument>,    <comment type="block">/* xCheckReservedLock method */</comment>
  <argument><literal type="number">0</literal></argument>                         <comment type="block">/* xShmMap method */</comment>
)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>afpIoFinder</argument>,              <comment type="block">/* Finder function name */</comment>
  <argument>afpIoMethods</argument>,             <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument><literal type="number">1</literal></argument>,                        <comment type="block">/* shared memory is disabled */</comment>
  <argument>afpClose</argument>,                 <comment type="block">/* xClose method */</comment>
  <argument>afpLock</argument>,                  <comment type="block">/* xLock method */</comment>
  <argument>afpUnlock</argument>,                <comment type="block">/* xUnlock method */</comment>
  <argument>afpCheckReservedLock</argument>,     <comment type="block">/* xCheckReservedLock method */</comment>
  <argument><literal type="number">0</literal></argument>                         <comment type="block">/* xShmMap method */</comment>
)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The proxy locking method is a "super-method" in the sense that it
** opens secondary file descriptors for the conch and lock files and
** it uses proxy, dot-file, AFP, and flock() locking methods on those
** secondary files.  For this reason, the division that implements
** proxy locking is located much further down in the file.  But we need
** to go ahead and define the sqlite3_io_methods and finder function
** for proxy locking here.  So we forward declare the I/O methods.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>proxyClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>proxyLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>proxyUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>proxyCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>proxyIoFinder</argument>,            <comment type="block">/* Finder function name */</comment>
  <argument>proxyIoMethods</argument>,           <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument><literal type="number">1</literal></argument>,                        <comment type="block">/* shared memory is disabled */</comment>
  <argument>proxyClose</argument>,               <comment type="block">/* xClose method */</comment>
  <argument>proxyLock</argument>,                <comment type="block">/* xLock method */</comment>
  <argument>proxyUnlock</argument>,              <comment type="block">/* xUnlock method */</comment>
  <argument>proxyCheckReservedLock</argument>,   <comment type="block">/* xCheckReservedLock method */</comment>
  <argument><literal type="number">0</literal></argument>                         <comment type="block">/* xShmMap method */</comment>
)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* nfs lockd on OSX 10.3+ doesn't clear write locks when a read lock is set */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>nfsIoFinder</argument>,               <comment type="block">/* Finder function name */</comment>
  <argument>nfsIoMethods</argument>,              <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument><literal type="number">1</literal></argument>,                         <comment type="block">/* shared memory is disabled */</comment>
  <argument>unixClose</argument>,                 <comment type="block">/* xClose method */</comment>
  <argument>unixLock</argument>,                  <comment type="block">/* xLock method */</comment>
  <argument>nfsUnlock</argument>,                 <comment type="block">/* xUnlock method */</comment>
  <argument>unixCheckReservedLock</argument>,     <comment type="block">/* xCheckReservedLock method */</comment>
  <argument><literal type="number">0</literal></argument>                          <comment type="block">/* xShmMap method */</comment>
)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<comment type="block">/* 
** This "finder" function attempts to determine the best locking strategy 
** for the database file "filePath".  It then returns the sqlite3_io_methods
** object that implements that strategy.
**
** This is for MacOSX only.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_io_methods</name> <modifier>*</modifier></type><name>autolockIoFinderImpl</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filePath</name></decl></parameter>,    <comment type="block">/* name of the database file */</comment>
  <parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>           <comment type="block">/* open file object for the database file */</comment>
)</parameter_list><block>{<block_content>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <name>Mapping</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilesystem</name></decl>;</decl_stmt>              <comment type="block">/* Filesystem type name */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_io_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>   <comment type="block">/* Appropriate locking method */</comment>
  }</block> <decl><name><name>aMap</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"hfs"</literal></expr>,    <expr><operator>&amp;</operator><name>posixIoMethods</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"ufs"</literal></expr>,    <expr><operator>&amp;</operator><name>posixIoMethods</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"afpfs"</literal></expr>,  <expr><operator>&amp;</operator><name>afpIoMethods</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"smbfs"</literal></expr>,  <expr><operator>&amp;</operator><name>afpIoMethods</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"webdav"</literal></expr>, <expr><operator>&amp;</operator><name>nolockIoMethods</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>statfs</name></name></type> <name>fsInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>lockInfo</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>filePath</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If filePath==NULL that means we are dealing with a transient file
    ** that does not need to be locked. */</comment>
    <return>return <expr><operator>&amp;</operator><name>nolockIoMethods</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>statfs</name><argument_list>(<argument><expr><name>filePath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsInfo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>fsInfo</name><operator>.</operator><name>f_flags</name></name> <operator>&amp;</operator> <name>MNT_RDONLY</name></expr> )</condition><block>{<block_content>
      <return>return <expr><operator>&amp;</operator><name>nolockIoMethods</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aMap</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zFilesystem</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fsInfo</name><operator>.</operator><name>f_fstypename</name></name></expr></argument>, <argument><expr><name><name>aMap</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zFilesystem</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name><name>aMap</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pMethods</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Default case. Handles, amongst others, "nfs".
  ** Test byte-range lock using fcntl(). If the call succeeds, 
  ** assume that the file-system supports POSIX style locks. 
  */</comment>
  <expr_stmt><expr><name><name>lockInfo</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lockInfo</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lockInfo</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lockInfo</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_RDLCK</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osFcntl</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_GETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lockInfo</name></expr></argument>)</argument_list></call><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition> <block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fsInfo</name><operator>.</operator><name>f_fstypename</name></name></expr></argument>, <argument><expr><literal type="string">"nfs"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><operator>&amp;</operator><name>nfsIoMethods</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><operator>&amp;</operator><name>posixIoMethods</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>&amp;</operator><name>dotlockIoMethods</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<expr_stmt><expr><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_io_methods</name> 
  <operator>*</operator><operator>(</operator><operator>*</operator><specifier>const</specifier> <name>autolockIoFinder</name><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>,</operator><name>unixFile</name><operator>*</operator><operator>)</operator> <operator>=</operator> <name>autolockIoFinderImpl</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__APPLE__) &amp;&amp; SQLITE_ENABLE_LOCKING_STYLE */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
<comment type="block">/*
** This "finder" function for VxWorks checks to see if posix advisory
** locking works.  If it does, then that is what is used.  If it does not
** work, then fallback to named semaphore locking.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_io_methods</name> <modifier>*</modifier></type><name>vxworksIoFinderImpl</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filePath</name></decl></parameter>,    <comment type="block">/* name of the database file */</comment>
  <parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>           <comment type="block">/* the open file object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>flock</name></name></type> <name>lockInfo</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>filePath</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If filePath==NULL that means we are dealing with a transient file
    ** that does not need to be locked. */</comment>
    <return>return <expr><operator>&amp;</operator><name>nolockIoMethods</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Test if fcntl() is supported and use POSIX style locks.
  ** Otherwise fall back to the named semaphore method.
  */</comment>
  <expr_stmt><expr><name><name>lockInfo</name><operator>.</operator><name>l_len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lockInfo</name><operator>.</operator><name>l_start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lockInfo</name><operator>.</operator><name>l_whence</name></name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lockInfo</name><operator>.</operator><name>l_type</name></name> <operator>=</operator> <name>F_RDLCK</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osFcntl</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>F_GETLK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lockInfo</name></expr></argument>)</argument_list></call><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition> <block>{<block_content>
    <return>return <expr><operator>&amp;</operator><name>posixIoMethods</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>&amp;</operator><name>semIoMethods</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<expr_stmt><expr><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_io_methods</name> 
  <operator>*</operator><operator>(</operator><operator>*</operator><specifier>const</specifier> <name>vxworksIoFinder</name><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>,</operator><name>unixFile</name><operator>*</operator><operator>)</operator> <operator>=</operator> <name>vxworksIoFinderImpl</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OS_VXWORKS */</comment>

<comment type="block">/*
** An abstract type for a pointer to an IO method finder function:
*/</comment>
<typedef>typedef <function_decl><type><specifier>const</specifier> <name>sqlite3_io_methods</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>finder_type</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>unixFile</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>


<comment type="block" format="doxygen">/****************************************************************************
**************************** sqlite3_vfs methods ****************************
**
** This division contains the implementation of methods on the
** sqlite3_vfs object.
*/</comment>

<comment type="block">/*
** Initialize the contents of the unixFile structure pointed to by pId.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fillInUnixFile</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,      <comment type="block">/* Pointer to vfs object */</comment>
  <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>,                  <comment type="block">/* Open file descriptor of file being opened */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pId</name></decl></parameter>,      <comment type="block">/* Write to the unixFile structure here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,  <comment type="block">/* Name of the file being opened */</comment>
  <parameter><decl><type><name>int</name></type> <name>ctrlFlags</name></decl></parameter>           <comment type="block">/* Zero or more UNIXFILE_* values */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_io_methods</name> <modifier>*</modifier></type><name>pLockingStyle</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>pId</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pInode</name></name><operator>==</operator><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Usually the path zFilename should not be a relative pathname. The
  ** exception is when opening the proxy "conch" file in builds that
  ** include the special Apple locking styles.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal> 
    <operator>||</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>==</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>autolockIoFinder</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* No locking occurs in temporary files */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zFilename</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>ctrlFlags</name> <operator>&amp;</operator> <name>UNIXFILE_NOLOCK</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPEN    %-3d %s\n"</literal><operator>,</operator> <name>h</name><operator>,</operator> <name>zFilename</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pVfs</name></name> <operator>=</operator> <name>pVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <name>zFilename</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>ctrlFlags</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>mmapSizeMax</name></name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szMmap</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_uri_boolean</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>ctrlFlags</name> <operator>&amp;</operator> <name>UNIXFILE_URI</name><operator>)</operator></expr> ?</condition><then> <expr><name>zFilename</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                           <argument><expr><literal type="string">"psow"</literal></expr></argument>, <argument><expr><name>SQLITE_POWERSAFE_OVERWRITE</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>|=</operator> <name>UNIXFILE_PSOW</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,<argument><expr><literal type="string">"unix-excl"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>|=</operator> <name>UNIXFILE_EXCL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pId</name></name> <operator>=</operator> <call><name>vxworksFindFileId</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>pId</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>ctrlFlags</name> <operator>|=</operator> <name>UNIXFILE_NOLOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>ctrlFlags</name> <operator>&amp;</operator> <name>UNIXFILE_NOLOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pLockingStyle</name> <operator>=</operator> <operator>&amp;</operator><name>nolockIoMethods</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pLockingStyle</name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>*</operator><operator>(</operator><name>finder_type</name><operator>*</operator><operator>)</operator><name><name>pVfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator><operator>(</operator><name>zFilename</name><operator>,</operator> <name>pNew</name><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
    <comment type="block">/* Cache zFilename in the locking context (AFP and dotlock override) for
    ** proxyLock activation is possible (remote proxy is based on db name)
    ** zFilename remains valid until file is closed, to support */</comment>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>lockingContext</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>zFilename</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pLockingStyle</name> <operator>==</operator> <operator>&amp;</operator><name>posixIoMethods</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
    <operator>||</operator> <name>pLockingStyle</name> <operator>==</operator> <operator>&amp;</operator><name>nfsIoMethods</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>findInodeInfo</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>pInode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If an error occurred in findInodeInfo(), close the file descriptor
      ** immediately, before releasing the mutex. findInodeInfo() may fail
      ** in two scenarios:
      **
      **   (a) A call to fstat() failed.
      **   (b) A malloc failed.
      **
      ** Scenario (b) may only occur if the process is holding no other
      ** file descriptors open on the same file. If there were other file
      ** descriptors on this file, then no malloc would be required by
      ** findInodeInfo(). If this is the case, it is quite safe to close
      ** handle h - as it is guaranteed that no posix locks will be released
      ** by doing so.
      **
      ** If scenario (a) caused the error then things are not so safe. The
      ** implicit assumption here is that if fstat() fails, things are in
      ** such bad shape that dropping a lock or two doesn't matter much.
      */</comment>
      <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if type="elseif">else if<condition>( <expr><name>pLockingStyle</name> <operator>==</operator> <operator>&amp;</operator><name>afpIoMethods</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* AFP locking uses the file path so it needs to be included in
    ** the afpLockingContext.
    */</comment>
    <decl_stmt><decl><type><name>afpLockingContext</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>lockingContext</name></name> <operator>=</operator> <name>pCtx</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCtx</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCtx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* NB: zFilename exists and remains valid until the file is closed
      ** according to requirement F11141.  So we do not need to make a
      ** copy of the filename. */</comment>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>dbPath</name></name> <operator>=</operator> <name>zFilename</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>srandomdev</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>findInodeInfo</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>pInode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>        
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if type="elseif">else if<condition>( <expr><name>pLockingStyle</name> <operator>==</operator> <operator>&amp;</operator><name>dotlockIoMethods</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Dotfile locking uses the file path so it needs to be included in
    ** the dotlockLockingContext 
    */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLockFile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nFilename</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zFilename</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nFilename</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zLockFile</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zLockFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nFilename</name></expr></argument>, <argument><expr><name>zLockFile</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal> <name>DOTLOCK_SUFFIX</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>lockingContext</name></name> <operator>=</operator> <name>zLockFile</name></expr>;</expr_stmt>
  </block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <if type="elseif">else if<condition>( <expr><name>pLockingStyle</name> <operator>==</operator> <operator>&amp;</operator><name>semIoMethods</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Named semaphore locking uses the file path so it needs to be
    ** included in the semLockingContext
    */</comment>
    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>findInodeInfo</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>pInode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pSem</name></name><operator>==</operator><name>NULL</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSemName</name> <init>= <expr><name><name>pNew</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>aSemName</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>MAX_PATHNAME</name></expr></argument>, <argument><expr><name>zSemName</name></expr></argument>, <argument><expr><literal type="string">"/%s.sem"</literal></expr></argument>,
                       <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pId</name><operator>-&gt;</operator><name>zCanonicalName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>( <init><expr><name>n</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>zSemName</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr> )</control><block type="pseudo"><block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zSemName</name><index>[<expr><name>n</name></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zSemName</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pSem</name></name> <operator>=</operator> <call><name>sem_open</name><argument_list>(<argument><expr><name>zSemName</name></expr></argument>, <argument><expr><name>O_CREAT</name></expr></argument>, <argument><expr><literal type="number">0666</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>pSem</name></name> <operator>==</operator> <name>SEM_FAILED</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>aSemName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>h</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>osUnlink</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>|=</operator> <name>UNIXFILE_DELETE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>h</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>=</operator> <name>pLockingStyle</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OpenCounter</name><argument_list>(<argument><expr><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>verifyDbFile</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the name of a directory in which to put temporary files.
** If no suitable temporary file directory can be found, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unixTempFileDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azDirs</name><index>[]</index></name> <init>= <expr><block>{
     <expr><literal type="number">0</literal></expr>,
     <expr><literal type="number">0</literal></expr>,
     <expr><literal type="string">"/var/tmp"</literal></expr>,
     <expr><literal type="string">"/usr/tmp"</literal></expr>,
     <expr><literal type="string">"/tmp"</literal></expr>,
     <expr><literal type="string">"."</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDir</name> <init>= <expr><name>sqlite3_temp_directory</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>azDirs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>azDirs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"SQLITE_TMPDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>azDirs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>azDirs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TMPDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azDirs</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azDirs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>zDir</name><operator>=</operator><name><name>azDirs</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>zDir</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>osStat</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>osAccess</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>, <argument><expr><literal type="number">07</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <break>break;</break>
  </block_content>}</block></for>
  <return>return <expr><name>zDir</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a temporary file name in zBuf.  zBuf must be allocated
** by the calling process and must be big enough to hold at least
** pVfs-&gt;mxPathname bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixGetTempname</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* It's odd to simulate an io-error here, but really this is just
  ** using the io-error infrastructure to test that SQLite handles this
  ** function failing. 
  */</comment>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><name>zDir</name> <operator>=</operator> <call><name>unixTempFileDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nBuf</name><operator>&gt;</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>nBuf</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal><name>SQLITE_TEMP_FILE_PREFIX</name><literal type="string">"%llx%c"</literal></expr></argument>,
                     <argument><expr><name>zDir</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zBuf</name><index>[<expr><name>nBuf</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iLimit</name><operator>++</operator><operator>)</operator><operator>&gt;</operator><literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block>while<condition>( <expr><call><name>osAccess</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Routine to transform a unixFile into a proxy-locking unixFile.
** Implementation in the proxy-lock division, but used by unixOpen()
** if SQLITE_PREFER_PROXY_LOCKING is defined.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>proxyTransformUnixFile</name><parameter_list>(<parameter><decl><type><name>unixFile</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Search for an unused file descriptor that was opened on the database 
** file (not a journal or master-journal file) identified by pathname
** zPath with SQLITE_OPEN_XXX flags matching those passed as the second
** argument to this function.
**
** Such a file descriptor may exist if a database connection was closed
** but the associated file descriptor could not be closed because some
** other file descriptor open on the same file is holding a file-lock.
** Refer to comments in the unixClose() function and the lengthy comment
** describing "Posix Advisory Locking" at the start of this file for 
** further details. Also, ticket #4018.
**
** If a suitable file descriptor is found, then it is returned. If no
** such file descriptor is located, -1 is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>UnixUnusedFd</name> <modifier>*</modifier></type><name>findReusableFd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pUnused</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Do not search for an unused file descriptor on vxworks. Not because
  ** vxworks would not benefit from the change (it might, we're not sure),
  ** but because no way to test it is currently available. It is better 
  ** not to risk breaking vxworks support for the sake of such an obscure 
  ** feature.  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>OS_VXWORKS</name></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>                   <comment type="block">/* Results of stat() call */</comment>

  <comment type="block">/* A stat() call may fail for various reasons. If this happens, it is
  ** almost certain that an open() call on the same path will also fail.
  ** For this reason, if an error occurs in the stat() call here, it is
  ** ignored and -1 is returned. The caller will try to open a new file
  ** descriptor on the same path, fail, and return an error to SQLite.
  **
  ** Even if a subsequent open() call does succeed, the consequences of
  ** not searching for a reusable file descriptor are not dire.  */</comment>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>osStat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unixInodeInfo</name> <modifier>*</modifier></type><name>pInode</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name>inodeList</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pInode</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pInode</name><operator>-&gt;</operator><name>fileId</name><operator>.</operator><name>dev</name></name><operator>!=</operator><name><name>sStat</name><operator>.</operator><name>st_dev</name></name>
                     <operator>||</operator> <name><name>pInode</name><operator>-&gt;</operator><name>fileId</name><operator>.</operator><name>ino</name></name><operator>!=</operator><name><name>sStat</name><operator>.</operator><name>st_ino</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>pInode</name> <operator>=</operator> <name><name>pInode</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>pInode</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pInode</name><operator>-&gt;</operator><name>pUnused</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>flags</name></name><operator>!=</operator><name>flags</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <expr_stmt><expr><name>pUnused</name> <operator>=</operator> <operator>*</operator><name>pp</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pUnused</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pUnused</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    <comment type="block">/* if !OS_VXWORKS */</comment>
  <return>return <expr><name>pUnused</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by unixOpen() to determine the unix permissions
** to create new files with. If no error occurs, then SQLITE_OK is returned
** and a value suitable for passing as the third argument to open(2) is
** written to *pMode. If an IO error occurs, an SQLite error code is 
** returned and the value of *pMode is not modified.
**
** In most cases, this routine sets *pMode to 0, which will become
** an indication to robust_open() to create the file using
** SQLITE_DEFAULT_FILE_PERMISSIONS adjusted by the umask.
** But if the file being opened is a WAL or regular journal file, then 
** this function queries the file-system for the permissions on the 
** corresponding database file and sets *pMode to this value. Whenever 
** possible, WAL and journal files are created using the same permissions 
** as the associated database file.
**
** If the SQLITE_ENABLE_8_3_NAMES option is enabled, then the
** original filename is unavailable.  But 8_3_NAMES is only used for
** FAT filesystems and permissions do not matter there, so just use
** the default permissions.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>findCreateFileMode</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,              <comment type="block">/* Path of file (possibly) being created */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                      <comment type="block">/* Flags passed as 4th argument to xOpen() */</comment>
  <parameter><decl><type><name>mode_t</name> <modifier>*</modifier></type><name>pMode</name></decl></parameter>,                  <comment type="block">/* OUT: Permissions to open file with */</comment>
  <parameter><decl><type><name>uid_t</name> <modifier>*</modifier></type><name>pUid</name></decl></parameter>,                    <comment type="block">/* OUT: uid to set on the file */</comment>
  <parameter><decl><type><name>gid_t</name> <modifier>*</modifier></type><name>pGid</name></decl></parameter>                     <comment type="block">/* OUT: gid to set on the file */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <expr_stmt><expr><operator>*</operator><name>pMode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pUid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pGid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_OPEN_WAL</name><operator>|</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zDb</name><index>[<expr><name>MAX_PATHNAME</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* Database file path */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nDb</name></decl>;</decl_stmt>                      <comment type="block">/* Number of valid bytes in zDb */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>            <comment type="block">/* Output of stat() on database file */</comment>

    <comment type="block">/* zPath is a path to a WAL or journal file. The following block derives
    ** the path to the associated database file from zPath. This block handles
    ** the following naming conventions:
    **
    **   "&lt;path to db&gt;-journal"
    **   "&lt;path to db&gt;-wal"
    **   "&lt;path to db&gt;-journalNN"
    **   "&lt;path to db&gt;-walNN"
    **
    ** where NN is a decimal number. The NN naming schemes are 
    ** used by the test_multiplex.c module.
    */</comment>
    <expr_stmt><expr><name>nDb</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
    <while>while<condition>( <expr><name><name>zPath</name><index>[<expr><name>nDb</name></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_8_3_NAMES</name></cpp:ifndef>
      <comment type="block">/* In the normal case (8+3 filenames disabled) the journal filename
      ** is guaranteed to contain a '-' character. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nDb</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3Isalnum</name><argument_list>(<argument><expr><name><name>zPath</name><index>[<expr><name>nDb</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* If 8+3 names are possible, then the journal file might not contain
      ** a '-' character.  So check for that case and return early. */</comment>
      <if_stmt><if>if<condition>( <expr><name>nDb</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zPath</name><index>[<expr><name>nDb</name></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>nDb</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>nDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zDb</name><index>[<expr><name>nDb</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>osStat</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pMode</name> <operator>=</operator> <name><name>sStat</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <literal type="number">0777</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pUid</name> <operator>=</operator> <name><name>sStat</name><operator>.</operator><name>st_uid</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pGid</name> <operator>=</operator> <name><name>sStat</name><operator>.</operator><name>st_gid</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_FSTAT</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pMode</name> <operator>=</operator> <literal type="number">0600</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open the file zPath.
** 
** Previously, the SQLite OS layer used three functions in place of this
** one:
**
**     sqlite3OsOpenReadWrite();
**     sqlite3OsOpenReadOnly();
**     sqlite3OsOpenExclusive();
**
** These calls correspond to the following combinations of flags:
**
**     ReadWrite() -&gt;     (READWRITE | CREATE)
**     ReadOnly()  -&gt;     (READONLY) 
**     OpenExclusive() -&gt; (READWRITE | CREATE | EXCLUSIVE)
**
** The old OpenExclusive() accepted a boolean argument - "delFlag". If
** true, the file was configured to be automatically deleted when the
** file handle closed. To achieve the same effect using this new 
** interface, add the DELETEONCLOSE flag to those specified above for 
** OpenExclusive().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,           <comment type="block">/* The VFS for which this is the xOpen method */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,           <comment type="block">/* Pathname of file to be opened */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,         <comment type="block">/* The file descriptor to be filled in */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                   <comment type="block">/* Input flags to control the opening */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutFlags</name></decl></parameter>               <comment type="block">/* Output flags returned to SQLite core */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* File descriptor returned by open() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>openFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Flags to pass to open() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><name>flags</name><operator>&amp;</operator><literal type="number">0xFFFFFF00</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Type of file to open */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>noLock</name></decl>;</decl_stmt>                    <comment type="block">/* True to omit locking primitives */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Function Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ctrlFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* UNIXFILE_* flags */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>isExclusive</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_EXCLUSIVE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isDelete</name>     <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isCreate</name>     <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_CREATE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadonly</name>   <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_READONLY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadWrite</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_READWRITE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>isAutoProxy</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_AUTOPROXY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>statfs</name></name></type> <name>fsInfo</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If creating a master or main-file journal, this function will open
  ** a file-descriptor on the directory too. The first time unixSync()
  ** is called the directory file descriptor will be fsync()ed and close()d.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>syncDir</name> <init>= <expr><operator>(</operator><name>isCreate</name> <operator>&amp;&amp;</operator> <operator>(</operator>
        <name>eType</name><operator>==</operator><name>SQLITE_OPEN_MASTER_JOURNAL</name> 
     <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name> 
     <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_WAL</name>
  <operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If argument zPath is a NULL pointer, this function is required to open
  ** a temporary file. Use this buffer to store the file name in.
  */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTmpname</name><index>[<expr><name>MAX_PATHNAME</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name>zPath</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the following statements are true: 
  **
  **   (a) Exactly one of the READWRITE and READONLY flags must be set, and 
  **   (b) if CREATE is set, then READWRITE must also be set, and
  **   (c) if EXCLUSIVE is set, then CREATE must also be set.
  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>isReadonly</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isReadWrite</name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>isReadWrite</name> <operator>||</operator> <name>isReadonly</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isCreate</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isReadWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isExclusive</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isDelete</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The main DB, main journal, WAL file and master journal are never 
  ** automatically deleted. Nor are they ever temporary files.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>!</operator><name>isDelete</name> <operator>&amp;&amp;</operator> <name>zName</name><operator>)</operator> <operator>||</operator> <name>eType</name><operator>!=</operator><name>SQLITE_OPEN_MAIN_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>!</operator><name>isDelete</name> <operator>&amp;&amp;</operator> <name>zName</name><operator>)</operator> <operator>||</operator> <name>eType</name><operator>!=</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>!</operator><name>isDelete</name> <operator>&amp;&amp;</operator> <name>zName</name><operator>)</operator> <operator>||</operator> <name>eType</name><operator>!=</operator><name>SQLITE_OPEN_MASTER_JOURNAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>!</operator><name>isDelete</name> <operator>&amp;&amp;</operator> <name>zName</name><operator>)</operator> <operator>||</operator> <name>eType</name><operator>!=</operator><name>SQLITE_OPEN_WAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Assert that the upper layer has set one of the "file-type" flags. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_OPEN_MAIN_DB</name>      <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_TEMP_DB</name> 
       <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_TEMP_JOURNAL</name> 
       <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_SUBJOURNAL</name>   <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_MASTER_JOURNAL</name> 
       <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_TRANSIENT_DB</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_WAL</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Detect a pid change and reset the PRNG.  There is a race condition
  ** here such that two or more threads all trying to open databases at
  ** the same instant might all reset the PRNG.  But multiple resets
  ** are harmless.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>randomnessPid</name><operator>!=</operator><call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>randomnessPid</name> <operator>=</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unixFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_OPEN_MAIN_DB</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pUnused</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pUnused</name> <operator>=</operator> <call><name>findReusableFd</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pUnused</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>fd</name> <operator>=</operator> <name><name>pUnused</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pUnused</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pUnused</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pUnused</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUnused</name></name> <operator>=</operator> <name>pUnused</name></expr>;</expr_stmt>

    <comment type="block">/* Database filenames are double-zero terminated if they are not
    ** URIs with parameters.  Hence, they can always be passed into
    ** sqlite3_uri_parameter(). */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_URI</name><operator>)</operator> <operator>||</operator> <name><name>zName</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name>zName</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If zName is NULL, the upper layer is requesting a temp file. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isDelete</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>syncDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixGetTempname</name><argument_list>(<argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>, <argument><expr><name>zTmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <name>zTmpname</name></expr>;</expr_stmt>

    <comment type="block">/* Generated temporary filenames are always double-zero terminated
    ** for use by sqlite3_uri_parameter(). */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zName</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Determine the value of the flags parameter passed to POSIX function
  ** open(). These must be calculated even if open() is not called, as
  ** they may be stored as part of the file handle and used by the 
  ** 'conch file' locking functions later on.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isReadonly</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_RDONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isReadWrite</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_RDWR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isCreate</name></expr> )</condition><block type="pseudo"><block_content>    <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_CREAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isExclusive</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <operator>(</operator><name>O_EXCL</name><operator>|</operator><name>O_NOFOLLOW</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <operator>(</operator><name>O_LARGEFILE</name><operator>|</operator><name>O_BINARY</name><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>mode_t</name></type> <name>openMode</name></decl>;</decl_stmt>              <comment type="block">/* Permissions to create file with */</comment>
    <decl_stmt><decl><type><name>uid_t</name></type> <name>uid</name></decl>;</decl_stmt>                    <comment type="block">/* Userid for the file */</comment>
    <decl_stmt><decl><type><name>gid_t</name></type> <name>gid</name></decl>;</decl_stmt>                    <comment type="block">/* Groupid for the file */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>findCreateFileMode</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>openMode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pUnused</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_OPEN_WAL</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>robust_open</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><name>openMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPENX   %-3d %s 0%o\n"</literal><operator>,</operator> <name>fd</name><operator>,</operator> <name>zName</name><operator>,</operator> <name>openFlags</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>isExclusive</name> <operator>||</operator> <operator>(</operator><name>openFlags</name> <operator>&amp;</operator> <name>O_CREAT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>!=</operator><name>EISDIR</name> <operator>&amp;&amp;</operator> <name>isReadWrite</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Failed to open the file for read/write access. Try read-only. */</comment>
      <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>openFlags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>O_RDWR</name><operator>|</operator><name>O_CREAT</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SQLITE_OPEN_READONLY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>openFlags</name> <operator>|=</operator> <name>O_RDONLY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>isReadonly</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>robust_open</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><name>openMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_BKPT</name></expr></argument>, <argument><expr><literal type="string">"open"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>open_finished</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this process is running as root and if creating a new rollback
    ** journal or WAL file, set the ownership of the journal or WAL to be
    ** the same as the original database.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_OPEN_WAL</name><operator>|</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>robustFchown</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>fd</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOutFlags</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutFlags</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pUnused</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUnused</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUnused</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>isDelete</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <name>zName</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_UNLINK_AFTER_CLOSE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zPath</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>osUnlink</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
  <else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>=</operator> <name>openFlags</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>noLock</name> <operator>=</operator> <name>eType</name><operator>!=</operator><name>SQLITE_OPEN_MAIN_DB</name></expr>;</expr_stmt>

  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>fstatfs</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsInfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_ACCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"msdos"</literal></expr></argument>, <argument><expr><name><name>fsInfo</name><operator>.</operator><name>f_fstypename</name></name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>fsFlags</name> <operator>|=</operator> <name>SQLITE_FSFLAGS_IS_MSDOS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"exfat"</literal></expr></argument>, <argument><expr><name><name>fsInfo</name><operator>.</operator><name>f_fstypename</name></name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>pFile</name><operator>)</operator><operator>-&gt;</operator><name>fsFlags</name> <operator>|=</operator> <name>SQLITE_FSFLAGS_IS_MSDOS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Set up appropriate ctrlFlags */</comment>
  <if_stmt><if>if<condition>( <expr><name>isDelete</name></expr> )</condition><block type="pseudo"><block_content>                <expr_stmt><expr><name>ctrlFlags</name> <operator>|=</operator> <name>UNIXFILE_DELETE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isReadonly</name></expr> )</condition><block type="pseudo"><block_content>              <expr_stmt><expr><name>ctrlFlags</name> <operator>|=</operator> <name>UNIXFILE_RDONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>noLock</name></expr> )</condition><block type="pseudo"><block_content>                  <expr_stmt><expr><name>ctrlFlags</name> <operator>|=</operator> <name>UNIXFILE_NOLOCK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>syncDir</name></expr> )</condition><block type="pseudo"><block_content>                 <expr_stmt><expr><name>ctrlFlags</name> <operator>|=</operator> <name>UNIXFILE_DIRSYNC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_URI</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ctrlFlags</name> <operator>|=</operator> <name>UNIXFILE_URI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_PREFER_PROXY_LOCKING</name></expr></cpp:if>
  <expr_stmt><expr><name>isAutoProxy</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>isAutoProxy</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>zPath</name><operator>!=</operator><name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>noLock</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>xOpen</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>envforce</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"SQLITE_FORCE_PROXY_LOCKING"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>useProxy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* SQLITE_FORCE_PROXY_LOCKING==1 means force always use proxy, 0 means 
    ** never use proxy, NULL means use proxy for non-local files only.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>envforce</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>useProxy</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>envforce</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>useProxy</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name><name>fsInfo</name><operator>.</operator><name>f_flags</name></name><operator>&amp;</operator><name>MNT_LOCAL</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>useProxy</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fillInUnixFile</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>ctrlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>proxyTransformUnixFile</name><argument_list>(<argument><expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></argument>, <argument><expr><literal type="string">":auto:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Use unixClose to clean up the resources added in fillInUnixFile 
          ** and clear all the structure's references.  Specifically, 
          ** pFile-&gt;pMethods will be NULL so sqlite3OsClose will be a no-op 
          */</comment>
          <expr_stmt><expr><call><name>unixClose</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>open_finished</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fillInUnixFile</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>ctrlFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>open_finished</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUnused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Delete the file at zPath. If the dirSync argument is true, fsync()
** the directory after deleting the file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixDelete</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>,     <comment type="block">/* VFS containing this as the xDelete method */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,        <comment type="block">/* Name of file to be deleted */</comment>
  <parameter><decl><type><name>int</name></type> <name>dirSync</name></decl></parameter>               <comment type="block">/* If true, fsync() directory after deleting file */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>(<argument>return SQLITE_IOERR_DELETE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osUnlink</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>errno</name><operator>==</operator><name>ENOENT</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
        <operator>||</operator> <call><name>osAccess</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_DELETE_NOENT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_DELETE</name></expr></argument>, <argument><expr><literal type="string">"unlink"</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_DIRSYNC</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>dirSync</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osOpenDirectory</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>full_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_DIR_FSYNC</name></expr></argument>, <argument><expr><literal type="string">"fsync"</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_CANTOPEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Test the existence of or access permissions of file zPath. The
** test performed depends on the value of flags:
**
**     SQLITE_ACCESS_EXISTS: Return 1 if the file exists
**     SQLITE_ACCESS_READWRITE: Return 1 if the file is read and writable.
**     SQLITE_ACCESS_READONLY: Return 1 if the file is readable.
**
** Otherwise return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixAccess</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>,   <comment type="block">/* The VFS containing this xAccess method */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,      <comment type="block">/* Path of the file to examine */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,              <comment type="block">/* What do we want to learn about the zPath file? */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>            <comment type="block">/* Write result boolean here */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_ACCESS;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pResOut</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The spec says there are three possible values for flags.  But only
  ** two of them are actually used */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><name>SQLITE_ACCESS_EXISTS</name> <operator>||</operator> <name>flags</name><operator>==</operator><name>SQLITE_ACCESS_READWRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>==</operator><name>SQLITE_ACCESS_EXISTS</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <operator>(</operator><literal type="number">0</literal><operator>==</operator><call><name>osStat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>.</operator><name>st_size</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <call><name>osAccess</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>W_OK</name><operator>|</operator><name>R_OK</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
**
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mkFullPathname</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,              <comment type="block">/* Input path */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>,                     <comment type="block">/* Output buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>nOut</name></decl></parameter>                        <comment type="block">/* Allocated size of buffer zOut */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nPath</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>osGetcwd</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>nOut</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_BKPT</name></expr></argument>, <argument><expr><literal type="string">"getcwd"</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>iOff</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iOff</name><operator>+</operator><name>nPath</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&gt;</operator><name>nOut</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* SQLite assumes that xFullPathname() nul-terminates the output buffer
    ** even if it returns an error.  */</comment>
    <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>iOff</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_CANTOPEN_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nOut</name><operator>-</operator><name>iOff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Turn a relative pathname into a full pathname. The relative path
** is stored as a nul-terminated string in the buffer pointed to by
** zPath. 
**
** zOut points to a buffer of at least sqlite3_vfs.mxPathname bytes 
** (in this case, MAX_PATHNAME bytes). The full-path is written to
** this buffer before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixFullPathname</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,            <comment type="block">/* Pointer to vfs object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,            <comment type="block">/* Possibly relative input path */</comment>
  <parameter><decl><type><name>int</name></type> <name>nOut</name></decl></parameter>,                     <comment type="block">/* Size of output buffer in bytes */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>                    <comment type="block">/* Output buffer */</comment>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINK</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <return>return <expr><call><name>mkFullPathname</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nLink</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of symbolic links followed so far */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name>zPath</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Input path for each iteration of loop */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>==</operator><name>MAX_PATHNAME</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* It's odd to simulate an io-error here, but really this is just
  ** using the io-error infrastructure to test that SQLite handles this
  ** function failing. This function could fail if, for example, the
  ** current working directory has been unlinked.
  */</comment>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_ERROR</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <do>do <block>{<block_content>

    <comment type="block">/* Call stat() on path zIn. Set bLink to true if the path is a symbolic
    ** link, or false otherwise.  */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bLink</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>osLstat</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>errno</name><operator>!=</operator><name>ENOENT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_BKPT</name></expr></argument>, <argument><expr><literal type="string">"lstat"</literal></expr></argument>, <argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>bLink</name> <operator>=</operator> <call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bLink</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zDel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zDel</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zDel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>++</operator><name>nLink</name><operator>&gt;</operator><name>SQLITE_MAX_SYMLINKS</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>osReadlink</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zDel</name></expr></argument>, <argument><expr><name>nOut</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_BKPT</name></expr></argument>, <argument><expr><literal type="string">"readlink"</literal></expr></argument>, <argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>zDel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>n</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
            <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>+</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>&gt;</operator><name>nOut</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN_BKPT</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zDel</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>zDel</name></expr></argument>, <argument><expr><name>nByte</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zDel</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>zDel</name><index>[<expr><name>nByte</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>zIn</name> <operator>=</operator> <name>zDel</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>zIn</name><operator>!=</operator><name>zOut</name> <operator>||</operator> <name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>zIn</name><operator>!=</operator><name>zOut</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mkFullPathname</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>bLink</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zIn</name> <operator>=</operator> <name>zOut</name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition>;</do>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* HAVE_READLINK &amp;&amp; HAVE_LSTAT */</comment>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
<comment type="block">/*
** Interfaces for opening a shared library, finding entry points
** within the shared library, and closing the shared library.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>unixDlOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>dlopen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>RTLD_NOW</name> <operator>|</operator> <name>RTLD_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQLite calls this function immediately after a call to unixDlSym() or
** unixDlOpen() fails (returns a null pointer). If a more detailed error
** message is available, it is written to zBufOut. If no error message
** is available, zBufOut is left unmodified and SQLite uses a default
** error message.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixDlError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBufOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>dlerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>zBufOut</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym)</argument>)</argument_list></macro><operator>(</operator><name>void</name><operator>)</operator><block>{
  <comment type="block">/* 
  ** GCC with -pedantic-errors says that C90 does not allow a void* to be
  ** cast into a pointer to a function.  And yet the library dlsym() routine
  ** returns a void* which is really a pointer to a function.  So how do we
  ** use dlsym() with -pedantic-errors?
  **
  ** Variable x below is defined to be a pointer to a function taking
  ** parameters void* and const char* and returning a pointer to a function.
  ** We initialize x by assigning it a pointer to the dlsym() function.
  ** (That assignment requires a cast.)  Then we call the function that
  ** x points to.  
  **
  ** This work-around is unlikely to work correctly on any system where
  ** you really cannot cast a function pointer into void*.  But then, on the
  ** other hand, dlsym() will not work on such a system either, so we have
  ** not really lost anything.
  */</comment>
  <expr><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><call>(<modifier>*</modifier><name>x</name>)<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>,<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;
  <expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>x</name> <operator>=</operator> <operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator><call>(<modifier>*</modifier>)<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>,<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call><operator>)</operator><name>dlsym</name></expr>;
  <return>return <expr><call>(<modifier>*</modifier><name>x</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSym</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unixDlClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pHandle</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlclose</name><argument_list>(<argument><expr><name>pHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* if SQLITE_OMIT_LOAD_EXTENSION is defined: */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unixDlOpen</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unixDlError</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unixDlSym</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unixDlClose</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Write nBuf bytes of random data to the supplied buffer zBuf.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixRandomness</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nBuf</name><operator>&gt;=</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>time_t</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We have to initialize zBuf to prevent valgrind from reporting
  ** errors.  The reports issued by valgrind are incorrect - we would
  ** prefer that the randomness be increased by making use of the
  ** uninitialized space in zBuf - but valgrind errors tend to worry
  ** some users.  Rather than argue, it seems easier just to initialize
  ** the whole array and silence valgrind, even if that means less randomness
  ** in the random seed.
  **
  ** When testing, initializing zBuf[] to zero is all we do.  That means
  ** that we always use the same random number sequence.  This makes the
  ** tests repeatable.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>randomnessPid</name> <operator>=</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_RANDOMNESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>got</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>robust_open</name><argument_list>(<argument><expr><literal type="string">"/dev/urandom"</literal></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>randomnessPid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>randomnessPid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>randomnessPid</name></expr></argument>)</argument_list></sizeof><operator>&lt;=</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>nBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>randomnessPid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <do>do<block>{<block_content> <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>osRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><name>got</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>EINTR</name></expr> )</condition>;</do>
      <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>nBuf</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Sleep for a little while.  Return the amount of time slept.
** The argument is the number of microseconds we want to sleep.
** The return value is the number of microseconds of sleep actually
** requested from the underlying operating system, a number which
** might be greater than or equal to the argument, but not less
** than the argument.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixSleep</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>microseconds</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>sp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>sp</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>microseconds</name> <operator>/</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sp</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <operator>(</operator><name>microseconds</name> <operator>%</operator> <literal type="number">1000000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nanosleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>microseconds</name></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USLEEP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_USLEEP</name></expr></cpp:elif>
  <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name>microseconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>microseconds</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>seconds</name> <init>= <expr><operator>(</operator><name>microseconds</name><operator>+</operator><literal type="number">999999</literal><operator>)</operator><operator>/</operator><literal type="number">1000000</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>seconds</name><operator>*</operator><literal type="number">1000000</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** The following variable, if set to a non-zero value, is interpreted as
** the number of seconds since 1970 and is used to set the result of
** sqlite3OsCurrentTime() during testing.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_current_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Fake system time in seconds since 1970. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Find the current time (in Universal Coordinated Time).  Write into *piNow
** the current time and date as a Julian Day number times 86_400_000.  In
** other words, write into *piNow the number of milliseconds since the Julian
** epoch of noon in Greenwich on November 24, 4714 B.C according to the
** proleptic Gregorian calendar.
**
** On success, return SQLITE_OK.  Return SQLITE_ERROR if the time and date 
** cannot be found.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixCurrentTimeInt64</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piNow</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_int64</name></type> <name>unixEpoch</name> <init>= <expr><literal type="number">24405875</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">8640000</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_GETTOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piNow</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>t</name><operator>)</operator><operator>*</operator><literal type="number">1000</literal> <operator>+</operator> <name>unixEpoch</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:elif>
  <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>sNow</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sNow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piNow</name> <operator>=</operator> <name>unixEpoch</name> <operator>+</operator> <literal type="number">1000</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>sNow</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>sNow</name><operator>.</operator><name>tv_nsec</name></name><operator>/</operator><literal type="number">1000000</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>sNow</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNow</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Cannot fail given valid arguments */</comment>
  <expr_stmt><expr><operator>*</operator><name>piNow</name> <operator>=</operator> <name>unixEpoch</name> <operator>+</operator> <literal type="number">1000</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>sNow</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>sNow</name><operator>.</operator><name>tv_usec</name></name><operator>/</operator><literal type="number">1000</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>sqlite3_current_time</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piNow</name> <operator>=</operator> <literal type="number">1000</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>sqlite3_current_time</name> <operator>+</operator> <name>unixEpoch</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** Find the current time (in Universal Coordinated Time).  Write the
** current time and date as a Julian Day number into *prNow and
** return 0.  Return 1 if the time and date cannot be found.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixCurrentTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>prNow</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixCurrentTimeInt64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>prNow</name> <operator>=</operator> <name>i</name><operator>/</operator><literal type="number">86400000.0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>unixCurrentTime</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** We added the xGetLastError() method with the intention of providing
** better low-level error messages when operating-system problems come up
** during SQLite operation.  But so far, none of that has been implemented
** in the core.  So this routine is never called.  For now, it is merely
** a place-holder.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unixGetLastError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>NotUsed2</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>NotUsed3</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>unixGetLastError</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
************************ End of sqlite3_vfs methods ***************************
******************************************************************************/</comment>

<comment type="block" format="doxygen">/******************************************************************************
************************** Begin Proxy Locking ********************************
**
** Proxy locking is a "uber-locking-method" in this sense:  It uses the
** other locking methods on secondary lock files.  Proxy locking is a
** meta-layer over top of the primitive locking implemented above.  For
** this reason, the division that implements of proxy locking is deferred
** until late in the file (here) after all of the other I/O methods have
** been defined - so that the primitive locking methods are available
** as services to help with the implementation of proxy locking.
**
****
**
** The default locking schemes in SQLite use byte-range locks on the
** database file to coordinate safe, concurrent access by multiple readers
** and writers [http://sqlite.org/lockingv3.html].  The five file locking
** states (UNLOCKED, PENDING, SHARED, RESERVED, EXCLUSIVE) are implemented
** as POSIX read &amp; write locks over fixed set of locations (via fsctl),
** on AFP and SMB only exclusive byte-range locks are available via fsctl
** with _IOWR('z', 23, struct ByteRangeLockPB2) to track the same 5 states.
** To simulate a F_RDLCK on the shared range, on AFP a randomly selected
** address in the shared range is taken for a SHARED lock, the entire
** shared range is taken for an EXCLUSIVE lock):
**
**      PENDING_BYTE        0x40000000
**      RESERVED_BYTE       0x40000001
**      SHARED_RANGE        0x40000002 -&gt; 0x40000200
**
** This works well on the local file system, but shows a nearly 100x
** slowdown in read performance on AFP because the AFP client disables
** the read cache when byte-range locks are present.  Enabling the read
** cache exposes a cache coherency problem that is present on all OS X
** supported network file systems.  NFS and AFP both observe the
** close-to-open semantics for ensuring cache coherency
** [http://nfs.sourceforge.net/#faq_a8], which does not effectively
** address the requirements for concurrent database access by multiple
** readers and writers
** [http://www.nabble.com/SQLite-on-NFS-cache-coherency-td15655701.html].
**
** To address the performance and cache coherency issues, proxy file locking
** changes the way database access is controlled by limiting access to a
** single host at a time and moving file locks off of the database file
** and onto a proxy file on the local file system.  
**
**
** Using proxy locks
** -----------------
**
** C APIs
**
**  sqlite3_file_control(db, dbname, SQLITE_FCNTL_SET_LOCKPROXYFILE,
**                       &lt;proxy_path&gt; | ":auto:");
**  sqlite3_file_control(db, dbname, SQLITE_FCNTL_GET_LOCKPROXYFILE,
**                       &amp;&lt;proxy_path&gt;);
**
**
** SQL pragmas
**
**  PRAGMA [database.]lock_proxy_file=&lt;proxy_path&gt; | :auto:
**  PRAGMA [database.]lock_proxy_file
**
** Specifying ":auto:" means that if there is a conch file with a matching
** host ID in it, the proxy path in the conch file will be used, otherwise
** a proxy path based on the user's temp dir
** (via confstr(_CS_DARWIN_USER_TEMP_DIR,...)) will be used and the
** actual proxy file name is generated from the name and path of the
** database file.  For example:
**
**       For database path "/Users/me/foo.db" 
**       The lock path will be "&lt;tmpdir&gt;/sqliteplocks/_Users_me_foo.db:auto:")
**
** Once a lock proxy is configured for a database connection, it can not
** be removed, however it may be switched to a different proxy path via
** the above APIs (assuming the conch file is not being held by another
** connection or process). 
**
**
** How proxy locking works
** -----------------------
**
** Proxy file locking relies primarily on two new supporting files: 
**
**   *  conch file to limit access to the database file to a single host
**      at a time
**
**   *  proxy file to act as a proxy for the advisory locks normally
**      taken on the database
**
** The conch file - to use a proxy file, sqlite must first "hold the conch"
** by taking an sqlite-style shared lock on the conch file, reading the
** contents and comparing the host's unique host ID (see below) and lock
** proxy path against the values stored in the conch.  The conch file is
** stored in the same directory as the database file and the file name
** is patterned after the database file name as ".&lt;databasename&gt;-conch".
** If the conch file does not exist, or its contents do not match the
** host ID and/or proxy path, then the lock is escalated to an exclusive
** lock and the conch file contents is updated with the host ID and proxy
** path and the lock is downgraded to a shared lock again.  If the conch
** is held by another process (with a shared lock), the exclusive lock
** will fail and SQLITE_BUSY is returned.
**
** The proxy file - a single-byte file used for all advisory file locks
** normally taken on the database file.   This allows for safe sharing
** of the database file for multiple readers and writers on the same
** host (the conch ensures that they all use the same local lock file).
**
** Requesting the lock proxy does not immediately take the conch, it is
** only taken when the first request to lock database file is made.  
** This matches the semantics of the traditional locking behavior, where
** opening a connection to a database file does not take a lock on it.
** The shared lock and an open file descriptor are maintained until 
** the connection to the database is closed. 
**
** The proxy file and the lock file are never deleted so they only need
** to be created the first time they are used.
**
** Configuration options
** ---------------------
**
**  SQLITE_PREFER_PROXY_LOCKING
**
**       Database files accessed on non-local file systems are
**       automatically configured for proxy locking, lock files are
**       named automatically using the same logic as
**       PRAGMA lock_proxy_file=":auto:"
**    
**  SQLITE_PROXY_DEBUG
**
**       Enables the logging of error messages during host id file
**       retrieval and creation
**
**  LOCKPROXYDIR
**
**       Overrides the default directory used for lock proxy files that
**       are named automatically via the ":auto:" setting
**
**  SQLITE_DEFAULT_PROXYDIR_PERMISSIONS
**
**       Permissions to use when creating a directory for storing the
**       lock proxy files, only used when LOCKPROXYDIR is not set.
**    
**    
** As mentioned above, when compiled with SQLITE_PREFER_PROXY_LOCKING,
** setting the environment variable SQLITE_FORCE_PROXY_LOCKING to 1 will
** force proxy locking to be used for every database file opened, and 0
** will force automatic proxy locking to be disabled for all database
** files (explicitly calling the SQLITE_FCNTL_SET_LOCKPROXYFILE pragma or
** sqlite_file_control API is not affected by SQLITE_FORCE_PROXY_LOCKING).
*/</comment>

<comment type="block">/*
** Proxy locking is only available on MacOSX 
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>

<comment type="block">/*
** The proxyLockingContext has the path and file structures for the remote 
** and local proxy files in it
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>proxyLockingContext</name></name></type> <name>proxyLockingContext</name>;</typedef>
<struct>struct <name>proxyLockingContext</name> <block>{
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>conchFile</name></decl>;</decl_stmt>         <comment type="block">/* Open conch file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>conchFilePath</name></decl>;</decl_stmt>         <comment type="block">/* Name of the conch file */</comment>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>lockProxy</name></decl>;</decl_stmt>         <comment type="block">/* Open proxy lock file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lockProxyPath</name></decl>;</decl_stmt>         <comment type="block">/* Name of the proxy lock file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dbPath</name></decl>;</decl_stmt>                <comment type="block">/* Name of the open file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>conchHeld</name></decl>;</decl_stmt>               <comment type="block">/* 1 if the conch is held, -1 if lockless */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFails</name></decl>;</decl_stmt>                  <comment type="block">/* Number of conch taking failures */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>oldLockingContext</name></decl>;</decl_stmt>     <comment type="block">/* Original lockingcontext to restore on close */</comment>
  <decl_stmt><decl><type><name>sqlite3_io_methods</name> <specifier>const</specifier> <modifier>*</modifier></type><name>pOldMethod</name></decl>;</decl_stmt>     <comment type="block">/* Original I/O methods for close */</comment>
}</block>;</struct>

<comment type="block">/* 
** The proxy lock file path for the database at dbPath is written into lPath, 
** which must point to valid, writable memory large enough for a maxLen length
** file path. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyGetLockPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbPath</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lPath</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxLen</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>dbLen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCKPROXYDIR</name></cpp:ifdef>
  <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlcpy</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr><name>LOCKPROXYDIR</name></expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>_CS_DARWIN_USER_TEMP_DIR</name></cpp:ifdef>
  <block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>confstr</name><argument_list>(<argument><expr><name>_CS_DARWIN_USER_TEMP_DIR</name></expr></argument>, <argument><expr><name>lPath</name></expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"GETLOCKPATH  failed %s errno=%d pid=%d\n"</literal><operator>,</operator>
               <name>lPath</name><operator>,</operator> <name>errno</name><operator>,</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR_LOCK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlcat</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr><literal type="string">"sqliteplocks"</literal></expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
  </block_content>}</block>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlcpy</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr><literal type="string">"/tmp/"</literal></expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name><name>lPath</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlcat</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* transform the db path to a unique cache name */</comment>
  <expr_stmt><expr><name>dbLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>( <init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>dbLen</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name><operator>+</operator><name>len</name><operator>+</operator><literal type="number">7</literal><operator>)</operator><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>maxLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>dbPath</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>lPath</name><index>[<expr><name>i</name><operator>+</operator><name>len</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c</name><operator>==</operator><literal type="char">'/'</literal><operator>)</operator></expr>?</condition><then><expr><literal type="char">'_'</literal></expr></then><else>:<expr><name>c</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>lPath</name><index>[<expr><name>i</name><operator>+</operator><name>len</name></expr>]</index></name><operator>=</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strlcat</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr><literal type="string">":auto:"</literal></expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"GETLOCKPATH  proxy lock path=%s pid=%d\n"</literal><operator>,</operator> <name>lPath</name><operator>,</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 ** Creates the lock file and any missing directories in lockPath
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyCreateLockPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lockPath</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lockPath</name><operator>!=</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* try to create all the intermediate directories */</comment>
  <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>lockPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>lockPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>( <init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>lockPath</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name>start</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <comment type="block">/* only mkdir if leaf dir != "." or "/" or ".." */</comment>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>-</operator><name>start</name><operator>&gt;</operator><literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>i</name><operator>-</operator><name>start</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>start</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>start</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal><operator>)</operator> 
         <operator>||</operator> <operator>(</operator><name>i</name><operator>-</operator><name>start</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>start</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>start</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>osMkdir</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>SQLITE_DEFAULT_PROXYDIR_PERMISSIONS</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>err</name><init>=<expr><name>errno</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>err</name><operator>!=</operator><name>EEXIST</name></expr> )</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"CREATELOCKPATH  FAILED creating %s, "</literal>
                     <literal type="string">"'%s' proxy lock path=%s pid=%d\n"</literal><operator>,</operator>
                     <name>buf</name><operator>,</operator> <call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>,</operator> <name>lockPath</name><operator>,</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>err</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>start</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lockPath</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"CREATELOCKPATH  proxy lock path=%s pid=%d\n"</literal><operator>,</operator><name>lockPath</name><operator>,</operator><call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new VFS file descriptor (stored in memory obtained from
** sqlite3_malloc) and open the file named "path" in the file descriptor.
**
** The caller is responsible not only for closing the file descriptor
** but also for freeing the memory associated with the file descriptor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyCreateUnixFile</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,        <comment type="block">/* path for the new unixFile */</comment>
    <parameter><decl><type><name>unixFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppFile</name></decl></parameter>,       <comment type="block">/* unixFile created and returned by ref */</comment>
    <parameter><decl><type><name>int</name></type> <name>islockfile</name></decl></parameter>           <comment type="block">/* if non zero missing dirs will be created */</comment>
)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>openFlags</name> <init>= <expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vfs</name></type> <name>dummyVfs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>terrno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnixUnusedFd</name> <modifier>*</modifier></type><name>pUnused</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* 1. first try to open/create the file
  ** 2. if that fails, and this is a lock file (not-conch), try creating
  ** the parent directories and then try again.
  ** 3. if that fails, try to open the file read-only
  ** otherwise return BUSY (if lock file) or CANTOPEN for the conch file
  */</comment>
  <expr_stmt><expr><name>pUnused</name> <operator>=</operator> <call><name>findReusableFd</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pUnused</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <name><name>pUnused</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pUnused</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pUnused</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pUnused</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>robust_open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>ENOENT</name> <operator>&amp;&amp;</operator> <name>islockfile</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>proxyCreateLockPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>robust_open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>openFlags</name> <operator>=</operator> <name>O_RDONLY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>robust_open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>islockfile</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <switch>switch <condition>(<expr><name>terrno</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>EACCES</name></expr>:</case>
        <return>return <expr><name>SQLITE_PERM</name></expr>;</return>
      <case>case <expr><name>EIO</name></expr>:</case> 
        <return>return <expr><name>SQLITE_IOERR_LOCK</name></expr>;</return> <comment type="block">/* even though it is the conch */</comment>
      <default>default:</default>
        <return>return <expr><name>SQLITE_CANTOPEN_BKPT</name></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>unixFile</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>end_create_proxy</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unixFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>=</operator> <name>openFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dummyVfs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dummyVfs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dummyVfs</name><operator>.</operator><name>pAppData</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>autolockIoFinder</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dummyVfs</name><operator>.</operator><name>zName</name></name> <operator>=</operator> <literal type="string">"dummy"</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pUnused</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pUnused</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>openFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUnused</name></name> <operator>=</operator> <name>pUnused</name></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fillInUnixFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dummyVfs</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>pNew</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppFile</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<label><name>end_create_proxy</name>:</label>    
  <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pUnused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/* simulate multiple hosts by creating unique hostid file paths */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_hostid_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_HOSTIDLEN</name></cpp:macro>    <cpp:value>16</cpp:value></cpp:define>  <comment type="block">/* conch file host id length */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETHOSTUUID</name></cpp:ifdef>
<comment type="block">/* Not always defined in the headers as it ought to be */</comment>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>gethostuuid</name><parameter_list>(<parameter><decl><type><name>uuid_t</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>wait</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* get the host ID via gethostuuid(), pHostID must point to PROXY_HOSTIDLEN 
** bytes of writable memory.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyGetHostID</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pHostID</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pError</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>PROXY_HOSTIDLEN</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uuid_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pHostID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PROXY_HOSTIDLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETHOSTUUID</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>timeout</name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* 1 sec timeout */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>gethostuuid</name><argument_list>(<argument><expr><name>pHostID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pError</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pError</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <comment type="block">/* simulate multiple hosts by creating unique hostid file paths */</comment>
  <if_stmt><if>if<condition>( <expr><name>sqlite3_hostid_num</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pHostID</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name><name>pHostID</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>sqlite3_hostid_num</name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The conch file contains the header, host id and lock file path
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_CONCHVERSION</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>   <comment type="block">/* 1-byte header, 16-byte host id, path */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_HEADERLEN</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>   <comment type="block">/* conch file header length */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_PATHINDEX</name></cpp:macro>    <cpp:value>(PROXY_HEADERLEN+PROXY_HOSTIDLEN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_MAXCONCHLEN</name></cpp:macro>  <cpp:value>(PROXY_HEADERLEN+PROXY_HOSTIDLEN+MAXPATHLEN)</cpp:value></cpp:define>

<comment type="block">/* 
** Takes an open conch file, copies the contents to a new path and then moves 
** it back.  The newly created file's file descriptor is assigned to the
** conch file structure and finally the original conch file descriptor is 
** closed.  Returns zero if successful.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyBreakConchLock</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>uuid_t</name></type> <name>myHostID</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><operator>(</operator><name>proxyLockingContext</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>conchFile</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFile</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>tPath</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>PROXY_MAXCONCHLEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cPath</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFilePath</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>readLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>pathLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>errmsg</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>myHostID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* create a new path by replace the trailing '-conch' with '-break' */</comment>
  <expr_stmt><expr><name>pathLen</name> <operator>=</operator> <call><name>strlcpy</name><argument_list>(<argument><expr><name>tPath</name></expr></argument>, <argument><expr><name>cPath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pathLen</name><operator>&gt;</operator><name>MAXPATHLEN</name> <operator>||</operator> <name>pathLen</name><operator>&lt;</operator><literal type="number">6</literal> <operator>||</operator> 
     <operator>(</operator><call><name>strlcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tPath</name><index>[<expr><name>pathLen</name><operator>-</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"break"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">5</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>errmsg</name></expr></argument>,<argument><expr><literal type="string">"path error (len %d)"</literal></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>pathLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_breaklock</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* read the conch content */</comment>
  <expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name>osPread</name><argument_list>(<argument><expr><name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>PROXY_MAXCONCHLEN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>readLen</name><operator>&lt;</operator><name>PROXY_PATHINDEX</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>errmsg</name></expr></argument>,<argument><expr><literal type="string">"read error (len %d)"</literal></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>readLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_breaklock</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* write it out to the temporary break file */</comment>
  <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>robust_open</name><argument_list>(<argument><expr><name>tPath</name></expr></argument>, <argument><expr><operator>(</operator><name>O_RDWR</name><operator>|</operator><name>O_CREAT</name><operator>|</operator><name>O_EXCL</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>, <argument><expr><literal type="string">"create failed (%d)"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_breaklock</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osPwrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>readLen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><name>readLen</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>, <argument><expr><literal type="string">"write failed (%d)"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_breaklock</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>rename</name><argument_list>(<argument><expr><name>tPath</name></expr></argument>, <argument><expr><name>cPath</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>, <argument><expr><literal type="string">"rename failed (%d)"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_breaklock</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"broke stale lock on %s\n"</literal></expr></argument>, <argument><expr><name>cPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>conchFile</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>=</operator> <name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name></expr>;</expr_stmt>

<label><name>end_breaklock</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>osUnlink</name><argument_list>(<argument><expr><name>tPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to break stale lock on %s, %s\n"</literal></expr></argument>, <argument><expr><name>cPath</name></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Take the requested lock on the conch file and break a stale lock if the 
** host id matches.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyConchLock</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>uuid_t</name></type> <name>myHostID</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lockType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><operator>(</operator><name>proxyLockingContext</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>conchFile</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFile</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>conchModTime</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conchModTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>conchModTime</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>conchFile</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>conchFile</name></expr></argument>, <argument><expr><name>lockType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nTries</name> <operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the lock failed (busy):
       * 1st try: get the mod time of the conch, wait 0.5s and try again. 
       * 2nd try: fail if the mod time changed or host id is different, wait 
       *           10 sec and try again
       * 3rd try: break the lock unless the mod time has changed.
       */</comment>
      <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>osFstat</name><argument_list>(<argument><expr><name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_IOERR_LOCK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      
      <if_stmt><if>if<condition>( <expr><name>nTries</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>conchModTime</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>st_mtimespec</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><literal type="number">500000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* wait 0.5 sec and try the lock again*/</comment>
        <continue>continue;</continue>  
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTries</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>conchModTime</name><operator>.</operator><name>tv_sec</name></name> <operator>!=</operator> <name><name>buf</name><operator>.</operator><name>st_mtimespec</name><operator>.</operator><name>tv_sec</name></name> <operator>||</operator> 
         <name><name>conchModTime</name><operator>.</operator><name>tv_nsec</name></name> <operator>!=</operator> <name><name>buf</name><operator>.</operator><name>st_mtimespec</name><operator>.</operator><name>tv_nsec</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      
      <if_stmt><if>if<condition>( <expr><name>nTries</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>  
        <decl_stmt><decl><type><name>char</name></type> <name><name>tBuf</name><index>[<expr><name>PROXY_MAXCONCHLEN</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>osPread</name><argument_list>(<argument><expr><name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>tBuf</name></expr></argument>, <argument><expr><name>PROXY_MAXCONCHLEN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>len</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_IOERR_LOCK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><name>PROXY_PATHINDEX</name> <operator>&amp;&amp;</operator> <name><name>tBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><operator>(</operator><name>char</name><operator>)</operator><name>PROXY_CONCHVERSION</name></expr>)</condition><block>{<block_content>
          <comment type="block">/* don't break the lock if the host id doesn't match */</comment>
          <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>!=</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tBuf</name><index>[<expr><name>PROXY_HEADERLEN</name></expr>]</index></name></expr></argument>, <argument><expr><name>myHostID</name></expr></argument>, <argument><expr><name>PROXY_HOSTIDLEN</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* don't break the lock on short read or a version mismatch */</comment>
          <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><literal type="number">10000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* wait 10 sec and try the lock again */</comment>
        <continue>continue;</continue> 
      </block_content>}</block></if></if_stmt>
      
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTries</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>proxyBreakConchLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>myHostID</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>lockType</name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>conchFile</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>conchFile</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>rc</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>conchFile</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>conchFile</name></expr></argument>, <argument><expr><name>lockType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block> while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name> <operator>&amp;&amp;</operator> <name>nTries</name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition>;</do>
  
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Takes the conch by taking a shared lock and read the contents conch, if 
** lockPath is non-NULL, the host ID and lock file path must match.  A NULL 
** lockPath means that the lockPath in the conch file will be used if the 
** host IDs match, or a new lock path will be generated automatically 
** and written to the conch file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyTakeConch</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><operator>(</operator><name>proxyLockingContext</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt> 
  
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchHeld</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>conchFile</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFile</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uuid_t</name></type> <name>myHostID</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pError</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>readBuf</name><index>[<expr><name>PROXY_MAXCONCHLEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>lockPath</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tempLockPath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>createConch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hostIdMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>readLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tryOldLockPath</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>forceNewLockPath</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TAKECONCH  %d for %s pid=%d\n"</literal><operator>,</operator> <name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator>
             <operator>(</operator><ternary><condition><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr> ?</condition><then> <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr> </then><else>: <expr><literal type="string">":auto:"</literal></expr></else></ternary><operator>)</operator><operator>,</operator>
             <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>proxyGetHostID</name><argument_list>(<argument><expr><name>myHostID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_IOERR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>pError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>end_takeconch</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>proxyConchLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>myHostID</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>end_takeconch</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* read the existing conch file */</comment>
    <expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name>seekAndRead</name><argument_list>(<argument><expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>conchFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>readBuf</name></expr></argument>, <argument><expr><name>PROXY_MAXCONCHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>readLen</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* I/O error: lastErrno set by seekAndRead */</comment>
      <expr_stmt><expr><call><name>storeLastErrno</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name><name>conchFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_READ</name></expr>;</expr_stmt>
      <goto>goto <name>end_takeconch</name>;</goto>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>readLen</name><operator>&lt;=</operator><operator>(</operator><name>PROXY_HEADERLEN</name><operator>+</operator><name>PROXY_HOSTIDLEN</name><operator>)</operator> <operator>||</operator> 
             <name><name>readBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><operator>(</operator><name>char</name><operator>)</operator><name>PROXY_CONCHVERSION</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* a short read or version format mismatch means we need to create a new 
      ** conch file. 
      */</comment>
      <expr_stmt><expr><name>createConch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* if the host id matches and the lock path already exists in the conch
    ** we'll try to use the path there, if we can't open that path, we'll 
    ** retry with a new auto-generated path 
    */</comment>
    <do>do <block>{<block_content> <comment type="block">/* in case we need to try again for an :auto: named lock file */</comment>

      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>createConch</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forceNewLockPath</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>hostIdMatch</name> <operator>=</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readBuf</name><index>[<expr><name>PROXY_HEADERLEN</name></expr>]</index></name></expr></argument>, <argument><expr><name>myHostID</name></expr></argument>, 
                                  <argument><expr><name>PROXY_HOSTIDLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* if the conch has data compare the contents */</comment>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* for auto-named local lock file, just check the host ID and we'll
           ** use the local lock file path that's already in there
           */</comment>
          <if_stmt><if>if<condition>( <expr><name>hostIdMatch</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>pathLen</name> <init>= <expr><operator>(</operator><name>readLen</name> <operator>-</operator> <name>PROXY_PATHINDEX</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            
            <if_stmt><if>if<condition>( <expr><name>pathLen</name><operator>&gt;=</operator><name>MAXPATHLEN</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>pathLen</name><operator>=</operator><name>MAXPATHLEN</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lockPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>readBuf</name><index>[<expr><name>PROXY_PATHINDEX</name></expr>]</index></name></expr></argument>, <argument><expr><name>pathLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lockPath</name><index>[<expr><name>pathLen</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>tempLockPath</name> <operator>=</operator> <name>lockPath</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>tryOldLockPath</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <comment type="block">/* create a copy of the lock path if the conch is taken */</comment>
            <goto>goto <name>end_takeconch</name>;</goto>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>hostIdMatch</name>
               <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>readBuf</name><index>[<expr><name>PROXY_PATHINDEX</name></expr>]</index></name></expr></argument>,
                           <argument><expr><name>readLen</name><operator>-</operator><name>PROXY_PATHINDEX</name></expr></argument>)</argument_list></call></expr>
        )</condition><block>{<block_content>
          <comment type="block">/* conch host and lock path match */</comment>
          <goto>goto <name>end_takeconch</name>;</goto> 
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      
      <comment type="block">/* if the conch isn't writable and doesn't match, we can't take it */</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>conchFile</name><operator>-&gt;</operator><name>openFlags</name></name><operator>&amp;</operator><name>O_RDWR</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        <goto>goto <name>end_takeconch</name>;</goto>
      </block_content>}</block></if></if_stmt>
      
      <comment type="block">/* either the conch didn't match or we need to create a new one */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>proxyGetLockPath</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name>lockPath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tempLockPath</name> <operator>=</operator> <name>lockPath</name></expr>;</expr_stmt>
        <comment type="block">/* create a copy of the lock path _only_ if the conch is taken */</comment>
      </block_content>}</block></if></if_stmt>
      
      <comment type="block">/* update conch with host and path (this will fail if other process
      ** has a shared lock already), if the host id matches, use the big
      ** stick.
      */</comment>
      <expr_stmt><expr><call><name>futimes</name><argument_list>(<argument><expr><name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>hostIdMatch</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>createConch</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>conchFile</name><operator>-&gt;</operator><name>pInode</name></name> <operator>&amp;&amp;</operator> <name><name>conchFile</name><operator>-&gt;</operator><name>pInode</name><operator>-&gt;</operator><name>nShared</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* We are trying for an exclusive lock but another thread in this
           ** same process is still holding a shared lock. */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>          
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>proxyConchLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>myHostID</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>proxyConchLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>myHostID</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>writeBuffer</name><index>[<expr><name>PROXY_MAXCONCHLEN</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>writeSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name><name>writeBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>PROXY_CONCHVERSION</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>writeBuffer</name><index>[<expr><name>PROXY_HEADERLEN</name></expr>]</index></name></expr></argument>, <argument><expr><name>myHostID</name></expr></argument>, <argument><expr><name>PROXY_HOSTIDLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>writeBuffer</name><index>[<expr><name>PROXY_PATHINDEX</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr></argument>,
                  <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>writeBuffer</name><index>[<expr><name>PROXY_PATHINDEX</name></expr>]</index></name></expr></argument>, <argument><expr><name>tempLockPath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>writeSize</name> <operator>=</operator> <name>PROXY_PATHINDEX</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>writeBuffer</name><index>[<expr><name>PROXY_PATHINDEX</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>robust_ftruncate</name><argument_list>(<argument><expr><name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>writeSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unixWrite</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><name>conchFile</name></expr></argument>, <argument><expr><name>writeBuffer</name></expr></argument>, <argument><expr><name>writeSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>full_fsync</name><argument_list>(<argument><expr><name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* If we created a new conch file (not just updated the contents of a 
         ** valid conch file), try to match the permissions of the database 
         */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>createConch</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>osFstat</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>err</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>mode_t</name></type> <name>cmode</name> <init>= <expr><name><name>buf</name><operator>.</operator><name>st_mode</name></name><operator>&amp;</operator><operator>(</operator><name>S_IRUSR</name><operator>|</operator><name>S_IWUSR</name> <operator>|</operator> <name>S_IRGRP</name><operator>|</operator><name>S_IWGRP</name> <operator>|</operator>
                                        <name>S_IROTH</name><operator>|</operator><name>S_IWOTH</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <comment type="block">/* try to match the database file R/W permissions, ignore failure */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_PROXY_DEBUG</name></cpp:ifndef>
            <expr_stmt><expr><call><name>osFchmod</name><argument_list>(<argument><expr><name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>cmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <do>do<block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFchmod</name><argument_list>(<argument><expr><name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>cmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>EINTR</name></expr> )</condition>;</do>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"fchmod %o FAILED with %d %s\n"</literal></expr></argument>,
                      <argument><expr><name>cmode</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"fchmod %o SUCCEDED\n"</literal></expr></argument>,<argument><expr><name>cmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"STAT FAILED[%d] with %d %s\n"</literal></expr></argument>, 
                    <argument><expr><name>err</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name><name>conchFile</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>conchFile</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
    <label><name>end_takeconch</name>:</label>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TRANSPROXY: CLOSE  %d\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>openFlags</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>robust_close</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>robust_open</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>openFlags</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TRANSPROXY: OPEN  %d\n"</literal><operator>,</operator> <name>fd</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name><operator>=</operator><name>SQLITE_CANTOPEN_BKPT</name></expr>;</expr_stmt> <comment type="block">/* SQLITE_BUSY? proxyTakeConch called
           during locking */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><ternary><condition><expr><name>tempLockPath</name></expr> ?</condition><then> <expr><name>tempLockPath</name></expr> </then><else>: <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>proxyCreateUnixFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_NOMEM</name> <operator>&amp;&amp;</operator> <name>tryOldLockPath</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* we couldn't create the proxy lock file with the old lock file path
           ** so try again via auto-naming 
           */</comment>
          <expr_stmt><expr><name>forceNewLockPath</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>tryOldLockPath</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <continue>continue;</continue> <comment type="block">/* go back to the do {} while start point, try again */</comment>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Need to make a copy of path if we extracted the value
         ** from the conch file or the path was allocated on the stack
         */</comment>
        <if_stmt><if>if<condition>( <expr><name>tempLockPath</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tempLockPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchHeld</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        
        <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>==</operator> <operator>&amp;</operator><name>afpIoMethods</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>afpLockingContext</name> <modifier>*</modifier></type><name>afpCtx</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>afpCtx</name> <operator>=</operator> <operator>(</operator><name>afpLockingContext</name> <operator>*</operator><operator>)</operator><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name><operator>-&gt;</operator><name>lockingContext</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>afpCtx</name><operator>-&gt;</operator><name>dbPath</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>conchFile</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>conchFile</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TAKECONCH  %d %s\n"</literal><operator>,</operator> <name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator>
               <ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>?</condition><then><expr><literal type="string">"ok"</literal></expr></then><else>:<expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block> while <condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do> <comment type="block">/* in case we need to retry the :auto: lock file - 
                 ** we should never get here except via the 'continue' call. */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If pFile holds a lock on a conch file, then release that lock.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyReleaseConch</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Subroutine return code */</comment>
  <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>  <comment type="block">/* The locking context for the proxy lock */</comment>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>conchFile</name></decl>;</decl_stmt>        <comment type="block">/* Name of the conch file */</comment>

  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <operator>(</operator><name>proxyLockingContext</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>conchFile</name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>conchFile</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"RELEASECONCH  %d for %s pid=%d\n"</literal><operator>,</operator> <name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator>
           <operator>(</operator><ternary><condition><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr> ?</condition><then> <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr> </then><else>: <expr><literal type="string">":auto:"</literal></expr></else></ternary><operator>)</operator><operator>,</operator> 
           <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchHeld</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>conchFile</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>conchFile</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchHeld</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"RELEASECONCH  %d %s\n"</literal><operator>,</operator> <name><name>conchFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator>
           <operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given the name of a database file, compute the name of its conch file.
** Store the conch filename in memory obtained from sqlite3_malloc64().
** Make *pConchPath point to the new name.  Return SQLITE_OK on success
** or SQLITE_NOMEM if unable to obtain memory.
**
** The caller is responsible for ensuring that the allocated memory
** space is eventually freed.
**
** *pConchPath is set to NULL if a memory allocation error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyCreateConchPathname</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dbPath</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pConchPath</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Length of database filename - dbPath */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>conchPath</name></decl>;</decl_stmt>              <comment type="block">/* buffer in which to construct conch name */</comment>

  <comment type="block">/* Allocate space for the conch filename and initialize the name to
  ** the name of the original database file. */</comment>  
  <expr_stmt><expr><operator>*</operator><name>pConchPath</name> <operator>=</operator> <name>conchPath</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>conchPath</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>conchPath</name></expr></argument>, <argument><expr><name>dbPath</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* now insert a "." before the last / character */</comment>
  <for>for<control>( <init><expr><name>i</name><operator>=</operator><operator>(</operator><name>len</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr> )</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>conchPath</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>conchPath</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator><literal type="char">'.'</literal></expr>;</expr_stmt>
  <while>while <condition>( <expr><name>i</name><operator>&lt;</operator><name>len</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>conchPath</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>=</operator><name><name>dbPath</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* append the "-conch" suffix to the file */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conchPath</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-conch"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>conchPath</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name><operator>+</operator><literal type="number">7</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Takes a fully configured proxy locking-style unix file and switches
** the local lock file path 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>switchLockProxyPath</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><operator>(</operator><name>proxyLockingContext</name><operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldPath</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>!=</operator><name>NO_LOCK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>  

  <comment type="block">/* nothing to do if the path is NULL, :auto: or matches the existing path */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>path</name> <operator>||</operator> <name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">":auto:"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
    <operator>(</operator><name>oldPath</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>oldPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>lockProxy</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchHeld</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>lockProxy</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name><operator>=</operator><call><name><name>lockProxy</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><name>lockProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>lockProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>oldPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pFile is a file that has been opened by a prior xOpen call.  dbPath
** is a string buffer at least MAXPATHLEN+1 characters in size.
**
** This routine find the filename associated with pFile and writes it
** int dbPath.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyGetDbPathForUnixFile</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dbPath</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>==</operator> <operator>&amp;</operator><name>afpIoMethods</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* afp style keeps a reference to the db path in the filePath field 
    ** of the struct */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></argument>)</argument_list></call><operator>&lt;=</operator><name>MAXPATHLEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>afpLockingContext</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name><operator>)</operator><operator>-&gt;</operator><name>dbPath</name></expr></argument>,
            <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>==</operator> <operator>&amp;</operator><name>dotlockIoMethods</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* dot lock style uses the locking context to store the dot lock
    ** file path */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>DOTLOCK_SUFFIX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* all other styles use the locking context to store the db file path */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></argument>)</argument_list></call><operator>&lt;=</operator><name>MAXPATHLEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Takes an already filled in unix file and alters it so all file locking 
** will be performed on the local proxy lock file.  The following fields
** are preserved in the locking context so that they can be restored and 
** the unix structure properly cleaned up at close time:
**  -&gt;lockingContext
**  -&gt;pMethod
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyTransformUnixFile</name><parameter_list>(<parameter><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>dbPath</name><index>[<expr><name>MAXPATHLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* Name of the database file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lockPath</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name><operator>!=</operator><name>NO_LOCK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>proxyGetDbPathForUnixFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>dbPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>path</name> <operator>||</operator> <name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">":auto:"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>lockPath</name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>lockPath</name><operator>=</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TRANSPROXY  %d for %s pid=%d\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator>
           <operator>(</operator><ternary><condition><expr><name>lockPath</name></expr> ?</condition><then> <expr><name>lockPath</name></expr> </then><else>: <expr><literal type="string">":auto:"</literal></expr></else></ternary><operator>)</operator><operator>,</operator> <call><name>osGetpid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCtx</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCtx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>proxyCreateConchPathname</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>conchFilePath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>proxyCreateUnixFile</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFilePath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>conchFile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_CANTOPEN</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>openFlags</name></name><operator>&amp;</operator><name>O_RDWR</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <comment type="block">/* if (a) the open flags are not O_RDWR, (b) the conch isn't there, and
      ** (c) the file system is read-only, then enable no-locking access.
      ** Ugh, since O_RDONLY==0x0000 we test for !O_RDWR since unixOpen asserts
      ** that openFlags will have only one of O_RDONLY or O_RDWR.
      */</comment>
      <decl_stmt><decl><type><name><name>struct</name> <name>statfs</name></name></type> <name>fsInfo</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>conchInfo</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>goLockless</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><call><name>osStat</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFilePath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conchInfo</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>err</name><operator>==</operator><name>ENOENT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>statfs</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsInfo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>goLockless</name> <operator>=</operator> <operator>(</operator><name><name>fsInfo</name><operator>.</operator><name>f_flags</name></name><operator>&amp;</operator><name>MNT_RDONLY</name><operator>)</operator> <operator>==</operator> <name>MNT_RDONLY</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>goLockless</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchHeld</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* read only FS/ lockless */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>  
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>lockPath</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lockPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>dbPath</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dbPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>dbPath</name></name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* all memory is allocated, proxys are created and assigned, 
    ** switch the locking context and pMethod then return.
    */</comment>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>oldLockingContext</name></name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOldMethod</name></name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pMethod</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>=</operator> <operator>&amp;</operator><name>proxyIoMethods</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFile</name></name></expr> )</condition><block>{<block_content> 
      <expr_stmt><expr><call><name><name>pCtx</name><operator>-&gt;</operator><name>conchFile</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><name><name>pCtx</name><operator>-&gt;</operator><name>conchFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFilePath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TRANSPROXY  %d %s\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator>
           <operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This routine handles sqlite3_file_control() calls that are specific
** to proxy locking.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_FCNTL_GET_LOCKPROXYFILE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>==</operator> <operator>&amp;</operator><name>proxyIoMethods</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><operator>(</operator><name>proxyLockingContext</name><operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>proxyTakeConch</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <literal type="string">":auto: (not held)"</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_SET_LOCKPROXYFILE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>isProxyStyle</name> <init>= <expr><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>==</operator> <operator>&amp;</operator><name>proxyIoMethods</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pArg</name><operator>==</operator><name>NULL</name> <operator>||</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>isProxyStyle</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* turn off proxy locking - not supported.  If support is added for
          ** switching proxy locking mode off then it will need to fail if
          ** the journal mode is WAL mode. 
          */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr> <comment type="block">/*SQLITE_PROTOCOL? SQLITE_MISUSE?*/</comment>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* turn off proxy locking - already off - NOOP */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proxyPath</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>isProxyStyle</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name> <init>= 
            <expr><operator>(</operator><name>proxyLockingContext</name><operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><literal type="string">":auto:"</literal></expr></argument>)</argument_list></call> 
           <operator>||</operator> <operator>(</operator><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name> <operator>&amp;&amp;</operator>
               <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr></argument>, <argument><expr><name>proxyPath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>switchLockProxyPath</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>proxyPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* turn on proxy file locking */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>proxyTransformUnixFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>proxyPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The call assures that only valid opcodes are sent */</comment>
    </block_content>}</block>
  </block_content>}</block></switch>
  <comment type="block">/*NOTREACHED*/</comment>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Within this division (the proxying locking implementation) the procedures
** above this point are all utilities.  The lock-related methods of the
** proxy-locking sqlite3_io_method object follow.
*/</comment>


<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>proxyTakeConch</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><operator>(</operator><name>proxyLockingContext</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchHeld</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>proxy</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name></name></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name><name>proxy</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xCheckReservedLock</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>proxy</name></expr></argument>, <argument><expr><name>pResOut</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content> <comment type="block">/* conchHeld &lt; 0 is lockless */</comment>
      <expr_stmt><expr><name>pResOut</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>proxyTakeConch</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><operator>(</operator><name>proxyLockingContext</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchHeld</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>proxy</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>proxy</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>proxy</name></expr></argument>, <argument><expr><name>eFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name><name>proxy</name><operator>-&gt;</operator><name>eFileLock</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* conchHeld &lt; 0 is lockless */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eFileLock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>proxyTakeConch</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><operator>(</operator><name>proxyLockingContext</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchHeld</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>proxy</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>proxy</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>proxy</name></expr></argument>, <argument><expr><name>eFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>eFileLock</name></name> <operator>=</operator> <name><name>proxy</name><operator>-&gt;</operator><name>eFileLock</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* conchHeld &lt; 0 is lockless */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a file that uses proxy locks.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>proxyClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>unixFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>proxyLockingContext</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><operator>(</operator><name>proxyLockingContext</name> <operator>*</operator><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>lockProxy</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unixFile</name> <modifier>*</modifier></type><name>conchFile</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFile</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>( <expr><name>lockProxy</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>lockProxy</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>lockProxy</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>lockProxy</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>lockProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>lockProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>conchFile</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchHeld</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>proxyReleaseConch</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>conchFile</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>conchFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>conchFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>lockProxyPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>conchFilePath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>dbPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* restore the original locking context and pMethod then close it */</comment>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lockingContext</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>oldLockingContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>pOldMethod</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethod</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>



<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__APPLE__) &amp;&amp; SQLITE_ENABLE_LOCKING_STYLE */</comment>
<comment type="block">/*
** The proxy locking style is intended for use with AFP filesystems.
** And since AFP is only supported on MacOSX, the proxy locking is also
** restricted to MacOSX.
** 
**
******************* End of the proxy lock implementation **********************
******************************************************************************/</comment>

<comment type="block">/*
** Initialize the operating system interface.
**
** This routine registers all VFS implementations for unix-like operating
** systems.  This routine, and the sqlite3_os_end() routine that follows,
** should be the only routines in this file that are visible from other
** files.
**
** This routine is called once during SQLite initialization and by a
** single thread.  The memory allocation and mutex subsystems have not
** necessarily been initialized when this routine is called, and so they
** should not be used.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_os_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> 
  <comment type="block">/* 
  ** The following macro defines an initializer for an sqlite3_vfs object.
  ** The name of the VFS is NAME.  The pAppData is a pointer to a pointer
  ** to the "finder" function.  (pAppData is a pointer to a pointer because
  ** silly C90 rules prohibit a void* from being cast to a function pointer
  ** and so we have to go through the intermediate pointer to avoid problems
  ** when compiling with -pedantic-errors on GCC.)
  **
  ** The FINDER parameter to this macro is the name of the pointer to the
  ** finder-function.  The finder-function returns a pointer to the
  ** sqlite_io_methods object that implements the desired locking
  ** behaviors.  See the division above that contains the IOMETHODS
  ** macro for addition information on finder-functions.
  **
  ** Most finders simply return a pointer to a fixed sqlite3_io_methods
  ** object.  But the "autolockIoFinder" available on MacOSX does a little
  ** more than that; it looks at the filesystem type that hosts the 
  ** database file and tries to choose an locking method appropriate for
  ** that filesystem time.
  */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIXVFS</name><parameter_list>(<parameter><type><name>VFSNAME</name></type></parameter>, <parameter><type><name>FINDER</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                        \
    3,                    <comment type="block">/* iVersion */</comment>                    \
    sizeof(unixFile),     <comment type="block">/* szOsFile */</comment>                    \
    MAX_PATHNAME,         <comment type="block">/* mxPathname */</comment>                  \
    0,                    <comment type="block">/* pNext */</comment>                       \
    VFSNAME,              <comment type="block">/* zName */</comment>                       \
    (void*)&amp;FINDER,       <comment type="block">/* pAppData */</comment>                    \
    unixOpen,             <comment type="block">/* xOpen */</comment>                       \
    unixDelete,           <comment type="block">/* xDelete */</comment>                     \
    unixAccess,           <comment type="block">/* xAccess */</comment>                     \
    unixFullPathname,     <comment type="block">/* xFullPathname */</comment>               \
    unixDlOpen,           <comment type="block">/* xDlOpen */</comment>                     \
    unixDlError,          <comment type="block">/* xDlError */</comment>                    \
    unixDlSym,            <comment type="block">/* xDlSym */</comment>                      \
    unixDlClose,          <comment type="block">/* xDlClose */</comment>                    \
    unixRandomness,       <comment type="block">/* xRandomness */</comment>                 \
    unixSleep,            <comment type="block">/* xSleep */</comment>                      \
    unixCurrentTime,      <comment type="block">/* xCurrentTime */</comment>                \
    unixGetLastError,     <comment type="block">/* xGetLastError */</comment>               \
    unixCurrentTimeInt64, <comment type="block">/* xCurrentTimeInt64 */</comment>           \
    unixSetSystemCall,    <comment type="block">/* xSetSystemCall */</comment>              \
    unixGetSystemCall,    <comment type="block">/* xGetSystemCall */</comment>              \
    unixNextSystemCall,   <comment type="block">/* xNextSystemCall */</comment>             \
  }</cpp:value></cpp:define>

  <comment type="block">/*
  ** All default VFSes for unix are contained in the following array.
  **
  ** Note that the sqlite3_vfs.pNext field of the VFS object is modified
  ** by the SQLite core when the VFS is registered.  So the following
  ** array cannot be const.
  */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_vfs</name></type> <name><name>aVfs</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix"</literal></expr></argument>,          <argument><expr><name>autolockIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:elif>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix"</literal></expr></argument>,          <argument><expr><name>vxworksIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix"</literal></expr></argument>,          <argument><expr><name>posixIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix-none"</literal></expr></argument>,     <argument><expr><name>nolockIoFinder</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix-dotfile"</literal></expr></argument>,  <argument><expr><name>dotlockIoFinder</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix-excl"</literal></expr></argument>,     <argument><expr><name>posixIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix-namedsem"</literal></expr></argument>, <argument><expr><name>semIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> <operator>||</operator> <name>OS_VXWORKS</name></expr></cpp:if>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix-posix"</literal></expr></argument>,    <argument><expr><name>posixIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix-flock"</literal></expr></argument>,    <argument><expr><name>flockIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix-afp"</literal></expr></argument>,      <argument><expr><name>afpIoFinder</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix-nfs"</literal></expr></argument>,      <argument><expr><name>nfsIoFinder</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr><literal type="string">"unix-proxy"</literal></expr></argument>,    <argument><expr><name>proxyIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>          <comment type="block">/* Loop counter */</comment>

  <comment type="block">/* Double-check that the aSyscall[] array has been constructed
  ** correctly.  See ticket [bb3a86e890c8e96ab] */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aSyscall</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">28</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Register all VFSes defined in the aVfs[] array */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aVfs</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_vfs</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aVfs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block">/*
** Shutdown the operating system interface.
**
** Some operating systems might need to do some cleanup in this routine,
** to release dynamically allocated objects.  But not on unix.
** This routine is a no-op for unix.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_os_end</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> 
  <return>return <expr><name>SQLITE_OK</name></expr>;</return> 
</block_content>}</block></function>
 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OS_UNIX */</comment>
</unit>
