<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/vdbeaux.c"><comment type="block">/*
** 2003 September 6
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used for creating, destroying, and populating
** a VDBE (or an "sqlite3_stmt" as it is known to the outside world.) 
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Create a new virtual database engine.
*/</comment>
<function><type><name>Vdbe</name> <modifier>*</modifier></type><name>sqlite3VdbeCreate</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Vdbe</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>VDBE_MAGIC_INIT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aLabel</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nLabel</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>szOpAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the error string stored in Vdbe.zErrMsg
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeError</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Remember the SQL string for a prepared statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetSql</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrepareV2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isPrepareV2</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>isPrepareV2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRACE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_SQLLOG</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isPrepareV2</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>isPrepareV2</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>isPrepareV2</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the SQL associated with a prepared statement
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_sql</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Swap all content between two VDBE structures.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSwap</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name></type> <name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pTmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTmp</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>pA</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pA</name> <operator>=</operator> <operator>*</operator><name>pB</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pB</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pTmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pTmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTmp</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>zSql</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>zSql</name></name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>zSql</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>zSql</name></name> <operator>=</operator> <name>zTmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>isPrepareV2</name></name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>isPrepareV2</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Resize the Vdbe.aOp array so that it is at least nOp elements larger 
** than its current size. nOp is guaranteed to be less than or equal
** to 1024/sizeof(Op).
**
** If an out-of-memory error occurs while resizing the array, return
** SQLITE_NOMEM. In this case Vdbe.aOp and Parse.nOpAlloc remain 
** unchanged (this is so that any opcodes already allocated can be 
** correctly deallocated along with the rest of the Vdbe).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>growOpArray</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The SQLITE_TEST_REALLOC_STRESS compile-time option is designed to force
  ** more frequent reallocs and hence provide more opportunities for 
  ** simulated OOM faults.  SQLITE_TEST_REALLOC_STRESS is generally used
  ** during testing only.  With SQLITE_TEST_REALLOC_STRESS grow the op array
  ** by the minimum* amount required until the size reaches 512.  Normal
  ** operation (without SQLITE_TEST_REALLOC_STRESS) is to double the current
  ** size of the op array or add 1KB of space, whichever is smaller. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST_REALLOC_STRESS</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>&gt;=</operator><literal type="number">512</literal></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>+</operator><name>nOp</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">1024</literal><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOp</name><operator>&lt;=</operator><operator>(</operator><literal type="number">1024</literal><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nNew</name><operator>&gt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>+</operator><name>nOp</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>, <argument><expr><name>nNew</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szOpAlloc</name></name> <operator>=</operator> <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>szOpAlloc</name></name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>pNew</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_NOMEM</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/* This routine is just a convenient place to set a breakpoint that will
** fire after each opcode is inserted and displayed using
** "PRAGMA vdbe_addoptrace=on".
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_addop_breakpoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Add a new instruction to the list of instructions current in the
** VDBE.  Return the address of the new instruction.
**
** Parameters:
**
**    p               Pointer to the VDBE
**
**    op              The opcode for this instruction
**
**    p1, p2, p3      Operands
**
** Use the sqlite3VdbeResolveLabel() function to fix an address and
** the sqlite3VdbeChangeP4() function to change the value of the P4
** operand.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>growOp3</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>growOpArray</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp3</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>op</name><operator>&lt;</operator><literal type="number">0xff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>&lt;=</operator><name>i</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>growOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <name>p3</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_NOTUSED</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>, <decl><type ref="prev"/><name>kk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>jj</name><operator>=</operator><name>kk</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>yColCache</name></name> <modifier>*</modifier></type><name>x</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name> <operator>+</operator> <name>jj</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>-&gt;</operator><name>iLevel</name></name><operator>&gt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>iCacheLevel</name></name> <operator>||</operator> <name><name>x</name><operator>-&gt;</operator><name>iReg</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" r[%d]={%d:%d}"</literal></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>iReg</name></name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>kk</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>kk</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>test_addop_breakpoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_VDBE_COVERAGE</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>iSrcLine</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp0</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp1</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp2</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate code for an unconditional jump to instruction iDest
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeGoto</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDest</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate code to cause the string zStr to be loaded into
** register iDest
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeLoadString</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that initializes multiple registers to string or integer
** constants.  The registers begin with iDest and increase consecutively.
** One register is initialized for each characgter in zTypes[].  For each
** "s" character in zTypes[], the register is a string if the argument is
** not NULL, or OP_Null if the value is a null pointer.  For each "i" character
** in zTypes[], the register is initialized to an integer.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMultiLoad</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTypes</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zTypes</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>OP_Null</name></expr> </then><else>: <expr><name>OP_String8</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDest</name><operator>++</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><literal type="char">'i'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iDest</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add an opcode that includes the p4 value as a pointer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp4</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* Add the opcode to this VM */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,             <comment type="block">/* The new opcode */</comment>
  <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>,             <comment type="block">/* The P1 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>,             <comment type="block">/* The P2 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>,             <comment type="block">/* The P3 operand */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zP4</name></decl></parameter>,    <comment type="block">/* The P4 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p4type</name></decl></parameter>          <comment type="block">/* P4 operand type */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name> <init>= <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>p4type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add an opcode that includes the p4 value with a P4_INT64 or
** P4_REAL type.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp4Dup8</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* Add the opcode to this VM */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,             <comment type="block">/* The new opcode */</comment>
  <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>,             <comment type="block">/* The P1 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>,             <comment type="block">/* The P2 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>,             <comment type="block">/* The P3 operand */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zP4</name></decl></parameter>,      <comment type="block">/* The P4 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p4type</name></decl></parameter>          <comment type="block">/* P4 operand type */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p4copy</name> <init>= <expr><call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p4copy</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p4copy</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>, <argument><expr><name>p4copy</name></expr></argument>, <argument><expr><name>p4type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add an OP_ParseSchema opcode.  This routine is broken out from
** sqlite3VdbeAddOp4() since it needs to also needs to mark all btrees
** as having been used.
**
** The zWhere string must have been obtained from sqlite3_malloc().
** This routine will take ownership of the allocated memory.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeAddParseSchemaOp</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_ParseSchema</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
** Add an opcode that includes the p4 value as an integer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp4Int</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* Add the opcode to this VM */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,             <comment type="block">/* The new opcode */</comment>
  <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>,             <comment type="block">/* The P1 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>,             <comment type="block">/* The P2 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>,             <comment type="block">/* The P3 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p4</name></decl></parameter>              <comment type="block">/* The P4 operand as an integer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name> <init>= <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>p4</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert the end of a co-routine
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeEndCoroutine</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regYield</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_EndCoroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clear the temporary register cache, thereby ensuring that each
  ** co-routine has its own independent set of registers, because co-routines
  ** might expect their registers to be preserved across an OP_Yield, and
  ** that could cause problems if two or more co-routines are using the same
  ** temporary register.
  */</comment>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Create a new symbolic label for an instruction that has yet to be
** coded.  The symbolic label is really just a negative number.  The
** label can be used as the P2 value of an operation.  Later, when
** the label is resolved to a specific address, the VDBE will scan
** through its operation list and change all values of P2 which match
** the label into the resolved address.
**
** The VDBE knows that a P2 value is a label because labels are
** always negative and P2 values are suppose to be non-negative.
** Hence, a negative P2 value is a label that has yet to be resolved.
**
** Zero is returned if a malloc() fails.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMakeLabel</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nLabel</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <operator>(</operator><name>i</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name></name> <operator>=</operator> <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name></name></expr></argument>, 
                                       <argument><expr><operator>(</operator><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>ADDR</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Resolve label "x" to be the address of the next instruction to
** be inserted.  The parameter "x" must have been obtained from
** a prior call to sqlite3VdbeMakeLabel().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeResolveLabel</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><call><name>ADDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nLabel</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iFixedOp</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nOp</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Mark the VDBE as one that can only be run one time.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeRunOnlyOnce</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>runOnlyOnce</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef> <comment type="block">/* sqlite3AssertMayAbort() logic */</comment>

<comment type="block">/*
** The following type and function are used to iterate through all opcodes
** in a Vdbe main program and each of the sub-programs (triggers) it may 
** invoke directly or indirectly. It should be used as follows:
**
**   Op *pOp;
**   VdbeOpIter sIter;
**
**   memset(&amp;sIter, 0, sizeof(sIter));
**   sIter.v = v;                            // v is of type Vdbe* 
**   while( (pOp = opIterNext(&amp;sIter)) ){
**     // Do something with pOp
**   }
**   sqlite3DbFree(v-&gt;db, sIter.apSub);
** 
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>VdbeOpIter</name></name></type> <name>VdbeOpIter</name>;</typedef>
<struct>struct <name>VdbeOpIter</name> <block>{
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>                   <comment type="block">/* Vdbe to iterate through the opcodes of */</comment>
  <decl_stmt><decl><type><name>SubProgram</name> <modifier>*</modifier><modifier>*</modifier></type><name>apSub</name></decl>;</decl_stmt>        <comment type="block">/* Array of subprograms */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSub</name></decl>;</decl_stmt>                  <comment type="block">/* Number of entries in apSub */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name></decl>;</decl_stmt>                 <comment type="block">/* Address of next instruction to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSub</name></decl>;</decl_stmt>                  <comment type="block">/* 0 = main program, 1 = first sub-program etc. */</comment>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>Op</name> <modifier>*</modifier></type><name>opIterNext</name><parameter_list>(<parameter><decl><type><name>VdbeOpIter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>v</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOp</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSub</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nSub</name></name></expr> )</condition><block>{<block_content>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSub</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aOp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nOp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>aOp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apSub</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iSub</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>aOp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nOp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apSub</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iSub</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>nOp</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iAddr</name></name><operator>&lt;</operator><name>nOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iAddr</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iAddr</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iAddr</name></name><operator>==</operator><name>nOp</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iSub</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iAddr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <if_stmt><if>if<condition>( <expr><name><name>pRet</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_SUBPROGRAM</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nSub</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SubProgram</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSub</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>pRet</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pProgram</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nSub</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apSub</name></name> <operator>=</operator> <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apSub</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>apSub</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apSub</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nSub</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pRet</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pProgram</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check if the program stored in the VM associated with pParse may
** throw an ABORT exception (causing the statement, but not entire transaction
** to be rolled back). This condition is true if the main program or any
** sub-programs contains any of the following:
**
**   *  OP_Halt with P1=SQLITE_CONSTRAINT and P2=OE_Abort.
**   *  OP_HaltIfNull with P1=SQLITE_CONSTRAINT and P2=OE_Abort.
**   *  OP_Destroy
**   *  OP_VUpdate
**   *  OP_VRename
**   *  OP_FkCounter with P2==0 (immediate foreign key constraint)
**   *  OP_CreateTable and OP_InitCoroutine (for CREATE TABLE AS SELECT ...)
**
** Then check that the value of Parse.mayAbort is true if an
** ABORT may be thrown, or false otherwise. Return true if it does
** match, or false otherwise. This function is intended to be used as
** part of an assert statement in the compiler. Similar to:
**
**   assert( sqlite3VdbeAssertMayAbort(pParse-&gt;pVdbe, pParse-&gt;mayAbort) );
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAssertMayAbort</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mayAbort</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>hasAbort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasFkCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasCreateTable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasInitCoroutine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOpIter</name></type> <name>sIter</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sIter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sIter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sIter</name><operator>.</operator><name>v</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>(</operator><name>pOp</name> <operator>=</operator> <call><name>opIterNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sIter</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>opcode</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>opcode</name><operator>==</operator><name>OP_Destroy</name> <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_VUpdate</name> <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_VRename</name> 
     <operator>||</operator> <operator>(</operator><operator>(</operator><name>opcode</name><operator>==</operator><name>OP_Halt</name> <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_HaltIfNull</name><operator>)</operator> 
      <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>OE_Abort</name><operator>)</operator><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>hasAbort</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>opcode</name><operator>==</operator><name>OP_CreateTable</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasCreateTable</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>opcode</name><operator>==</operator><name>OP_InitCoroutine</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasInitCoroutine</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>opcode</name><operator>==</operator><name>OP_FkCounter</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>hasFkCounter</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>sIter</name><operator>.</operator><name>apSub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return true if hasAbort==mayAbort. Or if a malloc failure occurred.
  ** If malloc failed, then the while() loop above may not have iterated
  ** through all opcodes and hasAbort may be set incorrectly. Return
  ** true for this case to prevent the assert() in the callers frame
  ** from failing.  */</comment>
  <return>return <expr><operator>(</operator> <name><name>v</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>||</operator> <name>hasAbort</name><operator>==</operator><name>mayAbort</name> <operator>||</operator> <name>hasFkCounter</name>
              <operator>||</operator> <operator>(</operator><name>hasCreateTable</name> <operator>&amp;&amp;</operator> <name>hasInitCoroutine</name><operator>)</operator> <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG - the sqlite3AssertMayAbort() function */</comment>

<comment type="block">/*
** This routine is called after all opcodes have been inserted.  It loops
** through all the opcodes and fixes up some details.
**
** (1) For each jump instruction with a negative P2 value (a label)
**     resolve the P2 value to an actual address.
**
** (2) Compute the maximum number of arguments used by any SQL function
**     and store that value in *pMaxFuncArgs.
**
** (3) Update the Vdbe.readOnly and Vdbe.bIsReader flags to accurately
**     indicate what the prepared statement actually does.
**
** (4) Initialize the p4.xAdvance pointer on opcodes that use it.
**
** (5) Reclaim the memory allocated for storing labels.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resolveP2Values</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pMaxFuncArgs</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMaxArgs</name> <init>= <expr><operator>*</operator><name>pMaxFuncArgs</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aLabel</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>aLabel</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pOp</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pOp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>opcode</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* NOTE: Be sure to update mkopcodeh.tcl when adding or removing
    ** cases from this switch! */</comment>
    <switch>switch<condition>( <expr><name>opcode</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OP_Transaction</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* fall thru */</comment>
      </block_content>}</block>
      <case>case <expr><name>OP_AutoCommit</name></expr>:</case>
      <case>case <expr><name>OP_Savepoint</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
      <case>case <expr><name>OP_Checkpoint</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <case>case <expr><name>OP_Vacuum</name></expr>:</case>
      <case>case <expr><name>OP_JournalMode</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      <case>case <expr><name>OP_VUpdate</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><name>nMaxArgs</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMaxArgs</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>OP_VFilter</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>-</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Integer</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p1</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name>nMaxArgs</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMaxArgs</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <case>case <expr><name>OP_Next</name></expr>:</case>
      <case>case <expr><name>OP_NextIfOpen</name></expr>:</case>
      <case>case <expr><name>OP_SorterNext</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>xAdvance</name></name> <operator>=</operator> <name>sqlite3BtreeNext</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_ADVANCE</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>OP_Prev</name></expr>:</case>
      <case>case <expr><name>OP_PrevIfOpen</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>xAdvance</name></name> <operator>=</operator> <name>sqlite3BtreePrevious</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_ADVANCE</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>

    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opflags</name></name> <operator>=</operator> <name><name>sqlite3OpcodeProperty</name><index>[<expr><name>opcode</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opflags</name></name> <operator>&amp;</operator> <name>OPFLG_JUMP</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ADDR</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nLabel</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name><name>aLabel</name><index>[<expr><call><name>ADDR</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aLabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aLabel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nLabel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pMaxFuncArgs</name> <operator>=</operator> <name>nMaxArgs</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>DbMaskAllZero</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the address of the next instruction to be inserted.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeCurrentAddr</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Verify that at least N opcode slots are available in p without
** having to malloc for more space (except when compiled using
** SQLITE_TEST_REALLOC_STRESS).  This interface is used during testing
** to verify that certain calls to sqlite3VdbeAddOpList() can never
** fail due to a OOM fault and hence that the return value from
** sqlite3VdbeAddOpList() will always be non-NULL.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST_REALLOC_STRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>sqlite3VdbeVerifyNoMallocRequired</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>+</operator> <name>N</name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nOpAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function returns a pointer to the array of opcodes associated with
** the Vdbe passed as the first argument. It is the callers responsibility
** to arrange for the returned array to be eventually freed using the 
** vdbeFreeOpArray() function.
**
** Before returning, *pnOp is set to the number of entries in the returned
** array. Also, *pnMaxArg is set to the larger of its current value and 
** the number of entries in the Vdbe.apArg[] array required to execute the 
** returned program.
*/</comment>
<function><type><name>VdbeOp</name> <modifier>*</modifier></type><name>sqlite3VdbeTakeOpArray</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnMaxArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>aOp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aOp</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check that sqlite3VdbeUsesBtree() was not called on this VM */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskAllZero</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>resolveP2Values</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pnMaxArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnOp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>aOp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add a whole list of operations to the operation stack.  Return a
** pointer to the first operation inserted.
**
** Non-zero P2 arguments to jump instructions are automatically adjusted
** so that the jump target is relative to the first operation inserted.
*/</comment>
<function><type><name>VdbeOp</name> <modifier>*</modifier></type><name>sqlite3VdbeAddOpList</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                     <comment type="block">/* Add opcodes to the prepared statement */</comment>
  <parameter><decl><type><name>int</name></type> <name>nOp</name></decl></parameter>,                     <comment type="block">/* Number of opcodes to add */</comment>
  <parameter><decl><type><name>VdbeOpList</name> <specifier>const</specifier> <modifier>*</modifier></type><name>aOp</name></decl></parameter>,       <comment type="block">/* The opcodes to be added */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLineno</name></decl></parameter>                  <comment type="block">/* Source-file line number of first opcode */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOut</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOp</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>+</operator> <name>nOp</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nOpAlloc</name></name> <operator>&amp;&amp;</operator> <call><name>growOpArray</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nOp</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pFirst</name> <operator>=</operator> <name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOp</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>aOp</name><operator>++</operator></expr><operator>,</operator> <expr><name>pOut</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name><name>aOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>aOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name><name>aOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>sqlite3OpcodeProperty</name><index>[<expr><name><name>aOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name> <operator>&amp;</operator> <name>OPFLG_JUMP</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p2</name></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <name><name>aOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_NOTUSED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>zComment</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_VDBE_COVERAGE</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>iSrcLine</name></name> <operator>=</operator> <name>iLineno</name><operator>+</operator><name>i</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>iLineno</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>+=</operator> <name>nOp</name></expr>;</expr_stmt>
  <return>return <expr><name>pFirst</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_STMT_SCANSTATUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Add an entry to the array of counters managed by sqlite3_stmt_scanstatus().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeScanStatus</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                        <comment type="block">/* VM to add scanstatus() to */</comment>
  <parameter><decl><type><name>int</name></type> <name>addrExplain</name></decl></parameter>,                <comment type="block">/* Address of OP_Explain (or 0) */</comment>
  <parameter><decl><type><name>int</name></type> <name>addrLoop</name></decl></parameter>,                   <comment type="block">/* Address of loop counter */</comment> 
  <parameter><decl><type><name>int</name></type> <name>addrVisit</name></decl></parameter>,                  <comment type="block">/* Address of rows visited counter */</comment>
  <parameter><decl><type><name>LogEst</name></type> <name>nEst</name></decl></parameter>,                    <comment type="block">/* Estimated number of output rows */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>               <comment type="block">/* Name of table or index being scanned */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nScan</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanStatus</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ScanStatus</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>aNew</name> <operator>=</operator> <operator>(</operator><name>ScanStatus</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aScan</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aNew</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ScanStatus</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><operator>&amp;</operator><name><name>aNew</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nScan</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrExplain</name></name> <operator>=</operator> <name>addrExplain</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrLoop</name></name> <operator>=</operator> <name>addrLoop</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrVisit</name></name> <operator>=</operator> <name>addrVisit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nEst</name></name> <operator>=</operator> <name>nEst</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aScan</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Change the value of the opcode, or P1, P2, P3, or P5 operands
** for a specific instruction.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeOpcode</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>iNewOpcode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name> <operator>=</operator> <name>iNewOpcode</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP1</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p1</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP2</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p2</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP3</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p3</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP5</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>p5</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p5</name> <operator>=</operator> <name>p5</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the P2 operand of instruction addr so that it points to
** the address of the next instruction to be coded.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeJumpHere</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>iFixedOp</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** If the input FuncDef structure is ephemeral, then free it.  If
** the FuncDef is not ephermal, then do nothing.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeEphemeralFunction</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pDef</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_EPHEM</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vdbeFreeOpArray</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Op</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Delete a P4 value if necessary.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeP4</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p4type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p4</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p4</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>p4type</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>P4_FUNCCTX</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>freeEphemeralFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>sqlite3_context</name><operator>*</operator><operator>)</operator><name>p4</name><operator>)</operator><operator>-&gt;</operator><name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Fall through into the next case */</comment>
      </block_content>}</block>
      <case>case <expr><name>P4_REAL</name></expr>:</case>
      <case>case <expr><name>P4_INT64</name></expr>:</case>
      <case>case <expr><name>P4_DYNAMIC</name></expr>:</case>
      <case>case <expr><name>P4_INTARRAY</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>P4_KEYINFO</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3KeyInfoUnref</name><argument_list>(<argument><expr><operator>(</operator><name>KeyInfo</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
      <case>case <expr><name>P4_EXPR</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <case>case <expr><name>P4_MPRINTF</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>P4_FUNCDEF</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>freeEphemeralFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>FuncDef</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>P4_MEM</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>p4</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>P4_VTAB</name></expr> :</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><operator>(</operator><name>VTable</name> <operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free the space allocated for aOp and any p4 values allocated for the
** opcodes contained within. If aOp is not NULL it is assumed to contain 
** nOp entries. 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeFreeOpArray</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Op</name> <modifier>*</modifier></type><name>aOp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>aOp</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pOp</name><operator>=</operator><name>aOp</name></expr>;</init> <condition><expr><name>pOp</name><operator>&lt;</operator><operator>&amp;</operator><name><name>aOp</name><index>[<expr><name>nOp</name></expr>]</index></name></expr>;</condition> <incr><expr><name>pOp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>     
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Link the SubProgram object passed as the second argument into the linked
** list at Vdbe.pSubProgram. This list is used to delete all sub-program
** objects when the VM is no longer required.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeLinkSubProgram</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVdbe</name></decl></parameter>, <parameter><decl><type><name>SubProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pVdbe</name><operator>-&gt;</operator><name>pProgram</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pVdbe</name><operator>-&gt;</operator><name>pProgram</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the opcode at addr into OP_Noop
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeChangeToNoop</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>addr</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>addr</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_NOTUSED</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_Noop</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the last opcode is "op" and it is not a jump destination,
** then remove it.  Return true if and only if an opcode was removed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeDeletePriorOpcode</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&gt;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>iFixedOp</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>op</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the value of the P4 operand for a specific instruction.
** This routine is useful when a large program is loaded from a
** static array using sqlite3VdbeAddOpList but we want to make a
** few minor changes to the program.
**
** If n&gt;=0 then the P4 operand is dynamic, meaning that a copy of
** the string is made into memory obtained from sqlite3_malloc().
** A value of n==0 means copy bytes of zP4 up to and including the
** first null byte.  If n&gt;0 then copy n+1 bytes of zP4.
** 
** Other values of n (P4_STATIC, P4_COLLSEQ etc.) indicate that zP4 points
** to a string or structure that is guaranteed to exist for the lifetime of
** the Vdbe. In these cases we can just copy the pointer.
**
** If addr&lt;0 then change P4 on the most recently inserted instruction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>SQLITE_NOINLINE</name></type> <name>vdbeChangeP4Full</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zP4</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>)</operator></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_DYNAMIC</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP4</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zP4</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>!=</operator><name>P4_VTAB</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>addr</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>addr</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeChangeP4Full</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><name>P4_INT32</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Note: this cast is safe, because the origin data point was an int
    ** that was cast to a (const char *). */</comment>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_INT32</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zP4</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>zP4</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <operator>(</operator><name>signed</name> <name>char</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><name>P4_VTAB</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VtabLock</name><argument_list>(<argument><expr><operator>(</operator><name>VTable</name><operator>*</operator><operator>)</operator><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the P4 on the most recently added opcode to the KeyInfo for the
** index given.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetP4KeyInfo</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3KeyInfoOfIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
<comment type="block">/*
** Change the comment on the most recently coded instruction.  Or
** insert a No-op and add the comment to that new instruction.  This
** makes the code easier to read during debugging.  None of this happens
** in a production build.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeVComment</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zComment</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zComment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zComment</name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeComment</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vdbeVComment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeNoopComment</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Noop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vdbeVComment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* NDEBUG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_VDBE_COVERAGE</name></cpp:ifdef>
<comment type="block">/*
** Set the value if the iSrcLine field for the previously coded instruction.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetLineNumber</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLine</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>iSrcLine</name> <operator>=</operator> <name>iLine</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_VDBE_COVERAGE */</comment>

<comment type="block">/*
** Return the opcode for a given address.  If the address is -1, then
** return the most recently inserted opcode.
**
** If a memory allocation error has occurred prior to the calling of this
** routine, then a pointer to a dummy VdbeOp will be returned.  That opcode
** is readable but not writable, though it is cast to a writable value.
** The return of a dummy opcode allows the call to continue functioning
** after an OOM fault without having to check to see if the return from 
** this routine is a valid pointer.  But because the dummy.opcode is 0,
** dummy will never be written to.  This is verified by code inspection and
** by running with Valgrind.
*/</comment>
<function><type><name>VdbeOp</name> <modifier>*</modifier></type><name>sqlite3VdbeGetOp</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* C89 specifies that the constant "dummy" will be initialized to all
  ** zeros, which is correct.  MSVC generates a warning, nevertheless. */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>VdbeOp</name></type> <name>dummy</name></decl>;</decl_stmt>  <comment type="block">/* Ignore the MSVC warning about no initializer */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>addr</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>addr</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>addr</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>)</operator> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>VdbeOp</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dummy</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Return an integer value for one of the parameters to the opcode pOp
** determined by character c.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>translateP</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'1'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'2'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'3'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'4'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute a string for the "comment" field of a VDBE opcode listing.
**
** The Synopsis: field in comments in the vdbe.c source file gets converted
** to an extra string that is appended to the sqlite3OpcodeName().  In the
** absence of other comments, this synopsis becomes the comment on the opcode.
** Some translation occurs:
**
**       "PX"      -&gt;  "r[X]"
**       "PX@PY"   -&gt;  "r[X..X+Y-1]"  or "r[x]" if y is 0 or 1
**       "PX@PY+1" -&gt;  "r[X..X+Y]"    or "r[x]" if y is 0
**       "PY..PY"  -&gt;  "r[X..Y]"      or "r[x]" if y&lt;=x
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>displayComment</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>,     <comment type="block">/* The opcode to be commented */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zP4</name></decl></parameter>,   <comment type="block">/* Previously obtained value for P4 */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zTemp</name></decl></parameter>,       <comment type="block">/* Write result here */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTemp</name></decl></parameter>          <comment type="block">/* Space available in zTemp[] */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOpName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSynopsis</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOpName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>zOpName</name> <operator>=</operator> <call><name>sqlite3OpcodeName</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nOpName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zOpName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zOpName</name><index>[<expr><name>nOpName</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>seenCom</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zSynopsis</name> <operator>=</operator> <name>zOpName</name> <operator>+=</operator> <name>nOpName</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>nTemp</name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <name><name>zSynopsis</name><index>[<expr><name>ii</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'P'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zSynopsis</name><index>[<expr><operator>++</operator><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'4'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name><operator>-</operator><name>jj</name></expr></argument>, <argument><expr><name>zTemp</name><operator>+</operator><name>jj</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'X'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name><operator>-</operator><name>jj</name></expr></argument>, <argument><expr><name>zTemp</name><operator>+</operator><name>jj</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>seenCom</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>v1</name> <init>= <expr><call><name>translateP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>v2</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name><operator>-</operator><name>jj</name></expr></argument>, <argument><expr><name>zTemp</name><operator>+</operator><name>jj</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zSynopsis</name><operator>+</operator><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"@P"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>ii</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>jj</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zTemp</name><operator>+</operator><name>jj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>translateP</name><argument_list>(<argument><expr><name><name>zSynopsis</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zSynopsis</name><operator>+</operator><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"+1"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>ii</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name>v2</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>v2</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name><operator>-</operator><name>jj</name></expr></argument>, <argument><expr><name>zTemp</name><operator>+</operator><name>jj</name></expr></argument>, <argument><expr><literal type="string">"..%d"</literal></expr></argument>, <argument><expr><name>v1</name><operator>+</operator><name>v2</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zSynopsis</name><operator>+</operator><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"..P3"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>ii</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>jj</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zTemp</name><operator>+</operator><name>jj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>zTemp</name><index>[<expr><name>jj</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>seenCom</name> <operator>&amp;&amp;</operator> <name>jj</name><operator>&lt;</operator><name>nTemp</name><operator>-</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name><operator>-</operator><name>jj</name></expr></argument>, <argument><expr><name>zTemp</name><operator>+</operator><name>jj</name></expr></argument>, <argument><expr><literal type="string">"; %s"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jj</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zTemp</name><operator>+</operator><name>jj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>jj</name><operator>&lt;</operator><name>nTemp</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zTemp</name><index>[<expr><name>jj</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>zTemp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>jj</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VDBE_DISPLAY_P4</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_CURSOR_HINTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Translate the P4.pExpr value for an OP_CursorHint opcode into text
** that can be displayed in the P4 column of EXPLAIN output.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>displayP4Expr</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_STRING</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%Q"</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TK_INTEGER</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TK_NULL</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TK_REGISTER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"r[%d]"</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"rowid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"c%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_LT</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"LT"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_LE</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"LE"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_GT</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"GT"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_GE</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"GE"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_NE</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"NE"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_EQ</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"EQ"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_IS</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"IS"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_ISNOT</name></expr>:</case>   <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"ISNOT"</literal></expr>;</expr_stmt>   <break>break;</break>
    <case>case <expr><name>TK_AND</name></expr>:</case>     <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_OR</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"OR"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_PLUS</name></expr>:</case>    <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"ADD"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_STAR</name></expr>:</case>    <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"MUL"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_MINUS</name></expr>:</case>   <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"SUB"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_REM</name></expr>:</case>     <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"REM"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_BITAND</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"BITAND"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_BITOR</name></expr>:</case>   <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"BITOR"</literal></expr>;</expr_stmt>   <break>break;</break>
    <case>case <expr><name>TK_SLASH</name></expr>:</case>   <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"DIV"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_LSHIFT</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"LSHIFT"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_RSHIFT</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"RSHIFT"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_CONCAT</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"CONCAT"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_UMINUS</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"MINUS"</literal></expr>;</expr_stmt>   <break>break;</break>
    <case>case <expr><name>TK_UPLUS</name></expr>:</case>   <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"PLUS"</literal></expr>;</expr_stmt>    <break>break;</break>
    <case>case <expr><name>TK_BITNOT</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"BITNOT"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_NOT</name></expr>:</case>     <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"NOT"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_ISNULL</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"ISNULL"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_NOTNULL</name></expr>:</case> <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"NOTNULL"</literal></expr>;</expr_stmt> <break>break;</break>

    <default>default:</default>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"expr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <if_stmt><if>if<condition>( <expr><name>zOp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name>zOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>displayP4Expr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>displayP4Expr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VDBE_DISPLAY_P4 &amp;&amp; defined(SQLITE_ENABLE_CURSOR_HINTS) */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VDBE_DISPLAY_P4</name></expr></cpp:if>
<comment type="block">/*
** Compute a string that describes the P4 parameter for an opcode.
** Use zTemp for any required temporary buffer space.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>displayP4</name><parameter_list>(<parameter><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zTemp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTemp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zP4</name> <init>= <expr><name>zTemp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTemp</name><operator>&gt;=</operator><literal type="number">20</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr><name>nTemp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>P4_KEYINFO</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortOrder</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"k(%d"</literal></expr></argument>, <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><ternary><condition><expr><name>pColl</name></expr> ?</condition><then> <expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zColl</name></expr></argument>, <argument><expr><literal type="string">"BINARY"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zColl</name> <operator>=</operator> <literal type="string">"B"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">",%s%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>j</name></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">"-"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
    <case>case <expr><name>P4_EXPR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>displayP4Expr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>P4_COLLSEQ</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pColl</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"(%.20s)"</literal></expr></argument>, <argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_FUNCDEF</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pFunc</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%s(%d)"</literal></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>nArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <case>case <expr><name>P4_FUNCCTX</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%s(%d)"</literal></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>nArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>P4_INT64</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pI64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_INT32</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_REAL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%.16g"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pReal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_MEM</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pMem</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zP4</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%.16g"</literal></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zP4</name> <operator>=</operator> <literal type="string">"NULL"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zP4</name> <operator>=</operator> <literal type="string">"(blob)"</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <case>case <expr><name>P4_VTAB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"vtab:%p"</literal></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>P4_INTARRAY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>ai</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>ai</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>ai</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The first element of an INTARRAY is always the
                       ** count of the number of elements to follow */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">",%d"</literal></expr></argument>, <argument><expr><name><name>ai</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>zTemp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'['</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_SUBPROGRAM</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"program"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_ADVANCE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>zTemp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><name>zP4</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zP4</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zP4</name> <operator>=</operator> <name>zTemp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zTemp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zP4</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zP4</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VDBE_DISPLAY_P4 */</comment>

<comment type="block">/*
** Declare to the Vdbe that the BTree object at db-&gt;aDb[i] is used.
**
** The prepared statements need to know in advance the complete set of
** attached databases that will be use.  A mask of these databases
** is maintained in p-&gt;btreeMask.  The p-&gt;lockMask value is the subset of
** p-&gt;btreeMask of databases that will require a lock.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeUsesBtree</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nDb</name></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yDbMask</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DbMaskSet</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3BtreeSharable</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>DbMaskSet</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lockMask</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** If SQLite is compiled to support shared-cache mode and to be threadsafe,
** this routine obtains the mutex associated with each BtShared structure
** that may be accessed by the VM passed as an argument. In doing so it also
** sets the BtShared.db member of each of the BtShared structures, ensuring
** that the correct busy-handler callback is invoked if required.
**
** If SQLite is not threadsafe but does support shared-cache mode, then
** sqlite3BtreeEnter() is invoked to set the BtShared.db variables
** of all of BtShared structures accessible via the database handle 
** associated with the VM.
**
** If SQLite is not threadsafe and does not support shared-cache mode, this
** function is a no-op.
**
** The p-&gt;btreeMask field is a bitmask of all btrees that the prepared 
** statement p will ever use.  Let N be the number of bits in p-&gt;btreeMask
** corresponding to btrees that use shared cache.  Then the runtime of
** this routine is N*N.  But as N is rarely more than 1, this should not
** be a problem.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeEnter</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>aDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>DbMaskAllZero</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lockMask</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* The common case */</comment>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDb</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lockMask</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Unlock all of the btrees previously locked by a call to sqlite3VdbeEnter().
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>vdbeLeave</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>aDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDb</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lockMask</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeLeave</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>DbMaskAllZero</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lockMask</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* The common case */</comment>
  <expr_stmt><expr><call><name>vdbeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Print a single opcode.  This routine is used for debugging only.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbePrintOp</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zP4</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zPtr</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zCom</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat1</name> <init>= <expr><literal type="string">"%4d %-13s %4d %4d %4d %-13s %.2X %s\n"</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pOut</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zP4</name> <operator>=</operator> <call><name>displayP4</name><argument_list>(<argument><expr><name>pOp</name></expr></argument>, <argument><expr><name>zPtr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
  <expr_stmt><expr><call><name>displayComment</name><argument_list>(<argument><expr><name>pOp</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>zCom</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zCom</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>zCom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* NB:  The sqlite3OpcodeName() function is implemented by code created
  ** by the mkopcodeh.awk and mkopcodec.awk scripts which extract the
  ** information from the vdbe.c source text */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>zFormat1</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, 
      <argument><expr><call><name>sqlite3OpcodeName</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>,
      <argument><expr><name>zCom</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Release an array of N Mem elements
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>releaseMemArray</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name>N</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><index>[<expr><name>N</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name></expr> )</condition><block>{<block_content>
      <do>do<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>++</operator><name>p</name><operator>)</operator><operator>&lt;</operator><name>pEnd</name></expr> )</condition>;</do>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>==</operator><name>pEnd</name> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>db</name><operator>==</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* This block is really an inlined version of sqlite3VdbeMemRelease()
      ** that takes advantage of the fact that the memory cell value is 
      ** being set to NULL after releasing any dynamic resources.
      **
      ** The justification for duplicating code is that according to 
      ** callgrind, this causes a certain test case to hit the CPU 4.7 
      ** percent less (x86 linux, gcc version 4.1.2, -O6) than if 
      ** sqlite3MemRelease() were called from here. With -O2, this jumps
      ** to 6.6 percent. The test case is inserting 1000 rows into a table 
      ** with no indexes using a single prepared INSERT statement, bind() 
      ** and reset(). Inserts are grouped into a transaction.
      */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Agg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Frame</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_RowSet</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Agg</name><operator>|</operator><name>MEM_Dyn</name><operator>|</operator><name>MEM_Frame</name><operator>|</operator><name>MEM_RowSet</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>++</operator><name>p</name><operator>)</operator><operator>&lt;</operator><name>pEnd</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Delete a VdbeFrame object and its contents. VdbeFrame objects are
** allocated by the OP_Program opcode in sqlite3VdbeExec().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeFrameDelete</name><parameter_list>(<parameter><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>aMem</name> <init>= <expr><call><name>VdbeFrameMem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>apCsr</name> <init>= <expr><operator>(</operator><name>VdbeCursor</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nChildMem</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nChildCsr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeFreeCursor</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name>aMem</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChildMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
<comment type="block">/*
** Give a listing of the program in the virtual machine.
**
** The interface is the same as sqlite3VdbeExec().  But instead of
** running the code, it invokes the callback once for each instruction.
** This feature is used to implement "EXPLAIN".
**
** When p-&gt;explain==1, each instruction is listed.  When
** p-&gt;explain==2, only OP_Explain instructions are listed and these
** are shown in a different format.  p-&gt;explain==2 is used to implement
** EXPLAIN QUERY PLAN.
**
** When p-&gt;explain==1, first the main program is listed, then each of
** the trigger subprograms are listed one by one.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeList</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>                   <comment type="block">/* The VDBE */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRow</name></decl>;</decl_stmt>                            <comment type="block">/* Stop when row count reaches this */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                        <comment type="block">/* Number of sub-vdbes seen so far */</comment>
  <decl_stmt><decl><type><name>SubProgram</name> <modifier>*</modifier><modifier>*</modifier></type><name>apSub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Array of sub-vdbes */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pSub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                       <comment type="block">/* Memory cell hold array of subprogs */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                               <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* First Mem of result set */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_RUN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_BUSY</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Even though this opcode does not use dynamic strings for
  ** the result, result columns may become dynamic if the user calls
  ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.
  */</comment>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This happens if a malloc() inside a call to sqlite3_column_text() or
    ** sqlite3_column_text16() failed.  */</comment>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* When the number of output rows reaches nRow, that means the
  ** listing has finished and sqlite3_step() should return SQLITE_DONE.
  ** nRow is the sum of the number of rows in the main program, plus
  ** the sum of the number of rows in all trigger subprograms encountered
  ** so far.  The nRow value will increase as new trigger subprograms are
  ** encountered, but p-&gt;pc will eventually catch up to nRow.
  */</comment>
  <expr_stmt><expr><name>nRow</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The first 8 memory cells are used for the result set.  So we will
    ** commandeer the 9th cell to use as storage for an array of pointers
    ** to trigger subprograms.  The VDBE is guaranteed to have at least 9
    ** cells.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>&gt;</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSub</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Blob</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* On the first call to sqlite3_step(), pSub will hold a NULL.  It is
      ** initialized to a BLOB by the P4_SUBPROGRAM processing logic below */</comment>
      <expr_stmt><expr><name>nSub</name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>n</name></name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Vdbe</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name>apSub</name> <operator>=</operator> <operator>(</operator><name>SubProgram</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>pSub</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSub</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>nRow</name> <operator>+=</operator> <name><name>apSub</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nOp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <do>do<block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pc</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>nRow</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>!=</operator><name>OP_Explain</name></expr> )</condition>;</do>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>nRow</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_INTERRUPT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zP4</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The output line number is small enough that we are still in the
      ** main program. */</comment>
      <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* We are currently listing subprograms.  Figure out which one and
      ** pick up the appropriate opcode. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>i</name> <operator>-=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><name><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>nOp</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>-=</operator> <name><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>nOp</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>                                <comment type="block">/* Program counter */</comment>
      <expr_stmt><expr><name>pMem</name><operator>++</operator></expr>;</expr_stmt>
  
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Static</name><operator>|</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3OpcodeName</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Opcode */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* When an OP_Program opcode is encounter (the only opcode that has
      ** a P4_SUBPROGRAM argument), expand the size of the array of subprograms
      ** kept in p-&gt;aMem[9].z to hold the new program - assuming this subprogram
      ** has not already been seen.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_SUBPROGRAM</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name>nSub</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SubProgram</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nSub</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pProgram</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name>nSub</name> <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pSub</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>nSub</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>apSub</name> <operator>=</operator> <operator>(</operator><name>SubProgram</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>pSub</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>apSub</name><index>[<expr><name>nSub</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pProgram</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Blob</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>nSub</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SubProgram</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>                          <comment type="block">/* P1 */</comment>
    <expr_stmt><expr><name>pMem</name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>                          <comment type="block">/* P2 */</comment>
    <expr_stmt><expr><name>pMem</name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>                          <comment type="block">/* P3 */</comment>
    <expr_stmt><expr><name>pMem</name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <comment type="block">/* P4 */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Str</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zP4</name> <operator>=</operator> <call><name>displayP4</name><argument_list>(<argument><expr><name>pOp</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zP4</name><operator>!=</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pMem</name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Str</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="string">"%.2x"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* P5 */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name><operator>++</operator></expr>;</expr_stmt>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Str</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <call><name>displayComment</name><argument_list>(<argument><expr><name>pOp</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>                       <comment type="block">/* Comment */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name> <operator>=</operator> <literal type="number">8</literal> <operator>-</operator> <literal type="number">4</literal><operator>*</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>explain</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ROW</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_EXPLAIN */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Print the SQL that was used to generate a VDBE program.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbePrintSql</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Init</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>sqlite3Isspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SQL: [%s]\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRACE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_IOTRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Print an IOTRACE message showing SQL content.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeIOTraceSql</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nOp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>sqlite3IoTrace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOp</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Init</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>sqlite3Isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3Isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">' '</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3IoTrace</name><argument_list>(<argument><expr><literal type="string">"SQL %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_TRACE &amp;&amp; SQLITE_ENABLE_IOTRACE */</comment>

<comment type="block">/* An instance of this object describes bulk memory available for use
** by subcomponents of a prepared statement.  Space is allocated out
** of a ReusableSpace object by the allocSpace() routine below.
*/</comment>
<struct>struct <name>ReusableSpace</name> <block>{
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSpace</name></decl>;</decl_stmt>          <comment type="block">/* Available memory */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFree</name></decl>;</decl_stmt>           <comment type="block">/* Bytes of available memory */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nNeeded</name></decl>;</decl_stmt>         <comment type="block">/* Total bytes that could not be allocated */</comment>
}</block>;</struct>

<comment type="block">/* Try to allocate nByte bytes of 8-byte aligned bulk memory for pBuf
** from the ReusableSpace object.  Return a pointer to the allocated
** memory on success.  If insufficient memory is available in the
** ReusableSpace object, increase the ReusableSpace.nNeeded
** value by the amount needed and return NULL.
**
** If pBuf is not initially NULL, that means that the memory has already
** been allocated by a prior call to this routine, so just return a copy
** of pBuf and leave ReusableSpace unchanged.
**
** This allocator is employed to repurpose unused slots at the end of the
** opcode array of prepared state for other memory needs of the prepared
** statement.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>allocSpace</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>ReusableSpace</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,  <comment type="block">/* Bulk memory available for allocation */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,               <comment type="block">/* Pointer to a prior allocation */</comment>
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>                 <comment type="block">/* Bytes of memory needed */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSpace</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nFree</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFree</name></name> <operator>-=</operator> <name>nByte</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pSpace</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nFree</name></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nNeeded</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pBuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rewind the VDBE back to the beginning in preparation for
** running it.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeRewind</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* There should be at least one opcode.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the magic to VDBE_MAGIC_RUN sooner rather than later. */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>VDBE_MAGIC_RUN</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>db</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cacheCtr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>minWriteFileFormat</name></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFkConstraint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cycles</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Prepare a virtual machine for execution for the first time after
** creating the virtual machine.  This involves things such
** as allocating registers and initializing the program counter.
** After the VDBE has be prepped, it can be executed by one or more
** calls to sqlite3VdbeExec().  
**
** This function may be called exactly once on each virtual machine.
** After this routine is called the VM has been "packaged" and is ready
** to run.  After this routine is called, further calls to 
** sqlite3VdbeAddOp() functions are prohibited.  This routine disconnects
** the Vdbe from the Parse object that helped generate it so that the
** the Vdbe becomes an independent entity and the Parse object can be
** destroyed.
**
** Use the sqlite3VdbeRewind() procedure to restore a virtual machine back
** to its initial state after it has been run.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMakeReady</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                       <comment type="block">/* The VDBE */</comment>
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>                  <comment type="block">/* Parsing context */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                   <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVar</name></decl>;</decl_stmt>                      <comment type="block">/* Number of parameters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMem</name></decl>;</decl_stmt>                      <comment type="block">/* Number of VM memory registers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCursor</name></decl>;</decl_stmt>                   <comment type="block">/* Number of cursors required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>                      <comment type="block">/* Number of arguments in subprograms */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOnce</name></decl>;</decl_stmt>                     <comment type="block">/* Number of OP_Once instructions */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                         <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>ReusableSpace</name></name></type> <name>x</name></decl>;</decl_stmt>        <comment type="block">/* Reusable bulk memory */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nVar</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nMem</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCursor</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nArg</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMaxArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nOnce</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nOnce</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOnce</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nOnce</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Ensure at least one byte in p-&gt;aOnceFlag[] */</comment>
  
  <comment type="block">/* For each cursor required, also allocate a memory cell. Memory
  ** cells (nMem+1-nCursor)..nMem, inclusive, will never be used by
  ** the vdbe program. Instead they are used to allocate memory for
  ** VdbeCursor/BtCursor structures. The blob of memory associated with 
  ** cursor 0 is stored in memory cell nMem. Memory cell (nMem-1)
  ** stores the blob of memory associated with cursor 1, etc.
  **
  ** See also: allocateCursor().
  */</comment>
  <expr_stmt><expr><name>nMem</name> <operator>+=</operator> <name>nCursor</name></expr>;</expr_stmt>

  <comment type="block">/* Figure out how much reusable memory is available at the end of the
  ** opcode array.  This extra memory will be reallocated for other elements
  ** of the prepared statement.
  */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>              <comment type="block">/* Bytes of opcode memory used */</comment>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pSpace</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>)</operator><index>[<expr><name>n</name></expr>]</index></expr>;</expr_stmt>               <comment type="block">/* Unused opcode memory */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>pSpace</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nFree</name></name> <operator>=</operator> <call><name>ROUNDDOWN8</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>szOpAlloc</name></name> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Bytes of unused memory */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>nFree</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>pSpace</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>nFree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>x</name><operator>.</operator><name>pSpace</name><index>[<expr><name><name>x</name><operator>.</operator><name>nFree</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>resolveP2Values</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>usesStmtJournal</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>isMultiWrite</name></name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>mayAbort</name></name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name> <operator>&amp;&amp;</operator> <name>nMem</name><operator>&lt;</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nMem</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Memory for registers, parameters, cursor, etc, is allocated in one or two
  ** passes.  On the first pass, we try to reuse unused memory at the 
  ** end of the opcode array.  If we are unable to satisfy all memory
  ** requirements by reusing the opcode array tail, then the second
  ** pass will fill in the remainder using a fresh memory allocation.  
  **
  ** This two-pass approach that reuses as much memory as possible from
  ** the leftover memory at the end of the opcode array.  This can significantly
  ** reduce the amount of memory held by a prepared statement.
  */</comment>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nNeeded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr></argument>, <argument><expr><name>nMem</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name></name></expr></argument>, <argument><expr><name>nVar</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apArg</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apArg</name></name></expr></argument>, <argument><expr><name>nArg</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name></expr></argument>, <argument><expr><name>nCursor</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOnceFlag</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOnceFlag</name></name></expr></argument>, <argument><expr><name>nOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>nNeeded</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pSpace</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFree</name></name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>nNeeded</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nFree</name></name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>nNeeded</name></name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition>;</do>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <name>nCursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOnceFlag</name></name> <operator>=</operator> <name>nOnce</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nVar</name></name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><name>nVar</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>nVar</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>db</name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nzVar</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nzVar</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>azVar</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>azVar</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nzVar</name></name> <operator>=</operator>  <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>azVar</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name><operator>--</operator></expr>;</expr_stmt>                      <comment type="block">/* aMem[] goes from 1..nMem */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name> <operator>=</operator> <name>nMem</name></expr>;</expr_stmt>                 <comment type="block">/*       not from 0..nMem-1 */</comment>
    <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;=</operator><name>nMem</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>db</name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeRewind</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close a VDBE cursor and release all the resources that cursor 
** happens to hold.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeFreeCursor</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pCx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pBt</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCx</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>pCx</name><operator>-&gt;</operator><name>eCurType</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>CURTYPE_SORTER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeSorterClose</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pCx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>CURTYPE_BTREE</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCx</name><operator>-&gt;</operator><name>pBt</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3BtreeClose</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The pCx-&gt;pCursor will be close automatically, if it exists, by
        ** the call above. */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3BtreeCloseCursor</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <case>case <expr><name>CURTYPE_VTAB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVCur</name> <init>= <expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pVCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Close all cursors in the current frame.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>closeCursorsInFrame</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pC</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeFreeCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Copy the values stored in the VdbeFrame structure to its Vdbe. This
** is used, for example, when a trigger sub-program is halted to restore
** control to the main program.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeFrameRestore</name><parameter_list>(<parameter><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pFrame</name><operator>-&gt;</operator><name>v</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>closeCursorsInFrame</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>anExec</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>anExec</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>aOnceFlag</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>aOnceFlag</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nOnceFlag</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nOnceFlag</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nOp</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>aMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nMem</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>apCsr</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>apCsr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>lastRowid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nDbChange</name></name></expr>;</expr_stmt>
  <return>return <expr><name><name>pFrame</name><operator>-&gt;</operator><name>pc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close all cursors.
**
** Also release any dynamic memory held by the VM in the Vdbe.aMem memory 
** cell array. This is necessary as the memory cell array may contain
** pointers to VdbeFrame objects, which may in turn contain pointers to
** open cursors.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>closeAllCursors</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pFrame</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</init> <condition><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</condition> <incr><expr><name>pFrame</name><operator>=</operator><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>sqlite3VdbeFrameRestore</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrame</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nFrame</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>closeCursorsInFrame</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pDelFrame</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pDel</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pDelFrame</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDelFrame</name></name> <operator>=</operator> <name><name>pDel</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeFrameDelete</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Delete any auxdata allocations made by the VM */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pAuxData</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeDeleteAuxData</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxData</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Clean up the VM after a single run.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>Cleanup</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Execute assert() statements to ensure that the Vdbe.apCsr[] and 
  ** Vdbe.aMem[] arrays have already been cleaned up.  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name></expr> )</condition><block type="pseudo"><block_content> <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name><operator>==</operator><name>MEM_Undefined</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the number of result columns that will be returned by this SQL
** statement. This is now set at compile time, rather than during
** execution of the vdbe program so that sqlite3_column_count() can
** be called on an SQL statement before sqlite3_step().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetNumCols</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nResColumn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pColName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name><operator>*</operator><name>COLNAME_N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>nResColumn</name><operator>*</operator><name>COLNAME_N</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nResColumn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name> <operator>=</operator> <name>pColName</name> <operator>=</operator> <operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pColName</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pColName</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColName</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Set the name of the idx'th column to be returned by the SQL statement.
** zName must be a pointer to a nul terminated string.
**
** This call must be made after a call to sqlite3VdbeSetNumCols().
**
** The final parameter, xDel, must be one of SQLITE_DYNAMIC, SQLITE_STATIC
** or SQLITE_TRANSIENT. If it is SQLITE_DYNAMIC, then the buffer pointed
** to by zName will be freed by sqlite3DbFree() when the vdbe is destroyed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeSetColName</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                         <comment type="block">/* Vdbe being configured */</comment>
  <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,                         <comment type="block">/* Index of column zName applies to */</comment>
  <parameter><decl><type><name>int</name></type> <name>var</name></decl></parameter>,                         <comment type="block">/* One of the COLNAME_* constants */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,               <comment type="block">/* Pointer to buffer containing name */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>              <comment type="block">/* Memory management strategy for zName */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pColName</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>var</name><operator>&lt;</operator><name>COLNAME_N</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>zName</name> <operator>||</operator> <name>xDel</name><operator>!=</operator><name>SQLITE_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pColName</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>aColName</name><index>[<expr><name>idx</name><operator>+</operator><name>var</name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pColName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>zName</name> <operator>||</operator> <operator>(</operator><name><name>pColName</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Term</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A read or write transaction may or may not be active on database handle
** db. If a transaction is active, commit it. If there is a
** write-transaction spanning more than one database file, this routine
** takes care of the master journal trickery.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeCommit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTrans</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of databases with an active write-transaction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>needXcommit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifdef>
  <comment type="block">/* With this option, sqlite3VtabSync() is defined to be simply 
  ** SQLITE_OK so p is not used. 
  */</comment>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Before doing anything else, call the xSync() callback for any
  ** virtual module tables written in this transaction. This has to
  ** be done before determining whether a master journal file is 
  ** required, as an xSync() callback may add an attached database
  ** to the transaction.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSync</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This loop determines (a) if the commit hook should be invoked and
  ** (b) how many database files have open write transactions, not 
  ** including the temp database. (b) is important because if more than 
  ** one database file has an open write transaction, a master journal
  ** file is required for an atomic commit.
  */</comment> 
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> 
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>needXcommit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nTrans</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerExclusiveLock</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If there are any write-transactions at all, invoke the commit hook */</comment>
  <if_stmt><if>if<condition>( <expr><name>needXcommit</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>xCommitCallback</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>db</name><operator>-&gt;</operator><name>xCommitCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pCommitArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_CONSTRAINT_COMMITHOOK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The simple case - no more than one database file (not counting the
  ** TEMP database) has a transaction active.   There is no need for the
  ** master-journal.
  **
  ** If the return value of sqlite3BtreeGetFilename() is a zero length
  ** string, it means the main database is :memory: or a temp file.  In 
  ** that case we do not support atomic multi-file commits, so use the 
  ** simple case then too.
  */</comment>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><call><name>sqlite3BtreeGetFilename</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
   <operator>||</operator> <name>nTrans</name><operator>&lt;=</operator><literal type="number">1</literal></expr>
  )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCommitPhaseOne</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Do the commit only if all databases successfully complete phase 1. 
    ** If one of the BtreeCommitPhaseOne() calls fails, this indicates an
    ** IO error while deleting or truncating a journal file. It is unlikely,
    ** but could happen. In this case abandon processing and return the error.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCommitPhaseTwo</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VtabCommit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>

  <comment type="block">/* The complex case - There is a multi-file write-transaction active.
  ** This requires a master journal file to ensure the transaction is
  ** committed atomically.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DISKIO</name></cpp:ifndef>
  <else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>needSync</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMaster</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* File-name for the master journal */</comment>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zMainFile</name> <init>= <expr><call><name>sqlite3BtreeGetFilename</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pMaster</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retryCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nMainFile</name></decl>;</decl_stmt>

    <comment type="block">/* Select a master journal file name */</comment>
    <expr_stmt><expr><name>nMainFile</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zMainFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zMaster</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s-mjXXXXXX9XXz"</literal></expr></argument>, <argument><expr><name>zMainFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zMaster</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iRandom</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>retryCount</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>retryCount</name><operator>&gt;</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_FULL</name></expr></argument>, <argument><expr><literal type="string">"MJ delete: %s"</literal></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>retryCount</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_FULL</name></expr></argument>, <argument><expr><literal type="string">"MJ collide: %s"</literal></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>retryCount</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iRandom</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRandom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zMaster</name><index>[<expr><name>nMainFile</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-mj%06X9%02X"</literal></expr></argument>,
                               <argument><expr><operator>(</operator><name>iRandom</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xffffff</literal></expr></argument>, <argument><expr><name>iRandom</name><operator>&amp;</operator><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The antipenultimate character of the master journal name must
      ** be "9" to avoid name collisions when using 8+3 filenames. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zMaster</name><index>[<expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zMaster</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'9'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3FileSuffix3</name><argument_list>(<argument><expr><name>zMainFile</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition>;</do>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Open the master journal. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpenMalloc</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMaster</name></expr></argument>, 
          <argument><expr><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name><operator>|</operator>
          <name>SQLITE_OPEN_EXCLUSIVE</name><operator>|</operator><name>SQLITE_OPEN_MASTER_JOURNAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
 
    <comment type="block">/* Write the name of each database file in the transaction into the new
    ** master journal file. If an error occurs at this point close
    ** and delete the master journal file. All the individual journal files
    ** still have 'null' as the master journal pointer, so they will roll
    ** back independently if a failure occurs.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><call><name>sqlite3BtreeGetJournalname</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>  <comment type="block">/* Ignore TEMP and :memory: databases */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>needSync</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3BtreeSyncDisabled</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>needSync</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Sync the master journal file. If the IOCAP_SEQUENTIAL device
    ** flag is set this is not required.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>needSync</name> 
     <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call><operator>&amp;</operator><name>SQLITE_IOCAP_SEQUENTIAL</name><operator>)</operator>
     <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>, <argument><expr><name>SQLITE_SYNC_NORMAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Sync all the db files involved in the transaction. The same call
    ** sets the master journal pointer in each individual journal. If
    ** an error occurs here, do not delete the master journal file.
    **
    ** If the error occurs during the first call to
    ** sqlite3BtreeCommitPhaseOne(), then there is a chance that the
    ** master journal file will be orphaned. But we cannot delete it,
    ** in case the master journal file name was written into the journal
    ** file before the failure occurred.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> 
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCommitPhaseOne</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Delete the master journal file. This commits the transaction. After
    ** doing this the directory is synced again before any individual
    ** transaction files are deleted.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name>needSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zMaster</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* All files and directories have already been synced, so the following
    ** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and
    ** deleting or truncating journals. If something goes wrong while
    ** this is happening we don't really care. The integrity of the
    ** transaction is already guaranteed, but some stray 'cold' journals
    ** may be lying around. Returning an error code won't help matters.
    */</comment>
    <expr_stmt><expr><call><name>disable_simulated_io_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> 
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3BtreeCommitPhaseTwo</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>enable_simulated_io_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3VtabCommit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** This routine checks that the sqlite3.nVdbeActive count variable
** matches the number of vdbe's in the list sqlite3.pVdbe that are
** currently active. An assertion fails if the two counts do not match.
** This is an internal self-check only - it is not an essential processing
** step.
**
** This is a no-op if NDEBUG is defined.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkActiveVdbeCnt</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stmt_busy</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_stmt</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nWrite</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nRead</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cnt</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nWrite</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRead</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>checkActiveVdbeCnt</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If the Vdbe passed as the first argument opened a statement-transaction,
** close it now. Argument eOp must be either SAVEPOINT_ROLLBACK or
** SAVEPOINT_RELEASE. If it is SAVEPOINT_ROLLBACK, then the statement
** transaction is rolled back. If eOp is SAVEPOINT_RELEASE, then the 
** statement transaction is committed.
**
** If an IO error occurs, an SQLITE_IOERR_XXX error code is returned. 
** Otherwise SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeCloseStatement</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier><specifier>const</specifier></type> <name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If p-&gt;iStatement is greater than zero, then this Vdbe opened a 
  ** statement transaction that should be closed here. The only exception
  ** is that an IO error may have occurred, causing an emergency rollback.
  ** In this case (db-&gt;nStatement==0), and there is nothing to do.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iSavepoint</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>+</operator><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> 
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3BtreeSavepoint</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>SAVEPOINT_ROLLBACK</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3BtreeSavepoint</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>SAVEPOINT_RELEASE</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SAVEPOINT_ROLLBACK</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SAVEPOINT_RELEASE</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the statement transaction is being rolled back, also restore the 
    ** database handles deferred constraint counter to the value it had when 
    ** the statement transaction was opened.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nStmtDefCons</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nStmtDefImmCons</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when a transaction opened by the database 
** handle associated with the VM passed as an argument is about to be 
** committed. If there are outstanding deferred foreign key constraint
** violations, return SQLITE_ERROR. Otherwise, SQLITE_OK.
**
** If there are outstanding FK violations and this function returns 
** SQLITE_ERROR, set the result of the VM to SQLITE_CONSTRAINT_FOREIGNKEY
** and write an error message to it. Then return SQLITE_ERROR.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3VdbeCheckFk</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deferred</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>deferred</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name><operator>+</operator><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator> 
   <operator>||</operator> <operator>(</operator><operator>!</operator><name>deferred</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nFkConstraint</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_CONSTRAINT_FOREIGNKEY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN KEY constraint failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine is called the when a VDBE tries to halt.  If the VDBE
** has made changes and is in autocommit mode, then commit those
** changes.  If a rollback is needed, then do the rollback.
**
** This routine is the only way to move the state of a VM from
** SQLITE_MAGIC_RUN to SQLITE_MAGIC_HALT.  It is harmless to
** call this on a VM that is in the SQLITE_MAGIC_HALT state.
**
** Return an error code.  If the commit could not complete because of
** lock contention, return SQLITE_BUSY.  If SQLITE_BUSY is returned, it
** means the close did not happen and needs to be repeated.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeHalt</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Used to store transient return codes */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* This function contains the logic that determines if a statement or
  ** transaction will be committed or rolled back as a result of the
  ** execution of this virtual machine. 
  **
  ** If any of the following errors occur:
  **
  **     SQLITE_NOMEM
  **     SQLITE_IOERR
  **     SQLITE_FULL
  **     SQLITE_INTERRUPT
  **
  ** Then the internal cache might have been left in an inconsistent
  ** state.  We need to rollback the statement transaction, if there is
  ** one, or the complete transaction if there is no statement transaction.
  */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aOnceFlag</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOnceFlag</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOnceFlag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>closeAllCursors</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>!=</operator><name>VDBE_MAGIC_RUN</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>checkActiveVdbeCnt</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* No commit or rollback needed if the program never started or if the
  ** SQL statement does not read or write a database file.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>mrc</name></decl>;</decl_stmt>   <comment type="block">/* Primary error code from p-&gt;rc */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>eStatementOp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isSpecialError</name></decl>;</decl_stmt>            <comment type="block">/* Set to true if a 'special' error */</comment>

    <comment type="block">/* Lock all btrees used by the statement */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check for one of the special errors */</comment>
    <expr_stmt><expr><name>mrc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>isSpecialError</name> <operator>=</operator> <name>mrc</name><operator>==</operator><name>SQLITE_NOMEM</name> <operator>||</operator> <name>mrc</name><operator>==</operator><name>SQLITE_IOERR</name>
                     <operator>||</operator> <name>mrc</name><operator>==</operator><name>SQLITE_INTERRUPT</name> <operator>||</operator> <name>mrc</name><operator>==</operator><name>SQLITE_FULL</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isSpecialError</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the query was read-only and the error code is SQLITE_INTERRUPT, 
      ** no rollback is necessary. Otherwise, at least a savepoint 
      ** transaction must be rolled back to restore the database to a 
      ** consistent state.
      **
      ** Even if the statement is read-only, it is important to perform
      ** a statement or transaction rollback operation. If the error 
      ** occurred while writing to the journal, sub-journal or database
      ** file as part of an effort to free up cache space (see function
      ** pagerStress() in pager.c), the rollback is required to restore 
      ** the pager to a consistent state.
      */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>||</operator> <name>mrc</name><operator>!=</operator><name>SQLITE_INTERRUPT</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mrc</name><operator>==</operator><name>SQLITE_NOMEM</name> <operator>||</operator> <name>mrc</name><operator>==</operator><name>SQLITE_FULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>usesStmtJournal</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>eStatementOp</name> <operator>=</operator> <name>SAVEPOINT_ROLLBACK</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* We are forced to roll back the active transaction. Before doing
          ** so, abort any other statements this handle currently has active.
          */</comment>
          <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for immediate foreign key violations. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeCheckFk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* If the auto-commit flag is set and this is the only active writer 
    ** VM, then we do either a commit or rollback of the current transaction. 
    **
    ** Note: This block also runs if one of the special errors handled 
    ** above has occurred. 
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3VtabInSync</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> 
     <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> 
     <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> 
    )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name><operator>==</operator><name>OE_Fail</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isSpecialError</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCheckFk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3VdbeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT_FOREIGNKEY</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content> 
          <comment type="block">/* The auto-commit flag is true, the vdbe program was successful 
          ** or hit an 'OR FAIL' constraint and there are no deferred foreign
          ** key constraints to hold up the transaction. This means a commit 
          ** is required. */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeCommit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_DeferFKs</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3CommitInternalChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eStatementOp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name><operator>==</operator><name>OE_Fail</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eStatementOp</name> <operator>=</operator> <name>SAVEPOINT_RELEASE</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name><operator>==</operator><name>OE_Abort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eStatementOp</name> <operator>=</operator> <name>SAVEPOINT_ROLLBACK</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* If eStatementOp is non-zero, then a statement transaction needs to
    ** be committed or rolled back. Call sqlite3VdbeCloseStatement() to
    ** do so. If this operation returns an error, and the current statement
    ** error code is SQLITE_OK or SQLITE_CONSTRAINT, then promote the
    ** current statement error code.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>eStatementOp</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCloseStatement</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>eStatementOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* If this was an INSERT, UPDATE or DELETE and no statement transaction
    ** has been rolled back, update the database connection change-counter. 
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>changeCntOn</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>eStatementOp</name><operator>!=</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Release the locks */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* We have successfully halted and closed the VM.  Record this fact. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>&gt;=</operator><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>&gt;=</operator><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>VDBE_MAGIC_HALT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checkActiveVdbeCnt</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the auto-commit flag is set to true, then any locks that were held
  ** by connection db have now been released. Call sqlite3ConnectionUnlocked() 
  ** to invoke any required unlock-notify callbacks.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ConnectionUnlocked</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_BUSY</name></expr> ?</condition><then> <expr><name>SQLITE_BUSY</name></expr> </then><else>: <expr><name>SQLITE_OK</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Each VDBE holds the result of the most recent sqlite3_step() call
** in p-&gt;rc.  This routine sets that result back to SQLITE_OK.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeResetStepResult</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Copy the error code and error message belonging to the VDBE passed
** as the first argument to its database handle (so that they will be 
** returned by calls to sqlite3_errcode() and sqlite3_errmsg()).
**
** This function does not clear the VDBE error code or message, just
** copies them to the database handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeTransferError</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>bBenignMalloc</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name> <operator>=</operator> <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>bBenignMalloc</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SQLLOG</name></cpp:ifdef>
<comment type="block">/*
** If an SQLITE_CONFIG_SQLLOG hook is registered and the VM has been run, 
** invoke it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeInvokeSqllog</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>zSql</name></name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>pc</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExpanded</name> <init>= <expr><call><name>sqlite3VdbeExpandSql</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zExpanded</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name><argument_list>(
          <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pSqllogArg</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zExpanded</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zExpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeInvokeSqllog</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Clean up a VDBE after execution but do not delete the VDBE just yet.
** Write any error messages into *pzErrMsg.  Return the result code.
**
** After this routine is run, the VDBE should be ready to be executed
** again.
**
** To look at it another way, this routine resets the state of the
** virtual machine from VDBE_MAGIC_RUN or VDBE_MAGIC_HALT back to
** VDBE_MAGIC_INIT.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeReset</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>

  <comment type="block">/* If the VM did not run to completion or if it encountered an
  ** error, then it might not have been halted properly.  So halt
  ** it now.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the VDBE has be run even partially, then transfer the error code
  ** and error message from the VDBE into the main database structure.  But
  ** if the VDBE has just been set to run but has not actually executed any
  ** instructions yet, leave the main database error information unchanged.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeInvokeSqllog</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeTransferError</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>runOnlyOnce</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>expired</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The expired flag was set on the VDBE before the first call
    ** to sqlite3_step(). For consistency (since sqlite3_step() was
    ** called), set the database error in this case as well.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> ?</condition><then> <expr><literal type="string">"%s"</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Reclaim all memory used by the VDBE
  */</comment>
  <expr_stmt><expr><call><name>Cleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Save profiling information from this VDBE run.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"vdbe_profile.out"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>out</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"---- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>pc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"-- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zSql</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>pc</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"-- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>pc</name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>zHdr</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zHdr</name></expr></argument>, <argument><expr><literal type="string">"%6u %12llu %8llu "</literal></expr></argument>,
           <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cnt</name></expr></argument>,
           <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cycles</name></expr></argument>,
           <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cnt</name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cycles</name><operator>/</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cnt</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCurrentTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>VDBE_MAGIC_INIT</name></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>errMask</name></name></expr>;</return>
</block_content>}</block></function>
 
<comment type="block">/*
** Clean up and delete a VDBE after execution.  Return an integer which is
** the result code.  Write any error message text into *pzErrMsg.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeFinalize</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_RUN</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_HALT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name> <operator>&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>errMask</name></name><operator>)</operator><operator>==</operator><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeDelete</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If parameter iOp is less than zero, then invoke the destructor for
** all auxiliary data pointers currently cached by the VM passed as
** the first argument.
**
** Or, if iOp is greater than or equal to zero, then the destructor is
** only invoked for those auxiliary data pointers created by the user 
** function invoked by the OP_Function opcode at instruction iOp of 
** VM pVdbe, and only then if:
**
**    * the associated function parameter is the 32nd or later (counting
**      from left to right), or
**
**    * the corresponding bit in argument mask is clear (where the first
**      function parameter corresponds to bit 0 etc.).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeDeleteAuxData</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVdbe</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iOp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AuxData</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name> <init>= <expr><operator>&amp;</operator><name><name>pVdbe</name><operator>-&gt;</operator><name>pAuxData</name></name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>pp</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>AuxData</name> <modifier>*</modifier></type><name>pAux</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iOp</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>pAux</name><operator>-&gt;</operator><name>iOp</name></name><operator>==</operator><name>iOp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pAux</name><operator>-&gt;</operator><name>iArg</name></name><operator>&gt;</operator><literal type="number">31</literal> <operator>||</operator> <operator>!</operator><operator>(</operator><name>mask</name> <operator>&amp;</operator> <call><name>MASKBIT32</name><argument_list>(<argument><expr><name><name>pAux</name><operator>-&gt;</operator><name>iArg</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pAux</name><operator>-&gt;</operator><name>iArg</name></name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAux</name><operator>-&gt;</operator><name>xDelete</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name><name>pAux</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name><name>pAux</name><operator>-&gt;</operator><name>pAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pAux</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pVdbe</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pp</name><operator>=</operator> <operator>&amp;</operator><name><name>pAux</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Free all memory associated with the Vdbe passed as the second argument,
** except for object itself, which is preserved.
**
** The difference between this function and sqlite3VdbeDelete() is that
** VdbeDelete() also unlinks the Vdbe from the list of VMs associated with
** the database connection and frees the object itself.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeClearObject</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SubProgram</name> <modifier>*</modifier></type><name>pSub</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nVar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name><operator>*</operator><name>COLNAME_N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pSub</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pProgram</name></name></expr>;</init> <condition><expr><name>pSub</name></expr>;</condition> <incr><expr><name>pSub</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vdbeFreeOpArray</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>, <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nzVar</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azVar</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azVar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vdbeFreeOpArray</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nScan</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aScan</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aScan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Delete an entire VDBE.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeDelete</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeClearObject</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>==</operator><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>VDBE_MAGIC_DEAD</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The cursor "p" has a pending seek operation that has not yet been
** carried out.  Seek the cursor now.  If an error occurs, return
** the appropriate error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_NOINLINE</name></type> <name>handleDeferredMoveto</name><parameter_list>(<parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlite3_search_count</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>deferredMoveto</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>movetoTarget</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_search_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Something has moved cursor "p" out of place.  Maybe the row it was
** pointed to was deleted out from under it.  Or maybe the btree was
** rebalanced.  Whatever the cause, try to restore "p" to the place it
** is supposed to be pointing.  If the row was deleted out from under the
** cursor, set the cursor to point to a NULL row.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_NOINLINE</name></type> <name>handleMovedCursor</name><parameter_list>(<parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>isDifferentRow</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorHasMoved</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCursorRestore</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isDifferentRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>isDifferentRow</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to ensure that the cursor is valid.  Restore the cursor
** if need be.  Return any I/O error from the restore operation.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeCursorRestore</name><parameter_list>(<parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeCursorHasMoved</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>handleMovedCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Make sure the cursor p is ready to read or write the row to which it
** was last positioned.  Return an error code if an OOM fault or I/O error
** prevents us from positioning the cursor to its correct position.
**
** If a MoveTo operation is pending on the given cursor, then do that
** MoveTo now.  If no move is pending, check to see if the row has been
** deleted out from under the cursor and if it has, mark the row as
** a NULL row.
**
** If the cursor is already pointing to the correct row and that row has
** not been deleted out from under the cursor, then this routine is a no-op.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeCursorMoveto</name><parameter_list>(<parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>deferredMoveto</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iMap</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAltMap</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iMap</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aAltMap</name><index>[<expr><literal type="number">1</literal><operator>+</operator><operator>*</operator><name>piCol</name></expr>]</index></name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pAltCursor</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>piCol</name> <operator>=</operator> <name>iMap</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><call><name>handleDeferredMoveto</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeCursorHasMoved</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>handleMovedCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following functions:
**
** sqlite3VdbeSerialType()
** sqlite3VdbeSerialTypeLen()
** sqlite3VdbeSerialLen()
** sqlite3VdbeSerialPut()
** sqlite3VdbeSerialGet()
**
** encapsulate the code that serializes values for storage in SQLite
** data and index records. Each serialized value consists of a
** 'serial-type' and a blob of data. The serial type is an 8-byte unsigned
** integer, stored as a varint.
**
** In an SQLite index record, the serial type is stored directly before
** the blob of data that it corresponds to. In a table record, all serial
** types are stored at the start of the record, and the blobs of data at
** the end. Hence these functions allow the caller to handle the
** serial-type and data blob separately.
**
** The following table describes the various storage classes for data:
**
**   serial type        bytes of data      type
**   --------------     ---------------    ---------------
**      0                     0            NULL
**      1                     1            signed integer
**      2                     2            signed integer
**      3                     3            signed integer
**      4                     4            signed integer
**      5                     6            signed integer
**      6                     8            signed integer
**      7                     8            IEEE float
**      8                     0            Integer constant 0
**      9                     0            Integer constant 1
**     10,11                               reserved for expansion
**    N&gt;=12 and even       (N-12)/2        BLOB
**    N&gt;=13 and odd        (N-13)/2        text
**
** The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions
** of SQLite will not understand those serial types.
*/</comment>

<comment type="block">/*
** Return the serial-type for the value stored in pMem.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3VdbeSerialType</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>file_format</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pLen</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLen</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>MEM_Int</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_6BYTE</name></cpp:macro> <cpp:value>((((i64)0x00008000)&lt;&lt;32)-1)</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>i64</name></type> <name>i</name> <init>= <expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u64</name></type> <name>u</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>u</name> <operator>=</operator> <operator>~</operator><name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>u</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>u</name><operator>&lt;=</operator><literal type="number">127</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><name>i</name> <operator>&amp;&amp;</operator> <name>file_format</name><operator>&gt;=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">8</literal><operator>+</operator><operator>(</operator><name>u32</name><operator>)</operator><name>u</name></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>u</name><operator>&lt;=</operator><literal type="number">32767</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <return>return <expr><literal type="number">2</literal></expr>;</return> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>u</name><operator>&lt;=</operator><literal type="number">8388607</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <return>return <expr><literal type="number">3</literal></expr>;</return> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>u</name><operator>&lt;=</operator><literal type="number">2147483647</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <return>return <expr><literal type="number">4</literal></expr>;</return> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>u</name><operator>&lt;=</operator><name>MAX_6BYTE</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt> <return>return <expr><literal type="number">5</literal></expr>;</return> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">6</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>MEM_Real</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">7</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>||</operator> <name>flags</name><operator>&amp;</operator><operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><operator>(</operator><name>n</name><operator>*</operator><literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">12</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><name>MEM_Str</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The sizes for serial types less than 128
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>sqlite3SmallTypeSizes</name><index>[]</index></name> <init>= <expr><block>{
        <comment type="block">/*  0   1   2   3   4   5   6   7   8   9 */</comment>   
<comment type="block">/*   0 */</comment>   <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  10 */</comment>   <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">3</literal></expr>,
<comment type="block">/*  20 */</comment>   <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">8</literal></expr>,
<comment type="block">/*  30 */</comment>   <expr><literal type="number">9</literal></expr>,  <expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>,
<comment type="block">/*  40 */</comment>  <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>,
<comment type="block">/*  50 */</comment>  <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>,
<comment type="block">/*  60 */</comment>  <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">28</literal></expr>,
<comment type="block">/*  70 */</comment>  <expr><literal type="number">29</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">33</literal></expr>, <expr><literal type="number">33</literal></expr>,
<comment type="block">/*  80 */</comment>  <expr><literal type="number">34</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">35</literal></expr>, <expr><literal type="number">35</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">38</literal></expr>, <expr><literal type="number">38</literal></expr>,
<comment type="block">/*  90 */</comment>  <expr><literal type="number">39</literal></expr>, <expr><literal type="number">39</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">43</literal></expr>, <expr><literal type="number">43</literal></expr>,
<comment type="block">/* 100 */</comment>  <expr><literal type="number">44</literal></expr>, <expr><literal type="number">44</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">46</literal></expr>, <expr><literal type="number">46</literal></expr>, <expr><literal type="number">47</literal></expr>, <expr><literal type="number">47</literal></expr>, <expr><literal type="number">48</literal></expr>, <expr><literal type="number">48</literal></expr>,
<comment type="block">/* 110 */</comment>  <expr><literal type="number">49</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">51</literal></expr>, <expr><literal type="number">51</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">53</literal></expr>, <expr><literal type="number">53</literal></expr>,
<comment type="block">/* 120 */</comment>  <expr><literal type="number">54</literal></expr>, <expr><literal type="number">54</literal></expr>, <expr><literal type="number">55</literal></expr>, <expr><literal type="number">55</literal></expr>, <expr><literal type="number">56</literal></expr>, <expr><literal type="number">56</literal></expr>, <expr><literal type="number">57</literal></expr>, <expr><literal type="number">57</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Return the length of the data corresponding to the supplied serial-type.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3VdbeSerialTypeLen</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>serial_type</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&gt;=</operator><literal type="number">128</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>serial_type</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>serial_type</name><operator>&lt;</operator><literal type="number">12</literal> 
            <operator>||</operator> <name><name>sqlite3SmallTypeSizes</name><index>[<expr><name>serial_type</name></expr>]</index></name><operator>==</operator><operator>(</operator><name>serial_type</name> <operator>-</operator> <literal type="number">12</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>sqlite3SmallTypeSizes</name><index>[<expr><name>serial_type</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>u8</name></type> <name>sqlite3VdbeOneByteSerialTypeLen</name><parameter_list>(<parameter><decl><type><name>u8</name></type> <name>serial_type</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>serial_type</name><operator>&lt;</operator><literal type="number">128</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>sqlite3SmallTypeSizes</name><index>[<expr><name>serial_type</name></expr>]</index></name></expr>;</return>  
</block_content>}</block></function>

<comment type="block">/*
** If we are on an architecture with mixed-endian floating 
** points (ex: ARM7) then swap the lower 4 bytes with the 
** upper 4 bytes.  Return the result.
**
** For most architectures, this is a no-op.
**
** (later):  It is reported to me that the mixed-endian problem
** on ARM7 is an issue with GCC, not with the ARM7 chip.  It seems
** that early versions of GCC stored the two words of a 64-bit
** float in the wrong order.  And that error has been propagated
** ever since.  The blame is not necessarily with GCC, though.
** GCC might have just copying the problem from a prior compiler.
** I am also told that newer versions of GCC that follow a different
** ABI get the byte order right.
**
** Developers using SQLite on an ARM7 should compile and run their
** application using -DSQLITE_DEBUG=1 at least once.  With DEBUG
** enabled, some asserts below will ensure that the byte order of
** floating point values is correct.
**
** (2007-08-30)  Frank van Vugt has studied this problem closely
** and has send his findings to the SQLite developers.  Frank
** writes that some Linux kernels offer floating point hardware
** emulation that uses only 32-bit mantissas instead of a full 
** 48-bits as required by the IEEE standard.  (This is the
** CONFIG_FPE_FASTFPE option.)  On such systems, floating point
** byte swapping becomes very complicated.  To avoid problems,
** the necessary byte swapping is carried out using a 64-bit integer
** rather than a 64-bit float.  Frank assures us that the code here
** works for him.  We, the developers, have no way to independently
** verify this, but Frank seems to know what he is talking about
** so we trust him.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_MIXED_ENDIAN_64BIT_FLOAT</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>u64</name></type> <name>floatSwap</name><parameter_list>(<parameter><decl><type><name>u64</name></type> <name>in</name></decl></parameter>)</parameter_list><block>{<block_content>
  <union>union <block>{
    <decl_stmt><decl><type><name>u64</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name><name>i</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  }</block> <decl><name>u</name></decl>;</union>
  <decl_stmt><decl><type><name>u32</name></type> <name>t</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>u</name><operator>.</operator><name>i</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>u</name><operator>.</operator><name>i</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>u</name><operator>.</operator><name>i</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>u</name><operator>.</operator><name>i</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  <return>return <expr><name><name>u</name><operator>.</operator><name>r</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>swapMixedEndianFloat</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>X = floatSwap(X)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>swapMixedEndianFloat</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Write the serialized data blob for the value stored in pMem into 
** buf. It is assumed that the caller has allocated sufficient space.
** Return the number of bytes written.
**
** nBuf is the amount of space left in buf[].  The caller is responsible
** for allocating enough space to buf[] to hold the entire field, exclusive
** of the pMem-&gt;u.nZero bytes for a MEM_Zero value.
**
** Return the number of bytes actually written into buf[].  The number
** of bytes in the zero-filled tail is included in the return value only
** if those bytes were zeroed in buf[].
*/</comment> 
<function><type><name>u32</name></type> <name>sqlite3VdbeSerialPut</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>serial_type</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* Integer and Real */</comment>
  <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&lt;=</operator><literal type="number">7</literal> <operator>&amp;&amp;</operator> <name>serial_type</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>swapMixedEndianFloat</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name>i</name> <operator>=</operator> <name><name>sqlite3SmallTypeSizes</name><index>[<expr><name>serial_type</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name><name>buf</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&amp;</operator><literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>i</name></expr> )</condition>;</do>
    <return>return <expr><name>len</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* String or blob */</comment>
  <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&gt;=</operator><literal type="number">12</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name><operator>)</operator></expr>?</condition><then><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
             <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>len</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* NULL or constants 0 or 1 */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Input "x" is a sequence of unsigned characters that represent a
** big-endian integer.  Return the equivalent native integer
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONE_BYTE_INT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>((i8)(x)[0])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWO_BYTE_INT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(256*(i8)((x)[0])|(x)[1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THREE_BYTE_INT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(65536*(i8)((x)[0])|((x)[1]&lt;&lt;8)|(x)[2])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUR_BYTE_UINT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(((u32)(x)[0]&lt;&lt;24)|((x)[1]&lt;&lt;16)|((x)[2]&lt;&lt;8)|(x)[3])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUR_BYTE_INT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(16777216*(i8)((x)[0])|((x)[1]&lt;&lt;16)|((x)[2]&lt;&lt;8)|(x)[3])</cpp:value></cpp:define>

<comment type="block">/*
** Deserialize the data blob pointed to by buf as serial type serial_type
** and store the result in pMem.  Return the number of bytes read.
**
** This function is implemented as two separate routines for performance.
** The few cases that require local variables are broken out into a separate
** routine so that in most cases the overhead of moving the stack pointer
** is avoided.
*/</comment> 
<function><type><specifier>static</specifier> <name>u32</name> <name>SQLITE_NOINLINE</name></type> <name>serialGet</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,     <comment type="block">/* Buffer to deserialize from */</comment>
  <parameter><decl><type><name>u32</name></type> <name>serial_type</name></decl></parameter>,              <comment type="block">/* Serial type to deserialize */</comment>
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>                     <comment type="block">/* Memory cell to write value into */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>x</name> <init>= <expr><call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>y</name> <init>= <expr><call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>+</operator> <name>y</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">6</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* EVIDENCE-OF: R-29851-52272 Value is a big-endian 64-bit
    ** twos-complement integer. */</comment>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* EVIDENCE-OF: R-57343-49114 Value is a big-endian IEEE 754-2008 64-bit
    ** floating point number. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_FLOATING_POINT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Verify that integers and floating point values use the same
    ** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is
    ** defined that 64-bit floating point values really are mixed
    ** endian.
    */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u64</name></type> <name>t1</name> <init>= <expr><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">0x3ff00000</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>r1</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u64</name></type> <name>t2</name> <init>= <expr><name>t1</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>swapMixedEndianFloat</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>swapMixedEndianFloat</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <ternary><condition><expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>MEM_Null</name></expr> </then><else>: <expr><name>MEM_Real</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">8</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>u32</name></type> <name>sqlite3VdbeSerialGet</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,     <comment type="block">/* Buffer to deserialize from */</comment>
  <parameter><decl><type><name>u32</name></type> <name>serial_type</name></decl></parameter>,              <comment type="block">/* Serial type to deserialize */</comment>
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>                     <comment type="block">/* Memory cell to write value into */</comment>
)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name>serial_type</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">10</literal></expr>:</case>   <comment type="block">/* Reserved for future use */</comment>
    <case>case <expr><literal type="number">11</literal></expr>:</case>   <comment type="block">/* Reserved for future use */</comment>
    <case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* Null */</comment>
      <comment type="block">/* EVIDENCE-OF: R-24078-09375 Value is a NULL. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-44885-25196 Value is an 8-bit twos-complement
      ** integer. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>ONE_BYTE_INT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 2-byte signed integer */</comment>
      <comment type="block">/* EVIDENCE-OF: R-49794-35026 Value is a big-endian 16-bit
      ** twos-complement integer. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 3-byte signed integer */</comment>
      <comment type="block">/* EVIDENCE-OF: R-37839-54301 Value is a big-endian 24-bit
      ** twos-complement integer. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>THREE_BYTE_INT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">3</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">4</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 4-byte signed integer */</comment>
      <comment type="block">/* EVIDENCE-OF: R-01849-26079 Value is a big-endian 32-bit
      ** twos-complement integer. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>FOUR_BYTE_INT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__HP_cc</name></cpp:ifdef> 
      <comment type="block">/* Work around a sign-extension bug in the HP compiler for HP/UX */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>|=</operator> <literal type="number">0xffffffff80000000LL</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">4</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 6-byte signed integer */</comment>
      <comment type="block">/* EVIDENCE-OF: R-50385-09674 Value is a big-endian 48-bit
      ** twos-complement integer. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator><operator>*</operator><call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">6</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">6</literal></expr>:</case>   <comment type="block">/* 8-byte signed integer */</comment>
    <case>case <expr><literal type="number">7</literal></expr>:</case> <block>{<block_content> <comment type="block">/* IEEE floating point */</comment>
      <comment type="block">/* These use local variables, so do them in a separate routine
      ** to avoid having to move the frame pointer in the common case */</comment>
      <return>return <expr><call><name>serialGet</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>serial_type</name></expr></argument>,<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">8</literal></expr>:</case>    <comment type="block">/* Integer 0 */</comment>
    <case>case <expr><literal type="number">9</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* Integer 1 */</comment>
      <comment type="block">/* EVIDENCE-OF: R-12976-22893 Value is the integer 0. */</comment>
      <comment type="block">/* EVIDENCE-OF: R-18143-12121 Value is the integer 1. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>serial_type</name><operator>-</operator><literal type="number">8</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-14606-31564 Value is a BLOB that is (N-12)/2 bytes in
      ** length.
      ** EVIDENCE-OF: R-28401-00140 Value is a string in the text encoding and
      ** (N-13)/2 bytes in length. */</comment>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u16</name></type> <name><name>aFlag</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>MEM_Blob</name><operator>|</operator><name>MEM_Ephem</name></expr>, <expr><name>MEM_Str</name><operator>|</operator><name>MEM_Ephem</name></expr> }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>serial_type</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>aFlag</name><index>[<expr><name>serial_type</name><operator>&amp;</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <return>return <expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** This routine is used to allocate sufficient space for an UnpackedRecord
** structure large enough to be used with sqlite3VdbeRecordUnpack() if
** the first argument is a pointer to KeyInfo structure pKeyInfo.
**
** The space is either allocated using sqlite3DbMallocRaw() or from within
** the unaligned buffer passed via the second and third arguments (presumably
** stack space). If the former, then *ppFree is set to a pointer that should
** be eventually freed by the caller using sqlite3DbFree(). Or, if the 
** allocation comes from the pSpace/szSpace buffer, *ppFree is set to NULL
** before returning.
**
** If an OOM error occurs, NULL is returned.
*/</comment>
<function><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>sqlite3VdbeAllocUnpackedRecord</name><parameter_list>(
  <parameter><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl></parameter>,              <comment type="block">/* Description of the record */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pSpace</name></decl></parameter>,                   <comment type="block">/* Unaligned space available */</comment>
  <parameter><decl><type><name>int</name></type> <name>szSpace</name></decl></parameter>,                    <comment type="block">/* Size of pSpace[] in bytes */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppFree</name></decl></parameter>                   <comment type="block">/* OUT: Caller should free this pointer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>              <comment type="block">/* Unpacked record to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOff</name></decl>;</decl_stmt>                       <comment type="block">/* Increment pSpace by nOff to align it */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                      <comment type="block">/* Number of bytes required for *p */</comment>

  <comment type="block">/* We want to shift the pointer pSpace up such that it is 8-byte aligned.
  ** Thus, we need to calculate a value, nOff, between 0 and 7, to shift 
  ** it by.  If pSpace is already 8-byte aligned, nOff should be zero.
  */</comment>
  <expr_stmt><expr><name>nOff</name> <operator>=</operator> <operator>(</operator><literal type="number">8</literal> <operator>-</operator> <operator>(</operator><call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name>pSpace</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">7</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnpackedRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&gt;</operator><name>szSpace</name><operator>+</operator><name>nOff</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>UnpackedRecord</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppFree</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>UnpackedRecord</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pSpace</name><index>[<expr><name>nOff</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppFree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnpackedRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortOrder</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name>pKeyInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given the nKey-byte encoding of a record in pKey[], populate the 
** UnpackedRecord structure indicated by the fourth argument with the
** contents of the decoded record.
*/</comment> 
<function><type><name>void</name></type> <name>sqlite3VdbeRecordUnpack</name><parameter_list>(
  <parameter><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl></parameter>,     <comment type="block">/* Information about the record format */</comment>
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,              <comment type="block">/* Size of the binary record */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,      <comment type="block">/* The binary record */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>p</name></decl></parameter>      <comment type="block">/* Populate this structure before returning. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aKey</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>u32</name></type> <name>idx</name></decl>;</decl_stmt>                        <comment type="block">/* Offset in aKey[] to read from */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>u</name></decl>;</decl_stmt>                          <comment type="block">/* Unsigned loop counter */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr><name>szHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name> <operator>=</operator> <name>szHdr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>idx</name><operator>&lt;</operator><name>szHdr</name> <operator>&amp;&amp;</operator> <name>d</name><operator>&lt;=</operator><name>nKey</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>serial_type</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <comment type="block">/* pMem-&gt;flags = 0; // sqlite3VdbeSerialGet() will set this for us */</comment>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>++</operator><name>u</name><operator>)</operator><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nField</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>&lt;=</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEBUG</name></expr></cpp:if>
<comment type="block">/*
** This function compares two index or table record keys in the same way
** as the sqlite3VdbeRecordCompare() routine. Unlike VdbeRecordCompare(),
** this function deserializes and compares values using the
** sqlite3VdbeSerialGet() and sqlite3MemCompare() functions. It is used
** in assert() statements to ensure that the optimized code in
** sqlite3VdbeRecordCompare() returns results with these two primitives.
**
** Return true if the result of comparison is equivalent to desiredResult.
** Return false if there is a disagreement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeRecordCompareDebug</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <comment type="block">/* Left key */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>UnpackedRecord</name> <modifier>*</modifier></type><name>pPKey2</name></decl></parameter>, <comment type="block">/* Right key */</comment>
  <parameter><decl><type><name>int</name></type> <name>desiredResult</name></decl></parameter>             <comment type="block">/* Correct answer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>d1</name></decl>;</decl_stmt>            <comment type="block">/* Offset into aKey[] of next data element */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>idx1</name></decl>;</decl_stmt>          <comment type="block">/* Offset into aKey[] of next header element */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr1</name></decl>;</decl_stmt>        <comment type="block">/* Number of bytes in header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aKey1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name></type> <name>mem1</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <comment type="block">/* mem1.flags = 0;  // Will be initialized by sqlite3VdbeSerialGet() */</comment>
  <macro><name>VVA_ONLY</name><argument_list>( <argument>mem1.szMalloc = <literal type="number">0</literal>;</argument> )</argument_list></macro> <comment type="block">/* Only needed by assert() statements */</comment>

  <comment type="block">/* Compilers may complain that mem1.u.i is potentially uninitialized.
  ** We could initialize it, as shown here, to silence those complaints.
  ** But in fact, mem1.u.i will never actually be used uninitialized, and doing 
  ** the unnecessary initialization has a measurable negative performance
  ** impact, since this routine is a very high runner.  And so, we choose
  ** to ignore the compiler warnings and leave this variable uninitialized.
  */</comment>
  <comment type="block">/*  mem1.u.i = 0;  // not needed, here to silence compiler warning */</comment>
  
  <expr_stmt><expr><name>idx1</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey1</name></expr></argument>, <argument><expr><name>szHdr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>szHdr1</name><operator>&gt;</operator><literal type="number">98307</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>szHdr1</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name><operator>+</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nXField</name></name><operator>&gt;=</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortOrder</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx1</name><operator>&lt;=</operator><name>szHdr1</name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>serial_type1</name></decl>;</decl_stmt>

    <comment type="block">/* Read the serial types for the next element in each key. */</comment>
    <expr_stmt><expr><name>idx1</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>( <argument><expr><name>aKey1</name><operator>+</operator><name>idx1</name></expr></argument>, <argument><expr><name>serial_type1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Verify that there is enough key space remaining to avoid
    ** a buffer overread.  The "d1+serial_type1+2" subexpression will
    ** always be greater than or equal to the amount of required key space.
    ** Use that approximation to avoid the more expensive call to
    ** sqlite3VdbeSerialTypeLen() in the common case.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>d1</name><operator>+</operator><name>serial_type1</name><operator>+</operator><literal type="number">2</literal><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>nKey1</name>
     <operator>&amp;&amp;</operator> <name>d1</name><operator>+</operator><call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type1</name></expr></argument>)</argument_list></call><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>nKey1</name></expr> 
    )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Extract the values to be compared.
    */</comment>
    <expr_stmt><expr><name>d1</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Do the comparison
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem1</name><operator>.</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* See comment below */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><name>rc</name></expr>;</expr_stmt>  <comment type="block">/* Invert the result for DESC sort order. */</comment>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>debugCompareEnd</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>idx1</name><operator>&lt;</operator><name>szHdr1</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name></expr> )</condition>;</do>

  <comment type="block">/* No memory allocation is ever used on mem1.  Prove this using
  ** the following assert().  If the assert() fails, it indicates a
  ** memory leak and a need to call sqlite3VdbeMemRelease(&amp;mem1).
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem1</name><operator>.</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* rc==0 here means that one of the keys ran out of fields and
  ** all the fields up to that point were equal. Return the default_rc
  ** value.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>default_rc</name></name></expr>;</expr_stmt>

<label><name>debugCompareEnd</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>desiredResult</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>desiredResult</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>desiredResult</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>CORRUPT_DB</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEBUG</name></expr></cpp:if>
<comment type="block">/*
** Count the number of fields (a.k.a. columns) in the record given by
** pKey,nKey.  The verify that this count is less than or equal to the
** limit given by pKeyInfo-&gt;nField + pKeyInfo-&gt;nXField.
**
** If this constraint is not satisfied, it means that the high-speed
** vdbeRecordCompareInt() and vdbeRecordCompareString() routines will
** not work correctly.  If this assert() ever fires, it probably means
** that the KeyInfo.nField or KeyInfo.nXField values were computed
** incorrectly.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeAssertFieldCountWithinLimits</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,   <comment type="block">/* The record to verify */</comment> 
  <parameter><decl><type><specifier>const</specifier> <name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl></parameter>       <comment type="block">/* Compare size with this KeyInfo */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>notUsed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aKey</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pKey</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>CORRUPT_DB</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr><name>szHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>szHdr</name><operator>&lt;=</operator><operator>(</operator><name>u32</name><operator>)</operator><name>nKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>idx</name><operator>&lt;</operator><name>szHdr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey</name><operator>+</operator><name>idx</name></expr></argument>, <argument><expr><name>notUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nField</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name> <operator>&lt;=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name><operator>+</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nXField</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeAssertFieldCountWithinLimits</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Both *pMem1 and *pMem2 contain string values. Compare the two values
** using the collation sequence pColl. As usual, return a negative , zero
** or positive value if *pMem1 is less than, equal to or greater than 
** *pMem2, respectively. Similar in spirit to "rc = (*pMem1) - (*pMem2);".
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeCompareMemString</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem1</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem2</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl></parameter>,
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>prcErr</name></decl></parameter>                      <comment type="block">/* If an OOM occurs, set to SQLITE_NOMEM */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The strings are already in the correct encoding.  Call the
     ** comparison function directly */</comment>
    <return>return <expr><call><name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>pUser</name></name></expr></argument>,<argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>n</name></name></expr></argument>,<argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>,<argument><expr><name><name>pMem2</name><operator>-&gt;</operator><name>n</name></name></expr></argument>,<argument><expr><name><name>pMem2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name></type> <name>c1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name></type> <name>c2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>, <argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><name>pMem1</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>, <argument><expr><name>pMem2</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>sqlite3ValueText</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n1</name> <operator>=</operator> <ternary><condition><expr><name>v1</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>c1</name><operator>.</operator><name>n</name></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>sqlite3ValueText</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c2</name></expr></argument>, <argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n2</name> <operator>=</operator> <ternary><condition><expr><name>v2</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>c2</name><operator>.</operator><name>n</name></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>pUser</name></name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>v1</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>v2</name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>prcErr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>prcErr</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compare two blobs.  Return negative, zero, or positive if the first
** is less than, equal to, or greater than the second, respectively.
** If one blob is a prefix of the other, then the shorter is the lessor.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>sqlite3BlobCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pB1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pB2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pB1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pB2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pB1</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><name><name>pB2</name><operator>-&gt;</operator><name>n</name></name></expr> ?</condition><then> <expr><name><name>pB2</name><operator>-&gt;</operator><name>n</name></name></expr> </then><else>: <expr><name><name>pB1</name><operator>-&gt;</operator><name>n</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pB1</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <name><name>pB2</name><operator>-&gt;</operator><name>n</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do a comparison between a 64-bit signed integer and a 64-bit floating-point
** number.  Return negative, zero, or positive if the first (i64) is less than,
** equal to, or greater than the second (double).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3IntFloatCompare</name><parameter_list>(<parameter><decl><type><name>i64</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>r</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><sizeof>sizeof<argument_list>(<argument><expr><name>LONGDOUBLE_TYPE</name></expr></argument>)</argument_list></sizeof><operator>&gt;</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>x</name> <init>= <expr><operator>(</operator><name>LONGDOUBLE_TYPE</name><operator>)</operator><name>i</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><name>r</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;</operator><name>r</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>r</name><operator>&lt;</operator><operator>-</operator><literal type="number">9223372036854775808.0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>r</name><operator>&gt;</operator><literal type="number">9223372036854775807.0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>y</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>r</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>y</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>y</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>y</name><operator>==</operator><name>SMALLEST_INT64</name> <operator>&amp;&amp;</operator> <name>r</name><operator>&gt;</operator><literal type="number">0.0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>s</name><operator>&lt;</operator><name>r</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>s</name><operator>&gt;</operator><name>r</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compare the values contained by the two memory cells, returning
** negative, zero or positive if pMem1 is less than, equal to, or greater
** than pMem2. Sorting order is NULL's first, followed by numbers (integers
** and reals) sorted numerically, followed by text ordered by the collating
** sequence pColl and finally blob's ordered by memcmp().
**
** Two NULL values are considered equal by this function.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3MemCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>f1</name></decl>, <decl><type ref="prev"/><name>f2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>combined_flags</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>f1</name> <operator>=</operator> <name><name>pMem1</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>f2</name> <operator>=</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>combined_flags</name> <operator>=</operator> <name>f1</name><operator>|</operator><name>f2</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>combined_flags</name> <operator>&amp;</operator> <name>MEM_RowSet</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
 
  <comment type="block">/* If one value is NULL, it is less than the other. If both values
  ** are NULL, return 0.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>combined_flags</name><operator>&amp;</operator><name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>f2</name><operator>&amp;</operator><name>MEM_Null</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>f1</name><operator>&amp;</operator><name>MEM_Null</name><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* At least one of the two values is a number
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>combined_flags</name><operator>&amp;</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f1</name> <operator>&amp;</operator> <name>f2</name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>&lt;</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>&gt;</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f1</name> <operator>&amp;</operator> <name>f2</name> <operator>&amp;</operator> <name>MEM_Real</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>&lt;</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>&gt;</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f1</name><operator>&amp;</operator><name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f2</name><operator>&amp;</operator><name>MEM_Real</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><call><name>sqlite3IntFloatCompare</name><argument_list>(<argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f1</name><operator>&amp;</operator><name>MEM_Real</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f2</name><operator>&amp;</operator><name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><operator>-</operator><call><name>sqlite3IntFloatCompare</name><argument_list>(<argument><expr><name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If one value is a string and the other is a blob, the string is less.
  ** If both are strings, compare using the collating functions.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>combined_flags</name><operator>&amp;</operator><name>MEM_Str</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f1</name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f2</name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name><name>pMem2</name><operator>-&gt;</operator><name>enc</name></name> <operator>||</operator> <name><name>pMem1</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> 
            <name><name>pMem1</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF16LE</name> <operator>||</operator> <name><name>pMem1</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The collation sequence must be defined at this point, even if
    ** the user deletes the collation sequence after the vdbe program is
    ** compiled (this was not always the case).
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pColl</name> <operator>||</operator> <name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>pColl</name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>vdbeCompareMemString</name><argument_list>(<argument><expr><name>pMem1</name></expr></argument>, <argument><expr><name>pMem2</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* If a NULL pointer was passed as the collate function, fall through
    ** to the blob case and use memcmp().  */</comment>
  </block_content>}</block></if></if_stmt>
 
  <comment type="block">/* Both values must be blobs.  Compare using memcmp().  */</comment>
  <return>return <expr><call><name>sqlite3BlobCompare</name><argument_list>(<argument><expr><name>pMem1</name></expr></argument>, <argument><expr><name>pMem2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The first argument passed to this function is a serial-type that
** corresponds to an integer - all values between 1 and 9 inclusive 
** except 7. The second points to a buffer containing an integer value
** serialized according to serial_type. This function deserializes
** and returns the value.
*/</comment>
<function><type><specifier>static</specifier> <name>i64</name></type> <name>vdbeRecordDecodeInt</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>serial_type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>y</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <operator>(</operator><name>serial_type</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>serial_type</name><operator>&lt;=</operator><literal type="number">9</literal> <operator>&amp;&amp;</operator> <name>serial_type</name><operator>!=</operator><literal type="number">7</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>serial_type</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>
    <case>case <expr><literal type="number">1</literal></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>ONE_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">2</literal></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">3</literal></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>THREE_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">4</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>y</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator><operator>*</operator><call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">6</literal></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>u64</name></type> <name>x</name> <init>= <expr><call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>|</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>x</name></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>

  <return>return <expr><operator>(</operator><name>serial_type</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function compares the two table rows or index records
** specified by {nKey1, pKey1} and pPKey2.  It returns a negative, zero
** or positive integer if key1 is less than, equal to or 
** greater than key2.  The {nKey1, pKey1} key must be a blob
** created by the OP_MakeRecord opcode of the VDBE.  The pPKey2
** key must be a parsed key such as obtained from
** sqlite3VdbeParseRecord.
**
** If argument bSkip is non-zero, it is assumed that the caller has already
** determined that the first fields of the keys are equal.
**
** Key1 and Key2 do not have to contain the same number of fields. If all 
** fields that appear in both keys are equal, then pPKey2-&gt;default_rc is 
** returned.
**
** If database corruption is discovered, set pPKey2-&gt;errCode to 
** SQLITE_CORRUPT and return 0. If an OOM error is encountered, 
** pPKey2-&gt;errCode is set to SQLITE_NOMEM and, if it is not NULL, the
** malloc-failed flag set on database handle (pPKey2-&gt;pKeyInfo-&gt;db).
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeRecordCompareWithSkip</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,   <comment type="block">/* Left key */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pPKey2</name></decl></parameter>,         <comment type="block">/* Right key */</comment>
  <parameter><decl><type><name>int</name></type> <name>bSkip</name></decl></parameter>                       <comment type="block">/* If true, skip the first field */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>d1</name></decl>;</decl_stmt>                         <comment type="block">/* Offset into aKey[] of next data element */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Index of next field to compare */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr1</name></decl>;</decl_stmt>                     <comment type="block">/* Size of record header in bytes */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>idx1</name></decl>;</decl_stmt>                       <comment type="block">/* Offset of first type in header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Return value */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRhs</name> <init>= <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Next field of pPKey2 to compare */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aKey1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name></type> <name>mem1</name></decl>;</decl_stmt>

  <comment type="block">/* If bSkip is true, then the caller has already determined that the first
  ** two elements in the keys are equal. Fix the various stack variables so
  ** that this routine begins comparing at the second field. */</comment>
  <if_stmt><if>if<condition>( <expr><name>bSkip</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>s1</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>idx1</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>szHdr1</name> <operator>=</operator> <name><name>aKey1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>szHdr1</name> <operator>+</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRhs</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>idx1</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey1</name></expr></argument>, <argument><expr><name>szHdr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>szHdr1</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>d1</name><operator>&gt;</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr> )</condition><block>{<block_content> 
      <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Corruption */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <macro><name>VVA_ONLY</name><argument_list>( <argument>mem1.szMalloc = <literal type="number">0</literal>;</argument> )</argument_list></macro> <comment type="block">/* Only needed by assert() statements */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name><operator>+</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nXField</name></name><operator>&gt;=</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name> 
       <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortOrder</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx1</name><operator>&lt;=</operator><name>szHdr1</name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>serial_type</name></decl>;</decl_stmt>

    <comment type="block">/* RHS is an integer */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>serial_type</name> <operator>=</operator> <name><name>aKey1</name><index>[<expr><name>idx1</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serial_type</name><operator>==</operator><literal type="number">12</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&gt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><call><name>sqlite3IntFloatCompare</name><argument_list>(<argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>mem1</name><operator>.</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>lhs</name> <init>= <expr><call><name>vdbeRecordDecodeInt</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>i64</name></type> <name>rhs</name> <init>= <expr><name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>lhs</name><operator>&lt;</operator><name>rhs</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>lhs</name><operator>&gt;</operator><name>rhs</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

    <comment type="block">/* RHS is real */</comment>
    <if type="elseif">else if<condition>( <expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>serial_type</name> <operator>=</operator> <name><name>aKey1</name><index>[<expr><name>idx1</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&gt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Serial types 12 or greater are strings and blobs (greater than
        ** numbers). Types 10 and 11 are currently "reserved for future 
        ** use", so it doesn't really matter what the results of comparing
        ** them to numberic values are.  */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>mem1</name><operator>.</operator><name>u</name><operator>.</operator><name>r</name></name><operator>&lt;</operator><name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>mem1</name><operator>.</operator><name>u</name><operator>.</operator><name>r</name></name><operator>&gt;</operator><name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3IntFloatCompare</name><argument_list>(<argument><expr><name><name>mem1</name><operator>.</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

    <comment type="block">/* RHS is a string */</comment>
    <if type="elseif">else if<condition>( <expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>getVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>idx1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serial_type</name><operator>==</operator><literal type="number">12</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&lt;</operator><literal type="number">12</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><operator>(</operator><name>serial_type</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>serial_type</name> <operator>-</operator> <literal type="number">12</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>d1</name><operator>+</operator><name><name>mem1</name><operator>.</operator><name>n</name></name><operator>)</operator><operator>==</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>d1</name><operator>+</operator><name><name>mem1</name><operator>.</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>d1</name><operator>+</operator><name><name>mem1</name><operator>.</operator><name>n</name></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">0</literal></expr>;</return>                <comment type="block">/* Corruption */</comment>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Str</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeCompareMemString</name><argument_list>(
              <argument><expr><operator>&amp;</operator><name>mem1</name></expr></argument>, <argument><expr><name>pRhs</name></expr></argument>, <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nCmp</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>mem1</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>nCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>mem1</name><operator>.</operator><name>n</name></name> <operator>-</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

    <comment type="block">/* RHS is a blob */</comment>
    <if type="elseif">else if<condition>( <expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>getVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>idx1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serial_type</name><operator>==</operator><literal type="number">12</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&lt;</operator><literal type="number">12</literal> <operator>||</operator> <operator>(</operator><name>serial_type</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nStr</name> <init>= <expr><operator>(</operator><name>serial_type</name> <operator>-</operator> <literal type="number">12</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>d1</name><operator>+</operator><name>nStr</name><operator>)</operator><operator>==</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>d1</name><operator>+</operator><name>nStr</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>d1</name><operator>+</operator><name>nStr</name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">0</literal></expr>;</return>                <comment type="block">/* Corruption */</comment>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nCmp</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>nStr</name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>nCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>nStr</name> <operator>-</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

    <comment type="block">/* RHS is null */</comment>
    <else>else<block>{<block_content>
      <expr_stmt><expr><name>serial_type</name> <operator>=</operator> <name><name>aKey1</name><index>[<expr><name>idx1</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>serial_type</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><name>rc</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>vdbeRecordCompareDebug</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem1</name><operator>.</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* See comment below */</comment>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRhs</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>d1</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx1</name> <operator>+=</operator> <call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>idx1</name><operator>&lt;</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>szHdr1</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name> <operator>&amp;&amp;</operator> <name>d1</name><operator>&lt;=</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr> )</condition>;</do>

  <comment type="block">/* No memory allocation is ever used on mem1.  Prove this using
  ** the following assert().  If the assert() fails, it indicates a
  ** memory leak and a need to call sqlite3VdbeMemRelease(&amp;mem1).  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem1</name><operator>.</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* rc==0 here means that one or both of the keys ran out of fields and
  ** all the fields up to that point were equal. Return the default_rc
  ** value.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> 
       <operator>||</operator> <call><name>vdbeRecordCompareDebug</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>default_rc</name></name></expr></argument>)</argument_list></call> 
       <operator>||</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>eqSeen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>default_rc</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeRecordCompare</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,   <comment type="block">/* Left key */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pPKey2</name></decl></parameter>          <comment type="block">/* Right key */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeRecordCompareWithSkip</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is an optimized version of sqlite3VdbeRecordCompare() 
** that (a) the first field of pPKey2 is an integer, and (b) the 
** size-of-header varint at the start of (pKey1/nKey1) fits in a single
** byte (i.e. is less than 128).
**
** To avoid concerns about buffer overreads, this routine is only used
** on schemas where the maximum valid header size is 63 bytes or less.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeRecordCompareInt</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <comment type="block">/* Left key */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pPKey2</name></decl></parameter>        <comment type="block">/* Right key */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aKey</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name><operator>)</operator><index>[<expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>serial_type</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>y</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>v</name> <init>= <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>lhs</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>vdbeAssertFieldCountWithinLimits</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name><operator>)</operator><operator>&lt;=</operator><literal type="number">0x3F</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>serial_type</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1-byte signed integer */</comment>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <call><name>ONE_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 2-byte signed integer */</comment>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 3-byte signed integer */</comment>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <call><name>THREE_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">4</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 4-byte signed integer */</comment>
      <expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>y</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 6-byte signed integer */</comment>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator><operator>*</operator><call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">6</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 8-byte signed integer */</comment>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>|</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>x</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">8</literal></expr>:</case> 
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">9</literal></expr>:</case>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>

    <comment type="block">/* This case could be removed without changing the results of running
    ** this code. Including it causes gcc to generate a faster switch 
    ** statement (since the range of switch targets now starts at zero and
    ** is contiguous) but does not cause any duplicate code to be generated
    ** (as gcc is clever enough to combine the two like cases). Other 
    ** compilers might be similar.  */</comment> 
    <case>case <expr><literal type="number">0</literal></expr>:</case> <case>case <expr><literal type="number">7</literal></expr>:</case>
      <return>return <expr><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>)</argument_list></call></expr>;</return>

    <default>default:</default>
      <return>return <expr><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>

  <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;</operator><name>lhs</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r1</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>v</name><operator>&lt;</operator><name>lhs</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r2</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The first fields of the two keys are equal. Compare the trailing 
    ** fields.  */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompareWithSkip</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The first fields of the two keys are equal and there are no trailing
    ** fields. Return pPKey2-&gt;default_rc in this case. */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>default_rc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>eqSeen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>vdbeRecordCompareDebug</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is an optimized version of sqlite3VdbeRecordCompare() 
** that (a) the first field of pPKey2 is a string, that (b) the first field
** uses the collation sequence BINARY and (c) that the size-of-header varint 
** at the start of (pKey1/nKey1) fits in a single byte.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeRecordCompareString</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <comment type="block">/* Left key */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pPKey2</name></decl></parameter>        <comment type="block">/* Right key */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aKey1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>serial_type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vdbeAssertFieldCountWithinLimits</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>getVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&lt;</operator><literal type="number">12</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r1</name></name></expr>;</expr_stmt>      <comment type="block">/* (pKey1/nKey1) is a number or a null */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><operator>(</operator><name>serial_type</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r2</name></name></expr>;</expr_stmt>      <comment type="block">/* (pKey1/nKey1) is a blob */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nCmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nStr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>szHdr</name> <init>= <expr><name><name>aKey1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>nStr</name> <operator>=</operator> <operator>(</operator><name>serial_type</name><operator>-</operator><literal type="number">12</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>szHdr</name> <operator>+</operator> <name>nStr</name><operator>)</operator> <operator>&gt;</operator> <name>nKey1</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Corruption */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nCmp</name> <operator>=</operator> <call><name>MIN</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name>nStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>szHdr</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>nCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name>nStr</name> <operator>-</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>n</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompareWithSkip</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>default_rc</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>eqSeen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r2</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r1</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r2</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r1</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>vdbeRecordCompareDebug</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call>
       <operator>||</operator> <name>CORRUPT_DB</name>
       <operator>||</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to an sqlite3VdbeRecordCompare() compatible function
** suitable for comparing serialized records to the unpacked record passed
** as the only argument.
*/</comment>
<function><type><name>RecordCompare</name></type> <name>sqlite3VdbeFindCompare</name><parameter_list>(<parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* varintRecordCompareInt() and varintRecordCompareString() both assume
  ** that the size-of-header varint that occurs at the start of each record
  ** fits in a single byte (i.e. is 127 or less). varintRecordCompareInt()
  ** also assumes that it is safe to overread a buffer by at least the 
  ** maximum possible legal header size plus 8 bytes. Because there is
  ** guaranteed to be at least 74 (but not 136) bytes of padding following each
  ** buffer passed to varintRecordCompareInt() this makes it convenient to
  ** limit the size of the header to 64 bytes in cases where the first field
  ** is an integer.
  **
  ** The easiest way to enforce this limit is to consider only records with
  ** 13 fields or less. If the first field is an integer, the maximum legal
  ** header size is (12*5 + 1 + 1) bytes.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nXField</name></name><operator>)</operator><operator>&lt;=</operator><literal type="number">13</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>flags</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>r1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>r2</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>r1</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>r2</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <return>return <expr><name>vdbeRecordCompareInt</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>flags</name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>flags</name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name> <operator>&amp;</operator> <name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>vdbeRecordCompareString</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>sqlite3VdbeRecordCompare</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pCur points at an index entry created using the OP_MakeRecord opcode.
** Read the rowid (the last field in the record) and store it in *rowid.
** Return SQLITE_OK if everything works, or an error code otherwise.
**
** pCur might be pointing to text obtained from a corrupt database file.
** So the content cannot be trusted.  Do appropriate checks on the content.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeIdxRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>rowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nCellKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr</name></decl>;</decl_stmt>        <comment type="block">/* Size of the header */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>typeRowid</name></decl>;</decl_stmt>    <comment type="block">/* Serial type of the rowid */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>lenRowid</name></decl>;</decl_stmt>     <comment type="block">/* Size of the rowid */</comment>
  <decl_stmt><decl><type><name>Mem</name></type> <name>m</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

  <comment type="block">/* Get the size of the index entry.  Only indices entries of less
  ** than 2GiB are support - anything large must be database corruption.
  ** Any corruption is detected in sqlite3BtreeParseCellPtr(), though, so
  ** this code can safely assume that nCellKey is 32-bits  
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>VVA_ONLY</name><argument_list>(<argument>rc =</argument>)</argument_list></macro> <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCellKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* pCur is always valid so KeySize cannot fail */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>nCellKey</name> <operator>&amp;</operator> <name>SQLITE_MAX_U32</name><operator>)</operator><operator>==</operator><operator>(</operator><name>u64</name><operator>)</operator><name>nCellKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read in the complete content of the index entry */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtree</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>nCellKey</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The index entry must begin with a header size */</comment>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>getVarint32</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>m</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>szHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szHdr</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szHdr</name><operator>==</operator><name><name>m</name><operator>.</operator><name>n</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>szHdr</name><argument_list type="generic">&lt;<argument><expr><literal type="number">3</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><name>szHdr</name></expr></argument>&gt;</argument_list></name><name><name>m</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>idx_rowid_corruption</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The last field of the index should be an integer - the ROWID.
  ** Verify that the last entry really is an integer. */</comment>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>getVarint32</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>m</name><operator>.</operator><name>z</name><index>[<expr><name>szHdr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>typeRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">6</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>typeRowid</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal> <operator>||</operator> <name>typeRowid</name></expr></argument>&gt;</argument_list></name><literal type="number">9</literal> <operator>||</operator> <name>typeRowid</name><operator>==</operator><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>idx_rowid_corruption</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>lenRowid</name> <operator>=</operator> <name><name>sqlite3SmallTypeSizes</name><index>[<expr><name>typeRowid</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>m</name><operator>.</operator><name>n</name></name><operator>==</operator><name>szHdr</name><operator>+</operator><name>lenRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>m</name><operator>.</operator><name>n</name></name><operator>&lt;</operator><name>szHdr</name><operator>+</operator><name>lenRowid</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>idx_rowid_corruption</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Fetch the integer off the end of the index record */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>m</name><operator>.</operator><name>z</name><index>[<expr><name><name>m</name><operator>.</operator><name>n</name></name><operator>-</operator><name>lenRowid</name></expr>]</index></name></expr></argument>, <argument><expr><name>typeRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>rowid</name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

  <comment type="block">/* Jump here if database corruption is detected after m has been
  ** allocated.  Free the m object and return SQLITE_CORRUPT. */</comment>
<label><name>idx_rowid_corruption</name>:</label>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>m</name><operator>.</operator><name>szMalloc</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the key of the index entry that cursor pC is pointing to against
** the key string in pUnpacked.  Write into *pRes a number
** that is negative, zero, or positive if pC is less than, equal to,
** or greater than pUnpacked.  Return SQLITE_OK on success.
**
** pUnpacked is either created without a rowid or is truncated so that it
** omits the rowid at the end.  The rowid at the end of the index entry
** is ignored as well.  Hence, this routine only compares the prefixes 
** of the keys prior to the final rowid, not the entire key.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeIdxKeyCompare</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                     <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl></parameter>,                  <comment type="block">/* The cursor to compare against */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pUnpacked</name></decl></parameter>,       <comment type="block">/* Unpacked version of key */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>                         <comment type="block">/* Write the comparison result here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nCellKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name></type> <name>m</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>VVA_ONLY</name><argument_list>(<argument>rc =</argument>)</argument_list></macro> <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCellKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* pCur is always valid so KeySize cannot fail */</comment>
  <comment type="block">/* nCellKey will always be between 0 and 0xffffffff because of the way
  ** that btreeParseCellPtr() and sqlite3GetVarint32() are implemented */</comment>
  <if_stmt><if>if<condition>( <expr><name>nCellKey</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>nCellKey</name><operator>&gt;</operator><literal type="number">0x7fffffff</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtree</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>nCellKey</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>m</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>pUnpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine sets the value to be returned by subsequent calls to
** sqlite3_changes() on the database handle 'db'. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetChanges</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nChange</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <name>nChange</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nTotalChange</name></name> <operator>+=</operator> <name>nChange</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set a flag in the vdbe to update the change counter when it is finalised
** or reset.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeCountChanges</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>changeCntOn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Mark every prepared statement associated with a database connection
** as expired.
**
** An expired statement means that recompilation of the statement is
** recommend.  Statements expire when things happen that make their
** programs obsolete.  Removing user-defined functions or collating
** sequences, or changing an authorization function are the types of
** things that make prepared statements obsolete.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExpirePreparedStatements</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Return the database associated with the Vdbe.
*/</comment>
<function><type><name>sqlite3</name> <modifier>*</modifier></type><name>sqlite3VdbeDb</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to an sqlite3_value structure containing the value bound
** parameter iVar of VM v. Except, if the value is an SQL NULL, return 
** 0 instead. Unless it is NULL, apply affinity aff (one of the SQLITE_AFF_*
** constants) to the value before returning it.
**
** The returned value must be freed by the caller using sqlite3ValueFree().
*/</comment>
<function><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>sqlite3VdbeGetBoundValue</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVar</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>aff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iVar</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name>iVar</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name> <operator>*</operator><operator>)</operator><name>pRet</name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>pRet</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configure SQL variable iVar so that binding a new value to it signals
** to sqlite3_reoptimize() that re-preparing the statement may result
** in a better query plan.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetVarmask</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVar</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iVar</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iVar</name><operator>&gt;</operator><literal type="number">32</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>expmask</name></name> <operator>=</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>expmask</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iVar</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Transfer error message text from an sqlite3_vtab.zErrMsg (text stored
** in memory obtained from sqlite3_malloc) into a Vdbe.zErrMsg (text stored
** in memory obtained from sqlite3DbMalloc).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabImportErrmsg</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
</unit>
