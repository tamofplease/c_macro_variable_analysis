<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/utf.c"><comment type="block">/*
** 2004 April 13
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains routines used to translate between UTF-8, 
** UTF-16, UTF-16BE, and UTF-16LE.
**
** Notes on UTF-8:
**
**   Byte-0    Byte-1    Byte-2    Byte-3    Value
**  0xxxxxxx                                 00000000 00000000 0xxxxxxx
**  110yyyyy  10xxxxxx                       00000000 00000yyy yyxxxxxx
**  1110zzzz  10yyyyyy  10xxxxxx             00000000 zzzzyyyy yyxxxxxx
**  11110uuu  10uuzzzz  10yyyyyy  10xxxxxx   000uuuuu zzzzyyyy yyxxxxxx
**
**
** Notes on UTF-16:  (with wwww+1==uuuuu)
**
**      Word-0               Word-1          Value
**  110110ww wwzzzzyy   110111yy yyxxxxxx    000uuuuu zzzzyyyy yyxxxxxx
**  zzzzyyyy yyxxxxxx                        00000000 zzzzyyyy yyxxxxxx
**
**
** BOM or Byte Order Mark:
**     0xff 0xfe   little-endian utf-16 follows
**     0xfe 0xff   big-endian utf-16 follows
**
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_AMALGAMATION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** The following constant value is used by the SQLITE_BIGENDIAN and
** SQLITE_LITTLEENDIAN macros.
*/</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>sqlite3one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_AMALGAMATION &amp;&amp; SQLITE_BYTEORDER==0 */</comment>

<comment type="block">/*
** This lookup table is used to help decode the first byte of
** a multi-byte UTF8 character.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>sqlite3Utf8Trans1</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x05</literal></expr>, <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0x07</literal></expr>,
  <expr><literal type="number">0x08</literal></expr>, <expr><literal type="number">0x09</literal></expr>, <expr><literal type="number">0x0a</literal></expr>, <expr><literal type="number">0x0b</literal></expr>, <expr><literal type="number">0x0c</literal></expr>, <expr><literal type="number">0x0d</literal></expr>, <expr><literal type="number">0x0e</literal></expr>, <expr><literal type="number">0x0f</literal></expr>,
  <expr><literal type="number">0x10</literal></expr>, <expr><literal type="number">0x11</literal></expr>, <expr><literal type="number">0x12</literal></expr>, <expr><literal type="number">0x13</literal></expr>, <expr><literal type="number">0x14</literal></expr>, <expr><literal type="number">0x15</literal></expr>, <expr><literal type="number">0x16</literal></expr>, <expr><literal type="number">0x17</literal></expr>,
  <expr><literal type="number">0x18</literal></expr>, <expr><literal type="number">0x19</literal></expr>, <expr><literal type="number">0x1a</literal></expr>, <expr><literal type="number">0x1b</literal></expr>, <expr><literal type="number">0x1c</literal></expr>, <expr><literal type="number">0x1d</literal></expr>, <expr><literal type="number">0x1e</literal></expr>, <expr><literal type="number">0x1f</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x05</literal></expr>, <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0x07</literal></expr>,
  <expr><literal type="number">0x08</literal></expr>, <expr><literal type="number">0x09</literal></expr>, <expr><literal type="number">0x0a</literal></expr>, <expr><literal type="number">0x0b</literal></expr>, <expr><literal type="number">0x0c</literal></expr>, <expr><literal type="number">0x0d</literal></expr>, <expr><literal type="number">0x0e</literal></expr>, <expr><literal type="number">0x0f</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x05</literal></expr>, <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0x07</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UTF8</name><parameter_list>(<parameter><type><name>zOut</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                          \
  if( c&lt;0x00080 ){                                     \
    *zOut++ = (u8)(c&amp;0xFF);                            \
  }                                                    \
  else if( c&lt;0x00800 ){                                \
    *zOut++ = 0xC0 + (u8)((c&gt;&gt;6)&amp;0x1F);                \
    *zOut++ = 0x80 + (u8)(c &amp; 0x3F);                   \
  }                                                    \
  else if( c&lt;0x10000 ){                                \
    *zOut++ = 0xE0 + (u8)((c&gt;&gt;12)&amp;0x0F);               \
    *zOut++ = 0x80 + (u8)((c&gt;&gt;6) &amp; 0x3F);              \
    *zOut++ = 0x80 + (u8)(c &amp; 0x3F);                   \
  }else{                                               \
    *zOut++ = 0xF0 + (u8)((c&gt;&gt;18) &amp; 0x07);             \
    *zOut++ = 0x80 + (u8)((c&gt;&gt;12) &amp; 0x3F);             \
    *zOut++ = 0x80 + (u8)((c&gt;&gt;6) &amp; 0x3F);              \
    *zOut++ = 0x80 + (u8)(c &amp; 0x3F);                   \
  }                                                    \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UTF16LE</name><parameter_list>(<parameter><type><name>zOut</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                                    \
  if( c&lt;=0xFFFF ){                                                  \
    *zOut++ = (u8)(c&amp;0x00FF);                                       \
    *zOut++ = (u8)((c&gt;&gt;8)&amp;0x00FF);                                  \
  }else{                                                            \
    *zOut++ = (u8)(((c&gt;&gt;10)&amp;0x003F) + (((c-0x10000)&gt;&gt;10)&amp;0x00C0));  \
    *zOut++ = (u8)(0x00D8 + (((c-0x10000)&gt;&gt;18)&amp;0x03));              \
    *zOut++ = (u8)(c&amp;0x00FF);                                       \
    *zOut++ = (u8)(0x00DC + ((c&gt;&gt;8)&amp;0x03));                         \
  }                                                                 \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UTF16BE</name><parameter_list>(<parameter><type><name>zOut</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                                    \
  if( c&lt;=0xFFFF ){                                                  \
    *zOut++ = (u8)((c&gt;&gt;8)&amp;0x00FF);                                  \
    *zOut++ = (u8)(c&amp;0x00FF);                                       \
  }else{                                                            \
    *zOut++ = (u8)(0x00D8 + (((c-0x10000)&gt;&gt;18)&amp;0x03));              \
    *zOut++ = (u8)(((c&gt;&gt;10)&amp;0x003F) + (((c-0x10000)&gt;&gt;10)&amp;0x00C0));  \
    *zOut++ = (u8)(0x00DC + ((c&gt;&gt;8)&amp;0x03));                         \
    *zOut++ = (u8)(c&amp;0x00FF);                                       \
  }                                                                 \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_UTF16LE</name><parameter_list>(<parameter><type><name>zIn</name></type></parameter>, <parameter><type><name>TERM</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{                                   \
  c = (*zIn++);                                                       \
  c += ((*zIn++)&lt;&lt;8);                                                 \
  if( c&gt;=0xD800 &amp;&amp; c&lt;0xE000 &amp;&amp; TERM ){                                \
    int c2 = (*zIn++);                                                \
    c2 += ((*zIn++)&lt;&lt;8);                                              \
    c = (c2&amp;0x03FF) + ((c&amp;0x003F)&lt;&lt;10) + (((c&amp;0x03C0)+0x0040)&lt;&lt;10);   \
  }                                                                   \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_UTF16BE</name><parameter_list>(<parameter><type><name>zIn</name></type></parameter>, <parameter><type><name>TERM</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{                                   \
  c = ((*zIn++)&lt;&lt;8);                                                  \
  c += (*zIn++);                                                      \
  if( c&gt;=0xD800 &amp;&amp; c&lt;0xE000 &amp;&amp; TERM ){                                \
    int c2 = ((*zIn++)&lt;&lt;8);                                           \
    c2 += (*zIn++);                                                   \
    c = (c2&amp;0x03FF) + ((c&amp;0x003F)&lt;&lt;10) + (((c&amp;0x03C0)+0x0040)&lt;&lt;10);   \
  }                                                                   \
}</cpp:value></cpp:define>

<comment type="block">/*
** Translate a single UTF-8 character.  Return the unicode value.
**
** During translation, assume that the byte that zTerm points
** is a 0x00.
**
** Write a pointer to the next unread byte back into *pzNext.
**
** Notes On Invalid UTF-8:
**
**  *  This routine never allows a 7-bit character (0x00 through 0x7f) to
**     be encoded as a multi-byte character.  Any multi-byte character that
**     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.
**
**  *  This routine never allows a UTF16 surrogate value to be encoded.
**     If a multi-byte character attempts to encode a value between
**     0xd800 and 0xe000 then it is rendered as 0xfffd.
**
**  *  Bytes in the range of 0x80 through 0xbf which occur as the first
**     byte of a character are interpreted as single-byte characters
**     and rendered as themselves even though they are technically
**     invalid characters.
**
**  *  This routine accepts over-length UTF8 encodings
**     for unicode values 0x80 and greater.  It does not change over-length
**     encodings to 0xfffd as some systems recommend.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_UTF8</name><parameter_list>(<parameter><type><name>zIn</name></type></parameter>, <parameter><type><name>zTerm</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>                           \
  <cpp:value>c = *(zIn++);                                            \
  if( c&gt;=0xc0 ){                                           \
    c = sqlite3Utf8Trans1[c-0xc0];                         \
    while( zIn!=zTerm &amp;&amp; (*zIn &amp; 0xc0)==0x80 ){            \
      c = (c&lt;&lt;6) + (0x3f &amp; *(zIn++));                      \
    }                                                      \
    if( c&lt;0x80                                             \
        || (c&amp;0xFFFFF800)==0xD800                          \
        || (c&amp;0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \
  }</cpp:value></cpp:define>
<function><type><name>u32</name></type> <name>sqlite3Utf8Read</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pz</name></decl></parameter>    <comment type="block">/* Pointer to string from which to read char */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

  <comment type="block">/* Same as READ_UTF8() above but without the zTerm parameter.
  ** For this routine, we assume the UTF8 string is always zero-terminated.
  */</comment>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>pz</name><operator>)</operator><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>sqlite3Utf8Trans1</name><index>[<expr><name>c</name><operator>-</operator><literal type="number">0xc0</literal></expr>]</index></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><operator>*</operator><operator>(</operator><operator>*</operator><name>pz</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">0x3f</literal> <operator>&amp;</operator> <operator>*</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>pz</name><operator>)</operator><operator>++</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0x80</literal>
        <operator>||</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xFFFFF800</literal><operator>)</operator><operator>==</operator><literal type="number">0xD800</literal>
        <operator>||</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xFFFFFFFE</literal><operator>)</operator><operator>==</operator><literal type="number">0xFFFE</literal></expr> )</condition><block>{<block_content>  <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0xFFFD</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>




<comment type="block">/*
** If the TRANSLATE_TRACE macro is defined, the value of each Mem is
** printed on stderr on the way into and out of sqlite3VdbeMemTranslate().
*/</comment> 
<comment type="block">/* #define TRANSLATE_TRACE 1 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** This routine transforms the internal text encoding used by pMem to
** desiredEnc. It is an error if the string is already of the desired
** encoding, or if *pMem does not contain a string value.
*/</comment>
<function><type><name>SQLITE_NOINLINE</name> <name>int</name></type> <name>sqlite3VdbeMemTranslate</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>desiredEnc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>                    <comment type="block">/* Maximum length of output string in bytes */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>                  <comment type="block">/* Output buffer */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>                   <comment type="block">/* Input iterator */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl>;</decl_stmt>                 <comment type="block">/* End of input */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                     <comment type="block">/* Output iterator */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name><operator>!=</operator><name>desiredEnc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TRANSLATE_TRACE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemPrettyPrint</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"INPUT:  %s\n"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the translation is between UTF-16 little and big endian, then 
  ** all that is required is to swap the byte order. This case is handled
  ** differently from the others.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name><operator>!=</operator><name>SQLITE_UTF8</name> <operator>&amp;&amp;</operator> <name>desiredEnc</name><operator>!=</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>temp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zIn</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>&amp;</operator><operator>~</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>zIn</name><operator>&lt;</operator><name>zTerm</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>*</operator><name>zIn</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>zIn</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zIn</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>zIn</name><operator>++</operator> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>desiredEnc</name></expr>;</expr_stmt>
    <goto>goto <name>translate_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set len to the maximum number of bytes required in the output buffer. */</comment>
  <if_stmt><if>if<condition>( <expr><name>desiredEnc</name><operator>==</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* When converting from UTF-16, the maximum growth results from
    ** translating a 2-byte character to a 4-byte UTF-8 character.
    ** A single byte is required for the output string
    ** nul-terminator.
    */</comment>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* When converting from UTF-8 to UTF-16 the maximum growth is caused
    ** when a 1-byte UTF-8 character is translated into a 2-byte UTF-16
    ** character. Two bytes are required in the output buffer for the
    ** nul-terminator.
    */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set zIn to point at the start of the input buffer and zTerm to point 1
  ** byte past the end.
  **
  ** Variable zOut is set to point at the output buffer, space obtained
  ** from sqlite3_malloc().
  */</comment>
  <expr_stmt><expr><name>zIn</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zOut</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name>zOut</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>desiredEnc</name><operator>==</operator><name>SQLITE_UTF16LE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* UTF-8 -&gt; UTF-16 Little-endian */</comment>
      <while>while<condition>( <expr><name>zIn</name><operator>&lt;</operator><name>zTerm</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>READ_UTF8</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WRITE_UTF16LE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredEnc</name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* UTF-8 -&gt; UTF-16 Big-endian */</comment>
      <while>while<condition>( <expr><name>zIn</name><operator>&lt;</operator><name>zTerm</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>READ_UTF8</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WRITE_UTF16BE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z</name> <operator>-</operator> <name>zOut</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>z</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredEnc</name><operator>==</operator><name>SQLITE_UTF8</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF16LE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* UTF-16 Little-endian -&gt; UTF-8 */</comment>
      <while>while<condition>( <expr><name>zIn</name><operator>&lt;</operator><name>zTerm</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>READ_UTF16LE</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zIn</name><operator>&lt;</operator><name>zTerm</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>WRITE_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* UTF-16 Big-endian -&gt; UTF-8 */</comment>
      <while>while<condition>( <expr><name>zIn</name><operator>&lt;</operator><name>zTerm</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>READ_UTF16BE</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zIn</name><operator>&lt;</operator><name>zTerm</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>WRITE_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z</name> <operator>-</operator> <name>zOut</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><operator>(</operator><ternary><condition><expr><name>desiredEnc</name><operator>==</operator><name>SQLITE_UTF8</name></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator><operator>)</operator><operator>&lt;=</operator><name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Str</name><operator>|</operator><name>MEM_Term</name><operator>|</operator><operator>(</operator><name>c</name><operator>&amp;</operator><operator>(</operator><name>MEM_AffMask</name><operator>|</operator><name>MEM_Subtype</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>desiredEnc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>translate_out</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TRANSLATE_TRACE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemPrettyPrint</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"OUTPUT: %s\n"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine checks for a byte-order mark at the beginning of the 
** UTF-16 string stored in *pMem. If one is present, it is removed and
** the encoding of the Mem adjusted. This routine does not do any
** byte-swapping, it just sets Mem.enc appropriately.
**
** The allocation (static, dynamic etc.) and encoding of the Mem may be
** changed by this function.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemHandleBom</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>bom</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>b1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>b2</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>b1</name><operator>==</operator><literal type="number">0xFE</literal> <operator>&amp;&amp;</operator> <name>b2</name><operator>==</operator><literal type="number">0xFF</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bom</name> <operator>=</operator> <name>SQLITE_UTF16BE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>b1</name><operator>==</operator><literal type="number">0xFF</literal> <operator>&amp;&amp;</operator> <name>b2</name><operator>==</operator><literal type="number">0xFE</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bom</name> <operator>=</operator> <name>SQLITE_UTF16LE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>bom</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Term</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>bom</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<comment type="block">/*
** pZ is a UTF-8 encoded unicode string. If nByte is less than zero,
** return the number of unicode characters in pZ up to (but not including)
** the first 0x00 byte. If nByte is not less than zero, return the
** number of unicode characters in the first nByte of pZ (or up to 
** the first 0x00, whichever comes first).
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Utf8CharLen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>zIn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zTerm</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>z</name><index>[<expr><name>nByte</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zTerm</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name><operator>&lt;=</operator><name>zTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>z</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>z</name><operator>&lt;</operator><name>zTerm</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This test function is not currently used by the automated test-suite. 
** Hence it is only available in debug builds.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Translate UTF-8 to UTF-8.
**
** This has the effect of making sure that the string is well-formed
** UTF-8.  Miscoded characters are removed.
**
** The translation is done in-place and aborted if the output
** overruns the input.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Utf8To8</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><name>zIn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zStart</name> <init>= <expr><name>zIn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>c</name></decl>;</decl_stmt>

  <while>while<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>zOut</name><operator>&lt;=</operator><name>zIn</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="number">0xfffd</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>WRITE_UTF8</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>zOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zOut</name> <operator>-</operator> <name>zStart</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Convert a UTF-16 string in the native encoding into a UTF-8 string.
** Memory to hold the UTF-8 string is obtained from sqlite3_malloc and must
** be freed by the calling function.
**
** NULL is returned if there is an allocation error.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3Utf16to8</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name></type> <name>m</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>m</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>m</name><operator>.</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>m</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Term</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>m</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>m</name><operator>.</operator><name>z</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>m</name><operator>.</operator><name>z</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** zIn is a UTF-16 encoded unicode string at least nChar characters long.
** Return the number of bytes in the first nChar unicode characters
** in pZ.  nChar must be non-negative.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Utf16ByteLen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nChar</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>z</name> <init>= <expr><name>zIn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>SQLITE_UTF16NATIVE</name><operator>==</operator><name>SQLITE_UTF16BE</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><name>n</name><operator>&lt;</operator><name>nChar</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>READ_UTF16BE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><name>n</name><operator>&lt;</operator><name>nChar</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>READ_UTF16LE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z</name><operator>-</operator><operator>(</operator><name>unsigned</name> <name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>zIn</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This routine is called from the TCL test function "translate_selftest".
** It checks that the primitives for serializing and deserializing
** characters in each encoding are inverses of each other.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3UtfSelfTest</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">0x00110000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z</name><operator>-</operator><name>zBuf</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;=</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">0xD800</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;=</operator><literal type="number">0xDFFF</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="number">0xFFFD</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">0xFFFFFFFE</literal><operator>)</operator><operator>==</operator><literal type="number">0xFFFE</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="number">0xFFFD</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><name>t</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>z</name><operator>-</operator><name>zBuf</name><operator>)</operator><operator>==</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">0x00110000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">0xD800</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">0xE000</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_UTF16LE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z</name><operator>-</operator><name>zBuf</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;=</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UTF16LE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>z</name><operator>-</operator><name>zBuf</name><operator>)</operator><operator>==</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">0x00110000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">0xD800</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">0xE000</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_UTF16BE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z</name><operator>-</operator><name>zBuf</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;=</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UTF16BE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>z</name><operator>-</operator><name>zBuf</name><operator>)</operator><operator>==</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_TEST */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>
</unit>
