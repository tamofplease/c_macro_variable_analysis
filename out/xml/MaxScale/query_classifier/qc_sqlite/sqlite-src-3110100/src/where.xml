<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/where.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This module contains C code that generates VDBE code used to process
** the WHERE clause of SQL statements.  This module is responsible for
** generating the code that loops through a table looking for applicable
** rows.  Indices are selected and used to speed the search when doing
** so is applicable.  Because this module is responsible for selecting
** indices, you might also think of this module as the "query optimizer".
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"whereInt.h"</cpp:file></cpp:include>

<comment type="block">/* Forward declaration of methods */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopResize</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>WhereLoop</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Test variable that can be set to enable WHERE tracing */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/***/</comment> <decl_stmt><decl><type><name>int</name></type> <name>sqlite3WhereTrace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Return the estimated number of output rows from a WHERE clause
*/</comment>
<function><type><name>u64</name></type> <name>sqlite3WhereOutputRowCount</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3LogEstToInt</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return one of the WHERE_DISTINCT_xxxxx values to indicate how this
** WHERE clause returns outputs for DISTINCT processing.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereIsDistinct</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the WHERE clause returns rows in ORDER BY order.
** Return FALSE if the output needs to be sorted.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereIsOrdered</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the VDBE address or label to jump to in order to continue
** immediately with the next row of a WHERE clause.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereContinueLabel</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iContinue</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iContinue</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the VDBE address or label to jump to in order to break
** out of a WHERE loop.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereBreakLabel</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iBreak</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return ONEPASS_OFF (0) if an UPDATE or DELETE statement is unable to
** operate directly on the rowis returned by a WHERE clause.  Return
** ONEPASS_SINGLE (1) if the statement can operation directly because only
** a single row is to be changed.  Return ONEPASS_MULTI (2) if the one-pass
** optimization can be used on multiple 
**
** If the ONEPASS optimization is used (if this routine returns true)
** then also write the indices of open cursors used by ONEPASS
** into aiCur[0] and aiCur[1].  iaCur[0] gets the cursor of the data
** table and iaCur[1] gets the cursor used by an auxiliary index.
** Either value may be -1, indicating that cursor is not used.
** Any cursors returned will have been opened for writing.
**
** aiCur[0] and aiCur[1] both get -1 if the where-clause logic is
** unable to use the ONEPASS optimization.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereOkOnePass</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aiCur</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;&amp;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"%s cursors: %d %d\n"</literal></expr></argument>,
         <argument><expr><ternary><condition><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_SINGLE</name></expr> ?</condition><then> <expr><literal type="string">"ONEPASS_SINGLE"</literal></expr> </then><else>: <expr><literal type="string">"ONEPASS_MULTI"</literal></expr></else></ternary></expr></argument>,
         <argument><expr><name><name>aiCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>aiCur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Move the content of pSrc into pDest
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereOrMove</name><parameter_list>(<parameter><decl><type><name>WhereOrSet</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>, <parameter><decl><type><name>WhereOrSet</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>n</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Try to insert a new prerequisite/cost entry into the WhereOrSet pSet.
**
** The new entry might overwrite an existing entry, or it might be
** appended, or it might be discarded.  Do whatever is the right thing
** so that pSet keeps the N_OR_COST best entries seen so far.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereOrInsert</name><parameter_list>(
  <parameter><decl><type><name>WhereOrSet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>,      <comment type="block">/* The WhereOrSet to be updated */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>prereq</name></decl></parameter>,        <comment type="block">/* Prerequisites of the new entry */</comment>
  <parameter><decl><type><name>LogEst</name></type> <name>rRun</name></decl></parameter>,           <comment type="block">/* Run-cost of the new entry */</comment>
  <parameter><decl><type><name>LogEst</name></type> <name>nOut</name></decl></parameter>            <comment type="block">/* Number of outputs for the new entry */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereOrCost</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pSet</name><operator>-&gt;</operator><name>n</name></name></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pSet</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rRun</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>prereq</name> <operator>&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>prereq</name></name><operator>)</operator><operator>==</operator><name>prereq</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>whereOrInsert_done</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>&lt;=</operator><name>rRun</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name>prereq</name><operator>)</operator><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>n</name></name><operator>&lt;</operator><name>N_OR_COST</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pSet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pSet</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pSet</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSet</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>&gt;</operator><name><name>pSet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rRun</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pSet</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>&lt;=</operator><name>rRun</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
<label><name>whereOrInsert_done</name>:</label>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name>prereq</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name>rRun</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;</operator><name>nOut</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the bitmask for the given cursor number.  Return 0 if
** iCursor is not in the set.
*/</comment>
<function><type><name>Bitmask</name></type> <name>sqlite3WhereGetMask</name><parameter_list>(<parameter><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>n</name></name><operator>&lt;=</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Bitmask</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pMaskSet</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>ix</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>iCursor</name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new mask for cursor iCursor.
**
** There is one cursor per table in the FROM clause.  The number of
** tables in the FROM clause is limited by a test early in the
** sqlite3WhereBegin() routine.  So we know that the pMaskSet-&gt;ix[]
** array will never overflow.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>createMask</name><parameter_list>(<parameter><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>n</name></name> <operator>&lt;</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>ix</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>ix</name><index>[<expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>iCursor</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Advance to the next WhereTerm that matches according to the criteria
** established when the pScan object was initialized by whereScanInit().
** Return NULL if there are no more matching WhereTerms.
*/</comment>
<function><type><specifier>static</specifier> <name>WhereTerm</name> <modifier>*</modifier></type><name>whereScanNext</name><parameter_list>(<parameter><decl><type><name>WhereScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>            <comment type="block">/* The cursor on the LHS of the term */</comment>
  <decl_stmt><decl><type><name>i16</name></type> <name>iColumn</name></decl>;</decl_stmt>         <comment type="block">/* The column on the LHS of the term.  -1 for IPK */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>            <comment type="block">/* An expression being tested */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>    <comment type="block">/* Shorthand for pScan-&gt;pWC */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>    <comment type="block">/* The term being tested */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name><name>pScan</name><operator>-&gt;</operator><name>k</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Where to start scanning */</comment>

  <while>while<condition>( <expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>&lt;=</operator><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>==</operator><name>XN_EXPR</name> <operator>&amp;&amp;</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pIdxExpr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>pWC</name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pWC</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name>k</name></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>==</operator><name>iCur</name>
         <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leftColumn</name></name><operator>==</operator><name>iColumn</name>
         <operator>&amp;&amp;</operator> <operator>(</operator><name>iColumn</name><operator>!=</operator><name>XN_EXPR</name>
             <operator>||</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>,<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pIdxExpr</name></name></expr></argument>,<argument><expr><name>iCur</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>&lt;=</operator><literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQUIV</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name></name></expr></argument>)</argument_list></call>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>pX</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>op</name><operator>==</operator><name>TK_COLUMN</name></expr>
          )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>pX</name><operator>-&gt;</operator><name>iTable</name></name>
               <operator>&amp;&amp;</operator> <name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>pX</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block>{<block_content>
                  <break>break;</break>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name><name>pScan</name><operator>-&gt;</operator><name>opMask</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <comment type="block">/* Verify the affinity and collating sequence match */</comment>
            <if_stmt><if>if<condition>( <expr><name><name>pScan</name><operator>-&gt;</operator><name>zCollName</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ISNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3IndexAffinityOk</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>idxaff</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
                <continue>continue;</continue>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                                                  <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>pColl</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>zCollName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
                <continue>continue;</continue>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
             <operator>&amp;&amp;</operator> <operator>(</operator><name>pX</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name><operator>)</operator><operator>-&gt;</operator><name>op</name><operator>==</operator><name>TK_COLUMN</name>
             <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
             <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>
            )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>k</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>pTerm</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pWC</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>pOuter</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pWC</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pOrigWC</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a WHERE clause scanner object.  Return a pointer to the
** first match.  Return NULL if there are no matches.
**
** The scanner will be searching the WHERE clause pWC.  It will look
** for terms of the form "X &lt;op&gt; &lt;expr&gt;" where X is column iColumn of table
** iCur.  The &lt;op&gt; must be one of the operators described by opMask.
**
** If the search is for X and the WHERE clause contains terms of the
** form X=Y then this routine might also return terms of the form
** "Y &lt;op&gt; &lt;expr&gt;".  The number of levels of transitivity is limited,
** but is enough to handle most commonly occurring SQL statements.
**
** If X is not the INTEGER PRIMARY KEY then X must be compatible with
** index pIdx.
*/</comment>
<function><type><specifier>static</specifier> <name>WhereTerm</name> <modifier>*</modifier></type><name>whereScanInit</name><parameter_list>(
  <parameter><decl><type><name>WhereScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>,       <comment type="block">/* The WhereScan object being initialized */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,       <comment type="block">/* The WHERE clause to be scanned */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,               <comment type="block">/* Cursor to scan for */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,            <comment type="block">/* Column to scan for */</comment>
  <parameter><decl><type><name>u32</name></type> <name>opMask</name></decl></parameter>,             <comment type="block">/* Operator(s) to scan for */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>             <comment type="block">/* Must be compatible with this index */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* memset(pScan, 0, sizeof(*pScan)); */</comment>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pOrigWC</name></name> <operator>=</operator> <name>pWC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pWC</name></name> <operator>=</operator> <name>pWC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pIdxExpr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIdx</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pIdxExpr</name></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIdx</name> <operator>&amp;&amp;</operator> <name>iColumn</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>idxaff</name></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iColumn</name></expr>]</index></name><operator>.</operator><name>affinity</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>zCollName</name></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>idxaff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>zCollName</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>opMask</name></name> <operator>=</operator> <name>opMask</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiCur</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>nEquiv</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>iEquiv</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><call><name>whereScanNext</name><argument_list>(<argument><expr><name>pScan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search for a term in the WHERE clause that is of the form "X &lt;op&gt; &lt;expr&gt;"
** where X is a reference to the iColumn of table iCur and &lt;op&gt; is one of
** the WO_xx operator codes specified by the op parameter.
** Return a pointer to the term.  Return 0 if not found.
**
** If pIdx!=0 then search for terms matching the iColumn-th column of pIdx
** rather than the iColumn-th column of table iCur.
**
** The term returned might by Y=&lt;expr&gt; if there is another constraint in
** the WHERE clause that specifies that X=Y.  Any such constraints will be
** identified by the WO_EQUIV bit in the pTerm-&gt;eOperator field.  The
** aiCur[]/iaColumn[] arrays hold X and all its equivalents. There are 11
** slots in aiCur[]/aiColumn[] so that means we can look for X plus up to 10
** other equivalent values.  Hence a search for X will return &lt;expr&gt; if X=A1
** and A1=A2 and A2=A3 and ... and A9=A10 and A10=&lt;expr&gt;.
**
** If there are multiple terms in the WHERE clause of the form "X &lt;op&gt; &lt;expr&gt;"
** then try for the one with no dependencies on &lt;expr&gt; - in other words where
** &lt;expr&gt; is a constant expression of some kind.  Only return entries of
** the form "X &lt;op&gt; Y" where Y is a column in another table if no terms of
** the form "X &lt;op&gt; &lt;const-expr&gt;" exist.   If no terms with a constant RHS
** exist, try to return a term that does not use WO_EQUIV.
*/</comment>
<function><type><name>WhereTerm</name> <modifier>*</modifier></type><name>sqlite3WhereFindTerm</name><parameter_list>(
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,     <comment type="block">/* The WHERE clause to be searched */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,             <comment type="block">/* Cursor number of LHS */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,          <comment type="block">/* Column number of LHS */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></parameter>,     <comment type="block">/* RHS must not overlap with this mask */</comment>
  <parameter><decl><type><name>u32</name></type> <name>op</name></decl></parameter>,               <comment type="block">/* Mask of WO_xx values describing operator */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>           <comment type="block">/* Must be compatible with this index, if not NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pResult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereScan</name></type> <name>scan</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>whereScanInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>&amp;=</operator> <name>WO_EQ</name><operator>|</operator><name>WO_IS</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name>notReady</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>prereqRight</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>eOperator</name></name><operator>&amp;</operator><name>op</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>p</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pResult</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pResult</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>whereScanNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>pResult</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function searches pList for an entry that matches the iCol-th column
** of index pIdx.
**
** If such an expression is found, its index in pList-&gt;a[] is returned. If
** no expression is found, -1 is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>findIndexCol</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,                <comment type="block">/* Expression list to search */</comment>
  <parameter><decl><type><name>int</name></type> <name>iBase</name></decl></parameter>,                      <comment type="block">/* Cursor for table associated with pIdx */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,                    <comment type="block">/* Index to match column of */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>                        <comment type="block">/* Column of index to match */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iCol</name></expr>]</index></name>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iBase</name></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pColl</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><name>i</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the iCol-th column of index pIdx is NOT NULL
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>indexColumnNotNull</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>notNull</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>j</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Assume an indexed expression can always yield a NULL */</comment>

  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the DISTINCT expression-list passed as the third argument
** is redundant.
**
** A DISTINCT list is redundant if any subset of the columns in the
** DISTINCT list are collectively unique and individually non-null.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isDistinctRedundant</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,            <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,        <comment type="block">/* The FROM clause */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,         <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pDistinct</name></decl></parameter>       <comment type="block">/* The result set that needs to be DISTINCT */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          
  <decl_stmt><decl><type><name>int</name></type> <name>iBase</name></decl>;</decl_stmt>

  <comment type="block">/* If there is more than one table or sub-select in the FROM clause of
  ** this query, then it will not be possible to show that the DISTINCT 
  ** clause is redundant. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iBase</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>

  <comment type="block">/* If any of the expressions is an IPK column on table iBase, then return 
  ** true. Note: The (p-&gt;iTable==iBase) part of this test may be false if the
  ** current SELECT is a correlated sub-query.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pDistinct</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pDistinct</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iBase</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Loop through all indices on the table, checking each to see if it makes
  ** the DISTINCT qualifier redundant. It does so if:
  **
  **   1. The index is itself UNIQUE, and
  **
  **   2. All of the columns in the index are either part of the pDistinct
  **      list, or else the WHERE clause contains a term of the form "col=X",
  **      where X is a constant value. The collation sequences of the
  **      comparison and select-list expressions must match those of the index.
  **
  **   3. All of those index columns for which the WHERE clause does not
  **      contain a "col=X" term are subject to a NOT NULL constraint.
  */</comment>
  <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3WhereFindTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iBase</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>~</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>WO_EQ</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>findIndexCol</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDistinct</name></expr></argument>, <argument><expr><name>iBase</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>indexColumnNotNull</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This index implies that the DISTINCT qualifier is redundant. */</comment>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Estimate the logarithm of the input value to base 2.
*/</comment>
<function><type><specifier>static</specifier> <name>LogEst</name></type> <name>estLog</name><parameter_list>(<parameter><decl><type><name>LogEst</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>N</name><operator>&lt;=</operator><literal type="number">10</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">33</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert OP_Column opcodes to OP_Copy in previously generated code.
**
** This routine runs over generated VDBE code and translates OP_Column
** opcodes into OP_Copy when the table is being accessed via co-routine 
** instead of via table lookup.
**
** If the bIncrRowid parameter is 0, then any OP_Rowid instructions on
** cursor iTabCur are transformed into OP_Null. Or, if bIncrRowid is non-zero,
** then each OP_Rowid is transformed into an instruction to increment the
** value stored in its output register.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>translateColumnToCopy</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,            <comment type="block">/* The VDBE containing code to translate */</comment>
  <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>,         <comment type="block">/* Translate from this opcode to the end */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTabCur</name></decl></parameter>,        <comment type="block">/* OP_Column/OP_Rowid references to this table */</comment>
  <parameter><decl><type><name>int</name></type> <name>iRegister</name></decl></parameter>,      <comment type="block">/* The first column is in this register */</comment>
  <parameter><decl><type><name>int</name></type> <name>bIncrRowid</name></decl></parameter>      <comment type="block">/* If non-zero, transform OP_rowid to OP_AddImm(1) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>iStart</name><operator>&lt;</operator><name>iEnd</name></expr>;</condition> <incr><expr><name>iStart</name><operator>++</operator></expr><operator>,</operator> <expr><name>pOp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>!=</operator><name>iTabCur</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Column</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_Copy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>+</operator> <name>iRegister</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Rowid</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>bIncrRowid</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Increment the value stored in the P2 operand of the OP_Rowid. */</comment>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_AddImm</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_Null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Two routines for printing the content of an sqlite3_index_info
** structure.  Used for testing and debugging only.  If neither
** SQLITE_TEST or SQLITE_DEBUG are defined, then these routines
** are no-ops.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WHERETRACE_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TRACE_IDX_INPUTS</name><parameter_list>(<parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>sqlite3WhereTrace</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  constraint[%d]: col=%d termid=%d op=%d usabled=%d\n"</literal></expr></argument>,
       <argument><expr><name>i</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iTermOffset</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>op</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>usable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOrderBy</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  orderby[%d]: col=%d desc=%d\n"</literal></expr></argument>,
       <argument><expr><name>i</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TRACE_IDX_OUTPUTS</name><parameter_list>(<parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>sqlite3WhereTrace</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  usage[%d]: argvIdx=%d omit=%d\n"</literal></expr></argument>,
       <argument><expr><name>i</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name></expr></argument>,
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  idxNum=%d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>idxNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  idxStr=%s\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  orderByConsumed=%d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>orderByConsumed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  estimatedCost=%g\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>estimatedCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  estimatedRows=%lld\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>estimatedRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE_IDX_INPUTS</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE_IDX_OUTPUTS</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOMATIC_INDEX</name></cpp:ifndef>
<comment type="block">/*
** Return TRUE if the WHERE clause term pTerm is of a form where it
** could be used with an index to access pSrc, assuming an appropriate
** index existed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>termCanDriveIndex</name><parameter_list>(
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>,              <comment type="block">/* WHERE clause term to check */</comment>
  <parameter><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,     <comment type="block">/* Table we are trying to access */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></parameter>               <comment type="block">/* Tables in outer loops of the join */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>aff</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name>notReady</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leftColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>aff</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leftColumn</name></name></expr>]</index></name><operator>.</operator><name>affinity</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3IndexAffinityOk</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOMATIC_INDEX</name></cpp:ifndef>
<comment type="block">/*
** Generate code to construct the Index object for an automatic index
** and to set up the WhereLevel object pLevel so that the code generator
** makes use of the automatic index.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>constructAutomaticIndex</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,              <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,           <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,  <comment type="block">/* The FROM clause term to get the next index */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></parameter>,           <comment type="block">/* Mask of cursors that are not available */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>          <comment type="block">/* Write new index here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nKeyCol</name></decl>;</decl_stmt>                <comment type="block">/* Number of columns in the constructed index */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>           <comment type="block">/* A single term of the WHERE clause */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pWCEnd</name></decl>;</decl_stmt>          <comment type="block">/* End of pWC-&gt;a[] */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>                <comment type="block">/* Object describing the transient index */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>                    <comment type="block">/* Prepared statement under construction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrInit</name></decl>;</decl_stmt>               <comment type="block">/* Address of the initialization bypass jump */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTable</name></decl>;</decl_stmt>              <comment type="block">/* The table being indexed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrTop</name></decl>;</decl_stmt>                <comment type="block">/* Top of the index fill loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRecord</name></decl>;</decl_stmt>              <comment type="block">/* Register holding an index record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                      <comment type="block">/* Column counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxBitCol</name></decl>;</decl_stmt>               <comment type="block">/* Maximum column in pSrc-&gt;colUsed */</comment>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>             <comment type="block">/* Collating sequence to on a column */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>           <comment type="block">/* The Loop object */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNotUsed</name></decl>;</decl_stmt>             <comment type="block">/* Extra space on the end of pIdx */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>idxCols</name></decl>;</decl_stmt>            <comment type="block">/* Bitmap of columns used for indexing */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>extraCols</name></decl>;</decl_stmt>          <comment type="block">/* Bitmap of additional columns */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>sentWarning</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* True if a warnning has been issued */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pPartial</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Partial Index Expression */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iContinue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Jump here to skip excluded rows */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pTabItem</name></decl>;</decl_stmt>  <comment type="block">/* FROM clause term being indexed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Address where integer counter is initialized */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>                <comment type="block">/* Array of registers where record is assembled */</comment>

  <comment type="block">/* Generate code to skip over the creation and initialization of the
  ** transient index on 2nd and subsequent iterations of the loop. */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrInit</name> <operator>=</operator> <call><name>sqlite3CodeOnce</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Count the number of columns that will be added to the index
  ** and used to match WHERE clause constraints */</comment>
  <expr_stmt><expr><name>nKeyCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWCEnd</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>idxCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pTerm</name><operator>&lt;</operator><name>pWCEnd</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call>    <comment type="block">/* prereq always non-zero */</comment>
         <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iRightJoinTable</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name>   <comment type="block">/*   for the right-hand   */</comment>
         <operator>||</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>prereq</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>                     <comment type="block">/*   table of a LEFT JOIN */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>prereq</name></name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsTableConstant</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pPartial</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pPartial</name></expr></argument>,
                                <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>termCanDriveIndex</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leftColumn</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>cMask</name> <init>= <expr><ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><name>BMS</name></expr> ?</condition><then> <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>sentWarning</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_WARNING_AUTOINDEX</name></expr></argument>,
            <argument><expr><literal type="string">"automatic index on %s(%s)"</literal></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
            <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sentWarning</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxCols</name> <operator>&amp;</operator> <name>cMask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>whereLoopResize</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pLoop</name></expr></argument>, <argument><expr><name>nKeyCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <goto>goto <name>end_auto_index_create</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>nKeyCol</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idxCols</name> <operator>|=</operator> <name>cMask</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKeyCol</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <name>nKeyCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_COLUMN_EQ</name> <operator>|</operator> <name>WHERE_IDX_ONLY</name> <operator>|</operator> <name>WHERE_INDEXED</name>
                     <operator>|</operator> <name>WHERE_AUTO_INDEX</name></expr>;</expr_stmt>

  <comment type="block">/* Count the number of additional columns needed to create a
  ** covering index.  A "covering index" is an index that contains all
  ** columns that are needed by the query.  With a covering index, the
  ** original table never needs to be accessed.  Automatic indices must
  ** be a covering index because the index will not be updated if the
  ** original table changes and the index and table cannot both be used
  ** if they go out of sync.
  */</comment>
  <expr_stmt><expr><name>extraCols</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>idxCols</name> <operator>|</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxBitCol</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>mxBitCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>extraCols</name> <operator>&amp;</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nKeyCol</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nKeyCol</name> <operator>+=</operator> <name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name> <operator>-</operator> <name>BMS</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Construct the Index object to describe this index */</comment>
  <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <call><name>sqlite3AllocateIndexObject</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nKeyCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zNotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>end_auto_index_create</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <literal type="string">"auto-index"</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name> <operator>=</operator> <name>pTable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>idxCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pTerm</name><operator>&lt;</operator><name>pWCEnd</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>termCanDriveIndex</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leftColumn</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>cMask</name> <init>= <expr><ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><name>BMS</name></expr> ?</condition><then> <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxCols</name> <operator>&amp;</operator> <name>cMask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>idxCols</name> <operator>|=</operator> <name>cMask</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leftColumn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>pColl</name></expr> ?</condition><then> <expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr> </then><else>: <expr><name>sqlite3StrBINARY</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>n</name><operator>==</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add additional columns needed to make the automatic index into
  ** a covering index */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>mxBitCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>extraCols</name> <operator>&amp;</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTable</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><name>nKeyCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>XN_ROWID</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt>

  <comment type="block">/* Create the automatic index */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenAutoindex</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><name>nKeyCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"for %s"</literal><operator>,</operator> <name><name>pTable</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fill the automatic index with content */</comment>
  <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regYield</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>addrCounter</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InitCoroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrTop</name> <operator>=</operator>  <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"next row of \"%s\""</literal><operator>,</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>addrTop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPartial</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iContinue</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPartial</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_PARTIALIDX</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>regRecord</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regBase</name> <operator>=</operator> <call><name>sqlite3GenerateIndexKey</name><argument_list>(
      <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_USESEEKRESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPartial</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCounter</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>translateColumnToCopy</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>, <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>, <argument><expr><name>addrTop</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_AUTOINDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Jump here when skipping the initialization */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrInit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end_auto_index_create</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pPartial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTOMATIC_INDEX */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Allocate and populate an sqlite3_index_info structure. It is the 
** responsibility of the caller to eventually release the structure
** by passing the pointer returned by this function to sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_index_info</name> <modifier>*</modifier></type><name>allocateIndexInfo</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,
  <parameter><decl><type><name>Bitmask</name></type> <name>mUnusable</name></decl></parameter>,              <comment type="block">/* Ignore terms with these prereqs */</comment>
  <parameter><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pIdxCons</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_orderby</name></name> <modifier>*</modifier></type><name>pIdxOrderBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint_usage</name></name> <modifier>*</modifier></type><name>pUsage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOrderBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl>;</decl_stmt>

  <comment type="block">/* Count the number of possible WHERE clause constraints referring
  ** to this virtual table */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nTerm</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>!=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name>mUnusable</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsPowerOfTwo</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>~</operator><name>WO_EQUIV</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ALL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_EQUIV</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leftColumn</name></name><operator>&gt;=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nTerm</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If the ORDER BY clause contains only columns in the current 
  ** virtual table then allocate space for the aOrderBy part of
  ** the sqlite3_index_info structure.
  */</comment>
  <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>n</name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate the sqlite3_index_info structure
  */</comment>
  <expr_stmt><expr><name>pIdxInfo</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pIdxInfo</name></expr></argument>)</argument_list></sizeof>
                           <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pIdxCons</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pUsage</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>*</operator><name>nTerm</name>
                           <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pIdxOrderBy</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nOrderBy</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIdxInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Initialize the structure.  The sqlite3_index_info structure contains
  ** many fields that are declared "const" to prevent xBestIndex from
  ** changing them.  We have to do some funky casting in order to
  ** initialize those fields.
  */</comment>
  <expr_stmt><expr><name>pIdxCons</name> <operator>=</operator> <operator>(</operator>struct <name>sqlite3_index_constraint</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxOrderBy</name> <operator>=</operator> <operator>(</operator>struct <name>sqlite3_index_orderby</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxCons</name><index>[<expr><name>nTerm</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pUsage</name> <operator>=</operator> <operator>(</operator>struct <name>sqlite3_index_constraint_usage</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxOrderBy</name><index>[<expr><name>nOrderBy</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name> <operator>=</operator> <name>nOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator>struct <name>sqlite3_index_constraint</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name> <operator>=</operator> <name>pIdxCons</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator>struct <name>sqlite3_index_orderby</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name></name> <operator>=</operator> <name>pIdxOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator>struct <name>sqlite3_index_constraint_usage</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name></name> <operator>=</operator>
                                                                   <name>pUsage</name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>op</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>!=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name>mUnusable</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsPowerOfTwo</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>~</operator><name>WO_EQUIV</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ALL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_EQUIV</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leftColumn</name></name><operator>&gt;=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iColumn</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leftColumn</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iTermOffset</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ALL</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WO_IN</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>WO_EQ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>WO_MATCH</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>eMatchOp</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
    <comment type="block">/* The direct assignment in the previous line is possible only because
    ** the WO_ and SQLITE_INDEX_CONSTRAINT_ codes are identical.  The
    ** following asserts verify this fact. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_EQ</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_LT</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_LE</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_GT</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_GE</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_MATCH</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_IN</name><operator>|</operator><name>WO_EQ</name><operator>|</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>|</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>|</operator><name>WO_MATCH</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pIdxOrderBy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxOrderBy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sortOrder</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>pIdxInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The table object reference passed as the second argument to this function
** must represent a virtual table. This function invokes the xBestIndex()
** method of the virtual table with the sqlite3_index_info object that
** comes in as the 3rd argument to this function.
**
** If an error occurs, pParse is populated with an error message and a
** non-zero value is returned. Otherwise, 0 is returned and the output
** part of the sqlite3_index_info structure is left populated.
**
** Whether or not an error is returned, it is the responsibility of the
** caller to eventually free p-&gt;idxStr if p-&gt;needToFreeIdxStr indicates
** that this is required.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vtabBestIndex</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name> <init>= <expr><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE_IDX_INPUTS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xBestIndex</name></name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE_IDX_OUTPUTS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>usable</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
          <argument><expr><literal type="string">"table %s: xBestIndex returned an invalid plan"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_VIRTUALTABLE) */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
<comment type="block">/*
** Estimate the location of a particular key among all keys in an
** index.  Store the results in aStat as follows:
**
**    aStat[0]      Est. number of rows less than pRec
**    aStat[1]      Est. number of rows equal to pRec
**
** Return the index of the sample that is the smallest sample that
** is greater than or equal to pRec. Note that this index is not an index
** into the aSample[] array - it is an index into a virtual set of samples
** based on the contents of aSample[] and the number of fields in record 
** pRec. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereKeyStats</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,              <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,                <comment type="block">/* Index to consider domain of */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pRec</name></decl></parameter>,       <comment type="block">/* Vector of values to consider */</comment>
  <parameter><decl><type><name>int</name></type> <name>roundUp</name></decl></parameter>,                <comment type="block">/* Round up if true.  Round down if false */</comment>
  <parameter><decl><type><name>tRowcnt</name> <modifier>*</modifier></type><name>aStat</name></decl></parameter>              <comment type="block">/* OUT: stats written here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IndexSample</name> <modifier>*</modifier></type><name>aSample</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aSample</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                   <comment type="block">/* Index of required stats in anEq[] etc. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Index of first sample &gt;= pRec */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSample</name></decl>;</decl_stmt>                <comment type="block">/* Smallest sample larger than or equal to pRec */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Smallest sample not yet tested */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTest</name></decl>;</decl_stmt>                  <comment type="block">/* Next sample to test */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>                    <comment type="block">/* Result of comparison operation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>                 <comment type="block">/* Number of fields in pRec */</comment>
  <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iLower</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* anLt[] + anEq[] of largest sample pRec is &gt; */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifndef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>( <argument><expr><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRec</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name><operator>&lt;=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nSampleCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Do a binary search to find the first sample greater than or equal
  ** to pRec. If pRec contains a single field, the set of samples to search
  ** is simply the aSample[] array. If the samples in aSample[] contain more
  ** than one fields, all fields following the first are ignored.
  **
  ** If pRec contains N fields, where N is more than one, then as well as the
  ** samples in aSample[] (truncated to N fields), the search also has to
  ** consider prefixes of those samples. For example, if the set of samples
  ** in aSample is:
  **
  **     aSample[0] = (a, 5) 
  **     aSample[1] = (a, 10) 
  **     aSample[2] = (b, 5) 
  **     aSample[3] = (c, 100) 
  **     aSample[4] = (c, 105)
  **
  ** Then the search space should ideally be the samples above and the 
  ** unique prefixes [a], [b] and [c]. But since that is hard to organize, 
  ** the code actually searches this set:
  **
  **     0: (a) 
  **     1: (a, 5) 
  **     2: (a, 10) 
  **     3: (a, 10) 
  **     4: (b) 
  **     5: (b, 5) 
  **     6: (c) 
  **     7: (c, 100) 
  **     8: (c, 105)
  **     9: (c, 105)
  **
  ** For each sample in the aSample[] array, N samples are present in the
  ** effective sample array. In the above, samples 0 and 1 are based on 
  ** sample aSample[0]. Samples 2 and 3 on aSample[1] etc.
  **
  ** Often, sample i of each block of N effective samples has (i+1) fields.
  ** Except, each sample may be extended to ensure that it is greater than or
  ** equal to the previous sample in the array. For example, in the above, 
  ** sample 2 is the first sample of a block of N samples, so at first it 
  ** appears that it should be 1 field in size. However, that would make it 
  ** smaller than sample 1, so the binary search would not work. As a result, 
  ** it is extended to two fields. The duplicates that this creates do not 
  ** cause any problems.
  */</comment>
  <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>iSample</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name> <operator>*</operator> <name>nField</name></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iSamp</name></decl>;</decl_stmt>                    <comment type="block">/* Index in aSample[] of test sample */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                        <comment type="block">/* Number of fields in test sample */</comment>

    <expr_stmt><expr><name>iTest</name> <operator>=</operator> <operator>(</operator><name>iMin</name><operator>+</operator><name>iSample</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iSamp</name> <operator>=</operator> <name>iTest</name> <operator>/</operator> <name>nField</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iSamp</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The proposed effective sample is a prefix of sample aSample[iSamp].
      ** Specifically, the shortest prefix of at least (1 + iTest%nField) 
      ** fields that is greater than the previous effective sample.  */</comment>
      <for>for<control>(<init><expr><name>n</name><operator>=</operator><operator>(</operator><name>iTest</name> <operator>%</operator> <name>nField</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>nField</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aSample</name><index>[<expr><name>iSamp</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <name>iTest</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iLower</name> <operator>=</operator> <name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name><name>anEq</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMin</name> <operator>=</operator> <name>iTest</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>nField</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iLower</name> <operator>=</operator> <name><name>aSample</name><index>[<expr><name>iSamp</name></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMin</name> <operator>=</operator> <name>iTest</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iSample</name> <operator>=</operator> <name>iTest</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>while<condition>( <expr><name>res</name> <operator>&amp;&amp;</operator> <name>iMin</name><operator>&lt;</operator><name>iSample</name></expr> )</condition>;</do>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name>iSample</name> <operator>/</operator> <name>nField</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* The following assert statements check that the binary search code
  ** above found the right answer. This block serves no purpose other
  ** than to invoke the asserts.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* If (res==0) is true, then pRec must be equal to sample i. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>nField</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>nField</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call> 
           <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> 
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Unless i==pIdx-&gt;nSample, indicating that pRec is larger than
      ** all samples in the aSample[] array, pRec must be smaller than the
      ** (iCol+1) field prefix of sample i.  */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>iCol</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name> 
           <operator>||</operator> <call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal>
           <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* if i==0 and iCol==0, then record pRec is smaller than all samples
      ** in the aSample[] array. Otherwise, if (iCol&gt;0) then pRec must
      ** be greater than or equal to the (iCol) field prefix of sample i.
      ** If (i&gt;0), then pRec must also be greater than sample (i-1).  */</comment>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">0</literal>
             <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>nField</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>aSample</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>aSample</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal>
             <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifdef SQLITE_DEBUG */</comment>

  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Record pRec is equal to sample i */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>nField</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aStat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aStat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>anEq</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* At this point, the (iCol+1) field prefix of aSample[i] is the first 
    ** sample that is greater than pRec. Or, if i==pIdx-&gt;nSample then pRec
    ** is larger than all samples in the array. */</comment>
    <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iUpper</name></decl>, <decl><type ref="prev"/><name>iGap</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nSample</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iUpper</name> <operator>=</operator> <call><name>sqlite3LogEstToInt</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iUpper</name> <operator>=</operator> <name><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>anLt</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iLower</name><operator>&gt;=</operator><name>iUpper</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iGap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iGap</name> <operator>=</operator> <name>iUpper</name> <operator>-</operator> <name>iLower</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>roundUp</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iGap</name> <operator>=</operator> <operator>(</operator><name>iGap</name><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>/</operator><literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iGap</name> <operator>=</operator> <name>iGap</name><operator>/</operator><literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>aStat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iLower</name> <operator>+</operator> <name>iGap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aStat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aAvgEq</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Restore the pRec-&gt;nField value before returning.  */</comment>
  <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>nField</name></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_STAT3_OR_STAT4 */</comment>

<comment type="block">/*
** If it is not NULL, pTerm is a term that provides an upper or lower
** bound on a range scan. Without considering pTerm, it is estimated 
** that the scan will visit nNew rows. This function returns the number
** estimated to be visited after taking pTerm into account.
**
** If the user explicitly specified a likelihood() value for this term,
** then the return value is the likelihood multiplied by the number of
** input rows. Otherwise, this function assumes that an "IS NOT NULL" term
** has a likelihood of 0.50, and any other term a likelihood of 0.25.
*/</comment>
<function><type><specifier>static</specifier> <name>LogEst</name></type> <name>whereRangeAdjust</name><parameter_list>(<parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>LogEst</name></type> <name>nNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>nRet</name> <init>= <expr><name>nNew</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTerm</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nRet</name> <operator>+=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nRet</name> <operator>-=</operator> <literal type="number">20</literal></expr>;</expr_stmt>        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">20</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>nRet</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
<comment type="block">/*
** Return the affinity for a single column of an index.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name></type> <name>sqlite3IndexColumnAffinity</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3IndexAffinityStr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_AFF_BLOB</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
<comment type="block">/* 
** This function is called to estimate the number of rows visited by a
** range-scan on a skip-scan index. For example:
**
**   CREATE INDEX i1 ON t1(a, b, c);
**   SELECT * FROM t1 WHERE a=? AND c BETWEEN ? AND ?;
**
** Value pLoop-&gt;nOut is currently set to the estimated number of rows 
** visited for scanning (a=? AND b=?). This function reduces that estimate 
** by some factor to account for the (c BETWEEN ? AND ?) expression based
** on the stat4 data for the index. this scan will be peformed multiple 
** times (once for each (a,b) combination that matches a=?) is dealt with 
** by the caller.
**
** It does this by scanning through all stat4 samples, comparing values
** extracted from pLower and pUpper with the corresponding column in each
** sample. If L and U are the number of samples found to be less than or
** equal to the values extracted from pLower and pUpper respectively, and
** N is the total number of samples, the pLoop-&gt;nOut value is adjusted
** as follows:
**
**   nOut = nOut * ( min(U - L, 1) / N )
**
** If pLower is NULL, or a value cannot be extracted from the term, L is
** set to zero. If pUpper is NULL, or a value cannot be extracted from it,
** U is set to N.
**
** Normally, this function sets *pbDone to 1 before returning. However,
** if no value can be extracted from either pLower or pUpper (and so the
** estimate of the number of rows delivered remains unchanged), *pbDone
** is left as is.
**
** If an error occurs, an SQLite error code is returned. Otherwise, 
** SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereRangeSkipScanEst</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing &amp; code generating context */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pLower</name></decl></parameter>,   <comment type="block">/* Lower bound on the range. ex: "x&gt;123" Might be NULL */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pUpper</name></decl></parameter>,   <comment type="block">/* Upper bound on the range. ex: "x&lt;455" Might be NULL */</comment>
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl></parameter>,    <comment type="block">/* Update the .nOut value of this loop */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbDone</name></decl></parameter>          <comment type="block">/* Set to true if at least one expr. value extracted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nLower</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nUpper</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>aff</name> <init>= <expr><call><name>sqlite3IndexColumnAffinity</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Value extracted from pLower */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Value extracted from pUpper */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Value extracted from record */</comment>

  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>nEq</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pLower</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4ValueFromExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pLower</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nLower</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pUpper</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4ValueFromExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pUpper</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nUpper</name> <operator>=</operator> <ternary><condition><expr><name>p2</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>p1</name> <operator>||</operator> <name>p2</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDiff</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4Column</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aSample</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>p1</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nLower</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>p2</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nUpper</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>nDiff</name> <operator>=</operator> <operator>(</operator><name>nUpper</name> <operator>-</operator> <name>nLower</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nDiff</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nDiff</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If there is both an upper and lower bound specified, and the 
    ** comparisons indicate that they are close together, use the fallback
    ** method (assume that the scan visits 1/64 of the rows) for estimating
    ** the number of rows visited. Otherwise, estimate the number of rows
    ** using the method described in the header comment for this function. */</comment>
    <if_stmt><if>if<condition>( <expr><name>nDiff</name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <name>pUpper</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pLower</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nAdjust</name> <init>= <expr><operator>(</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>nDiff</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-=</operator> <name>nAdjust</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pbDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x10</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"range skip-scan regions: %u..%u  adjust=%d est=%d\n"</literal><operator>,</operator>
                           <name>nLower</name><operator>,</operator> <name>nUpper</name><operator>,</operator> <name>nAdjust</name><operator>*</operator><operator>-</operator><literal type="number">1</literal><operator>,</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pbDone</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_STAT3_OR_STAT4 */</comment>

<comment type="block">/*
** This function is used to estimate the number of rows that will be visited
** by scanning an index for a range of values. The range may have an upper
** bound, a lower bound, or both. The WHERE clause terms that set the upper
** and lower bounds are represented by pLower and pUpper respectively. For
** example, assuming that index p is on t1(a):
**
**   ... FROM t1 WHERE a &gt; ? AND a &lt; ? ...
**                    |_____|   |_____|
**                       |         |
**                     pLower    pUpper
**
** If either of the upper or lower bound is not present, then NULL is passed in
** place of the corresponding WhereTerm.
**
** The value in (pBuilder-&gt;pNew-&gt;u.btree.nEq) is the number of the index
** column subject to the range constraint. Or, equivalently, the number of
** equality constraints optimized by the proposed index scan. For example,
** assuming index p is on t1(a, b), and the SQL query is:
**
**   ... FROM t1 WHERE a = ? AND b &gt; ? AND b &lt; ? ...
**
** then nEq is set to 1 (as the range restricted column, b, is the second 
** left-most column of the index). Or, if the query is:
**
**   ... FROM t1 WHERE a &gt; ? AND a &lt; ? ...
**
** then nEq is set to 0.
**
** When this function is called, *pnOut is set to the sqlite3LogEst() of the
** number of rows that the index scan is expected to visit without 
** considering the range constraints. If nEq is 0, then *pnOut is the number of 
** rows in the index. Assuming no error occurs, *pnOut is adjusted (reduced)
** to account for the range constraints pLower and pUpper.
** 
** In the absence of sqlite_stat4 ANALYZE data, or if such data cannot be
** used, a single range inequality reduces the search space by a factor of 4. 
** and a pair of constraints (x&gt;? AND x&lt;?) reduces the expected number of
** rows visited by a factor of 64.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereRangeScanEst</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing &amp; code generating context */</comment>
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pLower</name></decl></parameter>,   <comment type="block">/* Lower bound on the range. ex: "x&gt;123" Might be NULL */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pUpper</name></decl></parameter>,   <comment type="block">/* Upper bound on the range. ex: "x&lt;455" Might be NULL */</comment>
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl></parameter>     <comment type="block">/* Modify the .nOut and maybe .rRun fields */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOut</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>nNew</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nEq</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSampleCol</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nEq</name><operator>==</operator><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pRec</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>tRowcnt</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name></type> <name>aff</name></decl>;</decl_stmt>

      <comment type="block">/* Variable iLower will be set to the estimate of the number of rows in 
      ** the index that are less than the lower bound of the range query. The
      ** lower bound being the concatenation of $P and $L, where $P is the
      ** key-prefix formed by the nEq values matched against the nEq left-most
      ** columns of the index, and $L is the value in pLower.
      **
      ** Or, if pLower is NULL or $L cannot be extracted from it (because it
      ** is not a simple variable or literal value), the lower bound of the
      ** range is $P. Due to a quirk in the way whereKeyStats() works, even
      ** if $L is available, whereKeyStats() is called for both ($P) and 
      ** ($P:$L) and the larger of the two returned values is used.
      **
      ** Similarly, iUpper is to be set to the estimate of the number of rows
      ** less than the upper bound of the range query. Where the upper bound
      ** is either ($P) or ($P:$U). Again, even if $U is available, both values
      ** of iUpper are requested of whereKeyStats() and the smaller used.
      **
      ** The number of rows between the two bounds is then just iUpper-iLower.
      */</comment>
      <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iLower</name></decl>;</decl_stmt>     <comment type="block">/* Rows less than the lower bound */</comment>
      <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iUpper</name></decl>;</decl_stmt>     <comment type="block">/* Rows less than the upper bound */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iLwrIdx</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* aSample[] for the lower bound */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iUprIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* aSample[] for the upper bound */</comment>

      <if_stmt><if>if<condition>( <expr><name>pRec</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name><operator>!=</operator><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3IndexColumnAffinity</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nEq</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>nKeyCol</name></name> <operator>||</operator> <name>aff</name><operator>==</operator><name>SQLITE_AFF_INTEGER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Determine iLower and iUpper using ($P) only. */</comment>
      <if_stmt><if>if<condition>( <expr><name>nEq</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iLower</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>iUpper</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nRowEst0</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Note: this call could be optimized away - since the same values must 
        ** have been requested when testing key $P in whereEqualScanEst().  */</comment>
        <expr_stmt><expr><call><name>whereKeyStats</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iLower</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iUpper</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLower</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pLower</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pUpper</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pUpper</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aSortOrder</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>nEq</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The roles of pLower and pUpper are swapped for a DESC index */</comment>
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>WhereTerm</name><operator>*</operator></expr></argument>, <argument><expr><name>pLower</name></expr></argument>, <argument><expr><name>pUpper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If possible, improve on the iLower estimate using ($P:$L). */</comment>
      <if_stmt><if>if<condition>( <expr><name>pLower</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bOk</name></decl>;</decl_stmt>                    <comment type="block">/* True if value is extracted from pExpr */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pLower</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4ProbeSetValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRec</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bOk</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iNew</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>iLwrIdx</name> <operator>=</operator> <call><name>whereKeyStats</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iNew</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pLower</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_GT</name><operator>|</operator><name>WO_LE</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iNew</name><operator>&gt;</operator><name>iLower</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iLower</name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>nOut</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pLower</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If possible, improve on the iUpper estimate using ($P:$U). */</comment>
      <if_stmt><if>if<condition>( <expr><name>pUpper</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bOk</name></decl>;</decl_stmt>                    <comment type="block">/* True if value is extracted from pExpr */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pUpper</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4ProbeSetValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRec</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bOk</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>tRowcnt</name></type> <name>iNew</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>iUprIdx</name> <operator>=</operator> <call><name>whereKeyStats</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iNew</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pUpper</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_GT</name><operator>|</operator><name>WO_LE</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iNew</name><operator>&lt;</operator><name>iUpper</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iUpper</name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>nOut</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pUpper</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <name>pRec</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iUpper</name><operator>&gt;</operator><name>iLower</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nNew</name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>iUpper</name> <operator>-</operator> <name>iLower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* TUNING:  If both iUpper and iLower are derived from the same
          ** sample, then assume they are 4x more selective.  This brings
          ** the estimated selectivity more in line with what it would be
          ** if estimated without the use of STAT3/4 tables. */</comment>
          <if_stmt><if>if<condition>( <expr><name>iLwrIdx</name><operator>==</operator><name>iUprIdx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNew</name> <operator>-=</operator> <literal type="number">20</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">20</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>nNew</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">10</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&lt;</operator><name>nOut</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nOut</name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x10</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"STAT4 range scan: %u..%u  est=%d\n"</literal><operator>,</operator>
                           <operator>(</operator><name>u32</name><operator>)</operator><name>iLower</name><operator>,</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>iUpper</name><operator>,</operator> <name>nOut</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereRangeSkipScanEst</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLower</name></expr></argument>, <argument><expr><name>pUpper</name></expr></argument>, <argument><expr><name>pLoop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bDone</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLower</name> <operator>||</operator> <name>pUpper</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pUpper</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pUpper</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nNew</name> <operator>=</operator> <call><name>whereRangeAdjust</name><argument_list>(<argument><expr><name>pLower</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nNew</name> <operator>=</operator> <call><name>whereRangeAdjust</name><argument_list>(<argument><expr><name>pUpper</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* TUNING: If there is both an upper and lower limit and neither limit
  ** has an application-defined likelihood(), assume the range is
  ** reduced by an additional 75%. This means that, by default, an open-ended
  ** range query (e.g. col &gt; ?) is assumed to match 1/4 of the rows in the
  ** index. While a closed range (e.g. col BETWEEN ? AND ?) is estimated to
  ** match 1/64 of the index. */</comment> 
  <if_stmt><if>if<condition>( <expr><name>pLower</name> <operator>&amp;&amp;</operator> <name><name>pLower</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pUpper</name> <operator>&amp;&amp;</operator> <name><name>pUpper</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nNew</name> <operator>-=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nOut</name> <operator>-=</operator> <operator>(</operator><name>pLower</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>pUpper</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&lt;</operator><literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNew</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&lt;</operator><name>nOut</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nOut</name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WHERETRACE_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;</operator><name>nOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x10</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"Range scan lowers nOut from %d to %d\n"</literal><operator>,</operator>
                    <name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name><operator>,</operator> <name>nOut</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <operator>(</operator><name>LogEst</name><operator>)</operator><name>nOut</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
<comment type="block">/*
** Estimate the number of rows that will be returned based on
** an equality constraint x=VALUE and where that VALUE occurs in
** the histogram data.  This only works when x is the left-most
** column of an index and sqlite_stat3 histogram data is available
** for that index.  When pExpr==NULL that means the constraint is
** "x IS NULL" instead of "x=VALUE".
**
** Write the estimated row count into *pnRow and return SQLITE_OK. 
** If unable to make an estimate, leave *pnRow unchanged and return
** non-zero.
**
** This routine can fail if it is unable to load a collating sequence
** required for string comparison, or if unable to allocate memory
** for a UTF conversion required for comparison.  The error is stored
** in the pParse structure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereEqualScanEst</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing &amp; code generating context */</comment>
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,         <comment type="block">/* Expression for VALUE in the x=VALUE constraint */</comment>
  <parameter><decl><type><name>tRowcnt</name> <modifier>*</modifier></type><name>pnRow</name></decl></parameter>       <comment type="block">/* Write the revised row estimate here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pRec</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>aff</name></decl>;</decl_stmt>                   <comment type="block">/* Column affinity */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                   <comment type="block">/* Subfunction return code */</comment>
  <decl_stmt><decl><type><name>tRowcnt</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* Statistics */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bOk</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nEq</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nEq</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aSample</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSample</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name><operator>&lt;</operator><name>nEq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If values are not available for all fields of the index to the left
  ** of this one, no estimate can be made. Return SQLITE_NOTFOUND. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name><operator>&lt;</operator><operator>(</operator><name>nEq</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* This is an optimization only. The call to sqlite3Stat4ProbeSetValue()
  ** below would return the same value.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nEq</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnRow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3IndexColumnAffinity</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nEq</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Stat4ProbeSetValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRec</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>nEq</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <name>pRec</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>bOk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name> <operator>=</operator> <name>nEq</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>whereKeyStats</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x10</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"equality scan regions: %d\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnRow</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_STAT3_OR_STAT4 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
<comment type="block">/*
** Estimate the number of rows that will be returned based on
** an IN constraint where the right-hand side of the IN operator
** is a list of values.  Example:
**
**        WHERE x IN (1,2,3,4)
**
** Write the estimated row count into *pnRow and return SQLITE_OK. 
** If unable to make an estimate, leave *pnRow unchanged and return
** non-zero.
**
** This routine can fail if it is unable to load a collating sequence
** required for string comparison, or if unable to allocate memory
** for a UTF conversion required for comparison.  The error is stored
** in the pParse structure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereInScanEst</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing &amp; code generating context */</comment>
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,     <comment type="block">/* The value list on the RHS of "x IN (v1,v2,v3,...)" */</comment>
  <parameter><decl><type><name>tRowcnt</name> <modifier>*</modifier></type><name>pnRow</name></decl></parameter>       <comment type="block">/* Write the revised row estimate here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nRow0</name> <init>= <expr><call><name>sqlite3LogEstToInt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRecValid</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Subfunction return code */</comment>
  <decl_stmt><decl><type><name>tRowcnt</name></type> <name>nEst</name></decl>;</decl_stmt>           <comment type="block">/* Number of rows for a single term */</comment>
  <decl_stmt><decl><type><name>tRowcnt</name></type> <name>nRowEst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* New estimate of the number of rows */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                  <comment type="block">/* Loop counter */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aSample</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nEst</name> <operator>=</operator> <name>nRow0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereEqualScanEst</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nEst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRowEst</name> <operator>+=</operator> <name>nEst</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name> <operator>=</operator> <name>nRecValid</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nRowEst</name> <operator>&gt;</operator> <name>nRow0</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nRowEst</name> <operator>=</operator> <name>nRow0</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnRow</name> <operator>=</operator> <name>nRowEst</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x10</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"IN row estimate: est=%d\n"</literal><operator>,</operator> <name>nRowEst</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name><operator>==</operator><name>nRecValid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_STAT3_OR_STAT4 */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
<comment type="block">/*
** Print the content of a WhereTerm object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereTermPrint</name><parameter_list>(<parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTerm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pTerm</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"TERM-%-3d NULL\n"</literal></expr></argument>, <argument><expr><name>iTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zType</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zType</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zType</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'V'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQUIV</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zType</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'E'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zType</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'L'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(
       <argument><expr><literal type="string">"TERM-%-3d %p %s cursor=%-3d prob=%-3d op=0x%03x wtFlags=0x%04x\n"</literal></expr></argument>,
       <argument><expr><name>iTerm</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name></expr></argument>,
       <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewExpr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
<comment type="block">/*
** Print a WhereLoop object for debugging purposes
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopPrint</name><parameter_list>(<parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nb</name> <init>= <expr><literal type="number">1</literal><operator>+</operator><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>+</operator><literal type="number">7</literal><operator>)</operator><operator>/</operator><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>iTab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"%c%2d.%0*llx.%0*llx"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>cId</name></name></expr></argument>,
                     <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTab</name></name></expr></argument>, <argument><expr><name>nb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>maskSelf</name></name></expr></argument>, <argument><expr><name>nb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" %12s"</literal></expr></argument>,
                     <argument><expr><ternary><condition><expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> ?</condition><then> <expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> </then><else>: <expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>zName</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"sqlite_autoindex_"</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <while>while<condition>( <expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'_'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>zName</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">".%-16s %2d"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"%20s"</literal></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"(%d,\"%s\",%x)"</literal></expr></argument>,
                <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxNum</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>omitMask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"(%d,%x)"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxNum</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>omitMask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" %-19s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_SKIPSCAN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" f %05x %d-%d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSkip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" f %05x N %d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" cost %d,%d,%d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x100</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>whereTermPrint</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Convert bulk memory into a valid WhereLoop that can be passed
** to whereLoopClear harmlessly.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopInit</name><parameter_list>(<parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLSlot</name></name> <operator>=</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Clear the WhereLoop.u union.  Leave WhereLoop.pLTerm intact.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopClearUnion</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_VIRTUALTABLE</name><operator>|</operator><name>WHERE_AUTO_INDEX</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name><operator>-&gt;</operator><name>zColAff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate internal memory used by a WhereLoop object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopClear</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>whereLoopClearUnion</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereLoopInit</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Increase the memory allocation for pLoop-&gt;aLTerm[] to be at least n.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopResize</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier><modifier>*</modifier></type><name>paNew</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nLSlot</name></name><operator>&gt;=</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>n</name><operator>+</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">7</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>paNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>paNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>paNew</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nLSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLTerm</name></name> <operator>=</operator> <name>paNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLSlot</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Transfer content from the second pLoop into the first.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopXfer</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pTo</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>whereLoopClearUnion</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>whereLoopResize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>nLTerm</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTo</name><operator>-&gt;</operator><name>u</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>u</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>WHERE_LOOP_XFER_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pFrom</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete a WhereLoop object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>whereLoopClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free a WhereInfo structure
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereInfoFree</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name> <init>= <expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_ABLE</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3WhereClauseClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>whereLoopDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if all of the following are true:
**
**   (1)  X has the same or lower cost that Y
**   (2)  X is a proper subset of Y
**   (3)  X skips at least as many columns as Y
**
** By "proper subset" we mean that X uses fewer WHERE clause terms
** than Y and that every WHERE clause term used by X is also used
** by Y.
**
** If X is a proper subset of Y then Y is a better choice and ought
** to have a lower cost.  This routine returns TRUE when that cost 
** relationship is inverted and needs to be adjusted.  The third rule
** was added because if X uses skip-scan less than Y it still might
** deserve a lower cost even if it is a proper subset of Y.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopCheaperProperSubset</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>WhereLoop</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>,       <comment type="block">/* First WhereLoop to compare */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>WhereLoop</name> <modifier>*</modifier></type><name>pY</name></decl></parameter>        <comment type="block">/* Compare against this WhereLoop */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><name><name>pX</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>&gt;=</operator> <name><name>pY</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><name><name>pY</name><operator>-&gt;</operator><name>nSkip</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* X is not a subset of Y */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pY</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>&gt;</operator> <name><name>pX</name><operator>-&gt;</operator><name>nSkip</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>rRun</name></name> <operator>&gt;=</operator> <name><name>pY</name><operator>-&gt;</operator><name>rRun</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>rRun</name></name> <operator>&gt;</operator> <name><name>pY</name><operator>-&gt;</operator><name>rRun</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* X costs more than Y */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>nOut</name></name> <operator>&gt;</operator> <name><name>pY</name><operator>-&gt;</operator><name>nOut</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* X costs more than Y */</comment>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>pY</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pY</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>pX</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* X not a subset of Y since term X[i] not used by Y */</comment>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* All conditions meet */</comment>
</block_content>}</block></function>

<comment type="block">/*
** Try to adjust the cost of WhereLoop pTemplate upwards or downwards so
** that:
**
**   (1) pTemplate costs less than any other WhereLoops that are a proper
**       subset of pTemplate
**
**   (2) pTemplate costs more than any other WhereLoops for which pTemplate
**       is a proper subset.
**
** To say "WhereLoop X is a proper subset of Y" means that X uses fewer
** WHERE clause terms than Y and that every WHERE clause term used by X is
** also used by Y.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopAdjustCost</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pTemplate</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iTab</name></name><operator>!=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>iTab</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>whereLoopCheaperProperSubset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTemplate</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Adjust pTemplate cost downward so that it is cheaper than its 
      ** subset p. */</comment>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x80</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"subset cost adjustment %d,%d to %d,%d\n"</literal><operator>,</operator>
                       <name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name><operator>,</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>nOut</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rRun</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>whereLoopCheaperProperSubset</name><argument_list>(<argument><expr><name>pTemplate</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Adjust pTemplate cost upward so that it is costlier than p since
      ** pTemplate is a proper subset of p */</comment>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x80</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"subset cost adjustment %d,%d to %d,%d\n"</literal><operator>,</operator>
                       <name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name><operator>,</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>nOut</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rRun</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Search the list of WhereLoops in *ppPrev looking for one that can be
** supplanted by pTemplate.
**
** Return NULL if the WhereLoop list contains an entry that can supplant
** pTemplate, in other words if pTemplate does not belong on the list.
**
** If pX is a WhereLoop that pTemplate can supplant, then return the
** link that points to pX.
**
** If pTemplate cannot supplant any existing element of the list but needs
** to be added to the list, then return a pointer to the tail of the list.
*/</comment>
<function><type><specifier>static</specifier> <name>WhereLoop</name> <modifier>*</modifier><modifier>*</modifier></type><name>whereLoopFindLesser</name><parameter_list>(
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPrev</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>WhereLoop</name> <modifier>*</modifier></type><name>pTemplate</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><operator>(</operator><operator>*</operator><name>ppPrev</name><operator>)</operator></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>ppPrev</name><operator>=</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><operator>*</operator><name>ppPrev</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iTab</name></name><operator>!=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>iTab</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iSortIdx</name></name><operator>!=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>iSortIdx</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If either the iTab or iSortIdx values for two WhereLoop are different
      ** then those WhereLoops need to be considered separately.  Neither is
      ** a candidate to replace the other. */</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* In the current implementation, the rSetup value is either zero
    ** or the cost of building an automatic index (NlogN) and the NlogN
    ** is the same for compatible WhereLoops. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>rSetup</name></name><operator>==</operator><literal type="number">0</literal> 
                 <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name><operator>==</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* whereLoopAddBtree() always generates and inserts the automatic index
    ** case first.  Hence compatible candidate WhereLoops never have a larger
    ** rSetup. Call this SETUP-INVARIANT */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name><operator>&gt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Any loop using an appliation-defined index (or PRIMARY KEY or
    ** UNIQUE constraint) with one or more == constraints is better
    ** than an automatic index. Unless it is a skip-scan. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>nSkip</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_EQ</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name><operator>)</operator><operator>==</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name></expr>
    )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If existing WhereLoop p is better than pTemplate, pTemplate can be
    ** discarded.  WhereLoop p is better if:
    **   (1)  p has no more dependencies than pTemplate, and
    **   (2)  p has an equal or lower cost than pTemplate
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name><operator>)</operator><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name>    <comment type="block">/* (1)  */</comment>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name><operator>&lt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rSetup</name></name>                  <comment type="block">/* (2a) */</comment>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>&lt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name>                      <comment type="block">/* (2b) */</comment>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nOut</name></name><operator>&lt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name></expr>                      <comment type="block">/* (2c) */</comment>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Discard pTemplate */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If pTemplate is always better than p, then cause p to be overwritten
    ** with pTemplate.  pTemplate is better than p if:
    **   (1)  pTemplate has no more dependences than p, and
    **   (2)  pTemplate has an equal or lower cost than p.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name><operator>)</operator><operator>==</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name>   <comment type="block">/* (1)  */</comment>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>rRun</name></name><operator>&gt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name>                             <comment type="block">/* (2a) */</comment>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name></expr>                             <comment type="block">/* (2b) */</comment>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rSetup</name></name><operator>&gt;=</operator><name><name>pTemplate</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* SETUP-INVARIANT above */</comment>
      <break>break;</break>   <comment type="block">/* Cause p to be overwritten by pTemplate */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>ppPrev</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Insert or replace a WhereLoop entry using the template supplied.
**
** An existing WhereLoop entry might be overwritten if the new template
** is better and has fewer dependencies.  Or the template will be ignored
** and no insert will occur if an existing WhereLoop is faster and has
** fewer dependencies than the template.  Otherwise a new WhereLoop is
** added based on the template.
**
** If pBuilder-&gt;pOrSet is not NULL then we care about only the
** prerequisites and rRun and nOut costs of the N best loops.  That
** information is gathered in the pBuilder-&gt;pOrSet object.  This special
** processing mode is used only for OR clause processing.
**
** When accumulating multiple loops (when pBuilder-&gt;pOrSet is NULL) we
** still might overwrite similar loops with the new template if the
** new template is better.  Loops may be overwritten if the following 
** conditions are met:
**
**    (1)  They have the same iTab.
**    (2)  They have the same iSortIdx.
**    (3)  The template has same or fewer dependencies than the current loop
**    (4)  The template has the same or lower cost than the current loop
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopInsert</name><parameter_list>(<parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pTemplate</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPrev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If pBuilder-&gt;pOrSet is defined, then only keep track of the costs
  ** and prereqs.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrSet</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nLTerm</name></name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if>
      <decl_stmt><decl><type><name>u16</name></type> <name>n</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrSet</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr><call><name>whereOrInsert</name><argument_list>(<argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrSet</name></name></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>prereq</name></name></expr></argument>, <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>,
                                    <argument><expr><name><name>pTemplate</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x8 */</comment>
      <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><ternary><condition><expr><name>x</name></expr>?</condition><then><expr><literal type="string">"   or-%d:  "</literal></expr></then><else>:<expr><literal type="string">"   or-X:  "</literal></expr></else></ternary></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>whereLoopPrint</name><argument_list>(<argument><expr><name>pTemplate</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Look for an existing WhereLoop to replace with pTemplate
  */</comment>
  <expr_stmt><expr><call><name>whereLoopAdjustCost</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr></argument>, <argument><expr><name>pTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ppPrev</name> <operator>=</operator> <call><name>whereLoopFindLesser</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr></argument>, <argument><expr><name>pTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>ppPrev</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* There already exists a WhereLoop on the list that is better
    ** than pTemplate, so just ignore pTemplate */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x8 */</comment>
    <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"   skip: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>whereLoopPrint</name><argument_list>(<argument><expr><name>pTemplate</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>  
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>ppPrev</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* If we reach this point it means that either p[] should be overwritten
  ** with pTemplate[] if p[] exists, or if p==NULL then allocate a new
  ** WhereLoop and insert it.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x8 */</comment>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"replace: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>whereLoopPrint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"    add: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereLoopPrint</name><argument_list>(<argument><expr><name>pTemplate</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Allocate a new WhereLoop to add to the end of the list */</comment>
    <expr_stmt><expr><operator>*</operator><name>ppPrev</name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WhereLoop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>whereLoopInit</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* We will be overwriting WhereLoop p[].  But before we do, first
    ** go through the rest of the list and delete any other entries besides
    ** p[] that are also supplated by pTemplate */</comment>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTail</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pToDel</name></decl>;</decl_stmt>
    <while>while<condition>( <expr><operator>*</operator><name>ppTail</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>ppTail</name> <operator>=</operator> <call><name>whereLoopFindLesser</name><argument_list>(<argument><expr><name>ppTail</name></expr></argument>, <argument><expr><name>pTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>ppTail</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pToDel</name> <operator>=</operator> <operator>*</operator><name>ppTail</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pToDel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>ppTail</name> <operator>=</operator> <name><name>pToDel</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WHERETRACE_ENABLED</name></expr></cpp:if> <comment type="block">/* 0x8 */</comment>
      <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" delete: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>whereLoopPrint</name><argument_list>(<argument><expr><name>pToDel</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>whereLoopDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pToDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>whereLoopXfer</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIndex</name> <operator>&amp;&amp;</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>tnum</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Adjust the WhereLoop.nOut value downward to account for terms of the
** WHERE clause that reference the loop but which are not used by an
** index.
*
** For every WHERE clause term that is not used by the index
** and which has a truth probability assigned by one of the likelihood(),
** likely(), or unlikely() SQL functions, reduce the estimated number
** of output rows by the probability specified.
**
** TUNING:  For every WHERE clause term that is not used by the index
** and which does not have an assigned truth probability, heuristics
** described below are used to try to estimate the truth probability.
** TODO --&gt; Perhaps this is something that could be improved by better
** table statistics.
**
** Heuristic 1:  Estimate the truth probability as 93.75%.  The 93.75%
** value corresponds to -1 in LogEst notation, so this means decrement
** the WhereLoop.nOut field for every such WHERE clause term.
**
** Heuristic 2:  If there exists one or more WHERE clause terms of the
** form "x==EXPR" and EXPR is not a constant 0 or 1, then make sure the
** final output row estimate is no greater than 1/4 of the total number
** of rows in the table.  In other words, assume that x==EXPR will filter
** out at least 3 out of 4 rows.  If EXPR is -1 or 0 or 1, then maybe the
** "x" column is boolean or else -1 or 0 or 1 is a common default value
** on the "x" column and so in that case only cap the output row estimate
** at 1/2 instead of 1/4.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLoopOutputAdjust</name><parameter_list>(
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,      <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl></parameter>,      <comment type="block">/* The loop to adjust downward */</comment>
  <parameter><decl><type><name>LogEst</name></type> <name>nRow</name></decl></parameter>            <comment type="block">/* Number of rows in the entire table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>notAllowed</name> <init>= <expr><operator>~</operator><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>prereq</name></name><operator>|</operator><name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>iReduce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* pLoop-&gt;nOut should not exceed nRow-iReduce */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr><operator>,</operator> <expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name>notAllowed</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pX</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pX</name><operator>==</operator><name>pTerm</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>iParent</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pX</name><operator>-&gt;</operator><name>iParent</name></name></expr>]</index></name><operator>)</operator><operator>==</operator><name>pTerm</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If a truth probability is specified using the likelihood() hints,
        ** then use the probability provided by the application. */</comment>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* In the absence of explicit truth probabilities, use heuristics to
        ** guess a reasonable truth probability. */</comment>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name><operator>--</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>&amp;</operator><operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>k</name><operator>&gt;=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>k</name><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>iReduce</name><operator>&lt;</operator><name>k</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iReduce</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>&gt;</operator> <name>nRow</name><operator>-</operator><name>iReduce</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>nRow</name> <operator>-</operator> <name>iReduce</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Adjust the cost C by the costMult facter T.  This only occurs if
** compiled with -DSQLITE_ENABLE_COSTMULT
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COSTMULT</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ApplyCostMultiplier</name><parameter_list>(<parameter><type><name>C</name></type></parameter>,<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>C += T</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ApplyCostMultiplier</name><parameter_list>(<parameter><type><name>C</name></type></parameter>,<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** We have so far matched pBuilder-&gt;pNew-&gt;u.btree.nEq terms of the 
** index pIndex. Try to match one more.
**
** When this function is called, pBuilder-&gt;pNew-&gt;nOut contains the 
** number of rows expected to be visited by filtering using the nEq 
** terms only. If it is modified, this value is restored before this 
** function returns.
**
** If pProbe-&gt;tnum==0, that means pIndex is a fake index used for the
** INTEGER PRIMARY KEY.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddBtreeIndex</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,     <comment type="block">/* The WhereLoop factory */</comment>
  <parameter><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,      <comment type="block">/* FROM clause term being analyzed */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pProbe</name></decl></parameter>,                  <comment type="block">/* An index on pSrc */</comment>
  <parameter><decl><type><name>LogEst</name></type> <name>nInMul</name></decl></parameter>                   <comment type="block">/* log(Number of iterations due to IN) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* WHERE analyse context */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Database connection malloc context */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>                <comment type="block">/* Template WhereLoop under construction */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>               <comment type="block">/* A WhereTerm under consideration */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>opMask</name></decl>;</decl_stmt>                     <comment type="block">/* Valid operators for constraints */</comment>
  <decl_stmt><decl><type><name>WhereScan</name></type> <name>scan</name></decl>;</decl_stmt>                 <comment type="block">/* Iterator for WHERE terms */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>saved_prereq</name></decl>;</decl_stmt>           <comment type="block">/* Original value of pNew-&gt;prereq */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>saved_nLTerm</name></decl>;</decl_stmt>               <comment type="block">/* Original value of pNew-&gt;nLTerm */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>saved_nEq</name></decl>;</decl_stmt>                  <comment type="block">/* Original value of pNew-&gt;u.btree.nEq */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>saved_nSkip</name></decl>;</decl_stmt>                <comment type="block">/* Original value of pNew-&gt;nSkip */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>saved_wsFlags</name></decl>;</decl_stmt>              <comment type="block">/* Original value of pNew-&gt;wsFlags */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>saved_nOut</name></decl>;</decl_stmt>              <comment type="block">/* Original value of pNew-&gt;nOut */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>rSize</name></decl>;</decl_stmt>                   <comment type="block">/* Number of rows in the table */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>rLogSize</name></decl>;</decl_stmt>                <comment type="block">/* Logarithm of table size */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pBtm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Top and bottom range constraints */</comment>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TOP_LIMIT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BTM_LIMIT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>opMask</name> <operator>=</operator> <name>WO_LT</name><operator>|</operator><name>WO_LE</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <comment type="block">/*pProbe-&gt;tnum&lt;=0 ||*/</comment> <expr><operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>opMask</name> <operator>=</operator> <name>WO_EQ</name><operator>|</operator><name>WO_IN</name><operator>|</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>|</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>opMask</name> <operator>=</operator> <name>WO_EQ</name><operator>|</operator><name>WO_IN</name><operator>|</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>|</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>|</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_IS</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pProbe</name><operator>-&gt;</operator><name>bUnordered</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opMask</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>|</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>&lt;</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>saved_nEq</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_nSkip</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_nLTerm</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_wsFlags</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_prereq</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>saved_nOut</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>whereScanInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name>saved_nEq</name></expr></argument>,
                        <argument><expr><name>opMask</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rSize</name> <operator>=</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rLogSize</name> <operator>=</operator> <call><name>estLog</name><argument_list>(<argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>pTerm</name> <operator>=</operator> <call><name>whereScanNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>eOp</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Shorthand for pTerm-&gt;eOperator */</comment>
    <decl_stmt><decl><type><name>LogEst</name></type> <name>rCostIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LogEst</name></type> <name>nOutUnadjusted</name></decl>;</decl_stmt>        <comment type="block">/* nOut before IN() and WHERE adjustments */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>nRecValid</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eOp</name><operator>==</operator><name>WO_ISNULL</name> <operator>||</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name><operator>&amp;</operator><name>TERM_VNULL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <call><name>indexColumnNotNull</name><argument_list>(<argument><expr><name>pProbe</name></expr></argument>, <argument><expr><name>saved_nEq</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <continue>continue;</continue> <comment type="block">/* ignore IS [NOT] NULL constraints on NOT NULL columns */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* Do not allow the upper bound of a LIKE optimization range constraint
    ** to mix with a lower range bound from some other source */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name> <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>==</operator><name>WO_LT</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>saved_wsFlags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <name>saved_nEq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <name>saved_nLTerm</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>whereLoopResize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* OOM */</comment>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <operator>(</operator><name>saved_prereq</name> <operator>|</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nInMul</name><operator>==</operator><literal type="number">0</literal>
        <operator>||</operator> <operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_NULL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> 
        <operator>||</operator> <operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_IN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> 
        <operator>||</operator> <operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_SKIPSCAN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> 
    )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <name>WO_IN</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_COLUMN_IN</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* "x IN (SELECT ...)":  TUNING: the SELECT returns 25 rows */</comment>
        <expr_stmt><expr><name>nIn</name> <operator>=</operator> <literal type="number">46</literal></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">46</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* "x IN (value, value, ...)" */</comment>
        <expr_stmt><expr><name>nIn</name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nIn</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* RHS always has 2 or more terms...  The parser
                        ** changes "x IN (?)" into "x=?". */</comment>

    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pProbe</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>saved_nEq</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_COLUMN_EQ</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>saved_nEq</name><operator>==</operator><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name>XN_ROWID</name> 
       <operator>||</operator> <operator>(</operator><name>iCol</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nInMul</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>saved_nEq</name><operator>==</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>uniqNotNull</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_UNQ_WANTED</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_ONEROW</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_COLUMN_NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_COLUMN_RANGE</name><operator>|</operator><name>WHERE_BTM_LIMIT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBtm</name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Range contraints that come from the LIKE optimization are
        ** always used in pairs. */</comment>
        <expr_stmt><expr><name>pTop</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTerm</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>pTop</name><operator>-</operator><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>a</name></name><operator>)</operator><operator>)</operator><operator>&lt;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTop</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTop</name><operator>-&gt;</operator><name>eOperator</name></name><operator>==</operator><name>WO_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>whereLoopResize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* OOM */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pTop</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_TOP_LIMIT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_COLUMN_RANGE</name><operator>|</operator><name>WHERE_TOP_LIMIT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTop</name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBtm</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BTM_LIMIT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then>
                     <expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* At this point pNew-&gt;nOut is set to the number of rows expected to
    ** be visited by the index scan before considering term pTerm, or the
    ** values of nIn and nInMul. In other words, assuming that all 
    ** "x IN(...)" terms are replaced with "x = ?". This block updates
    ** the value of pNew-&gt;nOut to account for pTerm (but not nIn/nInMul).  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name><operator>==</operator><name>saved_nOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_RANGE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Adjust nOut using stat3/stat4 data. Or, if there is no stat3/stat4
      ** data, using some other estimate.  */</comment>
      <expr_stmt><expr><call><name>whereRangeScanEst</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pBtm</name></expr></argument>, <argument><expr><name>pTop</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><operator>++</operator><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_EQ</name><operator>|</operator><name>WO_IN</name><operator>|</operator><name>WO_IS</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name><operator>==</operator><name>saved_nOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name><operator>&lt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>saved_nEq</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>eOp</name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator> <operator>||</operator> <name>nIn</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-=</operator> <name>nIn</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
        <decl_stmt><decl><type><name>tRowcnt</name></type> <name>nOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>nInMul</name><operator>==</operator><literal type="number">0</literal> 
         <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>nSample</name></name> 
         <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>&lt;=</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nSampleCol</name></name>
         <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>eOp</name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereEqualScanEst</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereInScanEst</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOTFOUND</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>          <comment type="block">/* Jump out of the pTerm loop */</comment>
          <if_stmt><if>if<condition>( <expr><name>nOut</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;</operator><name>saved_nOut</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>saved_nOut</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-=</operator> <name>nIn</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>nOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <operator>(</operator><name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>nEq</name></expr>]</index></name> <operator>-</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>nEq</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* TUNING: If there is no likelihood() value, assume that a 
            ** "col IS NULL" expression matches twice as many rows 
            ** as (col=?). */</comment>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Set rCostIdx to the cost of visiting selected rows in index. Add
    ** it to pNew-&gt;rRun, which is currently set to the cost of the index
    ** seek only. Then, if this is a non-covering index, add the cost of
    ** visiting the rows in the main table.  */</comment>
    <expr_stmt><expr><name>rCostIdx</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">15</literal><operator>*</operator><name><name>pProbe</name><operator>-&gt;</operator><name>szIdxRow</name></name><operator>)</operator><operator>/</operator><name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name>rLogSize</name></expr></argument>, <argument><expr><name>rCostIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_IDX_ONLY</name><operator>|</operator><name>WHERE_IPK</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ApplyCostMultiplier</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pProbe</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>costMult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nOutUnadjusted</name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>+=</operator> <name>nInMul</name> <operator>+</operator> <name>nIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <name>nInMul</name> <operator>+</operator> <name>nIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereLoopOutputAdjust</name><argument_list>(<argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_RANGE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>saved_nOut</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>nOutUnadjusted</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TOP_LIMIT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>&lt;</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nColumn</name></name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>whereLoopAddBtreeIndex</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>, <argument><expr><name>nInMul</name><operator>+</operator><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>saved_nOut</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name> <operator>=</operator> <name>nRecValid</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name>saved_prereq</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <name>saved_nEq</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <name>saved_nSkip</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>saved_wsFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>saved_nOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <name>saved_nLTerm</name></expr>;</expr_stmt>

  <comment type="block">/* Consider using a skip-scan if there are no WHERE clause constraints
  ** available for the left-most terms of the index, and if the average
  ** number of repeats in the left-most terms is at least 18. 
  **
  ** The magic number 18 is selected on the basis that scanning 17 rows
  ** is almost always quicker than an index seek (even though if the index
  ** contains fewer than 2^17 rows we assume otherwise in other parts of
  ** the code). And, even if it is not, it should not be too much slower. 
  ** On the other hand, the extra seeks could end up being significantly
  ** more expensive.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">42</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>saved_nEq</name><operator>==</operator><name>saved_nSkip</name>
   <operator>&amp;&amp;</operator> <name>saved_nEq</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name><name>pProbe</name><operator>-&gt;</operator><name>nKeyCol</name></name>
   <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>noSkipScan</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>saved_nEq</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><literal type="number">42</literal>  <comment type="block">/* TUNING: Minimum for skip-scan */</comment>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>whereLoopResize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_OK</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LogEst</name></type> <name>nIter</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_SKIPSCAN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nIter</name> <operator>=</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>saved_nEq</name></expr>]</index></name> <operator>-</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><name>saved_nEq</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>-=</operator> <name>nIter</name></expr>;</expr_stmt>
    <comment type="block">/* TUNING:  Because uncertainties in the estimates for skip-scan queries,
    ** add a 1.375 fudge factor to make skip-scan slightly less likely. */</comment>
    <expr_stmt><expr><name>nIter</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereLoopAddBtreeIndex</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>, <argument><expr><name>nIter</name> <operator>+</operator> <name>nInMul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>saved_nOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <name>saved_nEq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <name>saved_nSkip</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>saved_wsFlags</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return True if it is possible that pIndex might be useful in
** implementing the ORDER BY clause in pBuilder.
**
** Return False if pBuilder does not contain an ORDER BY clause or
** if there is no way for pIndex to be useful in implementing that
** ORDER BY clause.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>indexMightHelpWithOrderBy</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iCursor</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOB</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>aColExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pIndex</name><operator>-&gt;</operator><name>bUnordered</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pOB</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pOB</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pOB</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iCursor</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>jj</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>aColExpr</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>jj</name></expr>]</index></name><operator>!=</operator><name>XN_EXPR</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>jj</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>,<argument><expr><name>iCursor</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a bitmask where 1s indicate that the corresponding column of
** the table is used by an index.  Only the first 63 columns are considered.
*/</comment>
<function><type><specifier>static</specifier> <name>Bitmask</name></type> <name>columnsInIndex</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>|=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check to see if a partial index with pPartIndexWhere can be used
** in the current query.  Return true if it can be and false if not.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereUsablePartialIndex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>, <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name><name>pWhere</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>whereUsablePartialIndex</name><argument_list>(<argument><expr><name>iTab</name></expr></argument>,<argument><expr><name>pWC</name></expr></argument>,<argument><expr><name><name>pWhere</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <name><name>pWhere</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprImpliesExpr</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call> 
     <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iRightJoinTable</name></name><operator>==</operator><name>iTab</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add all WhereLoop objects for a single table of the join where the table
** is idenfied by pBuilder-&gt;pNew-&gt;iTab.  That table is guaranteed to be
** a b-tree table, not a virtual table.
**
** The costs (WhereLoop.rRun) of the b-tree loops added by this function
** are calculated as follows:
**
** For a full scan, assuming the table (or index) contains nRow rows:
**
**     cost = nRow * 3.0                    // full-table scan
**     cost = nRow * K                      // scan of covering index
**     cost = nRow * (K+3.0)                // scan of non-covering index
**
** where K is a value between 1.1 and 3.0 set based on the relative 
** estimated average size of the index and table records.
**
** For an index scan, where nVisit is the number of index rows visited
** by the scan, and nSeek is the number of seek operations required on 
** the index b-tree:
**
**     cost = nSeek * (log(nRow) + K * nVisit)          // covering index
**     cost = nSeek * (log(nRow) + (K+3.0) * nVisit)    // non-covering index
**
** Normally, nSeek is 1. nSeek values greater than 1 come about if the 
** WHERE clause includes "x IN (....)" terms used in place of "x=?". Or when 
** implicit "x IN (SELECT x FROM tbl)" terms are added for skip-scans.
**
** The estimated values (nRow, nVisit, nSeek) often contain a large amount
** of uncertainty.  For this reason, scoring is designed to pick plans that
** "do the least harm" if the estimates are inaccurate.  For example, a
** log(nRow) factor is omitted from a non-covering index scan in order to
** bias the scoring in favor of using an index, since the worst-case
** performance of using an index is far better than the worst-case performance
** of a full table scan.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddBtree</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>, <comment type="block">/* WHERE clause information */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>mExtra</name></decl></parameter>              <comment type="block">/* Extra prerequesites for using this table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>          <comment type="block">/* WHERE analysis context */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pProbe</name></decl>;</decl_stmt>              <comment type="block">/* An index we are evaluating */</comment>
  <decl_stmt><decl><type><name>Index</name></type> <name>sPk</name></decl>;</decl_stmt>                  <comment type="block">/* A fake index object for the primary key */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name><name>aiRowEstPk</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* The aiRowLogEst[] value for the sPk index */</comment>
  <decl_stmt><decl><type><name>i16</name></type> <name>aiColumnPk</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* The aColumn[] value for the sPk index */</comment>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl>;</decl_stmt>          <comment type="block">/* The FROM clause */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>  <comment type="block">/* The FROM clause btree term to add */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>            <comment type="block">/* Template WhereLoop object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSortIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Index number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>                      <comment type="block">/* A boolean value */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>rSize</name></decl>;</decl_stmt>               <comment type="block">/* number of rows in the table */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>rLogSize</name></decl>;</decl_stmt>            <comment type="block">/* Logarithm of the number of rows in the table */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>           <comment type="block">/* The parsed WHERE clause */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                <comment type="block">/* Table being queried */</comment>
  
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabList</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>pIBIndex</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* An INDEXED BY clause specifies a particular index to use */</comment>
    <expr_stmt><expr><name>pProbe</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pIBIndex</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pProbe</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* There is no INDEXED BY clause.  Create a fake Index object in local
    ** variable sPk to represent the rowid primary key index.  Make this
    ** fake index the first in a chain of Index objects with all of the real
    ** indices to follow */</comment>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>                  <comment type="block">/* First of real indices on the table */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sPk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>nKeyCol</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>nColumn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>aiColumn</name></name> <operator>=</operator> <operator>&amp;</operator><name>aiColumnPk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>aiRowLogEst</name></name> <operator>=</operator> <name>aiRowEstPk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>onError</name></name> <operator>=</operator> <name>OE_Replace</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>pTable</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>szIdxRow</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aiRowEstPk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aiRowEstPk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFirst</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>notIndexed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* The real indices of the table are only considered if the
      ** NOT INDEXED qualifier is omitted from the FROM clause */</comment>
      <expr_stmt><expr><name><name>sPk</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name>pFirst</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pProbe</name> <operator>=</operator> <operator>&amp;</operator><name>sPk</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rSize</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nRowLogEst</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rLogSize</name> <operator>=</operator> <call><name>estLog</name><argument_list>(<argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOMATIC_INDEX</name></cpp:ifndef>
  <comment type="block">/* Automatic indexes */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrSet</name></name>      <comment type="block">/* Not part of an OR optimization */</comment>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_NO_AUTOINDEX</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_AutoIndex</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pIBIndex</name></name><operator>==</operator><literal type="number">0</literal>      <comment type="block">/* Has no INDEXED BY clause */</comment>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>notIndexed</name></name>   <comment type="block">/* Has no NOT INDEXED clause */</comment>
   <operator>&amp;&amp;</operator> <call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call>         <comment type="block">/* Not WITHOUT ROWID table. (FIXME: Why not?) */</comment>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCorrelated</name></name> <comment type="block">/* Not a correlated subquery */</comment>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pSrc</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isRecursive</name></name></expr>  <comment type="block">/* Not a recursive common table expression. */</comment>
  )</condition><block>{<block_content>
    <comment type="block">/* Generate auto-index WhereLoops */</comment>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pWCEnd</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pTerm</name><operator>&lt;</operator><name>pWCEnd</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>termCanDriveIndex</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
        <comment type="block">/* TUNING: One-time cost for computing the automatic index is
        ** estimated to be X*N*log2(N) where N is the number of rows in
        ** the table being indexed and where X is 7 (LogEst=28) for normal
        ** tables or 1.375 (LogEst=4) for views and subqueries.  The value
        ** of X is smaller for views and subqueries so that the query planner
        ** will be more aggressive about generating automatic indexes for
        ** those objects, since there is no opportunity to add schema
        ** indexes on subqueries and views. */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <name>rLogSize</name> <operator>+</operator> <name>rSize</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Ephemeral</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>+=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ApplyCostMultiplier</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>costMult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* TUNING: Each index lookup yields 20 rows in the table.  This
        ** is more than the usual guess of 10 rows, since we have no way
        ** of knowing how selective the index will ultimately be.  It would
        ** not be unreasonable to make this value much larger. */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <literal type="number">43</literal></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">43</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name>rLogSize</name></expr></argument>,<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_AUTO_INDEX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name>mExtra</name> <operator>|</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTOMATIC_INDEX */</comment>

  <comment type="block">/* Loop over all indices
  */</comment>
  <for>for<control>(<init>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pProbe</name></expr>;</condition> <incr><expr><name>pProbe</name><operator>=</operator><name><name>pProbe</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>iSortIdx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pProbe</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>whereUsablePartialIndex</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name><name>pProbe</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* See ticket [98d973b8f5] */</comment>
      <continue>continue;</continue>  <comment type="block">/* Partial index inappropriate for this query */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rSize</name> <operator>=</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>aiRowLogEst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iSortIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name>mExtra</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>rSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <name>pProbe</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>indexMightHelpWithOrderBy</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The ONEPASS_DESIRED flags never occurs together with ORDER BY */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>b</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pProbe</name><operator>-&gt;</operator><name>tnum</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Integer primary key index */</comment>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_IPK</name></expr>;</expr_stmt>

      <comment type="block">/* Full table scan */</comment>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iSortIdx</name></name> <operator>=</operator> <ternary><condition><expr><name>b</name></expr> ?</condition><then> <expr><name>iSortIdx</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <comment type="block">/* TUNING: Cost of full table scan is (N*3.0). */</comment>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name>rSize</name> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ApplyCostMultiplier</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>costMult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>whereLoopOutputAdjust</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>rSize</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pProbe</name><operator>-&gt;</operator><name>isCovering</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_IDX_ONLY</name> <operator>|</operator> <name>WHERE_INDEXED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <operator>~</operator><call><name>columnsInIndex</name><argument_list>(<argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>m</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>WHERE_IDX_ONLY</name><operator>|</operator><name>WHERE_INDEXED</name><operator>)</operator></expr> </then><else>: <expr><name>WHERE_INDEXED</name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Full scan via index */</comment>
      <if_stmt><if>if<condition>( <expr><name>b</name>
       <operator>||</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call>
       <operator>||</operator> <operator>(</operator> <name>m</name><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <name><name>pProbe</name><operator>-&gt;</operator><name>bUnordered</name></name><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pProbe</name><operator>-&gt;</operator><name>szIdxRow</name></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name><operator>)</operator>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bUseCis</name></name>
         <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_CoverIdxScan</name></expr></argument>)</argument_list></call>
          <operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iSortIdx</name></name> <operator>=</operator> <ternary><condition><expr><name>b</name></expr> ?</condition><then> <expr><name>iSortIdx</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

        <comment type="block">/* The cost of visiting the index rows is N*K, where K is
        ** between 1.1 and 3.0, depending on the relative sizes of the
        ** index and table rows. If this is a non-covering index scan,
        ** also add the cost of visiting table rows (N*3.0).  */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name>rSize</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">15</literal><operator>*</operator><name><name>pProbe</name><operator>-&gt;</operator><name>szIdxRow</name></name><operator>)</operator><operator>/</operator><name><name>pTab</name><operator>-&gt;</operator><name>szTabRow</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>m</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name>rSize</name><operator>+</operator><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ApplyCostMultiplier</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>costMult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>whereLoopOutputAdjust</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>rSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name>rSize</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddBtreeIndex</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlite3Stat4ProbeFree</name><argument_list>(<argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>nRecValid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If there was an INDEXED BY clause, then only that one index is
    ** considered. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>pIBIndex</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Add all WhereLoop objects for a table of the join identified by
** pBuilder-&gt;pNew-&gt;iTab.  That table is guaranteed to be a virtual table.
**
** If there are no LEFT or CROSS JOIN joins in the query, both mExtra and
** mUnusable are set to 0. Otherwise, mExtra is a mask of all FROM clause
** entries that occur before the virtual table in the FROM clause and are
** separated from it by at least one LEFT or CROSS JOIN. Similarly, the
** mUnusable mask contains all FROM clause entries that occur after the
** virtual table and are separated from it by at least one LEFT or 
** CROSS JOIN. 
**
** For example, if the query were:
**
**   ... FROM t1, t2 LEFT JOIN t3, t4, vt CROSS JOIN t5, t6;
**
** then mExtra corresponds to (t1, t2) and mUnusable to (t5, t6).
**
** All the tables in mExtra must be scanned before the current virtual 
** table. So any terms for which all prerequisites are satisfied by 
** mExtra may be specified as "usable" in all calls to xBestIndex. 
** Conversely, all tables in mUnusable must be scanned after the current
** virtual table, so any terms for which the prerequisites overlap with
** mUnusable should always be configured as "not-usable" for xBestIndex.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddVirtual</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>,  <comment type="block">/* WHERE clause information */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>mExtra</name></decl></parameter>,              <comment type="block">/* Tables that must be scanned before this one */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>mUnusable</name></decl></parameter>            <comment type="block">/* Tables that must be scanned after this one */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>           <comment type="block">/* WHERE analysis context */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>               <comment type="block">/* The parsing context */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>            <comment type="block">/* The WHERE clause */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>   <comment type="block">/* The FROM clause term to search */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pIdxCons</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint_usage</name></name> <modifier>*</modifier></type><name>pUsage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTerm</name></decl>, <decl><type ref="prev"/><name>mxTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>seenIn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* True if an IN operator is seen */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>seenVar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* True if a non-constant constraint is seen */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPhase</name></decl>;</decl_stmt>                  <comment type="block">/* 0: const w/o IN, 1: const, 2: no IN,  2: IN */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>mExtra</name> <operator>&amp;</operator> <name>mUnusable</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxInfo</name> <operator>=</operator> <call><name>allocateIndexInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>mUnusable</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>,<argument><expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIdxInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_VIRTUALTABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pUsage</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>whereLoopResize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>nConstraint</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIdxInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>iPhase</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPhase</name><operator>&lt;=</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>iPhase</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>seenIn</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iPhase</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPhase</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iPhase</name><operator>&gt;</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>seenVar</name> <operator>&amp;&amp;</operator> <name>iPhase</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pIdxCons</name> <operator>=</operator> <operator>*</operator><operator>(</operator>struct <name>sqlite3_index_constraint</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pIdxCons</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>pIdxCons</name><operator>-&gt;</operator><name>iTermOffset</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <switch>switch<condition>( <expr><name>iPhase</name></expr> )</condition><block>{<block_content>
        <case>case <expr><literal type="number">0</literal></expr>:</case>    <comment type="block">/* Constants without IN operator */</comment>
          <expr_stmt><expr><name><name>pIdxCons</name><operator>-&gt;</operator><name>usable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>seenIn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <operator>~</operator><name>mExtra</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>seenVar</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pIdxCons</name><operator>-&gt;</operator><name>usable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        <case>case <expr><literal type="number">1</literal></expr>:</case>    <comment type="block">/* Constants with IN operators */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>seenIn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pIdxCons</name><operator>-&gt;</operator><name>usable</name></name> <operator>=</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <operator>~</operator><name>mExtra</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><literal type="number">2</literal></expr>:</case>    <comment type="block">/* Variables without IN */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>seenVar</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pIdxCons</name><operator>-&gt;</operator><name>usable</name></name> <operator>=</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
        <default>default:</default>   <comment type="block">/* Variables with IN */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>seenVar</name> <operator>&amp;&amp;</operator> <name>seenIn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pIdxCons</name><operator>-&gt;</operator><name>usable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pUsage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pUsage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <name>SQLITE_BIG_DBL</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>pSrc</name><operator>-&gt;</operator><name>colUsed</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vtabBestIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pIdxInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereLoopAddVtab_exit</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pIdxCons</name> <operator>=</operator> <operator>*</operator><operator>(</operator>struct <name>sqlite3_index_constraint</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name>mExtra</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mxTerm</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLSlot</name></name><operator>&gt;=</operator><name>nConstraint</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nConstraint</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>omitMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nConstraint</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pIdxCons</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iTerm</name> <operator>=</operator> <name><name>pUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>pIdxCons</name><operator>-&gt;</operator><name>iTermOffset</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iTerm</name><operator>&gt;=</operator><name>nConstraint</name>
         <operator>||</operator> <name>j</name><operator>&lt;</operator><literal type="number">0</literal>
         <operator>||</operator> <name>j</name><operator>&gt;=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name>
         <operator>||</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s.xBestIndex() malfunction"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>whereLoopAddVtab_exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iTerm</name><operator>==</operator><name>nConstraint</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>|=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTerm</name><operator>&lt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>nLSlot</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>iTerm</name></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iTerm</name><operator>&gt;</operator><name>mxTerm</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mxTerm</name> <operator>=</operator> <name>iTerm</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iTerm</name><operator>==</operator><literal type="number">15</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iTerm</name><operator>==</operator><literal type="number">16</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iTerm</name><operator>&lt;</operator><literal type="number">16</literal> <operator>&amp;&amp;</operator> <name><name>pUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>omitMask</name></name> <operator>|=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name>iTerm</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <comment type="block">/* Do not attempt to use an IN constraint if the virtual table
            ** says that the equivalent EQ constraint cannot be safely omitted.
            ** If we do attempt to use such a constraint, some rows might be
            ** repeated in the output. */</comment>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
          <comment type="block">/* A virtual table that is constrained by an IN clause may not
          ** consume the ORDER BY clause because (1) the order of IN terms
          ** is not necessarily related to the order of output terms and
          ** (2) Multiple outputs from a single IN value will not merge
          ** together.  */</comment>
          <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_INDEX_SCAN_UNIQUE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>nConstraint</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <name>mxTerm</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name><operator>&lt;=</operator><name><name>pNew</name><operator>-&gt;</operator><name>nLSlot</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxNum</name></name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>isOrdered</name></name> <operator>=</operator> <operator>(</operator><name>i8</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name></expr> ?</condition><then>
                                      <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <call><name>sqlite3LogEstFromDouble</name><argument_list>(<argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set the WHERE_ONEROW flag if the xBestIndex() method indicated
      ** that the scan will visit at most one row. Clear it otherwise. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxFlags</name></name> <operator>&amp;</operator> <name>SQLITE_INDEX_SCAN_UNIQUE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_ONEROW</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>WHERE_ONEROW</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>  

<label><name>whereLoopAddVtab_exit</name>:</label>
  <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIdxInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** Add WhereLoop entries to handle OR terms.  This works for either
** btrees or virtual tables.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddOr</name><parameter_list>(
  <parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>, 
  <parameter><decl><type><name>Bitmask</name></type> <name>mExtra</name></decl></parameter>, 
  <parameter><decl><type><name>Bitmask</name></type> <name>mUnusable</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pWCEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereClause</name></type> <name>tempWC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoopBuilder</name></type> <name>sSubBuild</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereOrSet</name></type> <name>sSum</name></decl>, <decl><type ref="prev"/><name>sCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWCEnd</name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sSum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pTerm</name><operator>&lt;</operator><name>pWCEnd</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_OR</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pOrInfo</name><operator>-&gt;</operator><name>indexable</name></name> <operator>&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> 
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pOrWC</name> <init>= <expr><operator>&amp;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pOrInfo</name><operator>-&gt;</operator><name>wc</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pOrWCEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pOrWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pOrWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pOrTerm</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>once</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    
      <expr_stmt><expr><name>sSubBuild</name> <operator>=</operator> <operator>*</operator><name>pBuilder</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sSubBuild</name><operator>.</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sSubBuild</name><operator>.</operator><name>pOrSet</name></name> <operator>=</operator> <operator>&amp;</operator><name>sCur</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Begin processing OR-clause %p\n"</literal><operator>,</operator> <name>pTerm</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>pOrTerm</name><operator>=</operator><name><name>pOrWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pOrTerm</name><operator>&lt;</operator><name>pOrWCEnd</name></expr>;</condition> <incr><expr><name>pOrTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_AND</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>sSubBuild</name><operator>.</operator><name>pWC</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pAndInfo</name><operator>-&gt;</operator><name>wc</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>==</operator><name>iCur</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>pWInfo</name></name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>pOuter</name></name> <operator>=</operator> <name>pWC</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_AND</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>nTerm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tempWC</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name>pOrTerm</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sSubBuild</name><operator>.</operator><name>pWC</name></name> <operator>=</operator> <operator>&amp;</operator><name>tempWC</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>sCur</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"OR-term %d of %p has %d subterms:\n"</literal><operator>,</operator> 
                   <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOrTerm</name><operator>-</operator><name><name>pOrWC</name><operator>-&gt;</operator><name>a</name></name><operator>)</operator><operator>,</operator> <name>pTerm</name><operator>,</operator> <name><name>sSubBuild</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x400</literal></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>sSubBuild</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><call><name>whereTermPrint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sSubBuild</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
        <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddVirtual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSubBuild</name></expr></argument>, <argument><expr><name>mExtra</name></expr></argument>, <argument><expr><name>mUnusable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddBtree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSubBuild</name></expr></argument>, <argument><expr><name>mExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddOr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSubBuild</name></expr></argument>, <argument><expr><name>mExtra</name></expr></argument>, <argument><expr><name>mUnusable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>sCur</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>sCur</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>sSum</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>once</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>whereOrMove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>once</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>WhereOrSet</name></type> <name>sPrev</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>whereOrMove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sPrev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sSum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sSum</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>sPrev</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>sCur</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <expr_stmt><expr><call><name>whereOrInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSum</name></expr></argument>, <argument><expr><name><name>sPrev</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prereq</name> <operator>|</operator> <name><name>sCur</name><operator>.</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>prereq</name></expr></argument>,
                            <argument><expr><call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>sPrev</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rRun</name></expr></argument>, <argument><expr><name><name>sCur</name><operator>.</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>rRun</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>sPrev</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nOut</name></expr></argument>, <argument><expr><name><name>sCur</name><operator>.</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nOut</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_MULTI_OR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rSetup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iSortIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>u</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>sSum</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <comment type="block">/* TUNING: Currently sSum.a[i].rRun is set to the sum of the costs
        ** of all sub-scans required by the OR-scan. However, due to rounding
        ** errors, it may be that the cost of the OR-scan is equal to its
        ** most expensive sub-scan. Add the smallest possible penalty 
        ** (equivalent to multiplying the cost by 1.07) to ensure that 
        ** this does not happen. Otherwise, for WHERE clauses such as the
        ** following where there is an index on "y":
        **
        **     WHERE likelihood(x=?, 0.99) OR y=?
        **
        ** the planner may elect to "OR" together a full-table scan and an
        ** index lookup. And other similarly odd results.  */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <name><name>sSum</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rRun</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <name><name>sSum</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nOut</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereq</name></name> <operator>=</operator> <name><name>sSum</name><operator>.</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prereq</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopInsert</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x200</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"End processing OR-clause %p\n"</literal><operator>,</operator> <name>pTerm</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add all WhereLoop objects for all tables 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereLoopAddAll</name><parameter_list>(<parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mPrior</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>priorJointype</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Loop over the tables in the join, from left to right */</comment>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereLoopInit</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iTab</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pItem</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>iTab</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>mUnusable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iTab</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name> <operator>=</operator> <call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name><operator>|</operator><name>priorJointype</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_CROSS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* This condition is true when pItem is the FROM clause term on the
      ** right-hand-side of a LEFT or CROSS JOIN.  */</comment>
      <expr_stmt><expr><name>mExtra</name> <operator>=</operator> <name>mPrior</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>priorJointype</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><operator>&amp;</operator><name><name>pItem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name>p</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>mUnusable</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_CROSS</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mUnusable</name> <operator>|=</operator> <call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddVirtual</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mExtra</name></expr></argument>, <argument><expr><name>mUnusable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddBtree</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddOr</name><argument_list>(<argument><expr><name>pBuilder</name></expr></argument>, <argument><expr><name>mExtra</name></expr></argument>, <argument><expr><name>mUnusable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>mPrior</name> <operator>|=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>whereLoopClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Examine a WherePath (with the addition of the extra WhereLoop of the 5th
** parameters) to see if it outputs rows in the requested ORDER BY
** (or GROUP BY) without requiring a separate sort operation.  Return N:
** 
**   N&gt;0:   N terms of the ORDER BY clause are satisfied
**   N==0:  No terms of the ORDER BY clause are satisfied
**   N&lt;0:   Unknown yet how many terms of ORDER BY might be satisfied.   
**
** Note that processing for WHERE_GROUPBY and WHERE_DISTINCTBY is not as
** strict.  With GROUP BY and DISTINCT the only requirement is that
** equivalent rows appear immediately adjacent to one another.  GROUP BY
** and DISTINCT do not require rows to appear in any particular order as long
** as equivalent rows are grouped together.  Thus for GROUP BY and DISTINCT
** the pOrderBy terms can be matched in any order.  With ORDER BY, the 
** pOrderBy terms must be matched in strict left-to-right order.
*/</comment>
<function><type><specifier>static</specifier> <name>i8</name></type> <name>wherePathSatisfiesOrderBy</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,    <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,   <comment type="block">/* ORDER BY or GROUP BY or DISTINCT clause to check */</comment>
  <parameter><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>pPath</name></decl></parameter>,     <comment type="block">/* The WherePath to check */</comment>
  <parameter><decl><type><name>u16</name></type> <name>wctrlFlags</name></decl></parameter>,       <comment type="block">/* Might contain WHERE_GROUPBY or WHERE_DISTINCTBY */</comment>
  <parameter><decl><type><name>u16</name></type> <name>nLoop</name></decl></parameter>,            <comment type="block">/* Number of entries in pPath-&gt;aLoop[] */</comment>
  <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLast</name></decl></parameter>,     <comment type="block">/* Add this WhereLoop to the end of pPath-&gt;aLoop[] */</comment>
  <parameter><decl><type><name>Bitmask</name> <modifier>*</modifier></type><name>pRevMask</name></decl></parameter>     <comment type="block">/* OUT: Mask of WhereLoops to run in reverse order */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>revSet</name></decl>;</decl_stmt>            <comment type="block">/* True if rev is known */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>rev</name></decl>;</decl_stmt>               <comment type="block">/* Composite sort order */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>revIdx</name></decl>;</decl_stmt>            <comment type="block">/* Index sort order */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isOrderDistinct</name></decl>;</decl_stmt>   <comment type="block">/* All prior WhereLoops are order-distinct */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>distinctColumns</name></decl>;</decl_stmt>   <comment type="block">/* True if the loop has UNIQUE NOT NULL columns */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isMatch</name></decl>;</decl_stmt>           <comment type="block">/* iColumn matches a term of the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nKeyCol</name></decl>;</decl_stmt>          <comment type="block">/* Number of key columns in pIndex */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nColumn</name></decl>;</decl_stmt>          <comment type="block">/* Total number of ordered columns in the index */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nOrderBy</name></decl>;</decl_stmt>         <comment type="block">/* Number terms in the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLoop</name></decl>;</decl_stmt>            <comment type="block">/* Index of WhereLoop in pPath being processed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>             <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>             <comment type="block">/* Cursor number for current WhereLoop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name></decl>;</decl_stmt>          <comment type="block">/* A column number within table iCur */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Current WhereLoop being processed. */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>     <comment type="block">/* A single term of the WHERE clause */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOBExpr</name></decl>;</decl_stmt>        <comment type="block">/* An expression from the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>       <comment type="block">/* COLLATE function from an ORDER BY clause term */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl>;</decl_stmt>        <comment type="block">/* The index associated with pLoop */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>obSat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Mask of ORDER BY terms satisfied so far */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>obDone</name></decl>;</decl_stmt>       <comment type="block">/* Mask of all ORDER BY terms */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>orderDistinctMask</name></decl>;</decl_stmt>  <comment type="block">/* Mask of all well-ordered loops */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>ready</name></decl>;</decl_stmt>              <comment type="block">/* Mask of inner loops */</comment>

  <comment type="block">/*
  ** We say the WhereLoop is "one-row" if it generates no more than one
  ** row of output.  A WhereLoop is one-row if all of the following are true:
  **  (a) All index columns match with WHERE_COLUMN_EQ.
  **  (b) The index is unique
  ** Any WhereLoop with an WHERE_COLUMN_EQ constraint on the rowid is one-row.
  ** Every one-row WhereLoop will have the WHERE_ONEROW bit set in wsFlags.
  **
  ** We say the WhereLoop is "order-distinct" if the set of columns from
  ** that WhereLoop that are in the ORDER BY clause are different for every
  ** row of the WhereLoop.  Every one-row WhereLoop is automatically
  ** order-distinct.   A WhereLoop that has no columns in the ORDER BY clause
  ** is not order-distinct. To be order-distinct is not quite the same as being
  ** UNIQUE since a UNIQUE column or index can have multiple rows that 
  ** are NULL and NULL values are equivalent for the purpose of order-distinct.
  ** To be order-distinct, the columns must be UNIQUE and NOT NULL.
  **
  ** The rowid for a table is always UNIQUE and NOT NULL so whenever the
  ** rowid appears in the ORDER BY clause, the corresponding WhereLoop is
  ** automatically order-distinct.
  */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nLoop</name> <operator>&amp;&amp;</operator> <call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OrderByIdxJoin</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nOrderBy</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOrderBy</name><operator>&gt;</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Cannot optimize overly large ORDER BYs */</comment>
  <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>obDone</name> <operator>=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>nOrderBy</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>orderDistinctMask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>ready</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iLoop</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>isOrderDistinct</name> <operator>&amp;&amp;</operator> <name>obSat</name><operator>&lt;</operator><name>obDone</name> <operator>&amp;&amp;</operator> <name>iLoop</name><operator>&lt;=</operator><name>nLoop</name></expr>;</condition> <incr><expr><name>iLoop</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iLoop</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ready</name> <operator>|=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <ternary><condition><expr><name>iLoop</name><operator>&lt;</operator><name>nLoop</name></expr> ?</condition><then> <expr><name><name>pPath</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>iLoop</name></expr>]</index></name></expr> </then><else>: <expr><name>pLast</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>isOrdered</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>obSat</name> <operator>=</operator> <name>obDone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLoop</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>

    <comment type="block">/* Mark off any ORDER BY term X that is a column in the table of
    ** the current loop for which there is term in the WHERE
    ** clause of the form X IS NULL or X=? that reference only outer
    ** loops.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>obSat</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pOBExpr</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name>iCur</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>sqlite3WhereFindTerm</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>,
                       <argument><expr><operator>~</operator><name>ready</name></expr></argument>, <argument><expr><name>WO_EQ</name><operator>|</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_IS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pTerm</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>&amp;</operator><operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOBExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pColl</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>z1</name> <operator>=</operator> <name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pColl</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>z2</name> <operator>=</operator> <name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>obSat</name> <operator>|=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEROW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IPK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nKeyCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>pIndex</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>bUnordered</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nKeyCol</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nColumn</name><operator>==</operator><name>nKeyCol</name><operator>+</operator><literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>XN_ROWID</name>
                          <operator>||</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Loop through all columns of the index and deal with the ones
      ** that are not constrained by == or IN.
      */</comment>
      <expr_stmt><expr><name>rev</name> <operator>=</operator> <name>revSet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>distinctColumns</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>bOnce</name></decl>;</decl_stmt>   <comment type="block">/* True to run the ORDER BY search loop */</comment>

        <comment type="block">/* Skip over == and IS NULL terms */</comment>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name>
         <operator>&amp;&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>i</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>eOperator</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>isOrderDistinct</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <continue>continue;</continue>  
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Get the column number in the table (iColumn) and sort order
        ** (revIdx) for the j-th column of the index.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>pIndex</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>revIdx</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>==</operator><name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name>XN_ROWID</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>revIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* An unconstrained column that might be NULL means that this
        ** WhereLoop is not well-ordered
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>isOrderDistinct</name>
         <operator>&amp;&amp;</operator> <name>iColumn</name><operator>&gt;=</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <name>j</name><operator>&gt;=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name>
         <operator>&amp;&amp;</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iColumn</name></expr>]</index></name><operator>.</operator><name>notNull</name><operator>==</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Find the ORDER BY term that corresponds to the j-th column
        ** of the index and mark that ORDER BY term off 
        */</comment>
        <expr_stmt><expr><name>bOnce</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>isMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>bOnce</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>obSat</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>pOBExpr</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_GROUPBY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_DISTINCTBY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_GROUPBY</name><operator>|</operator><name>WHERE_DISTINCTBY</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bOnce</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>&gt;=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name>iCur</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pOBExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name>iColumn</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pOBExpr</name></expr></argument>,<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>,<argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pColl</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>isMatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>isMatch</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_GROUPBY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Make sure the sort order is compatible in an ORDER BY clause.
          ** Sort order is irrelevant for a GROUP BY clause. */</comment>
          <if_stmt><if>if<condition>( <expr><name>revSet</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rev</name> <operator>^</operator> <name>revIdx</name><operator>)</operator><operator>!=</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sortOrder</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>isMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>rev</name> <operator>=</operator> <name>revIdx</name> <operator>^</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sortOrder</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rev</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRevMask</name> <operator>|=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>iLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>revSet</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>isMatch</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>distinctColumns</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>distinctColumns</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>obSat</name> <operator>|=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* No match found */</comment>
          <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>j</name><operator>&lt;</operator><name>nKeyCol</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>isOrderDistinct</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for> <comment type="block">/* end Loop over all index columns */</comment>
      <if_stmt><if>if<condition>( <expr><name>distinctColumns</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>isOrderDistinct</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isOrderDistinct</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt> <comment type="block">/* end-if not one-row */</comment>

    <comment type="block">/* Mark off any other ORDER BY terms that reference pLoop */</comment>
    <if_stmt><if>if<condition>( <expr><name>isOrderDistinct</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>orderDistinctMask</name> <operator>|=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>mTerm</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>obSat</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mTerm</name> <operator>=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>mTerm</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mTerm</name><operator>&amp;</operator><operator>~</operator><name>orderDistinctMask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>obSat</name> <operator>|=</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for> <comment type="block">/* End the loop over all WhereLoops from outer-most down to inner-most */</comment>
  <if_stmt><if>if<condition>( <expr><name>obSat</name><operator>==</operator><name>obDone</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>i8</name><operator>)</operator><name>nOrderBy</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isOrderDistinct</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nOrderBy</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name> <init>= <expr><call><name>MASKBIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>obSat</name><operator>&amp;</operator><name>m</name><operator>)</operator><operator>==</operator><name>m</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** If the WHERE_GROUPBY flag is set in the mask passed to sqlite3WhereBegin(),
** the planner assumes that the specified pOrderBy list is actually a GROUP
** BY clause - and so any order that groups rows as required satisfies the
** request.
**
** Normally, in this case it is not possible for the caller to determine
** whether or not the rows are really being delivered in sorted order, or
** just in some other order that provides the required grouping. However,
** if the WHERE_SORTBYGROUP flag is also passed to sqlite3WhereBegin(), then
** this function may be called on the returned WhereInfo object. It returns
** true if the rows really will be sorted in the specified order, or false
** otherwise.
**
** For example, assuming:
**
**   CREATE INDEX i1 ON t1(x, Y);
**
** then
**
**   SELECT * FROM t1 GROUP BY x,y ORDER BY x,y;   -- IsSorted()==1
**   SELECT * FROM t1 GROUP BY y,x ORDER BY y,x;   -- IsSorted()==0
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereIsSorted</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_GROUPBY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_SORTBYGROUP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>sorted</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
<comment type="block">/* For debugging use only: */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wherePathName</name><parameter_list>(<parameter><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>pPath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLoop</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>zName</name><index>[<expr><literal type="number">65</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <expr_stmt><expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pPath</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>cId</name></expr>;</expr_stmt> </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pLast</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zName</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pLast</name><operator>-&gt;</operator><name>cId</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>zName</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return the cost of sorting nRow rows, assuming that the keys have 
** nOrderby columns and that the first nSorted columns are already in
** order.
*/</comment>
<function><type><specifier>static</specifier> <name>LogEst</name></type> <name>whereSortingCost</name><parameter_list>(
  <parameter><decl><type><name>LogEst</name></type> <name>nRow</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nOrderBy</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nSorted</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <comment type="block">/* TUNING: Estimated cost of a full external sort, where N is 
  ** the number of rows to sort is:
  **
  **   cost = (3.0 * N * log(N)).
  ** 
  ** Or, if the order-by clause has X terms but only the last Y 
  ** terms are out of order, then block-sorting will reduce the 
  ** sorting cost to:
  **
  **   cost = (3.0 * N * log(N)) * (Y/X)
  **
  ** The (Y/X) term is implemented using stack variable rScale
  ** below.  */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>rScale</name></decl>, <decl><type ref="prev"/><name>rSortCost</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOrderBy</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">66</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rScale</name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><operator>(</operator><name>nOrderBy</name><operator>-</operator><name>nSorted</name><operator>)</operator><operator>*</operator><literal type="number">100</literal><operator>/</operator><name>nOrderBy</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">66</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rSortCost</name> <operator>=</operator> <name>nRow</name> <operator>+</operator> <call><name>estLog</name><argument_list>(<argument><expr><name>nRow</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>rScale</name> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>
  <return>return <expr><name>rSortCost</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given the list of WhereLoop objects at pWInfo-&gt;pLoops, this routine
** attempts to find the lowest cost path that visits each WhereLoop
** once.  This path is then loaded into the pWInfo-&gt;a[].pWLoop fields.
**
** Assume that the total number of output rows that will need to be sorted
** will be nRowEst (in the 10*log2 representation).  Or, ignore sorting
** costs if nRowEst==0.
**
** Return SQLITE_OK on success or SQLITE_NOMEM of a memory allocation
** error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>wherePathSolver</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>, <parameter><decl><type><name>LogEst</name></type> <name>nRowEst</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>mxChoice</name></decl>;</decl_stmt>             <comment type="block">/* Maximum number of simultaneous paths tracked */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLoop</name></decl>;</decl_stmt>                <comment type="block">/* Number of terms in the join */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>            <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>              <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLoop</name></decl>;</decl_stmt>                <comment type="block">/* Loop counter over the terms of the join */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>;</decl_stmt>               <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxI</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Index of next entry to replace */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOrderBy</name></decl>;</decl_stmt>             <comment type="block">/* Number of ORDER BY clause terms */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>mxCost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Maximum cost of a set of paths */</comment>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>mxUnsorted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Maximum unsorted cost of a set of path */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTo</name></decl>, <decl><type ref="prev"/><name>nFrom</name></decl>;</decl_stmt>           <comment type="block">/* Number of valid entries in aTo[] and aFrom[] */</comment>
  <decl_stmt><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>aFrom</name></decl>;</decl_stmt>         <comment type="block">/* All nFrom paths at the previous level */</comment>
  <decl_stmt><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>aTo</name></decl>;</decl_stmt>           <comment type="block">/* The nTo best paths at the current level */</comment>
  <decl_stmt><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>pFrom</name></decl>;</decl_stmt>         <comment type="block">/* An element of aFrom[] that we are working on */</comment>
  <decl_stmt><decl><type><name>WherePath</name> <modifier>*</modifier></type><name>pTo</name></decl>;</decl_stmt>           <comment type="block">/* An element of aTo[] that we are working on */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pWLoop</name></decl>;</decl_stmt>        <comment type="block">/* One of the WhereLoop objects */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier><modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>           <comment type="block">/* Used to divy up the pSpace memory */</comment>
  <decl_stmt><decl><type><name>LogEst</name> <modifier>*</modifier></type><name>aSortCost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Sorting and partial sorting costs */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pSpace</name></decl>;</decl_stmt>             <comment type="block">/* Temporary memory used by this routine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSpace</name></decl>;</decl_stmt>               <comment type="block">/* Bytes of space allocated at pSpace */</comment>

  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nLoop</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>;</expr_stmt>
  <comment type="block">/* TUNING: For simple queries, only the best path is tracked.
  ** For 2-way joins, the 5 best paths are followed.
  ** For joins of 3 or more tables, track the 10 best paths */</comment>
  <expr_stmt><expr><name>mxChoice</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nLoop</name><operator>&lt;=</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>nLoop</name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">5</literal></expr> </then><else>: <expr><literal type="number">10</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nLoop</name><operator>&lt;=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x002</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"---- begin solver.  (nRowEst=%d)\n"</literal><operator>,</operator> <name>nRowEst</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If nRowEst is zero and there is an ORDER BY clause, ignore it. In this
  ** case the purpose of this call is to estimate the number of rows returned
  ** by the overall query. Once this estimate has been obtained, the caller
  ** will invoke this function a second time, passing the estimate as the
  ** nRowEst parameter.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nRowEst</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nOrderBy</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Allocate and initialize space for aTo, aFrom and aSortCost[] */</comment>
  <expr_stmt><expr><name>nSpace</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>WherePath</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>WhereLoop</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nLoop</name><operator>)</operator><operator>*</operator><name>mxChoice</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSpace</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogEst</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSpace</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSpace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>aTo</name> <operator>=</operator> <operator>(</operator><name>WherePath</name><operator>*</operator><operator>)</operator><name>pSpace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aFrom</name> <operator>=</operator> <name>aTo</name><operator>+</operator><name>mxChoice</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aFrom</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pX</name> <operator>=</operator> <operator>(</operator><name>WhereLoop</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>aFrom</name><operator>+</operator><name>mxChoice</name><operator>)</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name>mxChoice</name><operator>*</operator><literal type="number">2</literal></expr><operator>,</operator> <expr><name>pFrom</name><operator>=</operator><name>aTo</name></expr>;</init> <condition><expr><name>ii</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>ii</name><operator>--</operator></expr><operator>,</operator> <expr><name>pFrom</name><operator>++</operator></expr><operator>,</operator> <expr><name>pX</name> <operator>+=</operator> <name>nLoop</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name></name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>nOrderBy</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there is an ORDER BY clause and it is not being ignored, set up
    ** space for the aSortCost[] array. Each element of the aSortCost array
    ** is either zero - meaning it has not yet been initialized - or the
    ** cost of sorting nRowEst rows of data where the first X terms of
    ** the ORDER BY clause are already in order, where X is the array 
    ** index.  */</comment>
    <expr_stmt><expr><name>aSortCost</name> <operator>=</operator> <operator>(</operator><name>LogEst</name><operator>*</operator><operator>)</operator><name>pX</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aSortCost</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LogEst</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aSortCost</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>&amp;</operator><name><name>pSpace</name><index>[<expr><name>nSpace</name></expr>]</index></name><operator>==</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aSortCost</name><index>[<expr><name>nOrderBy</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aSortCost</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>&amp;</operator><name><name>pSpace</name><index>[<expr><name>nSpace</name></expr>]</index></name><operator>==</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Seed the search with a single WherePath containing zero WhereLoops.
  **
  ** TUNING: Do not let the number of iterations go above 28.  If the cost
  ** of computing an automatic index is not paid back within the first 28
  ** rows, then do not use the automatic index. */</comment>
  <expr_stmt><expr><name><name>aFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nRow</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name></expr></argument>, <argument><expr><literal type="number">48</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">48</literal><operator>==</operator><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nFrom</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isOrdered</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOrderBy</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If nLoop is zero, then there are no FROM terms in the query. Since
    ** in this case the query may return a maximum of one row, the results
    ** are already in the requested order. Set isOrdered to nOrderBy to
    ** indicate this. Or, if nLoop is greater than zero, set isOrdered to
    ** -1, indicating that the result set may or may not be ordered, 
    ** depending on the loops added to the current plan.  */</comment>
    <expr_stmt><expr><name><name>aFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isOrdered</name> <operator>=</operator> <ternary><condition><expr><name>nLoop</name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>nOrderBy</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compute successively longer WherePaths using the previous generation
  ** of WherePaths as the basis for the next.  Keep track of the mxChoice
  ** best paths at each generation */</comment>
  <for>for<control>(<init><expr><name>iLoop</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iLoop</name><operator>&lt;</operator><name>nLoop</name></expr>;</condition> <incr><expr><name>iLoop</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nTo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pFrom</name><operator>=</operator><name>aFrom</name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nFrom</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>pFrom</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>pWLoop</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr>;</init> <condition><expr><name>pWLoop</name></expr>;</condition> <incr><expr><name>pWLoop</name><operator>=</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>LogEst</name></type> <name>nOut</name></decl>;</decl_stmt>                      <comment type="block">/* Rows visited by (pFrom+pWLoop) */</comment>
        <decl_stmt><decl><type><name>LogEst</name></type> <name>rCost</name></decl>;</decl_stmt>                     <comment type="block">/* Cost of path (pFrom+pWLoop) */</comment>
        <decl_stmt><decl><type><name>LogEst</name></type> <name>rUnsorted</name></decl>;</decl_stmt>                 <comment type="block">/* Unsorted cost of (pFrom+pWLoop) */</comment>
        <decl_stmt><decl><type><name>i8</name></type> <name>isOrdered</name> <init>= <expr><name><name>pFrom</name><operator>-&gt;</operator><name>isOrdered</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* isOrdered for (pFrom+pWLoop) */</comment>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>maskNew</name></decl>;</decl_stmt>                  <comment type="block">/* Mask of src visited by (..) */</comment>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>revMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Mask of rev-order loops for (..) */</comment>

        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>prereq</name></name> <operator>&amp;</operator> <operator>~</operator><name><name>pFrom</name><operator>-&gt;</operator><name>maskLoop</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>maskSelf</name></name> <operator>&amp;</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>maskLoop</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* At this point, pWLoop is a candidate to be the next loop. 
        ** Compute its cost */</comment>
        <expr_stmt><expr><name>rUnsorted</name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name><name>pWLoop</name><operator>-&gt;</operator><name>rSetup</name></name></expr></argument>,<argument><expr><name><name>pWLoop</name><operator>-&gt;</operator><name>rRun</name></name> <operator>+</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rUnsorted</name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name>rUnsorted</name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>rUnsorted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nOut</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>nRow</name></name> <operator>+</operator> <name><name>pWLoop</name><operator>-&gt;</operator><name>nOut</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>maskNew</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>maskLoop</name></name> <operator>|</operator> <name><name>pWLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>isOrdered</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>isOrdered</name> <operator>=</operator> <call><name>wherePathSatisfiesOrderBy</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>,
                       <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name></expr></argument>,
                       <argument><expr><name>iLoop</name></expr></argument>, <argument><expr><name>pWLoop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>revMask</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>revLoop</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>isOrdered</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>isOrdered</name><operator>&lt;</operator><name>nOrderBy</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>aSortCost</name><index>[<expr><name>isOrdered</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>aSortCost</name><index>[<expr><name>isOrdered</name></expr>]</index></name> <operator>=</operator> <call><name>whereSortingCost</name><argument_list>(
                <argument><expr><name>nRowEst</name></expr></argument>, <argument><expr><name>nOrderBy</name></expr></argument>, <argument><expr><name>isOrdered</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>rCost</name> <operator>=</operator> <call><name>sqlite3LogEstAdd</name><argument_list>(<argument><expr><name>rUnsorted</name></expr></argument>, <argument><expr><name><name>aSortCost</name><index>[<expr><name>isOrdered</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0x002</literal></expr></argument>,
              <argument><expr><operator>(</operator><literal type="string">"---- sort cost=%-3d (%d/%d) increases cost %3d to %-3d\n"</literal><operator>,</operator>
               <name><name>aSortCost</name><index>[<expr><name>isOrdered</name></expr>]</index></name><operator>,</operator> <operator>(</operator><name>nOrderBy</name><operator>-</operator><name>isOrdered</name><operator>)</operator><operator>,</operator> <name>nOrderBy</name><operator>,</operator> 
               <name>rUnsorted</name><operator>,</operator> <name>rCost</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rCost</name> <operator>=</operator> <name>rUnsorted</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Check to see if pWLoop should be added to the set of
        ** mxChoice best-so-far paths.
        **
        ** First look for an existing path among best-so-far paths
        ** that covers the same set of loops and has the same isOrdered
        ** setting as the current path candidate.
        **
        ** The term "((pTo-&gt;isOrdered^isOrdered)&amp;0x80)==0" is equivalent
        ** to (pTo-&gt;isOrdered==(-1))==(isOrdered==(-1))" for the range
        ** of legal values for isOrdered, -1..64.
        */</comment>
        <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTo</name><operator>=</operator><name>aTo</name></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>nTo</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTo</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>maskLoop</name></name><operator>==</operator><name>maskNew</name>
           <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>^</operator><name>isOrdered</name><operator>)</operator><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jj</name><operator>==</operator><name>nTo</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>jj</name><operator>&gt;=</operator><name>nTo</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* None of the existing best-so-far paths match the candidate. */</comment>
          <if_stmt><if>if<condition>( <expr><name>nTo</name><operator>&gt;=</operator><name>mxChoice</name>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>rCost</name><operator>&gt;</operator><name>mxCost</name> <operator>||</operator> <operator>(</operator><name>rCost</name><operator>==</operator><name>mxCost</name> <operator>&amp;&amp;</operator> <name>rUnsorted</name><operator>&gt;=</operator><name>mxUnsorted</name><operator>)</operator><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <comment type="block">/* The current candidate is no better than any of the mxChoice
            ** paths currently in the best-so-far buffer.  So discard
            ** this candidate as not viable. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef> <comment type="block">/* 0x4 */</comment>
            <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name><operator>&amp;</operator><literal type="number">0x4</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"Skip   %s cost=%-3d,%3d order=%c\n"</literal></expr></argument>,
                  <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>iLoop</name></expr></argument>, <argument><expr><name>pWLoop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rCost</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>,
                  <argument><expr><ternary><condition><expr><name>isOrdered</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>isOrdered</name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <comment type="block">/* If we reach this points it means that the new candidate path
          ** needs to be added to the set of best-so-far paths. */</comment>
          <if_stmt><if>if<condition>( <expr><name>nTo</name><operator>&lt;</operator><name>mxChoice</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* Increase the size of the aTo set by one */</comment>
            <expr_stmt><expr><name>jj</name> <operator>=</operator> <name>nTo</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <comment type="block">/* New path replaces the prior worst to keep count below mxChoice */</comment>
            <expr_stmt><expr><name>jj</name> <operator>=</operator> <name>mxI</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>pTo</name> <operator>=</operator> <operator>&amp;</operator><name><name>aTo</name><index>[<expr><name>jj</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef> <comment type="block">/* 0x4 */</comment>
          <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name><operator>&amp;</operator><literal type="number">0x4</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"New    %s cost=%-3d,%3d order=%c\n"</literal></expr></argument>,
                <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>iLoop</name></expr></argument>, <argument><expr><name>pWLoop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rCost</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>,
                <argument><expr><ternary><condition><expr><name>isOrdered</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>isOrdered</name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Control reaches here if best-so-far path pTo=aTo[jj] covers the
          ** same set of loops and has the sam isOrdered setting as the
          ** candidate path.  Check to see if the candidate should replace
          ** pTo or if the candidate should be skipped */</comment>
          <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>&lt;</operator><name>rCost</name> <operator>||</operator> <operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>==</operator><name>rCost</name> <operator>&amp;&amp;</operator> <name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name><operator>&lt;=</operator><name>nOut</name><operator>)</operator></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef> <comment type="block">/* 0x4 */</comment>
            <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name><operator>&amp;</operator><literal type="number">0x4</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(
                  <argument><expr><literal type="string">"Skip   %s cost=%-3d,%3d order=%c"</literal></expr></argument>,
                  <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>iLoop</name></expr></argument>, <argument><expr><name>pWLoop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rCost</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>,
                  <argument><expr><ternary><condition><expr><name>isOrdered</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>isOrdered</name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"   vs %s cost=%-3d,%d order=%c\n"</literal></expr></argument>,
                  <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>iLoop</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument>,
                  <argument><expr><ternary><condition><expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* Discard the candidate path from further consideration */</comment>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>==</operator><name>rCost</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>==</operator><name>rCost</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* Control reaches here if the candidate path is better than the
          ** pTo path.  Replace pTo with the candidate. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef> <comment type="block">/* 0x4 */</comment>
          <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name><operator>&amp;</operator><literal type="number">0x4</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(
                <argument><expr><literal type="string">"Update %s cost=%-3d,%3d order=%c"</literal></expr></argument>,
                <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>iLoop</name></expr></argument>, <argument><expr><name>pWLoop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rCost</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>,
                <argument><expr><ternary><condition><expr><name>isOrdered</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>isOrdered</name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  was %s cost=%-3d,%3d order=%c\n"</literal></expr></argument>,
                <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>iLoop</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument>,
                <argument><expr><ternary><condition><expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>+</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* pWLoop is a winner.  Add it to the set of best so far */</comment>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>maskLoop</name></name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>maskLoop</name></name> <operator>|</operator> <name><name>pWLoop</name><operator>-&gt;</operator><name>maskSelf</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>revLoop</name></name> <operator>=</operator> <name>revMask</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name> <operator>=</operator> <name>rCost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>rUnsorted</name></name> <operator>=</operator> <name>rUnsorted</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name> <operator>=</operator> <name>isOrdered</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>aLoop</name></name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WhereLoop</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>iLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTo</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>iLoop</name></expr>]</index></name> <operator>=</operator> <name>pWLoop</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nTo</name><operator>&gt;=</operator><name>mxChoice</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mxI</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>mxCost</name> <operator>=</operator> <name><name>aTo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rCost</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>mxUnsorted</name> <operator>=</operator> <name><name>aTo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nRow</name></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>pTo</name><operator>=</operator><operator>&amp;</operator><name><name>aTo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>mxChoice</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTo</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>&gt;</operator><name>mxCost</name> 
             <operator>||</operator> <operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name><operator>==</operator><name>mxCost</name> <operator>&amp;&amp;</operator> <name><name>pTo</name><operator>-&gt;</operator><name>rUnsorted</name></name><operator>&gt;</operator><name>mxUnsorted</name><operator>)</operator></expr> 
            )</condition><block>{<block_content>
              <expr_stmt><expr><name>mxCost</name> <operator>=</operator> <name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name>mxUnsorted</name> <operator>=</operator> <name><name>pTo</name><operator>-&gt;</operator><name>rUnsorted</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name>mxI</name> <operator>=</operator> <name>jj</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>  <comment type="block">/* &gt;=2 */</comment>
    <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x02</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"---- after round %d ----\n"</literal></expr></argument>, <argument><expr><name>iLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTo</name><operator>=</operator><name>aTo</name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTo</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTo</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" %s cost=%-3d nrow=%-3d order=%c"</literal></expr></argument>,
           <argument><expr><call><name>wherePathName</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>iLoop</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>rCost</name></name></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument>,
           <argument><expr><ternary><condition><expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>+</operator><literal type="char">'0'</literal><operator>)</operator></expr> </then><else>: <expr><literal type="char">'?'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTo</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" rev=0x%llx\n"</literal></expr></argument>, <argument><expr><name><name>pTo</name><operator>-&gt;</operator><name>revLoop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Swap the roles of aFrom and aTo for the next generation */</comment>
    <expr_stmt><expr><name>pFrom</name> <operator>=</operator> <name>aTo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aTo</name> <operator>=</operator> <name>aFrom</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aFrom</name> <operator>=</operator> <name>pFrom</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nFrom</name> <operator>=</operator> <name>nTo</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>nFrom</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no query solution"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Find the lowest cost path.  pFrom will be left pointing to that path */</comment>
  <expr_stmt><expr><name>pFrom</name> <operator>=</operator> <name>aFrom</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nFrom</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>rCost</name></name><operator>&gt;</operator><name><name>aFrom</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>rCost</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pFrom</name> <operator>=</operator> <operator>&amp;</operator><name><name>aFrom</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>==</operator><name>nLoop</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Load the lowest cost path into pWInfo */</comment>
  <for>for<control>(<init><expr><name>iLoop</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iLoop</name><operator>&lt;</operator><name>nLoop</name></expr>;</condition> <incr><expr><name>iLoop</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name>iLoop</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name> <operator>=</operator> <name>pWLoop</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>iLoop</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name> <operator>=</operator> <name><name>pWLoop</name><operator>-&gt;</operator><name>iTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_DISTINCTBY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name><operator>==</operator><name>WHERE_DISTINCT_NOOP</name>
   <operator>&amp;&amp;</operator> <name>nRowEst</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>notUsed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>wherePathSatisfiesOrderBy</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pResultSet</name></name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>,
                 <argument><expr><name>WHERE_DISTINCTBY</name></expr></argument>, <argument><expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>notUsed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pResultSet</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_ORDERED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_DISTINCTBY</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pFrom</name><operator>-&gt;</operator><name>isOrdered</name></name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_ORDERED</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>isOrdered</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>revLoop</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_SORTBYGROUP</name><operator>)</operator>
        <operator>&amp;&amp;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>&amp;&amp;</operator> <name>nLoop</name><operator>&gt;</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>revMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nOrder</name> <init>= <expr><call><name>wherePathSatisfiesOrderBy</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, 
          <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>aLoop</name><index>[<expr><name>nLoop</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revMask</name></expr></argument>
      )</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>sorted</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nOrder</name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name> <operator>=</operator> <name>revMask</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>


  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>nRow</name></name></expr>;</expr_stmt>

  <comment type="block">/* Free temporary memory and return success */</comment>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Most queries use only a single table (they are not joins) and have
** simple == constraints against indexed fields.  This routine attempts
** to plan those simple cases using much less ceremony than the
** general-purpose query planner, and thereby yield faster sqlite3_prepare()
** times for the common case.
**
** Return non-zero on success, if this query can be handled by this
** no-frills query planner.  Return zero if this query needs the 
** general-purpose query planner.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereShortCut</name><parameter_list>(<parameter><decl><type><name>WhereLoopBuilder</name> <modifier>*</modifier></type><name>pBuilder</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pWInfo</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_FORCE_TABLE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pBuilder</name><operator>-&gt;</operator><name>pNew</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>sqlite3WhereFindTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WO_EQ</name><operator>|</operator><name>WO_IS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTerm</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_COLUMN_EQ</name><operator>|</operator><name>WHERE_IPK</name><operator>|</operator><name>WHERE_ONEROW</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* TUNING: Cost of a rowid lookup is 10 */</comment>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <literal type="number">33</literal></expr>;</expr_stmt>  <comment type="block">/* 33==sqlite3LogEst(10) */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>opMask</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTermSpace</name></name><operator>==</operator><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call>
       <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>!=</operator><literal type="number">0</literal> 
       <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>&gt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTermSpace</name></name></expr></argument>)</argument_list></call></expr> 
      )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>opMask</name> <operator>=</operator> <ternary><condition><expr><name><name>pIdx</name><operator>-&gt;</operator><name>uniqNotNull</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator></expr> </then><else>: <expr><name>WO_EQ</name></expr></else></ternary></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>sqlite3WhereFindTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>opMask</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pTerm</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>!=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <name>WHERE_COLUMN_EQ</name><operator>|</operator><name>WHERE_ONEROW</name><operator>|</operator><name>WHERE_INDEXED</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>isCovering</name></name> <operator>||</operator> <operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <operator>~</operator><call><name>columnsInIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_IDX_ONLY</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
      <comment type="block">/* TUNING: Cost of a unique index lookup is 15 */</comment>
      <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>rRun</name></name> <operator>=</operator> <literal type="number">39</literal></expr>;</expr_stmt>  <comment type="block">/* 39==sqlite3LogEst(15) */</comment>
      <break>break;</break>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name> <operator>=</operator> <operator>(</operator><name>LogEst</name><operator>)</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pWLoop</name> <operator>=</operator> <name>pLoop</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name> <operator>=</operator> <call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iTabCur</name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name> <operator>=</operator>  <name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_UNIQUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>cId</name></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate the beginning of the loop used for WHERE clause processing.
** The return value is a pointer to an opaque structure that contains
** information needed to terminate the loop.  Later, the calling routine
** should invoke sqlite3WhereEnd() with the return value of this function
** in order to complete the WHERE clause processing.
**
** If an error occurs, this routine returns NULL.
**
** The basic idea is to do a nested loop, one loop for each table in
** the FROM clause of a select.  (INSERT and UPDATE statements are the
** same as a SELECT with only a single table in the FROM clause.)  For
** example, if the SQL is this:
**
**       SELECT * FROM t1, t2, t3 WHERE ...;
**
** Then the code generated is conceptually like the following:
**
**      foreach row1 in t1 do       \    Code generated
**        foreach row2 in t2 do      |-- by sqlite3WhereBegin()
**          foreach row3 in t3 do   /
**            ...
**          end                     \    Code generated
**        end                        |-- by sqlite3WhereEnd()
**      end                         /
**
** Note that the loops might not be nested in the order in which they
** appear in the FROM clause if a different order is better able to make
** use of indices.  Note also that when the IN operator appears in
** the WHERE clause, it might result in additional nested loops for
** scanning through all values on the right-hand side of the IN.
**
** There are Btree cursors associated with each table.  t1 uses cursor
** number pTabList-&gt;a[0].iCursor.  t2 uses the cursor pTabList-&gt;a[1].iCursor.
** And so forth.  This routine generates code to open those VDBE cursors
** and sqlite3WhereEnd() generates the code to close them.
**
** The code that sqlite3WhereBegin() generates leaves the cursors named
** in pTabList pointing at their appropriate entries.  The [...] code
** can use OP_Column and OP_Rowid opcodes on these cursors to extract
** data from the various tables of the loop.
**
** If the WHERE clause is empty, the foreach loops must each scan their
** entire tables.  Thus a three-way join is an O(N^3) operation.  But if
** the tables have indices and there are terms in the WHERE clause that
** refer to those indices, a complete table scan can be avoided and the
** code will run much faster.  Most of the work of this routine is checking
** to see if there are indices that can be used to speed up the loop.
**
** Terms of the WHERE clause are also used to limit which rows actually
** make it to the "..." in the middle of the loop.  After each "foreach",
** terms of the WHERE clause that use only terms in that loop and outer
** loops are evaluated and if false a jump is made around all subsequent
** inner loops (or around the "..." if the test occurs within the inner-
** most loop)
**
** OUTER JOINS
**
** An outer join of tables t1 and t2 is conceptally coded as follows:
**
**    foreach row1 in t1 do
**      flag = 0
**      foreach row2 in t2 do
**        start:
**          ...
**          flag = 1
**      end
**      if flag==0 then
**        move the row2 cursor to a null row
**        goto start
**      fi
**    end
**
** ORDER BY CLAUSE PROCESSING
**
** pOrderBy is a pointer to the ORDER BY clause (or the GROUP BY clause
** if the WHERE_GROUPBY flag is set in wctrlFlags) of a SELECT statement
** if there is one.  If there is no ORDER BY clause or if this routine
** is called from an UPDATE or DELETE statement, then pOrderBy is NULL.
**
** The iIdxCur parameter is the cursor number of an index.  If 
** WHERE_ONETABLE_ONLY is set, iIdxCur is the cursor number of an index
** to use for OR clause processing.  The WHERE clause should use this
** specific cursor.  If WHERE_ONEPASS_DESIRED is set, then iIdxCur is
** the first cursor in an array of cursors for all indices.  iIdxCur should
** be used to compute the appropriate cursor depending on which index is
** used.
*/</comment>
<function><type><name>WhereInfo</name> <modifier>*</modifier></type><name>sqlite3WhereBegin</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,    <comment type="block">/* FROM clause: A list of all tables to be scanned */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,         <comment type="block">/* The WHERE clause */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,   <comment type="block">/* An ORDER BY (or GROUP BY) clause, or NULL */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pResultSet</name></decl></parameter>, <comment type="block">/* Result set of the query */</comment>
  <parameter><decl><type><name>u16</name></type> <name>wctrlFlags</name></decl></parameter>,       <comment type="block">/* One of the WHERE_* flags defined in sqliteInt.h */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCur</name></decl></parameter>           <comment type="block">/* If WHERE_ONETABLE_ONLY is set, index cursor number */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByteWInfo</name></decl>;</decl_stmt>            <comment type="block">/* Num. bytes allocated for WhereInfo struct */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTabList</name></decl>;</decl_stmt>              <comment type="block">/* Number of elements in pTabList */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>         <comment type="block">/* Will become the return value of this function */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The virtual database engine */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>notReady</name></decl>;</decl_stmt>          <comment type="block">/* Cursors that are not yet positioned */</comment>
  <decl_stmt><decl><type><name>WhereLoopBuilder</name></type> <name>sWLB</name></decl>;</decl_stmt>     <comment type="block">/* The WhereLoop builder */</comment>
  <decl_stmt><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl>;</decl_stmt>    <comment type="block">/* The expression mask set */</comment>
  <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>        <comment type="block">/* A single level in pWInfo-&gt;a[] */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>          <comment type="block">/* Pointer to a single WhereLoop object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                    <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                    <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bFordelete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* OPFLAG_FORDELETE or zero, as appropriate */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_MULTIROW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator>
        <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_OMIT_OPEN_CLOSE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
  <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Variable initialization */</comment>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWLB</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sWLB</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* An ORDER/GROUP BY clause of more than 63 terms cannot be optimized */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pOrderBy</name> <operator>&amp;&amp;</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name> <operator>&amp;&amp;</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;=</operator><name>BMS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pOrderBy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>sWLB</name><operator>.</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the DISTINCT optimization if SQLITE_DistinctOpt is set via
  ** sqlite3_test_ctrl(SQLITE_TESTCTRL_OPTIMIZATIONS,...) */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DistinctOpt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>wctrlFlags</name> <operator>&amp;=</operator> <operator>~</operator><name>WHERE_WANT_DISTINCT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The number of tables in the FROM clause is limited by the number of
  ** bits in a Bitmask 
  */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><name>BMS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"at most %d tables in a join"</literal></expr></argument>, <argument><expr><name>BMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* This function normally generates a nested loop for all tables in 
  ** pTabList.  But if the WHERE_ONETABLE_ONLY flag is set, then we should
  ** only generate code for the first table in pTabList and assume that
  ** any cursors associated with subsequent tables are uninitialized.
  */</comment>
  <expr_stmt><expr><name>nTabList</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONETABLE_ONLY</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* Allocate and initialize the WhereInfo structure that will become the
  ** return value. A single allocation is used to store the WhereInfo
  ** struct, the contents of WhereInfo.a[], the WhereClause structure
  ** and the WhereMaskSet structure. Since WhereClause contains an 8-byte
  ** field (type Bitmask) it must be aligned on an 8-byte boundary on
  ** some architectures. Hence the ROUND8() below.
  */</comment>
  <expr_stmt><expr><name>nByteWInfo</name> <operator>=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WhereInfo</name></expr></argument>)</argument_list></sizeof><operator>+</operator><operator>(</operator><name>nTabList</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>WhereLevel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByteWInfo</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WhereLoop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <goto>goto <name>whereBeginError</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name> <operator>=</operator> <name>nTabList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name></name> <operator>=</operator> <name>pTabList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <name>pResultSet</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iBreak</name></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>iContinue</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>=</operator> <name>wctrlFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>savedNQueryLoop</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ONEPASS defaults to OFF */</comment>
  <expr_stmt><expr><name>pMaskSet</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWLB</name><operator>.</operator><name>pWInfo</name></name> <operator>=</operator> <name>pWInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWLB</name><operator>.</operator><name>pNew</name></name> <operator>=</operator> <operator>(</operator><name>WhereLoop</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pWInfo</name><operator>)</operator><operator>+</operator><name>nByteWInfo</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name><name>sWLB</name><operator>.</operator><name>pNew</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereLoopInit</name><argument_list>(<argument><expr><name><name>sWLB</name><operator>.</operator><name>pNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>sWLB</name><operator>.</operator><name>pNew</name><operator>-&gt;</operator><name>cId</name></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Split the WHERE clause into separate subexpressions where each
  ** subexpression is separated by an AND operator.
  */</comment>
  <expr_stmt><expr><call><name>initMaskSet</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WhereClauseInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WhereSplit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>TK_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Special case: a WHERE clause that is constant.  Evaluate the
  ** expression and either jump over all of the code or fall thru.
  */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nTabList</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3ExprIsConstantNotJoin</name><argument_list>(<argument><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iBreak</name></name></expr></argument>,
                         <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Special case: No FROM clause
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nTabList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name> <operator>=</operator> <name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_UNIQUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Assign a bit from the bitmask to every term in the FROM clause.
  **
  ** The N-th term of the FROM clause is assigned a bitmask of 1&lt;&lt;N.
  **
  ** The rule of the previous sentence ensures thta if X is the bitmask for
  ** a table T, then X-1 is the bitmask for all other tables to the left of T.
  ** Knowing the bitmask for all tables to the left of a left join is
  ** important.  Ticket #3015.
  **
  ** Note that bitmasks are created for all pTabList-&gt;nSrc tables in
  ** pTabList, not just the first nTabList tables.  nTabList is normally
  ** equal to pTabList-&gt;nSrc but might be shortened to 1 if the
  ** WHERE_ONETABLE_ONLY flag is set.
  */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>createMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WhereTabFuncArgs</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name> <init>= <expr><call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>m</name><operator>==</operator><call><name>MASKBIT</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Analyze all of the subexpressions. */</comment>
  <expr_stmt><expr><call><name>sqlite3WhereExprAnalyze</name><argument_list>(<argument><expr><name>pTabList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>isDistinctRedundant</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>, <argument><expr><name>pResultSet</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* The DISTINCT marking is pointless.  Ignore it. */</comment>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name> <operator>=</operator> <name>WHERE_DISTINCT_UNIQUE</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pOrderBy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Try to ORDER BY the result set to make distinct processing easier */</comment>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>|=</operator> <name>WHERE_DISTINCTBY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name>pResultSet</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Construct the WhereLoop objects */</comment>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffff</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"*** Optimizer Start *** (wctrlFlags: 0x%x)\n"</literal><operator>,</operator>
             <name>wctrlFlags</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WHERETRACE_ENABLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name> <operator>&amp;</operator> <literal type="number">0x100</literal></expr> )</condition><block>{<block_content> <comment type="block">/* Display all terms of the WHERE clause */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>whereTermPrint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>nTabList</name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <call><name>whereShortCut</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWLB</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>whereLoopAddAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWLB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name></expr> )</condition><block>{<block_content>    <comment type="block">/* Display all of the WhereLoop objects */</comment>
      <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zLabel</name><index>[]</index></name> <init>= <expr><literal type="string">"0123456789abcdefghijklmnopqrstuvwyxz"</literal>
                                             <literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWYXZ"</literal></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pLoops</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextLoop</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cId</name></name> <operator>=</operator> <name><name>zLabel</name><index>[<expr><name>i</name><operator>%</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zLabel</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>whereLoopPrint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
    <expr_stmt><expr><call><name>wherePathSolver</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>wherePathSolver</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_ReverseOrder</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name> <operator>=</operator> <operator>(</operator><name>Bitmask</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>whereBeginError</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WHERETRACE_ENABLED</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>sqlite3WhereTrace</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"---- Solution nRow=%d"</literal></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">" ORDERBY=%d,0x%llx"</literal></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eDistinct</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>WHERE_DISTINCT_UNIQUE</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  DISTINCT=unique"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>WHERE_DISTINCT_ORDERED</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  DISTINCT=ordered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>WHERE_DISTINCT_UNORDERED</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"  DISTINCT=unordered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>whereLoopPrint</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pWLoop</name></expr></argument>, <argument><expr><name><name>sWLB</name><operator>.</operator><name>pWC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* Attempt to omit tables from the join that do not effect the result */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;=</operator><literal type="number">2</literal>
   <operator>&amp;&amp;</operator> <name>pResultSet</name><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OmitNoopJoin</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>tabUsed</name> <init>= <expr><call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pResultSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sWLB</name><operator>.</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>tabUsed</name> <operator>|=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>sWLB</name><operator>.</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pWLoop</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLoop</name><operator>-&gt;</operator><name>iTab</name></name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_WANT_DISTINCT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEROW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>tabUsed</name> <operator>&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>sWLB</name><operator>.</operator><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>pTerm</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>maskSelf</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr>
        )</condition><block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pTerm</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffff</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"-&gt; drop loop %c not used\n"</literal><operator>,</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>cId</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>nTabList</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffff</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="string">"*** Optimizer Finished ***\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>+=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nRowOut</name></name></expr>;</expr_stmt>

  <comment type="block">/* If the caller is an UPDATE or DELETE statement that is requesting
  ** to use a one-pass algorithm, determine if this is appropriate.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>wsFlags</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bOnerow</name> <init>= <expr><operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_ONEROW</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>bOnerow</name>
     <operator>||</operator> <operator>(</operator><operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_MULTIROW</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name> <operator>=</operator> <ternary><condition><expr><name>bOnerow</name></expr> ?</condition><then> <expr><name>ONEPASS_SINGLE</name></expr> </then><else>: <expr><name>ONEPASS_MULTI</name></expr></else></ternary></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_MULTIROW</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bFordelete</name> <operator>=</operator> <name>OPFLAG_FORDELETE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>=</operator> <operator>(</operator><name>wsFlags</name> <operator>&amp;</operator> <operator>~</operator><name>WHERE_IDX_ONLY</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Open all tables in the pTabList and any indices selected for
  ** searching those tables.
  */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pLevel</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTabList</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>pLevel</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>     <comment type="block">/* Table to open */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>         <comment type="block">/* Index of database containing table/index */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pTabItem</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pTabItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Ephemeral</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Do nothing */</comment>
    </block_content>}</block></if><if type="elseif">else
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCur</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VOpen</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* noop */</comment>
    </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_OMIT_OPEN_CLOSE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name>OP_OpenRead</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_OpenWrite</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
      <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name><operator>==</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>&lt;</operator><name>BMS</name> <operator>&amp;&amp;</operator> <call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>b</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>colUsed</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init>;</init> <condition><expr><name>b</name></expr>;</condition> <incr><expr><name>b</name><operator>=</operator><name>b</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_SEEKEQ</name><operator>|</operator><name>bFordelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bFordelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_USED_MASK</name></cpp:ifdef>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Dup8</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ColumnsUsed</name></expr></argument>, <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>colUsed</name></name></expr></argument>, <argument><expr><name>P4_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIx</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iIndexCur</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name>OP_OpenRead</name></expr></init></decl>;</decl_stmt>
      <comment type="block">/* iIdxCur is always set if to a positive value if ONEPASS is possible */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIdxCur</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIx</name></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONETABLE_ONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* This is one term of an OR-optimization using the PRIMARY KEY of a
        ** WITHOUT ROWID table.  No need for a separate index */</comment>
        <expr_stmt><expr><name>iIndexCur</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pJ</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>iIndexCur</name> <operator>=</operator> <name>iIdxCur</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONEPASS_DESIRED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pJ</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pJ</name><operator>!=</operator><name>pIx</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iIndexCur</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pJ</name> <operator>=</operator> <name><name>pJ</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_OpenWrite</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>iIndexCur</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iIdxCur</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_ONETABLE_ONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iIndexCur</name> <operator>=</operator> <name>iIdxCur</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>wctrlFlags</name> <operator>&amp;</operator> <name>WHERE_REOPEN_IDX</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_ReopenIdx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iIndexCur</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name> <operator>=</operator> <name>iIndexCur</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIx</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIndexCur</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIndexCur</name></expr></argument>, <argument><expr><name><name>pIx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_CONSTRAINT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_COLUMN_RANGE</name><operator>|</operator><name>WHERE_SKIPSCAN</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name><operator>&amp;</operator><name>WHERE_ORDERBY_MIN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_SEEKEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Hint to COMDB2 */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pIx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_USED_MASK</name></cpp:ifdef>
        <block>{<block_content>
          <decl_stmt><decl><type><name>u64</name></type> <name>colUsed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pIx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name>jj</name> <operator>=</operator> <name><name>pIx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>jj</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>jj</name><operator>&gt;</operator><literal type="number">63</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>jj</name> <operator>=</operator> <literal type="number">63</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>&amp;</operator> <call><name>MASKBIT</name><argument_list>(<argument><expr><name>jj</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>colUsed</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><operator>(</operator><ternary><condition><expr><name>ii</name><operator>&lt;</operator><literal type="number">63</literal></expr> ?</condition><then> <expr><name>ii</name></expr> </then><else>: <expr><literal type="number">63</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Dup8</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ColumnsUsed</name></expr></argument>, <argument><expr><name>iIndexCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>colUsed</name></expr></argument>, <argument><expr><name>P4_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_COLUMN_USED_MASK */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iTop</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Generate the code to do the search.  Each iteration of the for
  ** loop below generates code for a single nested loop of the VM
  ** program.
  */</comment>
  <expr_stmt><expr><name>notReady</name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTabList</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addrExplain</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>wsFlags</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pLevel</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>wsFlags</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOMATIC_INDEX</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>constructAutomaticIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>whereBeginError</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>addrExplain</name> <operator>=</operator> <call><name>sqlite3WhereExplainOneScan</name><argument_list>(
        <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr></argument>, <argument><expr><name>wctrlFlags</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBody</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>notReady</name> <operator>=</operator> <call><name>sqlite3WhereCodeOneLoopStart</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iContinue</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wsFlags</name><operator>&amp;</operator><name>WHERE_MULTI_OR</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>wctrlFlags</name><operator>&amp;</operator><name>WHERE_ONETABLE_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WhereAddScanStatus</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>addrExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Done. */</comment>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Begin WHERE-core"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pWInfo</name></expr>;</return>

  <comment type="block">/* Jump here if malloc fails */</comment>
<label><name>whereBeginError</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>pWInfo</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>savedNQueryLoop</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereInfoFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate the end of the WHERE loop.  See comments on 
** sqlite3WhereBegin() for additional information.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereEnd</name><parameter_list>(<parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Generate loop termination code.
  */</comment>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"End WHERE-core"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCacheClear</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pLevel</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>OP_Noop</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>OP_Next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>OP_Prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>OP_VNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IN_ABLE</name> <operator>&amp;&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>InLoop</name></name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name></expr><operator>,</operator> <expr><name>pIn</name><operator>=</operator><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr><operator>,</operator> <expr><name>pIn</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>eEndLoopOp</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>iCur</name></name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>eEndLoopOp</name></name><operator>==</operator><name>OP_PrevIfOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>eEndLoopOp</name></name><operator>==</operator><name>OP_NextIfOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"next skip-scan on %s"</literal><operator>,</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrLikeRep</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrLikeRep</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p1</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_DecrJumpZero</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_JumpZeroIncr</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrLikeRep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
           <operator>||</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>OP_Return</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"End WHERE-loop%d: %s"</literal><operator>,</operator> <name>i</name><operator>,</operator>
                     <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name><operator>.</operator><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* The "break" point is here, just past the end of the outer loop.
  ** Set it.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>iBreak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&lt;=</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pLevel</name><operator>=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pLevel</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pTabItem</name> <init>= <expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>

    <comment type="block">/* For a co-routine, change all OP_Column references to the table of
    ** the co-routine into OP_Copy of result contained in a register.
    ** OP_Rowid becomes OP_Null.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>translateColumnToCopy</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBody</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr></argument>,
                            <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>regResult</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Close all of the cursors that were opened by sqlite3WhereBegin.
    ** Except, do not close cursors that will be reused by the OR optimization
    ** (WHERE_OMIT_OPEN_CLOSE).  And do not close the OP_OpenWrite cursors
    ** created for the ONEPASS optimization.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Ephemeral</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_OMIT_OPEN_CLOSE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ws</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ws</name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>ws</name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>ws</name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_IPK</name><operator>|</operator><name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
       <operator>&amp;&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name><operator>!=</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this scan uses an index, make VDBE code substitutions to read data
    ** from the index instead of from the table where possible.  In some cases
    ** this optimization prevents the table from ever being read, which can
    ** yield a significant performance boost.
    ** 
    ** Calls to the code generator in between sqlite3WhereBegin and
    ** sqlite3WhereEnd will have created code that references the table
    ** directly.  This loop scans all that code looking for opcodes
    ** that reference the table and converts them into opcodes that
    ** reference the index.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_INDEXED</name><operator>|</operator><name>WHERE_IDX_ONLY</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCovidx</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIdx</name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>==</operator><name>ONEPASS_OFF</name> <operator>||</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrBody</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOp</name> <operator>=</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>last</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr><operator>,</operator> <expr><name>pOp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>!=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Column</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name><operator>==</operator><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3ColumnOfIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Rowid</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_IdxRowid</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Final cleanup
  */</comment>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>savedNQueryLoop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereInfoFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>
</unit>
