<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/rowset.c"><comment type="block">/*
** 2008 December 3
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This module implements an object we call a "RowSet".
**
** The RowSet object is a collection of rowids.  Rowids
** are inserted into the RowSet in an arbitrary order.  Inserts
** can be intermixed with tests to see if a given rowid has been
** previously inserted into the RowSet.
**
** After all inserts are finished, it is possible to extract the
** elements of the RowSet in sorted order.  Once this extraction
** process has started, no new elements may be inserted.
**
** Hence, the primitive operations for a RowSet are:
**
**    CREATE
**    INSERT
**    TEST
**    SMALLEST
**    DESTROY
**
** The CREATE and DESTROY primitives are the constructor and destructor,
** obviously.  The INSERT primitive adds a new element to the RowSet.
** TEST checks to see if an element is already in the RowSet.  SMALLEST
** extracts the least value from the RowSet.
**
** The INSERT primitive might allocate additional memory.  Memory is
** allocated in chunks so most INSERTs do no allocation.  There is an 
** upper bound on the size of allocated memory.  No memory is freed
** until DESTROY.
**
** The TEST primitive includes a "batch" number.  The TEST primitive
** will only see elements that were inserted before the last change
** in the batch number.  In other words, if an INSERT occurs between
** two TESTs where the TESTs have the same batch nubmer, then the
** value added by the INSERT will not be visible to the second TEST.
** The initial batch number is zero, so if the very first TEST contains
** a non-zero batch number, it will see all prior INSERTs.
**
** No INSERTs may occurs after a SMALLEST.  An assertion will fail if
** that is attempted.
**
** The cost of an INSERT is roughly constant.  (Sometimes new memory
** has to be allocated on an INSERT.)  The cost of a TEST with a new
** batch number is O(NlogN) where N is the number of elements in the RowSet.
** The cost of a TEST using the same batch number is O(logN).  The cost
** of the first SMALLEST is O(NlogN).  Second and subsequent SMALLEST
** primitives are constant time.  The cost of DESTROY is O(N).
**
** There is an added cost of O(N) when switching between TEST and
** SMALLEST primitives.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>


<comment type="block">/*
** Target size for allocation chunks.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROWSET_ALLOCATION_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<comment type="block">/*
** The number of rowset entries per allocation chunk.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROWSET_ENTRY_PER_CHUNK</name></cpp:macro>  \
                       <cpp:value>((ROWSET_ALLOCATION_SIZE-8)/sizeof(struct RowSetEntry))</cpp:value></cpp:define>

<comment type="block">/*
** Each entry in a RowSet is an instance of the following object.
**
** This same object is reused to store a linked list of trees of RowSetEntry
** objects.  In that alternative use, pRight points to the next entry
** in the list, pLeft points to the tree, and v is unused.  The
** RowSet.pForest value points to the head of this forest list.
*/</comment>
<struct>struct <name>RowSetEntry</name> <block>{            
  <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>                        <comment type="block">/* ROWID value for this entry */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>   <comment type="block">/* Right subtree (larger entries) or list */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>    <comment type="block">/* Left subtree (smaller entries) */</comment>
}</block>;</struct>

<comment type="block">/*
** RowSetEntry objects are allocated in large chunks (instances of the
** following structure) to reduce memory allocation overhead.  The
** chunks are kept on a linked list so that they can be deallocated
** when the RowSet is destroyed.
*/</comment>
<struct>struct <name>RowSetChunk</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetChunk</name></name> <modifier>*</modifier></type><name>pNextChunk</name></decl>;</decl_stmt>        <comment type="block">/* Next chunk on list of them all */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name></type> <name><name>aEntry</name><index>[<expr><name>ROWSET_ENTRY_PER_CHUNK</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Allocated entries */</comment>
}</block>;</struct>

<comment type="block">/*
** A RowSet in an instance of the following structure.
**
** A typedef of this structure if found in sqliteInt.h.
*/</comment>
<struct>struct <name>RowSet</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetChunk</name></name> <modifier>*</modifier></type><name>pChunk</name></decl>;</decl_stmt>    <comment type="block">/* List of all chunk allocations */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                   <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>    <comment type="block">/* List of entries using pRight */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>     <comment type="block">/* Last entry on the pEntry list */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pFresh</name></decl>;</decl_stmt>    <comment type="block">/* Source of new entry objects */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pForest</name></decl>;</decl_stmt>   <comment type="block">/* List of binary trees of entries */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nFresh</name></decl>;</decl_stmt>                    <comment type="block">/* Number of objects on pFresh */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>rsFlags</name></decl>;</decl_stmt>                   <comment type="block">/* Various flags */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBatch</name></decl>;</decl_stmt>                    <comment type="block">/* Current insert batch */</comment>
}</block>;</struct>

<comment type="block">/*
** Allowed values for RowSet.rsFlags
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROWSET_SORTED</name></cpp:macro>  <cpp:value>0x01</cpp:value></cpp:define>   <comment type="block">/* True if RowSet.pEntry is sorted */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROWSET_NEXT</name></cpp:macro>    <cpp:value>0x02</cpp:value></cpp:define>   <comment type="block">/* True if sqlite3RowSetNext() has been called */</comment>

<comment type="block">/*
** Turn bulk memory into a RowSet object.  N bytes of memory
** are available at pSpace.  The db pointer is used as a memory context
** for any subsequent allocations that need to occur.
** Return a pointer to the new RowSet object.
**
** It must be the case that N is sufficient to make a Rowset.  If not
** an assertion fault occurs.
** 
** If N is larger than the minimum, use the surplus as an initial
** allocation of entries available to be filled.
*/</comment>
<function><type><name>RowSet</name> <modifier>*</modifier></type><name>sqlite3RowSetInit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pSpace</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RowSet</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>N</name> <operator>&gt;=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pSpace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pChunk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLast</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pForest</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFresh</name></name> <operator>=</operator> <operator>(</operator>struct <name>RowSetEntry</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFresh</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><operator>(</operator><name>N</name> <operator>-</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>RowSetEntry</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>=</operator> <name>ROWSET_SORTED</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iBatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate all chunks from a RowSet.  This frees all memory that
** the RowSet has allocated over its lifetime.  This routine is
** the destructor for the RowSet.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RowSetClear</name><parameter_list>(<parameter><decl><type><name>RowSet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetChunk</name></name> <modifier>*</modifier></type><name>pChunk</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNextChunk</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pChunk</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pChunk</name></name></expr>;</init> <condition><expr><name>pChunk</name></expr>;</condition> <incr><expr><name>pChunk</name> <operator>=</operator> <name>pNextChunk</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNextChunk</name> <operator>=</operator> <name><name>pChunk</name><operator>-&gt;</operator><name>pNextChunk</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pChunk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFresh</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLast</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pForest</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>=</operator> <name>ROWSET_SORTED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new RowSetEntry object that is associated with the
** given RowSet.  Return a pointer to the new and completely uninitialized
** objected.
**
** In an OOM situation, the RowSet.db-&gt;mallocFailed flag is set and this
** routine returns NULL.
*/</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>rowSetEntryAlloc</name><parameter_list>(<parameter><decl><type><name>RowSet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nFresh</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>RowSetChunk</name></name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNextChunk</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pChunk</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pChunk</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFresh</name></name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>aEntry</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFresh</name></name> <operator>=</operator> <name>ROWSET_ENTRY_PER_CHUNK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFresh</name></name><operator>--</operator></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pFresh</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Insert a new value into a RowSet.
**
** The mallocFailed flag of the database connection is set if a
** memory allocation fails.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RowSetInsert</name><parameter_list>(<parameter><decl><type><name>RowSet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>rowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>  <comment type="block">/* The new entry */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>   <comment type="block">/* The last prior entry */</comment>

  <comment type="block">/* This routine is never called after sqlite3RowSetNext() */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>&amp;</operator> <name>ROWSET_NEXT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>rowSetEntryAlloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pEntry</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <name>rowid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLast</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLast</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pLast</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>&amp;</operator> <name>ROWSET_SORTED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rowid</name><operator>&lt;=</operator><name><name>pLast</name><operator>-&gt;</operator><name>v</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ROWSET_SORTED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pLast</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pEntry</name></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLast</name></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Merge two lists of RowSetEntry objects.  Remove duplicates.
**
** The input lists are connected via pRight pointers and are 
** assumed to each already be in sorted order.
*/</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>rowSetEntryMerge</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pA</name></decl></parameter>,    <comment type="block">/* First sorted list to be merged */</comment>
  <parameter><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pB</name></decl></parameter>     <comment type="block">/* Second sorted list to be merged */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name></type> <name>head</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pTail</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pTail</name> <operator>=</operator> <operator>&amp;</operator><name>head</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pA</name> <operator>&amp;&amp;</operator> <name>pB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pA</name><operator>-&gt;</operator><name>v</name></name><operator>&lt;=</operator><name><name>pA</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>v</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pB</name><operator>-&gt;</operator><name>v</name></name><operator>&lt;=</operator><name><name>pB</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>v</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>v</name></name><operator>&lt;</operator><name><name>pB</name><operator>-&gt;</operator><name>v</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <name><name>pTail</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pB</name><operator>-&gt;</operator><name>v</name></name><operator>&lt;</operator><name><name>pA</name><operator>-&gt;</operator><name>v</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pB</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <name><name>pTail</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pA</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pA</name><operator>-&gt;</operator><name>v</name></name><operator>&lt;=</operator><name><name>pA</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>v</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pB</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pB</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pB</name><operator>-&gt;</operator><name>v</name></name><operator>&lt;=</operator><name><name>pB</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>v</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name><name>head</name><operator>.</operator><name>pRight</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sort all elements on the list of RowSetEntry objects into order of
** increasing v.
*/</comment> 
<function><type><specifier>static</specifier> <name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>rowSetEntrySort</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pNext</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name><name>aBucket</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aBucket</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aBucket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pIn</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aBucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pIn</name> <operator>=</operator> <call><name>rowSetEntryMerge</name><argument_list>(<argument><expr><name><name>aBucket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aBucket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>aBucket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>pIn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aBucket</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aBucket</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pIn</name> <operator>=</operator> <call><name>rowSetEntryMerge</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name><name>aBucket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pIn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The input, pIn, is a binary tree (or subtree) of RowSetEntry objects.
** Convert this tree into a linked list connected by the pRight pointers
** and return pointers to the first and last elements of the new list.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rowSetTreeToList</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,         <comment type="block">/* Root of the input tree */</comment>
  <parameter><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ppFirst</name></decl></parameter>,    <comment type="block">/* Write head of the output list here */</comment>
  <parameter><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ppLast</name></decl></parameter>      <comment type="block">/* Write tail of the output list here */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn</name><operator>-&gt;</operator><name>pLeft</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>rowSetTreeToList</name><argument_list>(<argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>ppFirst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppFirst</name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>rowSetTreeToList</name><argument_list>(<argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIn</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>ppLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppLast</name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><operator>(</operator><operator>*</operator><name>ppLast</name><operator>)</operator><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Convert a sorted list of elements (connected by pRight) into a binary
** tree with depth of iDepth.  A depth of 1 means the tree contains a single
** node taken from the head of *ppList.  A depth of 2 means a tree with
** three nodes.  And so forth.
**
** Use as many entries from the input list as required and update the
** *ppList to point to the unused elements of the list.  If the input
** list contains too few elements, then construct an incomplete tree
** and leave *ppList set to NULL.
**
** Return a pointer to the root of the constructed binary tree.
*/</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>rowSetNDeepTree</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ppList</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iDepth</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>         <comment type="block">/* Root of the new tree */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>     <comment type="block">/* Left subtree */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>ppList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iDepth</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>ppList</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>p</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <call><name>rowSetNDeepTree</name><argument_list>(<argument><expr><name>ppList</name></expr></argument>, <argument><expr><name>iDepth</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>ppList</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>pLeft</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <call><name>rowSetNDeepTree</name><argument_list>(<argument><expr><name>ppList</name></expr></argument>, <argument><expr><name>iDepth</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert a sorted list of elements into a binary tree. Make the tree
** as deep as it needs to be in order to contain the entire list.
*/</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>rowSetListToTree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iDepth</name></decl>;</decl_stmt>           <comment type="block">/* Depth of the tree so far */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>       <comment type="block">/* Current tree root */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>   <comment type="block">/* Left subtree */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iDepth</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>pList</name></expr>;</condition> <incr><expr><name>iDepth</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <call><name>rowSetNDeepTree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pList</name></expr></argument>, <argument><expr><name>iDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Take all the entries on p-&gt;pEntry and on the trees in p-&gt;pForest and
** sort them all together into one big ordered list on p-&gt;pEntry.
**
** This routine should only be called once in the life of a RowSet.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rowSetToList</name><parameter_list>(<parameter><decl><type><name>RowSet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>

  <comment type="block">/* This routine is called only once */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>&amp;</operator> <name>ROWSET_NEXT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>&amp;</operator> <name>ROWSET_SORTED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pEntry</name></name> <operator>=</operator> <call><name>rowSetEntrySort</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* While this module could theoretically support it, sqlite3RowSetNext()
  ** is never called after sqlite3RowSetText() for the same RowSet.  So
  ** there is never a forest to deal with.  Should this change, simply
  ** remove the assert() and the #if 0. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pForest</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  while( p-&gt;pForest ){
    struct RowSetEntry *pTree = p-&gt;pForest-&gt;pLeft;
    if( pTree ){
      struct RowSetEntry *pHead, *pTail;
      rowSetTreeToList(pTree, &amp;pHead, &amp;pTail);
      p-&gt;pEntry = rowSetEntryMerge(p-&gt;pEntry, pHead);
    }
    p-&gt;pForest = p-&gt;pForest-&gt;pRight;
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>|=</operator> <name>ROWSET_NEXT</name></expr>;</expr_stmt>  <comment type="block">/* Verify this routine is never called again */</comment>
</block_content>}</block></function>

<comment type="block">/*
** Extract the smallest element from the RowSet.
** Write the element into *pRowid.  Return 1 on success.  Return
** 0 if the RowSet is already empty.
**
** After this routine has been called, the sqlite3RowSetInsert()
** routine may not be called again.  
*/</comment>
<function><type><name>int</name></type> <name>sqlite3RowSetNext</name><parameter_list>(<parameter><decl><type><name>RowSet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Merge the forest into a single sorted list on first call */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>&amp;</operator> <name>ROWSET_NEXT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rowSetToList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Return the next entry on the list */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pEntry</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEntry</name><operator>-&gt;</operator><name>v</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pEntry</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEntry</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pEntry</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3RowSetClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if element iRowid was inserted into the rowset as
** part of any insert batch prior to iBatch.  Return 1 or 0.
**
** If this is the first test of a new batch and if there exist entries
** on pRowSet-&gt;pEntry, then sort those entries into the forest at
** pRowSet-&gt;pForest so that they can be tested.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3RowSetTest</name><parameter_list>(<parameter><decl><type><name>RowSet</name> <modifier>*</modifier></type><name>pRowSet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBatch</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pTree</name></decl>;</decl_stmt>

  <comment type="block">/* This routine is never called after sqlite3RowSetNext() */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRowSet</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRowSet</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>&amp;</operator> <name>ROWSET_NEXT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Sort entries into the forest on the first test of a new batch 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>iBatch</name><operator>!=</operator><name><name>pRowSet</name><operator>-&gt;</operator><name>iBatch</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pRowSet</name><operator>-&gt;</operator><name>pEntry</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPrevTree</name> <init>= <expr><operator>&amp;</operator><name><name>pRowSet</name><operator>-&gt;</operator><name>pForest</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRowSet</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>&amp;</operator> <name>ROWSET_SORTED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>rowSetEntrySort</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>pTree</name> <operator>=</operator> <name><name>pRowSet</name><operator>-&gt;</operator><name>pForest</name></name></expr>;</init> <condition><expr><name>pTree</name></expr>;</condition> <incr><expr><name>pTree</name><operator>=</operator><name><name>pTree</name><operator>-&gt;</operator><name>pRight</name></name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>ppPrevTree</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTree</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTree</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <call><name>rowSetListToTree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name><name>struct</name> <name>RowSetEntry</name></name> <modifier>*</modifier></type><name>pAux</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pTail</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>rowSetTreeToList</name><argument_list>(<argument><expr><name><name>pTree</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pAux</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>rowSetEntryMerge</name><argument_list>(<argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pTree</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppPrevTree</name> <operator>=</operator> <name>pTree</name> <operator>=</operator> <call><name>rowSetEntryAlloc</name><argument_list>(<argument><expr><name>pRowSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pTree</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <call><name>rowSetListToTree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pRowSet</name><operator>-&gt;</operator><name>pEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRowSet</name><operator>-&gt;</operator><name>pLast</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRowSet</name><operator>-&gt;</operator><name>rsFlags</name></name> <operator>|=</operator> <name>ROWSET_SORTED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pRowSet</name><operator>-&gt;</operator><name>iBatch</name></name> <operator>=</operator> <name>iBatch</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Test to see if the iRowid value appears anywhere in the forest.
  ** Return 1 if it does and 0 if not.
  */</comment>
  <for>for<control>(<init><expr><name>pTree</name> <operator>=</operator> <name><name>pRowSet</name><operator>-&gt;</operator><name>pForest</name></name></expr>;</init> <condition><expr><name>pTree</name></expr>;</condition> <incr><expr><name>pTree</name><operator>=</operator><name><name>pTree</name><operator>-&gt;</operator><name>pRight</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pTree</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>v</name></name><operator>&lt;</operator><name>iRowid</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>v</name></name><operator>&gt;</operator><name>iRowid</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
