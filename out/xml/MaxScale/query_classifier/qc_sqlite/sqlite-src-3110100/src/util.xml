<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/util.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Utility functions used throughout sqlite.
**
** This file contains functions for allocating memory, comparing
** strings, and stuff like that.
**
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_ISNAN</name> <operator>||</operator> <name>SQLITE_HAVE_ISNAN</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Routine needed to support the testcase() macro.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_COVERAGE_TEST</name></cpp:ifdef>
<function><type><name>void</name></type> <name>sqlite3Coverage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>dummy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>dummy</name> <operator>+=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Give a callback to the test harness that can be used to simulate faults
** in places where it is difficult or expensive to do so purely by means
** of inputs.
**
** The intent of the integer argument is to let the fault simulator know
** which of multiple sqlite3FaultSim() calls has been hit.
**
** Return whatever integer value the test callback returns, or return
** SQLITE_OK if no test callback is installed.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BUILTIN_TEST</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3FaultSim</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iTest</name></decl></parameter>)</parameter_list><block>{<block_content>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list> <init>= <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xTestCallback</name></name></expr></init>;</function_decl>
  <return>return <expr><ternary><condition><expr><name>xCallback</name></expr> ?</condition><then> <expr><call><name>xCallback</name><argument_list>(<argument><expr><name>iTest</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>SQLITE_OK</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/*
** Return true if the floating point value is Not a Number (NaN).
**
** Use the math library isnan() function if compiled with SQLITE_HAVE_ISNAN.
** Otherwise, we have our own implementation that works on most systems.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsNaN</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>   <comment type="block">/* The value return */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_HAVE_ISNAN</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAVE_ISNAN</name></expr></cpp:if>
  <comment type="block">/*
  ** Systems that support the isnan() library function should probably
  ** make use of it by compiling with -DSQLITE_HAVE_ISNAN.  But we have
  ** found that many systems do not have a working isnan() function so
  ** this implementation is provided as an alternative.
  **
  ** This NaN test sometimes fails if compiled on GCC with -ffast-math.
  ** On the other hand, the use of -ffast-math comes with the following
  ** warning:
  **
  **      This option [-ffast-math] should never be turned on by any
  **      -O option since it can result in incorrect output for programs
  **      which depend on an exact implementation of IEEE or ISO 
  **      rules/specifications for math functions.
  **
  ** Under MSVC, this NaN test may fail if compiled with a floating-
  ** point precision mode other than /fp:precise.  From the MSDN 
  ** documentation:
  **
  **      The compiler [with /fp:precise] will properly handle comparisons 
  **      involving NaN. For example, x != x evaluates to true if x is NaN 
  **      ...
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__FAST_MATH__</name></cpp:ifdef>
<cpp:error># <cpp:directive>error</cpp:directive> SQLite will not work correctly with the -ffast-math option of GCC.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>double</name></type> <name>y</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>double</name></type> <name>z</name> <init>= <expr><name>y</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>y</name><operator>!=</operator><name>z</name><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* if HAVE_ISNAN */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_ISNAN */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_FLOATING_POINT */</comment>

<comment type="block">/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
**
** The value returned will never be negative.  Nor will it ever be greater
** than the actual length of the string.  For very long strings (greater
** than 1GiB) the value returned might be less than the true string length.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Strlen30</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0x3fffffff</literal> <operator>&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the current error code to err_code and clear any prior error message.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Error</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>err_code</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>err_code</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ValueSetNull</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the most recent error code and error string for the sqlite
** handle "db". The error code is set to "err_code".
**
** If it is not NULL, string zFormat specifies the format of the
** error string in the style of the printf functions: The following
** format characters are allowed:
**
**      %s      Insert a string
**      %z      A string that should be freed after use
**      %d      Insert an integer
**      %T      Insert a token
**      %S      Insert the first element of a SrcList
**
** zFormat and any string tokens that follow it are assumed to be
** encoded in UTF-8.
**
** To clear the most recent error for sqlite handle "db", sqlite3Error
** should be called with err_code set to SQLITE_OK and zFormat set
** to NULL.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ErrorWithMsg</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>err_code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>err_code</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFormat</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>err_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name> <operator>||</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name> <operator>=</operator> <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add an error message to pParse-&gt;zErrMsg and increment pParse-&gt;nErr.
** The following formatting characters are allowed:
**
**      %s      Insert a string
**      %z      A string that should be freed after use
**      %d      Insert an integer
**      %T      Insert a token
**      %S      Insert the first element of a SrcList
**
** This function should be used to report any error that occurs while
** compiling an SQL statement (i.e. within sqlite3_prepare()). The
** last thing the sqlite3_prepare() function does is copy the error
** stored by this function into the database handle using sqlite3Error().
** Functions sqlite3Error() or sqlite3ErrorWithMsg() should be used
** during statement execution (sqlite3_step() etc.).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ErrorMsg</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <name>zMsg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Convert an SQL-style quoted string into a normal string by removing
** the quote characters.  The conversion is done in-place.  If the
** input does not begin with a quote character, then this routine
** is a no-op.
**
** The input string must be zero-terminated.  A new zero-terminator
** is added to the dequoted string.
**
** The return value is -1 if no dequoting occurs or the length of the
** dequoted string, exclusive of the zero terminator, if dequoting does
** occur.
**
** 2002-Feb-14: This routine is extended to remove MS-Access style
** brackets from around identifiers.  For example:  "[a-b-c]" becomes
** "a-b-c".
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Dequote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>quote</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>quote</name> <operator>=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>quote</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="char">'\''</literal></expr>:</case>  <break>break;</break>
    <case>case <expr><literal type="char">'"'</literal></expr>:</case>   <break>break;</break>
    <case>case <expr><literal type="char">'`'</literal></expr>:</case>   <break>break;</break>                <comment type="block">/* For MySQL compatibility */</comment>
    <case>case <expr><literal type="char">'['</literal></expr>:</case>   <expr_stmt><expr><name>quote</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt>  <break>break;</break>  <comment type="block">/* For MS SqlServer compatibility */</comment>
    <default>default:</default>    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></switch>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAXSCALE</name></cpp:ifdef>
    <if_stmt><if>if <condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="line">// TODO: This is needed only because exposed_sqlite3Dequote() is called</comment>
      <comment type="line">// TODO: in qc_sqlite.c:update_names(). That call probably is not needed</comment>
      <comment type="line">// TODO: and should be removed, in which case this check could also be</comment>
      <comment type="line">// TODO: removed.</comment>
      <break>break;</break>
    </block_content>}</block></if><if type="elseif">else if <condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
      <comment type="line">// If we want to dequote properly, a few more characters would have to be</comment>
      <comment type="line">// handled explicitly. That would not affect the classification, however,</comment>
      <comment type="line">// so we won't do that.</comment>
      <if_stmt><if>if <condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>quote</name> <operator>||</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>quote</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>j</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate a Token object from a string
*/</comment>
<function><type><name>void</name></type> <name>sqlite3TokenInit</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Convenient short-hand */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UpperToLower</name></cpp:macro> <cpp:value>sqlite3UpperToLower</cpp:value></cpp:define>

<comment type="block">/*
** Some systems have stricmp().  Others have strcasecmp().  Because
** there is no consistency, we will define our own.
**
** IMPLEMENTATION-OF: R-30243-02494 The sqlite3_stricmp() and
** sqlite3_strnicmp() APIs allow applications and extensions to compare
** the contents of two buffers containing UTF-8 strings in a
** case-independent fashion, using the same definition of "case
** independence" that SQLite uses internally when comparing identifiers.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_stricmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>zRight</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zLeft</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zRight</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>a</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>a</name></expr>]</index></name><operator>==</operator><name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>b</name></expr>]</index></name></expr>)</condition><block>{<block_content> <expr_stmt><expr><name>a</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>b</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>a</name></expr>]</index></name> <operator>-</operator> <name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>b</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_strnicmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>zRight</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zLeft</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zRight</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>N</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>a</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>a</name></expr>]</index></name><operator>==</operator><name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>b</name></expr>]</index></name></expr>)</condition><block>{<block_content> <expr_stmt><expr><name>a</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>b</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><ternary><condition><expr><name>N</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>a</name></expr>]</index></name> <operator>-</operator> <name><name>UpperToLower</name><index>[<expr><operator>*</operator><name>b</name></expr>]</index></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The string z[] is an text representation of a real number.
** Convert this string to a double and write it into *pResult.
**
** The string z[] is length bytes in length (bytes, not characters) and
** uses the encoding enc.  The string is not necessarily zero-terminated.
**
** Return TRUE if the result is a valid real number (or integer) and FALSE
** if the string is empty or contains extraneous text.  Valid numbers
** are in one of these formats:
**
**    [+-]digits[E[+-]digits]
**    [+-]digits.[digits][E[+-]digits]
**    [+-].digits[E[+-]digits]
**
** Leading and trailing whitespace is ignored for the purpose of determining
** validity.
**
** If some prefix of the input string is a valid number, this routine
** returns FALSE but it still converts the prefix and writes the result
** into *pResult.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3AtoF</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pResult</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>incr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><name>z</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* sign * significand * (10 ^ (esign * exponent)) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* sign of significand */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* significand */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* adjust exponent for shifting decimal point */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>esign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* sign of exponent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* exponent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eValid</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* True exponent is either not used or is well-formed */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDigits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nonNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> <name>enc</name><operator>==</operator><name>SQLITE_UTF16LE</name> <operator>||</operator> <name>enc</name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>   <comment type="block">/* Default return value, in case of an error */</comment>

  <if_stmt><if>if<condition>( <expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>incr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>incr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_UTF16LE</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>SQLITE_UTF16BE</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal><operator>-</operator><name>enc</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>length</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content/>}</block></for>
    <expr_stmt><expr><name>nonNum</name> <operator>=</operator> <name>i</name><operator>&lt;</operator><name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <name>z</name><operator>+</operator><name>i</name><operator>+</operator><name>enc</name><operator>-</operator><literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <operator>(</operator><name>enc</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* skip leading spaces */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* get sign of significand */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* skip leading zeroes */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr><operator>,</operator> <expr><name>nDigits</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

  <comment type="block">/* copy max significant digits to significand */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>s</name><operator>&lt;</operator><operator>(</operator><operator>(</operator><name>LARGEST_INT64</name><operator>-</operator><literal type="number">9</literal><operator>)</operator><operator>/</operator><literal type="number">10</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>z</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr><operator>,</operator> <expr><name>nDigits</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* skip non-significant significand digits
  ** (increase exponent by d to shift decimal left) */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr><operator>,</operator> <expr><name>nDigits</name><operator>++</operator></expr><operator>,</operator> <expr><name>d</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>do_atof_calc</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* if decimal point is present */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    <comment type="block">/* copy digits from after decimal to significand
    ** (decrease exponent by d to shift decimal right) */</comment>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>s</name><operator>&lt;</operator><operator>(</operator><operator>(</operator><name>LARGEST_INT64</name><operator>-</operator><literal type="number">9</literal><operator>)</operator><operator>/</operator><literal type="number">10</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>z</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr><operator>,</operator> <expr><name>nDigits</name><operator>++</operator></expr><operator>,</operator> <expr><name>d</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* skip non-significant digits */</comment>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr><operator>,</operator> <expr><name>nDigits</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>do_atof_calc</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* if exponent is present */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>eValid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>do_atof_calc</name>;</goto></block_content></block></if></if_stmt>
    <comment type="block">/* get sign of exponent */</comment>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>esign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* copy digits to exponent */</comment>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>e</name> <operator>=</operator> <ternary><condition><expr><name>e</name><operator>&lt;</operator><literal type="number">10000</literal></expr> ?</condition><then> <expr><operator>(</operator><name>e</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>z</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator><operator>)</operator></expr> </then><else>: <expr><literal type="number">10000</literal></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>eValid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* skip trailing spaces */</comment>
  <if_stmt><if>if<condition>( <expr><name>nDigits</name> <operator>&amp;&amp;</operator> <name>eValid</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></if></if_stmt>

<label><name>do_atof_calc</name>:</label>
  <comment type="block">/* adjust exponent by d, and update sign */</comment>
  <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>e</name><operator>*</operator><name>esign</name><operator>)</operator> <operator>+</operator> <name>d</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>e</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><name>esign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> <operator>*=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>esign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* if 0 significand */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>s</name></expr> )</condition> <block>{<block_content>
    <comment type="block">/* In the IEEE 754 standard, zero is signed.
    ** Add the sign if we've seen at least one digit */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>sign</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nDigits</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* attempt to reduce exponent */</comment>
    <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><name><name>s</name><argument_list type="generic">&lt;<argument><expr><operator>(</operator><name>LARGEST_INT64</name><operator>/</operator><literal type="number">10</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>e</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>e</name><operator>--</operator></expr><operator>,</operator><expr><name>s</name><operator>*=</operator><literal type="number">10</literal></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if><else>else<block>{<block_content>
      <while>while<condition>( <expr><operator>!</operator><operator>(</operator><name>s</name><operator>%</operator><literal type="number">10</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>e</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>e</name><operator>--</operator></expr><operator>,</operator><expr><name>s</name><operator>/=</operator><literal type="number">10</literal></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* adjust the sign of significand */</comment>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <ternary><condition><expr><name>sign</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>s</name></expr> </then><else>: <expr><name>s</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* if exponent, scale significand as appropriate
    ** and store in result. */</comment>
    <if_stmt><if>if<condition>( <expr><name>e</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>scale</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
      <comment type="block">/* attempt to handle extremely small/large numbers better */</comment>
      <if_stmt><if>if<condition>( <expr><name>e</name><operator>&gt;</operator><literal type="number">307</literal> <operator>&amp;&amp;</operator> <name>e</name><operator>&lt;</operator><literal type="number">342</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name>e</name><operator>%</operator><literal type="number">308</literal></expr> )</condition> <block>{<block_content> <expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">1.0e+1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>e</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>/</operator> <name>scale</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>result</name> <operator>/=</operator> <literal type="number">1.0e+308</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>*</operator> <name>scale</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>result</name> <operator>*=</operator> <literal type="number">1.0e+308</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>e</name><operator>&gt;=</operator><literal type="number">342</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal><operator>*</operator><name>s</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1e308</literal><operator>*</operator><literal type="number">1e308</literal><operator>*</operator><name>s</name></expr>;</expr_stmt>  <comment type="block">/* Infinity */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* 1.0e+22 is the largest power of 10 than can be 
        ** represented exactly. */</comment>
        <while>while<condition>( <expr><name>e</name><operator>%</operator><literal type="number">22</literal></expr> )</condition> <block>{<block_content> <expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">1.0e+1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>e</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></while>
        <while>while<condition>( <expr><name>e</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content> <expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">1.0e+22</literal></expr>;</expr_stmt> <expr_stmt><expr><name>e</name> <operator>-=</operator> <literal type="number">22</literal></expr>;</expr_stmt> </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>/</operator> <name>scale</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>*</operator> <name>scale</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>s</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* store the result */</comment>
  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

  <comment type="block">/* return true if number and no extra non-whitespace chracters after */</comment>
  <return>return <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <name>nDigits</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eValid</name> <operator>&amp;&amp;</operator> <name>nonNum</name><operator>==</operator><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><operator>!</operator><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>pResult</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_FLOATING_POINT */</comment>
</block_content>}</block></function>

<comment type="block">/*
** Compare the 19-character string zNum against the text representation
** value 2^63:  9223372036854775808.  Return negative, zero, or positive
** if zNum is less than, equal to, or greater than the string.
** Note that zNum must contain exactly 19 characters.
**
** Unlike memcmp() this routine is guaranteed to return the difference
** in the values of the last digit if the only difference is in the
** last digit.  So, for example,
**
**      compare2pow63("9223372036854775800", 1)
**
** will return -8.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>compare2pow63</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>incr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                    <comment type="block">/* 012345678901234567 */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pow63</name> <init>= <expr><literal type="string">"922337203685477580"</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">18</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name><name>zNum</name><index>[<expr><name>i</name><operator>*</operator><name>incr</name></expr>]</index></name><operator>-</operator><name><name>pow63</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>*</operator><literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zNum</name><index>[<expr><literal type="number">18</literal><operator>*</operator><name>incr</name></expr>]</index></name> <operator>-</operator> <literal type="char">'8'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>c</name><operator>==</operator><operator>(</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert zNum to a 64-bit signed integer.  zNum must be decimal. This
** routine does *not* accept hexadecimal notation.
**
** If the zNum value is representable as a 64-bit twos-complement 
** integer, then write that value into *pNum and return 0.
**
** If zNum is exactly 9223372036854775808, return 2.  This special
** case is broken out because while 9223372036854775808 cannot be a 
** signed 64-bit integer, its negative -9223372036854775808 can be.
**
** If zNum is too big for a 64-bit integer and is not
** 9223372036854775808  or if zNum contains any non-numeric text,
** then return 1.
**
** length is the number of bytes in the string (bytes, not characters).
** The string is not necessarily zero-terminated.  The encoding is
** given by enc.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Atoi64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNum</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>incr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* assume positive */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nonNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><name>zNum</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> <name>enc</name><operator>==</operator><name>SQLITE_UTF16LE</name> <operator>||</operator> <name>enc</name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>enc</name><operator>==</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>incr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>incr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_UTF16LE</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>SQLITE_UTF16BE</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal><operator>-</operator><name>enc</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>length</name> <operator>&amp;&amp;</operator> <name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content/>}</block></for>
    <expr_stmt><expr><name>nonNum</name> <operator>=</operator> <name>i</name><operator>&lt;</operator><name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <name>zNum</name><operator>+</operator><name>i</name><operator>+</operator><name>enc</name><operator>-</operator><literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zNum</name> <operator>+=</operator> <operator>(</operator><name>enc</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <while>while<condition>( <expr><name>zNum</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zNum</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zNum</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>zNum</name><operator>&lt;</operator><name>zEnd</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zNum</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zNum</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>zNum</name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zNum</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zStart</name> <operator>=</operator> <name>zNum</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>zNum</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zNum</name><operator>+=</operator><name>incr</name></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* Skip leading zeros. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>&amp;</operator><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>=</operator><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>incr</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>u</name> <operator>=</operator> <name>u</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>u</name><operator>&gt;</operator><name>LARGEST_INT64</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pNum</name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><name>SMALLEST_INT64</name></expr> </then><else>: <expr><name>LARGEST_INT64</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>neg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pNum</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>i64</name><operator>)</operator><name>u</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pNum</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>u</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">18</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">19</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">20</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>&amp;</operator><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name>zEnd</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zStart</name><operator>==</operator><name>zNum</name><operator>)</operator>
       <operator>||</operator> <name>i</name><operator>&gt;</operator><literal type="number">19</literal><operator>*</operator><name>incr</name> <operator>||</operator> <name>nonNum</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* zNum is empty or contains non-numeric text or is longer
    ** than 19 digits (thus guaranteeing that it is too large) */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">19</literal><operator>*</operator><name>incr</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Less than 19 digits, so we know that it fits in 64 bits */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>&lt;=</operator><name>LARGEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* zNum is a 19-digit numbers.  Compare it against 9223372036854775808. */</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>compare2pow63</name><argument_list>(<argument><expr><name>zNum</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* zNum is less than 9223372036854775808 so it fits */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>&lt;=</operator><name>LARGEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* zNum is greater than 9223372036854775808 so it overflows */</comment>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* zNum is exactly 9223372036854775808.  Fits if negative.  The
      ** special case 2 overflow if positive */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>-</operator><literal type="number">1</literal><operator>==</operator><name>LARGEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Transform a UTF-8 integer literal, in either decimal or hexadecimal,
** into a 64-bit signed integer.  This routine accepts hexadecimal literals,
** whereas sqlite3Atoi64() does not.
**
** Returns:
**
**     0    Successful transformation.  Fits in a 64-bit signed integer.
**     1    Integer too large for a 64-bit signed integer or is malformed
**     2    Special case of 9223372036854775808
*/</comment>
<function><type><name>int</name></type> <name>sqlite3DecOrHexToI64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_HEX_INTEGER</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'x'</literal> <operator>||</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'X'</literal><operator>)</operator>
   <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><name>i</name></expr>;</init> <condition><expr><call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>u</name> <operator>=</operator> <name>u</name><operator>*</operator><literal type="number">16</literal> <operator>+</operator> <call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>k</name><operator>-</operator><name>i</name><operator>&lt;=</operator><literal type="number">16</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_HEX_INTEGER */</comment>
  <block>{<block_content>
    <return>return <expr><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If zNum represents an integer that will fit in 32-bits, then set
** *pValue to that integer and return true.  Otherwise return false.
**
** This routine accepts both decimal and hexadecimal notation for integers.
**
** Any non-numeric characters that following zNum are ignored.
** This is different from sqlite3Atoi64() which requires the
** input number to be zero-terminated.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GetInt32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNum</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_HEX_INTEGER</name></cpp:ifndef>
  <if type="elseif">else if<condition>( <expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal>
        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zNum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'x'</literal> <operator>||</operator> <name><name>zNum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'X'</literal><operator>)</operator>
        <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zNum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zNum</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>u</name> <operator>=</operator> <name>u</name><operator>*</operator><literal type="number">16</literal> <operator>+</operator> <call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u</name><operator>&amp;</operator><literal type="number">0x80000000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while<condition>( <expr><name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">11</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="number">9</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <name>v</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* The longest decimal representation of a 32 bit integer is 10 digits:
  **
  **             1234567890
  **     2^31 -&gt; 2147483648
  */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">10</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>v</name><operator>-</operator><name>neg</name><operator>==</operator><literal type="number">2147483647</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>-</operator><name>neg</name><operator>&gt;</operator><literal type="number">2147483647</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>neg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>-</operator><name>v</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pValue</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a 32-bit integer value extracted from a string.  If the
** string is not an integer, just return 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Atoi</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3GetInt32</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The variable-length integer encoding is as follows:
**
** KEY:
**         A = 0xxxxxxx    7 bits of data and one flag bit
**         B = 1xxxxxxx    7 bits of data and one flag bit
**         C = xxxxxxxx    8 bits of data
**
**  7 bits - A
** 14 bits - BA
** 21 bits - BBA
** 28 bits - BBBA
** 35 bits - BBBBA
** 42 bits - BBBBBA
** 49 bits - BBBBBBA
** 56 bits - BBBBBBBA
** 64 bits - BBBBBBBBC
*/</comment>

<comment type="block">/*
** Write a 64-bit variable-length integer to memory starting at p[0].
** The length of data write will be between 1 and 9 bytes.  The number
** of bytes written is returned.
**
** A variable-length integer consists of the lower 7 bits of each byte
** for all bytes that have the 8th bit set and one byte with the 8th
** bit clear.  Except, if we get to the 9th byte, it stores the full
** 8 bits and is the last byte.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_NOINLINE</name></type> <name>putVarint64</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>buf</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">0xff000000</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">7</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">9</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>    
  <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;=</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3PutVarint</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;=</operator><literal type="number">0x7f</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;=</operator><literal type="number">0x3fff</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x7f</literal><operator>)</operator><operator>|</operator><literal type="number">0x80</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>putVarint64</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Bitmasks used by sqlite3GetVarint().  These precomputed constants
** are defined here rather than simply putting the constant expressions
** inline in order to work around bugs in the RVT compiler.
**
** SLOT_2_0     A mask for  (0x7f&lt;&lt;14) | 0x7f
**
** SLOT_4_2_0   A mask for  (0x7f&lt;&lt;28) | SLOT_2_0
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOT_2_0</name></cpp:macro>     <cpp:value>0x001fc07f</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOT_4_2_0</name></cpp:macro>   <cpp:value>0xf01fc07f</cpp:value></cpp:define>


<comment type="block">/*
** Read a 64-bit variable-length integer from memory starting at p[0].
** Return the number of bytes read.  The value is stored in *v.
*/</comment>
<function><type><name>u8</name></type> <name>sqlite3GetVarint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u64</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>a</name></decl>,<decl><type ref="prev"/><name>b</name></decl>,<decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p1 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Verify that constants are precomputed correctly */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SLOT_2_0</name> <operator>==</operator> <operator>(</operator><operator>(</operator><literal type="number">0x7f</literal><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>)</operator><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SLOT_4_2_0</name> <operator>==</operator> <operator>(</operator><operator>(</operator><literal type="number">0xfU</literal><operator>&lt;&lt;</operator><literal type="number">28</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>)</operator><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0&lt;&lt;14 | p2 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">3</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* CSE1 from below */</comment>
  <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p1&lt;&lt;14 | p3 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
    <comment type="block">/* moved CSE1 up */</comment>
    <comment type="block">/* a &amp;= (0x7f&lt;&lt;14)|(0x7f); */</comment>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* a: p0&lt;&lt;14 | p2 (masked) */</comment>
  <comment type="block">/* b: p1&lt;&lt;14 | p3 (unmasked) */</comment>
  <comment type="block">/* 1:save off p0&lt;&lt;21 | p1&lt;&lt;14 | p2&lt;&lt;7 | p3 (masked) */</comment>
  <comment type="block">/* moved CSE1 up */</comment>
  <comment type="block">/* a &amp;= (0x7f&lt;&lt;14)|(0x7f); */</comment>
  <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>s</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
  <comment type="block">/* s: p0&lt;&lt;14 | p2 (masked) */</comment>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0&lt;&lt;28 | p2&lt;&lt;14 | p4 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* we can skip these cause they were (effectively) done above
    ** while calculating s */</comment>
    <comment type="block">/* a &amp;= (0x7f&lt;&lt;28)|(0x7f&lt;&lt;14)|(0x7f); */</comment>
    <comment type="block">/* b &amp;= (0x7f&lt;&lt;14)|(0x7f); */</comment>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&gt;&gt;</operator><literal type="number">18</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>s</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">5</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* 2:save off p0&lt;&lt;21 | p1&lt;&lt;14 | p2&lt;&lt;7 | p3 (masked) */</comment>
  <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>s</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
  <comment type="block">/* s: p0&lt;&lt;21 | p1&lt;&lt;14 | p2&lt;&lt;7 | p3 (masked) */</comment>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p1&lt;&lt;28 | p3&lt;&lt;14 | p5 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* we can skip this cause it was (effectively) done above in calc'ing s */</comment>
    <comment type="block">/* b &amp;= (0x7f&lt;&lt;28)|(0x7f&lt;&lt;14)|(0x7f); */</comment>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&gt;&gt;</operator><literal type="number">18</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>s</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">6</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p2&lt;&lt;28 | p4&lt;&lt;14 | p6 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_4_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&gt;&gt;</operator><literal type="number">11</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>s</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">7</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* CSE2 from below */</comment>
  <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p3&lt;&lt;28 | p5&lt;&lt;14 | p7 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_4_2_0</name></expr>;</expr_stmt>
    <comment type="block">/* moved CSE2 up */</comment>
    <comment type="block">/* a &amp;= (0x7f&lt;&lt;14)|(0x7f); */</comment>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&gt;&gt;</operator><literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>s</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">8</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">15</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p4&lt;&lt;29 | p6&lt;&lt;15 | p8 (unmasked) */</comment>

  <comment type="block">/* moved CSE2 up */</comment>
  <comment type="block">/* a &amp;= (0x7f&lt;&lt;29)|(0x7f&lt;&lt;15)|(0xff); */</comment>
  <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_2_0</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>&lt;&lt;</operator><literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&gt;&gt;</operator><literal type="number">3</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>s</name> <operator>|=</operator> <name>b</name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>s</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator> <name>a</name></expr>;</expr_stmt>

  <return>return <expr><literal type="number">9</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read a 32-bit variable-length integer from memory starting at p[0].
** Return the number of bytes read.  The value is stored in *v.
**
** If the varint stored in p[0] is larger than can fit in a 32-bit unsigned
** integer, then set *v to 0xffffffff.
**
** A MACRO version, getVarint32, is provided which inlines the 
** single-byte case.  All code should use the MACRO version as 
** this function assumes the single-byte case has already been handled.
*/</comment>
<function><type><name>u8</name></type> <name>sqlite3GetVarint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>a</name></decl>,<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

  <comment type="block">/* The 1-byte case.  Overwhelmingly the most common.  Handled inline
  ** by the getVarin32() macro */</comment>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0 (unmasked) */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>getVarint32</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Values between 0 and 127 */</comment>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* The 2-byte case */</comment>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p1 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Values between 128 and 16383 */</comment>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name> <operator>|</operator> <name>b</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The 3-byte case */</comment>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0&lt;&lt;14 | p2 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Values between 16384 and 2097151 */</comment>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator><operator>|</operator><operator>(</operator><literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name> <operator>|</operator> <name>b</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">3</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* A 32-bit varint is used to store size information in btrees.
  ** Objects are rarely larger than 2MiB limit of a 3-byte varint.
  ** A 3-byte varint is sufficient, for example, to record the size
  ** of a 1048569-byte BLOB or string.
  **
  ** We only unroll the first 1-, 2-, and 3- byte cases.  The very
  ** rare larger cases can be handled by the slower 64-bit varint
  ** routine.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
  <block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>v64</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;=</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>v64</name> <operator>&amp;</operator> <name>SQLITE_MAX_U32</name><operator>)</operator><operator>!=</operator><name>v64</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>v64</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>n</name></expr>;</return>
  </block_content>}</block>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* For following code (kept for historical record only) shows an
  ** unrolling for the 3- and 4-byte varint cases.  This code is
  ** slightly faster, but it is also larger and much harder to test.
  */</comment>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* b: p1&lt;&lt;14 | p3 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Values between 2097152 and 268435455 */</comment>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator><operator>|</operator><operator>(</operator><literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">0x7f</literal><operator>&lt;&lt;</operator><literal type="number">14</literal><operator>)</operator><operator>|</operator><operator>(</operator><literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name> <operator>|</operator> <name>b</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <comment type="block">/* a: p0&lt;&lt;28 | p2&lt;&lt;14 | p4 (unmasked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Values  between 268435456 and 34359738367 */</comment>
    <expr_stmt><expr><name>a</name> <operator>&amp;=</operator> <name>SLOT_4_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>&amp;=</operator> <name>SLOT_4_2_0</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name><operator>&lt;&lt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name> <operator>|</operator> <name>b</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">5</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* We can only reach this point when reading a corrupt database
  ** file.  In that case we are not in any hurry.  Use the (relatively
  ** slow) general-purpose sqlite3GetVarint() routine to extract the
  ** value. */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>v64</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;=</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>v64</name></expr>;</expr_stmt>
    <return>return <expr><name>n</name></expr>;</return>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of bytes that will be needed to store the given
** 64-bit integer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VarintLen</name><parameter_list>(<parameter><decl><type><name>u64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> </block_content>}</block></for>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Read or write a four-byte big-endian integer value.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3Get4byte</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>x</name></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DISABLE_INTRINSIC</name></expr></argument>)</argument_list></call> \
    <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">4003000</literal></expr></cpp:elif>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>__builtin_bswap32</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DISABLE_INTRINSIC</name></expr></argument>)</argument_list></call> \
    <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:elif>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>_byteswap_ulong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3Put4byte</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">4003000</literal></expr></cpp:elif>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name> <init>= <expr><call><name>__builtin_bswap32</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:elif>
  <decl_stmt><decl><type><name>u32</name></type> <name>x</name> <init>= <expr><call><name>_byteswap_ulong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>



<comment type="block">/*
** Translate a single byte of Hex into an integer.
** This routine only works if h really is a valid hexadecimal
** character:  0..9a..fA..F
*/</comment>
<function><type><name>u8</name></type> <name>sqlite3HexToInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>h</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>h</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator> <operator>||</operator>  <operator>(</operator><name>h</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>h</name><operator>&lt;=</operator><literal type="char">'f'</literal><operator>)</operator> <operator>||</operator>  <operator>(</operator><name>h</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>h</name><operator>&lt;=</operator><literal type="char">'F'</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ASCII</name></cpp:ifdef>
  <expr_stmt><expr><name>h</name> <operator>+=</operator> <literal type="number">9</literal><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>&amp;</operator><operator>(</operator><name>h</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EBCDIC</name></cpp:ifdef>
  <expr_stmt><expr><name>h</name> <operator>+=</operator> <literal type="number">9</literal><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>&amp;</operator><operator>~</operator><operator>(</operator><name>h</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>h</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_BLOB_LITERAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAS_CODEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Convert a BLOB literal of the form "x'hhhhhh'" into its binary
** value.  Return a pointer to its binary value.  Space to hold the
** binary value has been obtained from malloc and must be freed by
** the calling routine.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3HexToBlob</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zBlob</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>n</name><operator>/</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zBlob</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>zBlob</name><index>[<expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>|</operator> <call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>zBlob</name><index>[<expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zBlob</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_BLOB_LITERAL || SQLITE_HAS_CODEC */</comment>

<comment type="block">/*
** Log an error that is an API call on a connection pointer that should
** not have been used.  The "type" of connection pointer is given as the
** argument.  The zType is a word like "NULL" or "closed" or "invalid".
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>logBadConnection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_MISUSE</name></expr></argument>, 
     <argument><expr><literal type="string">"API call with %s database connection pointer"</literal></expr></argument>,
     <argument><expr><name>zType</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Check to make sure we have a valid db pointer.  This test is not
** foolproof but it does provide some measure of protection against
** misuse of the interface such as passing in db pointers that are
** NULL or which have been previously closed.  If this routine returns
** 1 it means that the db pointer is valid and 0 if it should not be
** dereferenced for any reason.  The calling function should invoke
** SQLITE_MISUSE immediately.
**
** sqlite3SafetyCheckOk() requires that the db pointer be valid for
** use.  sqlite3SafetyCheckSickOrOk() allows a db pointer that failed to
** open properly and is not fit for general use but which can be
** used as an argument to sqlite3_errmsg() or sqlite3_close().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3SafetyCheckOk</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>magic</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>db</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>logBadConnection</name><argument_list>(<argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>magic</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>magic</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>magic</name><operator>!=</operator><name>SQLITE_MAGIC_OPEN</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>logBadConnection</name><argument_list>(<argument><expr><literal type="string">"unopened"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3SafetyCheckSickOrOk</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>magic</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>magic</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>magic</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>magic</name><operator>!=</operator><name>SQLITE_MAGIC_SICK</name> <operator>&amp;&amp;</operator>
      <name>magic</name><operator>!=</operator><name>SQLITE_MAGIC_OPEN</name> <operator>&amp;&amp;</operator>
      <name>magic</name><operator>!=</operator><name>SQLITE_MAGIC_BUSY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>logBadConnection</name><argument_list>(<argument><expr><literal type="string">"invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to add, substract, or multiply the 64-bit signed value iB against
** the other 64-bit signed integer at *pA and store the result in *pA.
** Return 0 on success.  Or if the operation would have resulted in an
** overflow, leave *pA unchanged and return 1.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3AddInt64</name><parameter_list>(<parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>iA</name> <init>= <expr><operator>*</operator><name>pA</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iB</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iB</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iB</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>LARGEST_INT64</name> <operator>-</operator> <name>iA</name> <operator>==</operator> <name>iB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>LARGEST_INT64</name> <operator>-</operator> <name>iA</name> <operator>==</operator> <name>iB</name> <operator>-</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iA</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>LARGEST_INT64</name> <operator>-</operator> <name>iA</name> <operator>&lt;</operator> <name>iB</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>-</operator><operator>(</operator><name>iA</name> <operator>+</operator> <name>LARGEST_INT64</name><operator>)</operator> <operator>==</operator> <name>iB</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iA</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>-</operator><operator>(</operator><name>iA</name> <operator>+</operator> <name>LARGEST_INT64</name><operator>)</operator> <operator>==</operator> <name>iB</name> <operator>+</operator> <literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>iA</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>-</operator><operator>(</operator><name>iA</name> <operator>+</operator> <name>LARGEST_INT64</name><operator>)</operator></expr></argument> &gt;</argument_list></name> <name>iB</name> <operator>+</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pA</name> <operator>+=</operator> <name>iB</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3SubInt64</name><parameter_list>(<parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iB</name><operator>==</operator><name>SMALLEST_INT64</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iB</name><operator>==</operator><name>SMALLEST_INT64</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><operator>*</operator><name>pA</name><operator>)</operator><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><operator>*</operator><name>pA</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pA</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pA</name> <operator>-=</operator> <name>iB</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>sqlite3AddInt64</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><operator>-</operator><name>iB</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWOPOWER32</name></cpp:macro> <cpp:value>(((i64)1)&lt;&lt;32)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWOPOWER31</name></cpp:macro> <cpp:value>(((i64)1)&lt;&lt;31)</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>sqlite3MulInt64</name><parameter_list>(<parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>iA</name> <init>= <expr><operator>*</operator><name>pA</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iA1</name></decl>, <decl><type ref="prev"/><name>iA0</name></decl>, <decl><type ref="prev"/><name>iB1</name></decl>, <decl><type ref="prev"/><name>iB0</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>iA1</name> <operator>=</operator> <name>iA</name><operator>/</operator><name>TWOPOWER32</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iA0</name> <operator>=</operator> <name>iA</name> <operator>%</operator> <name>TWOPOWER32</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iB1</name> <operator>=</operator> <name>iB</name><operator>/</operator><name>TWOPOWER32</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iB0</name> <operator>=</operator> <name>iB</name> <operator>%</operator> <name>TWOPOWER32</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iA1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iB1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pA</name> <operator>*=</operator> <name>iB</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <name>iA0</name><operator>*</operator><name>iB1</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iB1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <name>iA1</name><operator>*</operator><name>iB0</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If both iA1 and iB1 are non-zero, overflow will result */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>r</name><operator>==</operator><operator>(</operator><operator>-</operator><name>TWOPOWER31</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>r</name><operator>==</operator><operator>(</operator><operator>-</operator><name>TWOPOWER31</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>r</name><operator>==</operator><name>TWOPOWER31</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>r</name><operator>==</operator><name>TWOPOWER31</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>r</name><operator>&lt;</operator><operator>(</operator><operator>-</operator><name>TWOPOWER31</name><operator>)</operator> <operator>||</operator> <name>r</name><operator>&gt;=</operator><name>TWOPOWER31</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>r</name> <operator>*=</operator> <name>TWOPOWER32</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AddInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>iA0</name><operator>*</operator><name>iB0</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pA</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute the absolute value of a 32-bit signed integer, of possible.  Or 
** if the integer has a value of -2147483648, return +2147483647
*/</comment>
<function><type><name>int</name></type> <name>sqlite3AbsInt32</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>x</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><operator>(</operator><name>int</name><operator>)</operator><literal type="number">0x80000000</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0x7fffffff</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>-</operator><name>x</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_8_3_NAMES</name></cpp:ifdef>
<comment type="block">/*
** If SQLITE_ENABLE_8_3_NAMES is set at compile-time and if the database
** filename in zBaseFilename is a URI with the "8_3_names=1" parameter and
** if filename in z[] has a suffix (a.k.a. "extension") that is longer than
** three characters, then shorten the suffix on z[] to be the last three
** characters of the original suffix.
**
** If SQLITE_ENABLE_8_3_NAMES is set to 2 at compile-time, then always
** do the suffix shortening regardless of URI parameter.
**
** Examples:
**
**     test.db-journal    =&gt;   test.nal
**     test.db-wal        =&gt;   test.wal
**     test.db-shm        =&gt;   test.shm
**     test.db-mj7f3319fa =&gt;   test.9fa
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FileSuffix3</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBaseFilename</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_8_3_NAMES</name><operator>&lt;</operator><literal type="number">2</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_uri_boolean</name><argument_list>(<argument><expr><name>zBaseFilename</name></expr></argument>, <argument><expr><literal type="string">"8_3_names"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>sz</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>sz</name><operator>&gt;</operator><name>i</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>sz</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* 
** Find (an approximate) sum of two LogEst values.  This computation is
** not a simple "+" operator because LogEst is stored as a logarithmic
** value.
** 
*/</comment>
<function><type><name>LogEst</name></type> <name>sqlite3LogEstAdd</name><parameter_list>(<parameter><decl><type><name>LogEst</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>LogEst</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>x</name><index>[]</index></name> <init>= <expr><block>{
     <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>,                         <comment type="block">/* 0,1 */</comment>
      <expr><literal type="number">9</literal></expr>, <expr><literal type="number">9</literal></expr>,                          <comment type="block">/* 2,3 */</comment>
      <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>,                          <comment type="block">/* 4,5 */</comment>
      <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>,                       <comment type="block">/* 6,7,8 */</comment>
      <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>,                       <comment type="block">/* 9,10,11 */</comment>
      <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>,                       <comment type="block">/* 12-14 */</comment>
      <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>,                    <comment type="block">/* 15-18 */</comment>
      <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>,              <comment type="block">/* 19-24 */</comment>
      <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>,           <comment type="block">/* 25-31 */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>a</name><operator>&gt;=</operator><name>b</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>a</name><operator>&gt;</operator><name>b</name><operator>+</operator><literal type="number">49</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>a</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>a</name><operator>&gt;</operator><name>b</name><operator>+</operator><literal type="number">31</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>a</name><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>a</name><operator>+</operator><name><name>x</name><index>[<expr><name>a</name><operator>-</operator><name>b</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>b</name><operator>&gt;</operator><name>a</name><operator>+</operator><literal type="number">49</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>b</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>b</name><operator>&gt;</operator><name>a</name><operator>+</operator><literal type="number">31</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>b</name><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>b</name><operator>+</operator><name><name>x</name><index>[<expr><name>b</name><operator>-</operator><name>a</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Convert an integer into a LogEst.  In other words, compute an
** approximation for 10*log2(x).
*/</comment>
<function><type><name>LogEst</name></type> <name>sqlite3LogEst</name><parameter_list>(<parameter><decl><type><name>u64</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>LogEst</name></type> <name><name>a</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>y</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>  <expr_stmt><expr><name>y</name> <operator>-=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><name>x</name><operator>&gt;</operator><literal type="number">255</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>y</name> <operator>+=</operator> <literal type="number">40</literal></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt> </block_content>}</block></while>
    <while>while<condition>( <expr><name>x</name><operator>&gt;</operator><literal type="number">15</literal></expr> )</condition><block>{<block_content>  <expr_stmt><expr><name>y</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name><name>a</name><index>[<expr><name>x</name><operator>&amp;</operator><literal type="number">7</literal></expr>]</index></name> <operator>+</operator> <name>y</name> <operator>-</operator> <literal type="number">10</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Convert a double into a LogEst
** In other words, compute an approximation for 10*log2(x).
*/</comment>
<function><type><name>LogEst</name></type> <name>sqlite3LogEstFromDouble</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>a</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LogEst</name></type> <name>e</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">2000000000</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>sqlite3LogEst</name><argument_list>(<argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>a</name><operator>&gt;&gt;</operator><literal type="number">52</literal><operator>)</operator> <operator>-</operator> <literal type="number">1022</literal></expr>;</expr_stmt>
  <return>return <expr><name>e</name><operator>*</operator><literal type="number">10</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** Convert a LogEst into an integer.
*/</comment>
<function><type><name>u64</name></type> <name>sqlite3LogEstToInt</name><parameter_list>(<parameter><decl><type><name>LogEst</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>n</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>x</name><operator>%</operator><literal type="number">10</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><literal type="number">5</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if<condition>( <expr><name>n</name><operator>&gt;=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>x</name><operator>&gt;</operator><literal type="number">60</literal></expr> ?</condition><then> <expr><operator>(</operator><name>u64</name><operator>)</operator><name>LARGEST_INT64</name></expr> </then><else>: <expr><operator>(</operator><name>n</name><operator>+</operator><literal type="number">8</literal><operator>)</operator><operator>&lt;&lt;</operator><operator>(</operator><name>x</name><operator>-</operator><literal type="number">3</literal><operator>)</operator></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>n</name><operator>+</operator><literal type="number">8</literal><operator>)</operator><operator>&gt;&gt;</operator><operator>(</operator><literal type="number">3</literal><operator>-</operator><name>x</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
