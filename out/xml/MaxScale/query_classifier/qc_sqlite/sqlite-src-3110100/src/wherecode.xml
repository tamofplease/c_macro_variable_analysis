<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/wherecode.c"><comment type="block">/*
** 2015-06-06
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This module contains C code that generates VDBE code used to process
** the WHERE clause of SQL statements.
**
** This file was split off from where.c on 2015-06-06 in order to reduce the
** size of where.c and make it easier to edit.  This file contains the routines
** that actually generate the bulk of the WHERE loop code.  The original where.c
** file retains the code that does query planning and analysis.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"whereInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
<comment type="block">/*
** This routine is a helper for explainIndexRange() below
**
** pStr holds the text of an expression that we are building up one term
** at a time.  This routine adds a new term to the end of the expression.
** Terms are separated by AND so add the "AND" text for second and subsequent
** terms only.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>explainAppendTerm</name><parameter_list>(
  <parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>,             <comment type="block">/* The text expression being built */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTerm</name></decl></parameter>,                  <comment type="block">/* Index of this term.  First is zero */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColumn</name></decl></parameter>,        <comment type="block">/* Name of the column */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOp</name></decl></parameter>             <comment type="block">/* Name of the operator */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iTerm</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumAppendAll</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>zColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>zOp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the name of the i-th column of the pIdx index.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>explainIndexColumnName</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"&lt;expr&gt;"</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>XN_ROWID</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"rowid"</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Argument pLevel describes a strategy for scanning table pTab. This 
** function appends text to pStr that describes the subset of table
** rows scanned by the strategy in the form of an SQL expression.
**
** For example, if the query:
**
**   SELECT * FROM t1 WHERE a=1 AND b&gt;2;
**
** is run and there is an index on (a, b), then this function returns a
** string similar to:
**
**   "a=? AND b&gt;?"
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>explainIndexRange</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>, <parameter><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nEq</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nSkip</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nEq</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>&amp;</operator><operator>(</operator><name>WHERE_BTM_LIMIT</name><operator>|</operator><name>WHERE_TOP_LIMIT</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nEq</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>explainIndexColumnName</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name><operator>&gt;=</operator><name>nSkip</name></expr> ?</condition><then> <expr><literal type="string">"%s=?"</literal></expr> </then><else>: <expr><literal type="string">"ANY(%s)"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>&amp;</operator><name>WHERE_BTM_LIMIT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>explainIndexColumnName</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>explainAppendTerm</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>&amp;</operator><name>WHERE_TOP_LIMIT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>explainIndexColumnName</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>explainAppendTerm</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op unless currently processing an EXPLAIN QUERY PLAN
** command, or if either SQLITE_DEBUG or SQLITE_ENABLE_STMT_SCANSTATUS was
** defined at compile-time. If it is not a no-op, a single OP_Explain opcode 
** is added to the output to describe the table scan strategy in pLevel.
**
** If an OP_Explain opcode is added to the VM, its address is returned.
** Otherwise, if no OP_Explain is coded, zero is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WhereExplainOneScan</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,              <comment type="block">/* Table list this loop refers to */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,             <comment type="block">/* Scan to write OP_Explain opcode for */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,                     <comment type="block">/* Value for "level" column of output */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFrom</name></decl></parameter>,                      <comment type="block">/* Value for "from" column of output */</comment>
  <parameter><decl><type><name>u16</name></type> <name>wctrlFlags</name></decl></parameter>                  <comment type="block">/* Flags passed to sqlite3WhereBegin() */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_STMT_SCANSTATUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* VM being constructed */</comment>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Database handle */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iId</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelectId</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Select id (left-most output column) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>isSearch</name></decl>;</decl_stmt>                 <comment type="block">/* True for a SEARCH. False for SCAN. */</comment>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>             <comment type="block">/* The controlling WhereLoop object */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>flags</name></decl>;</decl_stmt>                    <comment type="block">/* Flags that describe this loop */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>                   <comment type="block">/* Text to add to EQP output */</comment>
    <decl_stmt><decl><type><name>StrAccum</name></type> <name>str</name></decl>;</decl_stmt>                 <comment type="block">/* EQP output string */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>               <comment type="block">/* Initial space for EQP output string */</comment>

    <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><name>WHERE_MULTI_OR</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>wctrlFlags</name><operator>&amp;</operator><name>WHERE_ONETABLE_ONLY</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>isSearch</name> <operator>=</operator> <operator>(</operator><name>flags</name><operator>&amp;</operator><operator>(</operator><name>WHERE_BTM_LIMIT</name><operator>|</operator><name>WHERE_TOP_LIMIT</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
            <operator>||</operator> <operator>(</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator>
            <operator>||</operator> <operator>(</operator><name>wctrlFlags</name><operator>&amp;</operator><operator>(</operator><name>WHERE_ORDERBY_MIN</name><operator>|</operator><name>WHERE_ORDERBY_MAX</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SQLITE_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StrAccumAppendAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><ternary><condition><expr><name>isSearch</name></expr> ?</condition><then> <expr><literal type="string">"SEARCH"</literal></expr> </then><else>: <expr><literal type="string">"SCAN"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" SUBQUERY %d"</literal></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iSelectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" TABLE %s"</literal></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_IPK</name><operator>|</operator><name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><name>WHERE_AUTO_INDEX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>flags</name><operator>&amp;</operator><name>WHERE_IDX_ONLY</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>isSearch</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"PRIMARY KEY"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>WHERE_PARTIALIDX</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"AUTOMATIC PARTIAL COVERING INDEX"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"AUTOMATIC COVERING INDEX"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"COVERING INDEX %s"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"INDEX %s"</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zFmt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" USING "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>explainIndexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>pLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WHERE_IPK</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WHERE_CONSTRAINT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRangeOp</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><operator>(</operator><name>WHERE_COLUMN_EQ</name><operator>|</operator><name>WHERE_COLUMN_IN</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zRangeOp</name> <operator>=</operator> <literal type="string">"="</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><name>WHERE_BOTH_LIMIT</name><operator>)</operator><operator>==</operator><name>WHERE_BOTH_LIMIT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zRangeOp</name> <operator>=</operator> <literal type="string">"&gt;? AND rowid&lt;"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>WHERE_BTM_LIMIT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zRangeOp</name> <operator>=</operator> <literal type="string">"&gt;"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>&amp;</operator><name>WHERE_TOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zRangeOp</name> <operator>=</operator> <literal type="string">"&lt;"</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" USING INTEGER PRIMARY KEY (rowid%s?)"</literal></expr></argument>,<argument><expr><name>zRangeOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" VIRTUAL TABLE INDEX %d:%s"</literal></expr></argument>,
                  <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxNum</name></name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EXPLAIN_ESTIMATED_ROWS</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name><operator>&gt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" (~%llu rows)"</literal></expr></argument>, <argument><expr><call><name>sqlite3LogEstToInt</name><argument_list>(<argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" (~1 row)"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Explain</name></expr></argument>, <argument><expr><name>iId</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>,<argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_EXPLAIN */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
<comment type="block">/*
** Configure the VM passed as the first argument with an
** sqlite3_stmt_scanstatus() entry corresponding to the scan used to 
** implement level pLvl. Argument pSrclist is a pointer to the FROM 
** clause that the scan reads data from.
**
** If argument addrExplain is not 0, it must be the address of an 
** OP_Explain instruction that describes the same loop.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereAddScanStatus</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,                        <comment type="block">/* Vdbe to add scanstatus entry to */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrclist</name></decl></parameter>,              <comment type="block">/* FROM clause pLvl reads data from */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLvl</name></decl></parameter>,               <comment type="block">/* Level to add scanstatus() entry for */</comment>
  <parameter><decl><type><name>int</name></type> <name>addrExplain</name></decl></parameter>                 <comment type="block">/* Address of OP_Explain (or 0) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zObj</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><name><name>pLvl</name><operator>-&gt;</operator><name>pWLoop</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>  <operator>&amp;&amp;</operator>  <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zObj</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zObj</name> <operator>=</operator> <name><name>pSrclist</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLvl</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeScanStatus</name><argument_list>(
      <argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrExplain</name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>addrBody</name></name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>addrVisit</name></name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nOut</name></name></expr></argument>, <argument><expr><name>zObj</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Disable a term in the WHERE clause.  Except, do not disable the term
** if it controls a LEFT OUTER JOIN and it did not originate in the ON
** or USING clause of that join.
**
** Consider the term t2.z='ok' in the following queries:
**
**   (1)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x WHERE t2.z='ok'
**   (2)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x AND t2.z='ok'
**   (3)  SELECT * FROM t1, t2 WHERE t1.a=t2.x AND t2.z='ok'
**
** The t2.z='ok' is disabled in the in (2) because it originates
** in the ON clause.  The term is disabled in (3) because it is not part
** of a LEFT OUTER JOIN.  In (1), the term is not disabled.
**
** Disabling a term causes that term to not be tested in the inner loop
** of the join.  Disabling is an optimization.  When terms are satisfied
** by indices, we disable them to prevent redundant tests in the inner
** loop.  We would get the correct results if nothing were ever disabled,
** but joins might run a little slower.  The trick is to disable as much
** as we can without disabling too much.  If we disabled in (1), we'd get
** the wrong answer.  See ticket #813.
**
** If all the children of a term are disabled, then that term is also
** automatically disabled.  In this way, terms get disabled if derived
** virtual terms are tested first.  For example:
**
**      x GLOB 'abc*' AND x&gt;='abc' AND x&lt;'acd'
**      \___________/     \______/     \_____/
**         parent          child1       child2
**
** Only the parent term was in the original WHERE clause.  The child1
** and child2 terms were added by the LIKE optimization.  If both of
** the virtual child terms are valid, then testing of the parent can be 
** skipped.
**
** Usually the parent term is marked as TERM_CODED.  But if the parent
** term was originally TERM_LIKE, then the parent gets TERM_LIKECOND instead.
** The TERM_LIKECOND marking indicates that the term should be coded inside
** a conditional such that is only evaluated on the second pass of a
** LIKE-optimization loop, when scanning BLOBs instead of strings.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>disableTerm</name><parameter_list>(<parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>, <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nLoop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>pTerm</name>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_CODED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name> <operator>&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nLoop</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_LIKECOND</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>iParent</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pTerm</name><operator>-&gt;</operator><name>iParent</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>nChild</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>nChild</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nLoop</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Code an OP_Affinity opcode to apply the column affinity string zAff
** to the n registers starting at base. 
**
** As an optimization, SQLITE_AFF_BLOB entries (which are no-ops) at the
** beginning and end of zAff are ignored.  If all entries in zAff are
** SQLITE_AFF_BLOB, then no code gets generated.
**
** This routine makes its own copy of zAff so that the caller is free
** to modify zAff after this routine returns.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeApplyAffinity</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zAff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zAff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Adjust base and n to skip over SQLITE_AFF_BLOB entries at the beginning
  ** and end of the affinity string.
  */</comment>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zAff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>base</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>zAff</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zAff</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Code the OP_Affinity opcode if there is anything left to do. */</comment>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Affinity</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zAff</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Generate code for a single equality term of the WHERE clause.  An equality
** term can be either X=expr or X IN (...).   pTerm is the term to be 
** coded.
**
** The current value for the constraint is left in register iReg.
**
** For a constraint of the form X=expr, the expression is evaluated and its
** result is left on the stack.  For constraints of the form X IN (...)
** this routine sets up a loop that will iterate over all values of X.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeEqualityTerm</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>,   <comment type="block">/* The term of the WHERE clause to be coded */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>, <comment type="block">/* The level of the FROM clause we are working on */</comment>
  <parameter><decl><type><name>int</name></type> <name>iEq</name></decl></parameter>,            <comment type="block">/* Index of the equality term within this level */</comment>
  <parameter><decl><type><name>int</name></type> <name>bRev</name></decl></parameter>,           <comment type="block">/* True for reverse-order IN operations */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTarget</name></decl></parameter>         <comment type="block">/* Attempt to leave results in this register */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>                  <comment type="block">/* Register holding results */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTarget</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EQ</name> <operator>||</operator> <name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>iTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iReg</name> <operator>=</operator> <name>iTarget</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iTab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>InLoop</name></name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
      <operator>&amp;&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal>
      <operator>&amp;&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>iEq</name></expr>]</index></name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iEq</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>bRev</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bRev</name> <operator>=</operator> <operator>!</operator><name>bRev</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iReg</name> <operator>=</operator> <name>iTarget</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <call><name>sqlite3FindInIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><name>IN_INDEX_LOOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>IN_INDEX_INDEX_DESC</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>bRev</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bRev</name> <operator>=</operator> <operator>!</operator><name>bRev</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iTab</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Last</name></expr> </then><else>: <expr><name>OP_Rewind</name></expr></else></ternary></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>!</operator><name>bRev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>|=</operator> <name>WHERE_IN_ABLE</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name></name> <operator>=</operator>
       <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name></name></expr></argument>,
                              <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>aInLoop</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIn</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pIn</name> <operator>+=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>iCur</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>IN_INDEX_ROWID</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>addrInTop</name></name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>eEndLoopOp</name></name> <operator>=</operator> <ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_PrevIfOpen</name></expr> </then><else>: <expr><name>OP_NextIfOpen</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>nIn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iReg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will evaluate all == and IN constraints for an
** index scan.
**
** For example, consider table t1(a,b,c,d,e,f) with index i1(a,b,c).
** Suppose the WHERE clause is this:  a==5 AND b IN (1,2,3) AND c&gt;5 AND c&lt;10
** The index has as many as three equality constraints, but in this
** example, the third "c" value is an inequality.  So only two 
** constraints are coded.  This routine will generate code to evaluate
** a==5 and b IN (1,2,3).  The current values for a and b will be stored
** in consecutive registers and the index of the first register is returned.
**
** In the example above nEq==2.  But this subroutine works for any value
** of nEq including 0.  If nEq==0, this routine is nearly a no-op.
** The only thing it does is allocate the pLevel-&gt;iMem memory cell and
** compute the affinity string.
**
** The nExtraReg parameter is 0 or 1.  It is 0 if all WHERE clause constraints
** are == or IN and are covered by the nEq.  nExtraReg is 1 if there is
** an inequality constraint (such as the "c&gt;=5 AND c&lt;10" in the example) that
** occurs after the nEq quality constraints.
**
** This routine allocates a range of nEq+nExtraReg memory cells and returns
** the index of the first memory cell in that range. The code that
** calls this routine will use that memory range to store keys for
** start and termination conditions of the loop.
** key value of the loop.  If one or more IN operators appear, then
** this routine allocates an additional nEq memory cells for internal
** use.
**
** Before returning, *pzAff is set to point to a buffer containing a
** copy of the column affinity string of the index allocated using
** sqlite3DbMalloc(). Except, entries in the copy of the string associated
** with equality constraints that use BLOB or NONE affinity are set to
** SQLITE_AFF_BLOB. This is to deal with SQL such as the following:
**
**   CREATE TABLE t1(a TEXT PRIMARY KEY, b);
**   SELECT ... FROM t1 AS t2, t1 WHERE t1.a = t2.b;
**
** In the example above, the index on t1(a) has TEXT affinity. But since
** the right hand side of the equality constraint (t2.b) has BLOB/NONE affinity,
** no conversion should be attempted before using a t2.b value as part of
** a key to search the index. Hence the first byte in the returned affinity
** string in this example would be set to SQLITE_AFF_BLOB.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeAllEqualityTerms</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,   <comment type="block">/* Which nested loop of the FROM we are coding */</comment>
  <parameter><decl><type><name>int</name></type> <name>bRev</name></decl></parameter>,             <comment type="block">/* Reverse the order of IN operators */</comment>
  <parameter><decl><type><name>int</name></type> <name>nExtraReg</name></decl></parameter>,        <comment type="block">/* Number of extra registers to allocate */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzAff</name></decl></parameter>          <comment type="block">/* OUT: Set to point to affinity string */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>nEq</name></decl>;</decl_stmt>                      <comment type="block">/* The number of == or IN constraints to code */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nSkip</name></decl>;</decl_stmt>                    <comment type="block">/* Number of left-most columns to skip */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* The vm under construction */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>                  <comment type="block">/* The index being used for this loop */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>             <comment type="block">/* A single constraint term */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>             <comment type="block">/* The WhereLoop object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>                  <comment type="block">/* Base register */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nReg</name></decl>;</decl_stmt>                     <comment type="block">/* Number of registers to allocate */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAff</name></decl>;</decl_stmt>                   <comment type="block">/* Affinity string to return */</comment>

  <comment type="block">/* This module is only called on query plans that use an index. */</comment>
  <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nEq</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSkip</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out how many memory cells we will need then allocate them.
  */</comment>
  <expr_stmt><expr><name>regBase</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nReg</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name> <operator>+</operator> <name>nExtraReg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nReg</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>zAff</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><call><name>sqlite3IndexAffinityStr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zAff</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nSkip</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bRev</name></expr>?</condition><then><expr><name>OP_Last</name></expr></then><else>:<expr><name>OP_Rewind</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"begin skip-scan on %s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrSkip</name></name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bRev</name></expr>?</condition><then><expr><name>OP_SeekLT</name></expr></then><else>:<expr><name>OP_SeekGT</name></expr></else></ternary><operator>)</operator></expr></argument>,
                            <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nSkip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nSkip</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name>XN_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <call><name>explainIndexColumnName</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>    

  <comment type="block">/* Evaluate the equality constraints
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zAff</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zAff</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><name>nEq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>nSkip</name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nEq</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The following testcase is true for indices with redundant columns. 
    ** Ex: CREATE INDEX i1 ON t1(a,b,a); SELECT * FROM t1 WHERE a=0 AND b=0; */</comment>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_CODED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>codeEqualityTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>bRev</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>r1</name><operator>!=</operator><name>regBase</name><operator>+</operator><name>j</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nReg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>regBase</name> <operator>=</operator> <name>r1</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_ISNULL</name><operator>|</operator><name>WO_IN</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_IS</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zAff</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name><name>zAff</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zAff</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprNeedsNoAffinityChange</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name><name>zAff</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zAff</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pzAff</name> <operator>=</operator> <name>zAff</name></expr>;</expr_stmt>
  <return>return <expr><name>regBase</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifndef>
<comment type="block">/*
** If the most recently coded instruction is a constant range contraint
** that originated from the LIKE optimization, then change the P3 to be
** pLoop-&gt;iLikeRepCntr and set P5.
**
** The LIKE optimization trys to evaluate "x LIKE 'abc%'" as a range
** expression: "x&gt;='ABC' AND x&lt;'abd'".  But this requires that the range
** scan loop run twice, once for strings and a second time for BLOBs.
** The OP_String opcodes on the second pass convert the upper and lower
** bound string contants to blobs.  This routine makes the necessary changes
** to the OP_String opcodes for that to happen.
**
** Except, of course, if SQLITE_LIKE_DOESNT_MATCH_BLOBS is defined, then
** only the one pass through the string space is required, so this routine
** becomes a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereLikeOptimizationStringFixup</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,                <comment type="block">/* prepared statement under construction */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,     <comment type="block">/* The loop that contains the LIKE operator */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>        <comment type="block">/* The upper or lower bound just coded */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_String8</name> 
            <operator>||</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>whereLikeOptimizationStringFixup</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
<comment type="block">/*
** Information is passed from codeCursorHint() down to individual nodes of
** the expression tree (by sqlite3WalkExpr()) using an instance of this
** structure.
*/</comment>
<struct>struct <name>CCurHint</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iTabCur</name></decl>;</decl_stmt>    <comment type="block">/* Cursor for the main table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name></decl>;</decl_stmt>    <comment type="block">/* Cursor for the index, if pIdx!=0.  Unused otherwise */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>    <comment type="block">/* The index used to access the table */</comment>
}</block>;</struct>

<comment type="block">/*
** This function is called for every node of an expression that is a candidate
** for a cursor hint on an index cursor.  For TK_COLUMN nodes that reference
** the table CCurHint.iTabCur, verify that the same column can be
** accessed through the index.  If it cannot, then set pWalker-&gt;eCode to 1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeCursorHintCheckExpr</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>CCurHint</name></name> <modifier>*</modifier></type><name>pHint</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCCurHint</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>pIdx</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pHint</name><operator>-&gt;</operator><name>iTabCur</name></name>
   <operator>&amp;&amp;</operator> <call><name>sqlite3ColumnOfIndex</name><argument_list>(<argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>pIdx</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is called on every node of an expression tree used as an
** argument to the OP_CursorHint instruction. If the node is a TK_COLUMN
** that accesses any table other than the one identified by
** CCurHint.iTabCur, then do the following:
**
**   1) allocate a register and code an OP_Column instruction to read 
**      the specified column into the new register, and
**
**   2) transform the expression node to a TK_REGISTER node that reads 
**      from the newly populated register.
**
** Also, if the node is a TK_COLUMN that does access the table idenified
** by pCCurHint.iTabCur, and an index is being used (which we will
** know because CCurHint.pIdx!=0) then transform the TK_COLUMN into
** an access of the index rather than the original table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeCursorHintFixExpr</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>WRC_Continue</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>CCurHint</name></name> <modifier>*</modifier></type><name>pHint</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCCurHint</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name><name>pHint</name><operator>-&gt;</operator><name>iTabCur</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>reg</name> <init>= <expr><operator>++</operator><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Register for column value */</comment>
      <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(
          <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_REGISTER</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pHint</name><operator>-&gt;</operator><name>pIdx</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pHint</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <call><name>sqlite3ColumnOfIndex</name><argument_list>(<argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>pIdx</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* An aggregate function in the WHERE clause of a query means this must
    ** be a correlated sub-query, and expression pExpr is an aggregate from
    ** the parent context. Do not walk the function arguments in this case.
    **
    ** todo: It should be possible to replace this node with a TK_REGISTER
    ** expression, as the result of the expression must be stored in a 
    ** register at this point. The same holds for TK_AGG_COLUMN nodes. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WRC_Prune</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Insert an OP_CursorHint instruction if it is appropriate to do so.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeCursorHint</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,    <comment type="block">/* The where clause */</comment>
  <parameter><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>,   <comment type="block">/* Which loop to provide hints for */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pEndRange</name></decl></parameter>  <comment type="block">/* Hint this end-of-scan boundary term if not NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name> <init>= <expr><name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>CCurHint</name></name></type> <name>sHint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>sWalker</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_CursorHints</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iTabCur</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCur</name><operator>==</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sHint</name><operator>.</operator><name>iTabCur</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sHint</name><operator>.</operator><name>iIdxCur</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sHint</name><operator>.</operator><name>pIdx</name></name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sWalker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>u</name><operator>.</operator><name>pCCurHint</name></name> <operator>=</operator> <operator>&amp;</operator><name>sHint</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_CODED</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* All terms in pWLoop-&gt;aLTerm[] except pEndRange are used to initialize
    ** the cursor.  These terms are not needed as hints for a pure range
    ** scan (that has no == terms) so omit them. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pTerm</name><operator>!=</operator><name>pEndRange</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name> <operator>&amp;&amp;</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><name>pTerm</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No subqueries or non-deterministic functions allowed */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprContainsSubquery</name><argument_list>(<argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* For an index scan, make sure referenced columns are actually in
    ** the index. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>sHint</name><operator>.</operator><name>pIdx</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>codeCursorHintCheckExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sWalker</name><operator>.</operator><name>eCode</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we survive all prior tests, that means this term is worth hinting */</comment>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sWalker</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>codeCursorHintFixExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sWalker</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CursorHint</name></expr></argument>, 
                      <argument><expr><operator>(</operator><ternary><condition><expr><name><name>sHint</name><operator>.</operator><name>pIdx</name></name></expr> ?</condition><then> <expr><name><name>sHint</name><operator>.</operator><name>iIdxCur</name></name></expr> </then><else>: <expr><name><name>sHint</name><operator>.</operator><name>iTabCur</name></name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                      <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>pExpr</name></expr></argument>, <argument><expr><name>P4_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>codeCursorHint</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>  <comment type="block">/* No-op */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_CURSOR_HINTS */</comment>

<comment type="block">/*
** Cursor iCur is open on an intkey b-tree (a table). Register iRowid contains
** a rowid value just read from cursor iIdxCur, open on index pIdx. This
** function generates code to do a deferred seek of cursor iCur to the 
** rowid stored in register iRowid.
**
** Normally, this is just:
**
**   OP_Seek $iCur $iRowid
**
** However, if the scan currently being coded is a branch of an OR-loop and
** the statement currently being coded is a SELECT, then P3 of the OP_Seek
** is set to iIdxCur and P4 is set to point to an array of integers
** containing one entry for each column of the table cursor iCur is open 
** on. For each table column, if the column is the i'th column of the 
** index, then the corresponding array entry is set to (i+1). If the column
** does not appear in the index at all, the array entry is set to 0.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeDeferredSeek</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,              <comment type="block">/* Where clause context */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,                    <comment type="block">/* Index scan is using */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,                       <comment type="block">/* Cursor for IPK b-tree */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCur</name></decl></parameter>                     <comment type="block">/* Index cursor */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Parse context */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Vdbe to generate code within */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIdxCur</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Seek</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_FORCE_TABLE</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <call><name>DbMaskAllZero</name><argument_list>(<argument><expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>writeMask</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>ai</name> <init>= <expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>ai</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>ai</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ai</name><index>[<expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ai</name></expr></argument>, <argument><expr><name>P4_INTARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code for the start of the iLevel-th loop in the WHERE clause
** implementation described by pWInfo.
*/</comment>
<function><type><name>Bitmask</name></type> <name>sqlite3WhereCodeOneLoopStart</name><parameter_list>(
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>,   <comment type="block">/* Complete information about the WHERE clause */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,          <comment type="block">/* Which level of pWInfo-&gt;a[] should be coded */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></parameter>     <comment type="block">/* Which tables are currently available */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>            <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>            <comment type="block">/* The VDBE cursor for the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrNxt</name></decl>;</decl_stmt>         <comment type="block">/* Where to jump to continue with the next IN case */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>omitTable</name></decl>;</decl_stmt>       <comment type="block">/* True if we use the index only */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRev</name></decl>;</decl_stmt>            <comment type="block">/* True if we need to scan in reverse order */</comment>
  <decl_stmt><decl><type><name>WhereLevel</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>  <comment type="block">/* The where level to be coded */</comment>
  <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pLoop</name></decl>;</decl_stmt>    <comment type="block">/* The WhereLoop object being coded */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl>;</decl_stmt>    <comment type="block">/* Decomposition of the entire WHERE clause */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>               <comment type="block">/* A WHERE clause term */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>                  <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>                        <comment type="block">/* The prepared stmt under constructions */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pTabItem</name></decl>;</decl_stmt>  <comment type="block">/* FROM clause term being coded */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrBrk</name></decl>;</decl_stmt>                    <comment type="block">/* Jump here to break out of the loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrCont</name></decl>;</decl_stmt>                   <comment type="block">/* Jump here to continue with next cycle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRowidReg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Rowid is stored in this register, if not zero */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iReleaseReg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Temp register to free before returning */</comment>

  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sWC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLevel</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iLevel</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLoop</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>pWLoop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name> <operator>=</operator> <name>notReady</name> <operator>&amp;</operator> <operator>~</operator><call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bRev</name> <operator>=</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>revMask</name></name><operator>&gt;&gt;</operator><name>iLevel</name><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>omitTable</name> <operator>=</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IDX_ONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> 
           <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_FORCE_TABLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Begin WHERE-loop%d: %s"</literal><operator>,</operator><name>iLevel</name><operator>,</operator><name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create labels for the "break" and "continue" instructions
  ** for the current loop.  Jump to addrBrk to break out of a loop.
  ** Jump to cont to go immediately to the next iteration of the
  ** loop.
  **
  ** When there is an IN operator, we also have a "addrNxt" label that
  ** means to continue with the next IN value combination.  When
  ** there are no IN operators in the constraints, the "addrNxt" label
  ** is the same as "addrBrk".
  */</comment>
  <expr_stmt><expr><name>addrBrk</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrCont</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrCont</name></name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is the right table of a LEFT OUTER JOIN, allocate and
  ** initialize a memory cell that records if this table matches any
  ** row of the left table of the join.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTabItem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"init LEFT JOIN no-match flag"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Special case of a FROM clause subquery implemented as a co-routine */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>viaCoroutine</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regYield</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InitCoroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTabItem</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator>  <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"next row of \"%s\""</literal><operator>,</operator> <name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Goto</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  if<condition>(  <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_VIRTUALTABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Case 1:  The table is a virtual-table.  Use the VFilter and VNext
    **          to access the data.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>   <comment type="block">/* P3 Value for OP_VFilter */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrNotFound</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>nLTerm</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iReg</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nConstraint</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrNotFound</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nConstraint</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iTarget</name> <init>= <expr><name>iReg</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pTerm</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>codeEqualityTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>bRev</name></expr></argument>, <argument><expr><name>iTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>addrNotFound</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>iTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxNum</name></name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>nConstraint</name></expr></argument>, <argument><expr><name>iReg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VFilter</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrNotFound</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>,
                      <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>idxStr</name></name></expr></argument>,
                      <argument><expr><ternary><condition><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name></expr> ?</condition><then> <expr><name>P4_MPRINTF</name></expr> </then><else>: <expr><name>P4_STATIC</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>needFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nConstraint</name> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><literal type="number">16</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>vtab</name><operator>.</operator><name>omitMask</name></name><operator>&gt;&gt;</operator><name>j</name><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name></expr> ?</condition><then> <expr><name>OP_Noop</name></expr> </then><else>: <expr><name>OP_VNext</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>nConstraint</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

  if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IPK</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>WHERE_COLUMN_IN</name><operator>|</operator><name>WHERE_COLUMN_EQ</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* Case 2:  We can directly reference a single row using an
    **          equality comparison against the ROWID field.  Or
    **          we reference multiple rows using a "rowid IN (...)"
    **          construct.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>omitTable</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iReleaseReg</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iRowidReg</name> <operator>=</operator> <call><name>codeEqualityTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bRev</name></expr></argument>, <argument><expr><name>iReleaseReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iRowidReg</name><operator>!=</operator><name>iReleaseReg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iReleaseReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>addrNxt</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCacheStore</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"pk"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Noop</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_IPK</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_COLUMN_RANGE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* Case 3:  We have an inequality comparison against the ROWID field.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>testOp</name> <init>= <expr><name>OP_Noop</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>memEndValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pStart</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>omitTable</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStart</name> <operator>=</operator> <name>pEnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BTM_LIMIT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pStart</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TOP_LIMIT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pStart</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>pEnd</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bRev</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name>pStart</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pStart</name> <operator>=</operator> <name>pEnd</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>codeCursorHint</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pStart</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>             <comment type="block">/* The expression that defines the start bound */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>rTemp</name></decl>;</decl_stmt>        <comment type="block">/* Registers for holding the start boundary */</comment>

      <comment type="block">/* The following constant maps TK_xx codes into corresponding 
      ** seek opcodes.  It depends on a particular ordering of TK_xx
      */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name></type> <name><name>aMoveOp</name><index>[]</index></name> <init>= <expr><block>{
           <comment type="block">/* TK_GT */</comment>  <expr><name>OP_SeekGT</name></expr>,
           <comment type="block">/* TK_LE */</comment>  <expr><name>OP_SeekLE</name></expr>,
           <comment type="block">/* TK_LT */</comment>  <expr><name>OP_SeekLT</name></expr>,
           <comment type="block">/* TK_GE */</comment>  <expr><name>OP_SeekGE</name></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LE</name><operator>==</operator><name>TK_GT</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Make sure the ordering.. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LT</name><operator>==</operator><name>TK_GT</name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/*  ... of the TK_xx values... */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GE</name><operator>==</operator><name>TK_GT</name><operator>+</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/*  ... is correcct. */</comment>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pStart</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pX</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pStart</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>!=</operator><name>iCur</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* transitive constraints */</comment>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aMoveOp</name><index>[<expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>-</operator><name>TK_GT</name></expr>]</index></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"pk"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>rTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Last</name></expr> </then><else>: <expr><name>OP_Rewind</name></expr></else></ternary></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pEnd</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pEnd</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pX</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pEnd</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>!=</operator><name>iCur</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Transitive constraints */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>memEndValue</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>memEndValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LT</name> <operator>||</operator> <name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>testOp</name> <operator>=</operator> <ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Le</name></expr> </then><else>: <expr><name>OP_Ge</name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>testOp</name> <operator>=</operator> <ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Lt</name></expr> </then><else>: <expr><name>OP_Gt</name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <ternary><condition><expr><name>bRev</name></expr> ?</condition><then> <expr><name>OP_Prev</name></expr> </then><else>: <expr><name>OP_Next</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>testOp</name><operator>!=</operator><name>OP_Noop</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iRowidReg</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCacheStore</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name></expr></argument>, <argument><expr><name>memEndValue</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name> <operator>|</operator> <name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Case 4: A scan using an index.
    **
    **         The WHERE clause may contain zero or more equality 
    **         terms ("==" or "IN" operators) that refer to the N
    **         left-most columns of the index. It may also contain
    **         inequality constraints (&gt;, &lt;, &gt;= or &lt;=) on the indexed
    **         column that immediately follows the N equalities. Only 
    **         the right-most column can be an inequality - the rest must
    **         use the "==" and "IN" operators. For example, if the 
    **         index is on (x,y,z), then the following clauses are all 
    **         optimized:
    **
    **            x=5
    **            x=5 AND y=10
    **            x=5 AND y&lt;10
    **            x=5 AND y&gt;5 AND y&lt;10
    **            x=5 AND y=5 AND z&lt;=10
    **
    **         The z&lt;10 term of the following cannot be used, only
    **         the x=5 term:
    **
    **            x=5 AND z&lt;10
    **
    **         N may be zero if there are inequality constraints.
    **         If there are no inequality constraints, then N is at
    **         least one.
    **
    **         This case is also used when there are no WHERE clause
    **         constraints but an index is selected anyway, in order
    **         to force the output order to conform to an ORDER BY.
    */</comment>  
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aStartOp</name><index>[]</index></name> <init>= <expr><block>{
      <expr><literal type="number">0</literal></expr>,
      <expr><literal type="number">0</literal></expr>,
      <expr><name>OP_Rewind</name></expr>,           <comment type="block">/* 2: (!start_constraints &amp;&amp; startEq &amp;&amp;  !bRev) */</comment>
      <expr><name>OP_Last</name></expr>,             <comment type="block">/* 3: (!start_constraints &amp;&amp; startEq &amp;&amp;   bRev) */</comment>
      <expr><name>OP_SeekGT</name></expr>,           <comment type="block">/* 4: (start_constraints  &amp;&amp; !startEq &amp;&amp; !bRev) */</comment>
      <expr><name>OP_SeekLT</name></expr>,           <comment type="block">/* 5: (start_constraints  &amp;&amp; !startEq &amp;&amp;  bRev) */</comment>
      <expr><name>OP_SeekGE</name></expr>,           <comment type="block">/* 6: (start_constraints  &amp;&amp;  startEq &amp;&amp; !bRev) */</comment>
      <expr><name>OP_SeekLE</name></expr>            <comment type="block">/* 7: (start_constraints  &amp;&amp;  startEq &amp;&amp;  bRev) */</comment>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aEndOp</name><index>[]</index></name> <init>= <expr><block>{
      <expr><name>OP_IdxGE</name></expr>,            <comment type="block">/* 0: (end_constraints &amp;&amp; !bRev &amp;&amp; !endEq) */</comment>
      <expr><name>OP_IdxGT</name></expr>,            <comment type="block">/* 1: (end_constraints &amp;&amp; !bRev &amp;&amp;  endEq) */</comment>
      <expr><name>OP_IdxLE</name></expr>,            <comment type="block">/* 2: (end_constraints &amp;&amp;  bRev &amp;&amp; !endEq) */</comment>
      <expr><name>OP_IdxLT</name></expr>,            <comment type="block">/* 3: (end_constraints &amp;&amp;  bRev &amp;&amp;  endEq) */</comment>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u16</name></type> <name>nEq</name> <init>= <expr><name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>nEq</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Number of == or IN terms */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>                 <comment type="block">/* Base register holding constraint values */</comment>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pRangeStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Inequality constraint at range start */</comment>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pRangeEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Inequality constraint at range end */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>startEq</name></decl>;</decl_stmt>                 <comment type="block">/* True if range start uses ==, &gt;= or &lt;= */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>endEq</name></decl>;</decl_stmt>                   <comment type="block">/* True if range end uses ==, &gt;= or &lt;= */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>start_constraints</name></decl>;</decl_stmt>       <comment type="block">/* Start of range is constrained */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name></decl>;</decl_stmt>             <comment type="block">/* Number of constraint terms */</comment>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>                 <comment type="block">/* The index we will be using */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name></decl>;</decl_stmt>                 <comment type="block">/* The VDBE cursor for the index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nExtraReg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Number of extra registers needed */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                      <comment type="block">/* Instruction opcode */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStartAff</name></decl>;</decl_stmt>             <comment type="block">/* Affinity for start of range constraint */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>cEndAff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Affinity for end of range constraint */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>bSeekPastNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* True to seek past initial nulls */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>bStopAtNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Add condition to terminate at NULLs */</comment>

    <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iIdxCur</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nEq</name><operator>&gt;=</operator><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If this loop satisfies a sort order (pOrderBy) request that 
    ** was passed to this function to implement a "SELECT min(x) ..." 
    ** query, then the caller will only allow the loop to run for
    ** a single iteration. This means that the first row returned
    ** should not have a NULL value stored in 'x'. If column 'x' is
    ** the first one after the nEq equality constraints in the index,
    ** this requires some special handling.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal>
         <operator>||</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><literal type="number">1</literal>
         <operator>||</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name><operator>&amp;</operator><name>WHERE_ORDERBY_MIN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name><operator>&amp;</operator><name>WHERE_ORDERBY_MIN</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nOBSat</name></name><operator>&gt;</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>&gt;</operator><name>nEq</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLoop</name><operator>-&gt;</operator><name>nSkip</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bSeekPastNull</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtraReg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find any inequality constraint terms for the start and end 
    ** of the range. 
    */</comment>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>nEq</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_BTM_LIMIT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pRangeStart</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtraReg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <comment type="block">/* Like optimization range constraints always occur in pairs */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pRangeStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> 
              <operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TOP_LIMIT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_TOP_LIMIT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pRangeEnd</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtraReg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRangeEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRangeStart</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>                     <comment type="block">/* LIKE opt constraints */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRangeStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKEOPT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* occur in pairs */</comment>
        <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>bRev</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>nEq</name></expr>]</index></name><operator>==</operator><name>SQLITE_SO_DESC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>,
                          <argument><expr><name>bRev</name> <operator>^</operator> <operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>nEq</name></expr>]</index></name><operator>==</operator><name>SQLITE_SO_DESC</name><operator>)</operator></expr></argument>,
                          <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"LIKE loop counter"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrLikeRep</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name>pRangeStart</name><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>j</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>nEq</name></expr>]</index></name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal> 
       <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>notNull</name><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>bSeekPastNull</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRangeEnd</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pRangeEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we are doing a reverse order scan on an ascending index, or
    ** a forward order scan on a descending index, interchange the 
    ** start and end terms (pRangeStart and pRangeEnd).
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nEq</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name> <operator>&amp;&amp;</operator> <name>bRev</name><operator>==</operator><operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>nEq</name></expr>]</index></name><operator>==</operator><name>SQLITE_SO_ASC</name><operator>)</operator><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name>bRev</name> <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><name>nEq</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>WhereTerm</name> <operator>*</operator></expr></argument>, <argument><expr><name>pRangeEnd</name></expr></argument>, <argument><expr><name>pRangeStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>u8</name></expr></argument>, <argument><expr><name>bSeekPastNull</name></expr></argument>, <argument><expr><name>bStopAtNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Generate code to evaluate all constraint terms using == or IN
    ** and store the values of those terms in an array of registers
    ** starting at regBase.
    */</comment>
    <expr_stmt><expr><call><name>codeCursorHint</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regBase</name> <operator>=</operator> <call><name>codeAllEqualityTerms</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pLevel</name></expr></argument>,<argument><expr><name>bRev</name></expr></argument>,<argument><expr><name>nExtraReg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zStartAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zStartAff</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zStartAff</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><name>nEq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zStartAff</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cEndAff</name> <operator>=</operator> <name><name>zStartAff</name><index>[<expr><name>nEq</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>addrNxt</name> <operator>=</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>addrNxt</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeStart</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRangeStart</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_LE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeStart</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRangeStart</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_GE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRangeEnd</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_LE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRangeEnd</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_GE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>startEq</name> <operator>=</operator> <operator>!</operator><name>pRangeStart</name> <operator>||</operator> <name><name>pRangeStart</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_LE</name><operator>|</operator><name>WO_GE</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>endEq</name> <operator>=</operator>   <operator>!</operator><name>pRangeEnd</name> <operator>||</operator> <name><name>pRangeEnd</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_LE</name><operator>|</operator><name>WO_GE</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>start_constraints</name> <operator>=</operator> <name>pRangeStart</name> <operator>||</operator> <name>nEq</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Seek the index cursor to the start of the range. */</comment>
    <expr_stmt><expr><name>nConstraint</name> <operator>=</operator> <name>nEq</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRangeStart</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pRangeStart</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>whereLikeOptimizationStringFixup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRangeStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zStartAff</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name><name>zStartAff</name><index>[<expr><name>nEq</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr>)</condition><block>{<block_content>
          <comment type="block">/* Since the comparison is to be performed with no conversions
          ** applied to the operands, set the affinity to apply to pRight to 
          ** SQLITE_AFF_BLOB.  */</comment>
          <expr_stmt><expr><name><name>zStartAff</name><index>[<expr><name>nEq</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprNeedsNoAffinityChange</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name><name>zStartAff</name><index>[<expr><name>nEq</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zStartAff</name><index>[<expr><name>nEq</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>  
      <expr_stmt><expr><name>nConstraint</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRangeStart</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bSeekPastNull</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nConstraint</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>startEq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>start_constraints</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>codeApplyAffinity</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nConstraint</name> <operator>-</operator> <name>bSeekPastNull</name></expr></argument>, <argument><expr><name>zStartAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>aStartOp</name><index>[<expr><operator>(</operator><name>start_constraints</name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>startEq</name><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>bRev</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Rewind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Rewind</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_Last</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_SeekGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_SeekLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Load the value for the inequality constraint at the end of the
    ** range (if any).
    */</comment>
    <expr_stmt><expr><name>nConstraint</name> <operator>=</operator> <name>nEq</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRangeEnd</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pRangeEnd</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCacheRemove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>whereLikeOptimizationStringFixup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRangeEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>cEndAff</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_AFF_BLOB</name>
       <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3ExprNeedsNoAffinityChange</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>cEndAff</name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>codeApplyAffinity</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cEndAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nConstraint</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRangeEnd</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bStopAtNull</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>endEq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nConstraint</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStartAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Top of the loop body */</comment>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the index cursor is past the end of the range. */</comment>
    <if_stmt><if>if<condition>( <expr><name>nConstraint</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>aEndOp</name><index>[<expr><name>bRev</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <name>endEq</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_IdxLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Seek the table cursor, if required */</comment>
    <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>omitTable</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* pIdx is a covering index.  No need to access the main table. */</comment>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>eOnePass</name></name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iRowidReg</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxRowid</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCacheStore</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iRowidReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>codeDeferredSeek</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iCur</name><operator>!=</operator><name>iIdxCur</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>iRowidReg</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>sqlite3ColumnOfIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>iRowidReg</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>,
                           <argument><expr><name>iRowidReg</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Record the instruction used to terminate the loop. Disable 
    ** WHERE clause terms made redundant by the index range scan.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONEROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Noop</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bRev</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Prev</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Next</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>iIdxCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name><operator>&amp;</operator><name>WHERE_UNQ_WANTED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_CONSTRAINT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <name>SQLITE_STMTSTATUS_FULLSCAN_STEP</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_OR_OPTIMIZATION</name></cpp:ifndef>
  if<condition>( <expr><name><name>pLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_MULTI_OR</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Case 5:  Two or more separately indexed terms connected by OR
    **
    ** Example:
    **
    **   CREATE TABLE t1(a,b,c,d);
    **   CREATE INDEX i1 ON t1(a);
    **   CREATE INDEX i2 ON t1(b);
    **   CREATE INDEX i3 ON t1(c);
    **
    **   SELECT * FROM t1 WHERE a=5 OR b=7 OR (c=11 AND d=13)
    **
    ** In the example, there are three indexed terms connected by OR.
    ** The top of the loop looks like this:
    **
    **          Null       1                # Zero the rowset in reg 1
    **
    ** Then, for each indexed term, the following. The arguments to
    ** RowSetTest are such that the rowid of the current row is inserted
    ** into the RowSet. If it is already present, control skips the
    ** Gosub opcode and jumps straight to the code generated by WhereEnd().
    **
    **        sqlite3WhereBegin(&lt;term&gt;)
    **          RowSetTest                  # Insert rowid into rowset
    **          Gosub      2 A
    **        sqlite3WhereEnd()
    **
    ** Following the above, code to terminate the loop. Label A, the target
    ** of the Gosub above, jumps to the instruction right after the Goto.
    **
    **          Null       1                # Zero the rowset in reg 1
    **          Goto       B                # The loop is finished.
    **
    **       A: &lt;loop body&gt;                 # Return data, whatever.
    **
    **          Return     2                # Jump back to the Gosub
    **
    **       B: &lt;after the loop&gt;
    **
    ** Added 2014-05-26: If the table is a WITHOUT ROWID table, then
    ** use an ephemeral index instead of a RowSet to record the primary
    ** keys of the rows we have already seen.
    **
    */</comment>
    <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pOrWc</name></decl>;</decl_stmt>    <comment type="block">/* The OR-clause broken out into subterms */</comment>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pOrTab</name></decl>;</decl_stmt>       <comment type="block">/* Shortened table list or OR-clause generation */</comment>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pCov</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Potential covering index (or NULL) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iCovCur</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* Cursor used for index scans (if any) */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>regReturn</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Register used with OP_Gosub */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regRowset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                        <comment type="block">/* Register for RowSet object */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                         <comment type="block">/* Register holding rowid */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iLoopBody</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Start of loop body */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iRetInit</name></decl>;</decl_stmt>                             <comment type="block">/* Address of regReturn init */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>untestedTerms</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Some terms not completely tested */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                            <comment type="block">/* Loop counter */</comment>
    <decl_stmt><decl><type><name>u16</name></type> <name>wctrlFlags</name></decl>;</decl_stmt>                    <comment type="block">/* Flags for sub-WHERE clause */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pAndExpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* An ".. AND (...)" expression */</comment>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
   
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name><name>pLoop</name><operator>-&gt;</operator><name>aLTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_OR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_ORINFO</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOrWc</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pOrInfo</name><operator>-&gt;</operator><name>wc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Return</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>regReturn</name></expr>;</expr_stmt>

    <comment type="block">/* Set up a new SrcList in pOrTab containing the table being scanned
    ** by this loop in the a[0] slot and all notReady tables in a[1..] slots.
    ** This becomes the SrcList in the recursive call to sqlite3WhereBegin().
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nNotReady</name></decl>;</decl_stmt>                 <comment type="block">/* The number of notReady tables */</comment>
      <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>origSrc</name></decl>;</decl_stmt>     <comment type="block">/* Original list of tables */</comment>
      <expr_stmt><expr><name>nNotReady</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name> <operator>-</operator> <name>iLevel</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOrTab</name> <operator>=</operator> <call><name>sqlite3StackAllocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pOrTab</name></expr></argument>)</argument_list></sizeof><operator>+</operator> <name>nNotReady</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pOrTab</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pOrTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>notReady</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pOrTab</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>nNotReady</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOrTab</name><operator>-&gt;</operator><name>nSrc</name></name> <operator>=</operator> <name><name>pOrTab</name><operator>-&gt;</operator><name>nAlloc</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pOrTab</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>pTabItem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pTabItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>origSrc</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;=</operator><name>nNotReady</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOrTab</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origSrc</name><index>[<expr><name><name>pLevel</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>iFrom</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pOrTab</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pOrTab</name> <operator>=</operator> <name><name>pWInfo</name><operator>-&gt;</operator><name>pTabList</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Initialize the rowset register to contain NULL. An SQL NULL is 
    ** equivalent to an empty rowset.  Or, create an ephemeral index
    ** capable of holding primary keys in the case of a WITHOUT ROWID.
    **
    ** Also initialize regReturn to contain the address of the instruction 
    ** immediately following the OP_Return at the bottom of the loop. This
    ** is required in a few obscure LEFT JOIN cases where control jumps
    ** over the top of the loop into the body of it. In this case the 
    ** correct response for the end-of-loop code (the OP_Return) is to 
    ** fall through to the next instruction, just as an OP_Next does if
    ** called on an uninitialized cursor.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_DUPLICATES_OK</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>regRowset</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>regRowset</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>regRowset</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iRetInit</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regReturn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the original WHERE clause is z of the form:  (x1 OR x2 OR ...) AND y
    ** Then for every term xN, evaluate as the subexpression: xN AND z
    ** That way, terms in y that are factored into the disjunction will
    ** be picked up by the recursive calls to sqlite3WhereBegin() below.
    **
    ** Actually, each subexpression is converted to "xN AND w" where w is
    ** the "interesting" terms of z - terms that did not originate in the
    ** ON or USING clause of a LEFT JOIN, and terms that are usable as 
    ** indices.
    **
    ** This optimization also only applies if the (x1 OR x2 OR ...) term
    ** is not contained in the ON clause of a LEFT JOIN.
    ** See ticket http://www.sqlite.org/src/info/f2369304e4
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iTerm</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>iTerm</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iTerm</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>iTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name> <operator>==</operator> <name>pTerm</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_CODED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_CODED</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>eOperator</name> <operator>&amp;</operator> <name>WO_ALL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_ORINFO</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pAndExpr</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAndExpr</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pAndExpr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pAndExpr</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_AND</name><operator>|</operator><name>TKFLG_DONTFOLD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pAndExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Run a separate WHERE clause for each term of the OR clause.  After
    ** eliminating duplicates from other WHERE clauses, the action for each
    ** sub-WHERE clause is to to invoke the main loop body as a subroutine.
    */</comment>
    <expr_stmt><expr><name>wctrlFlags</name> <operator>=</operator>  <name>WHERE_OMIT_OPEN_CLOSE</name>
                <operator>|</operator> <name>WHERE_FORCE_TABLE</name>
                <operator>|</operator> <name>WHERE_ONETABLE_ONLY</name>
                <operator>|</operator> <name>WHERE_NO_AUTOINDEX</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pOrTerm</name> <init>= <expr><operator>&amp;</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>==</operator><name>iCur</name> <operator>||</operator> <operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_AND</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pSubWInfo</name></decl>;</decl_stmt>           <comment type="block">/* Info for single OR-term scan */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOrExpr</name> <init>= <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Current OR clause term */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>jmp1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Address of jump operation */</comment>
        <if_stmt><if>if<condition>( <expr><name>pAndExpr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pOrExpr</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pAndExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pOrExpr</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOrExpr</name> <operator>=</operator> <name>pAndExpr</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Loop through table entries that match term pOrTerm. */</comment>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr><literal type="number">0xffff</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Subplan for OR-clause:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pSubWInfo</name> <operator>=</operator> <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrTab</name></expr></argument>, <argument><expr><name>pOrExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                      <argument><expr><name>wctrlFlags</name></expr></argument>, <argument><expr><name>iCovCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSubWInfo</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pSubWInfo</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>WhereLoop</name> <modifier>*</modifier></type><name>pSubLoop</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>addrExplain</name> <init>= <expr><call><name>sqlite3WhereExplainOneScan</name><argument_list>(
              <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSubWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iFrom</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
          )</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3WhereAddScanStatus</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pOrTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSubWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>addrExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* This is the sub-WHERE clause body.  First skip over
          ** duplicate rows from prior sub-WHERE clauses, and record the
          ** rowid (or PRIMARY KEY) for the current row so that the same
          ** row will be skipped in subsequent sub-WHERE clauses.
          */</comment>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_DUPLICATES_OK</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>iSet</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>ii</name><operator>==</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><operator>-</operator><literal type="number">1</literal></expr></then><else>:<expr><name>ii</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sqlite3ExprCodeGetColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>jmp1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetTest</name></expr></argument>, <argument><expr><name>regRowset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name>r</name></expr></argument>,<argument><expr><name>iSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>int</name></type> <name>nPk</name> <init>= <expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>int</name></type> <name>iPk</name></decl>;</decl_stmt>

              <comment type="block">/* Read the PK into an array of temp registers. */</comment>
              <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <for>for<control>(<init><expr><name>iPk</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPk</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>iPk</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iPk</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnToReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>r</name><operator>+</operator><name>iPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></for>

              <comment type="block">/* Check if the temp table already contains this key. If so,
              ** the row has already been included in the result set and
              ** can be ignored (by jumping past the Gosub below). Otherwise,
              ** insert the key into the temp table and proceed with processing
              ** the row.
              **
              ** Use some of the same optimizations as OP_RowSetTest: If iSet
              ** is zero, assume that the key cannot already be present in
              ** the temp table. And if iSet is -1, assume that there is no 
              ** need to insert the key into the temp table, as it will never 
              ** be tested for.  */</comment> 
              <if_stmt><if>if<condition>( <expr><name>iSet</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>jmp1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>regRowset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><name>iSet</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>regRowset</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>( <expr><name>iSet</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_USESEEKRESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>

              <comment type="block">/* Release the array of temp registers */</comment>
              <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Invoke the main loop body as a subroutine */</comment>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regReturn</name></expr></argument>, <argument><expr><name>iLoopBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Jump here (skipping the main loop body subroutine) if the
          ** current sub-WHERE row is a duplicate from prior sub-WHEREs. */</comment>
          <if_stmt><if>if<condition>( <expr><name>jmp1</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>jmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <comment type="block">/* The pSubWInfo-&gt;untestedTerms flag means that this OR term
          ** contained one or more AND term from a notReady table.  The
          ** terms from the notReady table could not be tested and will
          ** need to be tested later.
          */</comment>
          <if_stmt><if>if<condition>( <expr><name><name>pSubWInfo</name><operator>-&gt;</operator><name>untestedTerms</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>untestedTerms</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <comment type="block">/* If all of the OR-connected terms are optimized using the same
          ** index, and the index is opened using the same cursor number
          ** by each call to sqlite3WhereBegin() made by this loop, it may
          ** be possible to use that index as a covering index.
          **
          ** If the call to sqlite3WhereBegin() above resulted in a scan that
          ** uses an index, and this is either the first OR-connected term
          ** processed or the index is the same as that used by all previous
          ** terms, set pCov to the candidate covering index. Otherwise, set 
          ** pCov to NULL to indicate that no candidate covering index will 
          ** be available.
          */</comment>
          <expr_stmt><expr><name>pSubLoop</name> <operator>=</operator> <name><name>pSubWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pWLoop</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pSubLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_AUTO_INDEX</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pSubLoop</name><operator>-&gt;</operator><name>wsFlags</name></name> <operator>&amp;</operator> <name>WHERE_INDEXED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>ii</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pSubLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name><operator>==</operator><name>pCov</name><operator>)</operator>
           <operator>&amp;&amp;</operator> <operator>(</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name><name>pSubLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSubWInfo</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iIdxCur</name><operator>==</operator><name>iCovCur</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pCov</name> <operator>=</operator> <name><name>pSubLoop</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>btree</name><operator>.</operator><name>pIndex</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>wctrlFlags</name> <operator>|=</operator> <name>WHERE_REOPEN_IDX</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>pCov</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>

          <comment type="block">/* Finish the loop through table entries that match term pOrTerm. */</comment>
          <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pSubWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pCovidx</name></name> <operator>=</operator> <name>pCov</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCov</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iIdxCur</name></name> <operator>=</operator> <name>iCovCur</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pAndExpr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pAndExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAndExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRetInit</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrBrk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iLoopBody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>nLevel</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3StackFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>untestedTerms</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_OR_OPTIMIZATION */</comment>

  <block>{<block_content>
    <comment type="block">/* Case 6:  There is no usable index.  We must do a complete
    **          scan of the entire table.
    */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aStep</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>OP_Next</name></expr>, <expr><name>OP_Prev</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aStart</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>OP_Rewind</name></expr>, <expr><name>OP_Last</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bRev</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bRev</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTabItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isRecursive</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Tables marked isRecursive have only a single row that is stored in
      ** a pseudo-cursor.  No need to Rewind or Next such cursors. */</comment>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP_Noop</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>codeCursorHint</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>aStep</name><index>[<expr><name>bRev</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aStart</name><index>[<expr><name>bRev</name></expr>]</index></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <name>SQLITE_STMTSTATUS_FULLSCAN_STEP</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrVisit</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Insert code to test every subexpression that can be completely
  ** computed using the current set of tables.
  */</comment>
  <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</init> <condition><expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>skipLikeAddr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_CODED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_CODED</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>untestedTerms</name></name><operator>==</operator><literal type="number">0</literal>
               <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>wctrlFlags</name></name> <operator>&amp;</operator> <name>WHERE_ONETABLE_ONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>untestedTerms</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pE</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pE</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_LIKECOND</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifdef>
      <continue>continue;</continue>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>skipLikeAddr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLikeRepCntr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>skipLikeAddr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>skipLikeAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Insert code to test for implied constraints based on transitivity
  ** of the "==" operator.
  **
  ** Example: If the WHERE clause contains "t1.a=t2.b" and "t2.b=123"
  ** and we are coding the t1 loop and the t2 loop has not yet coded,
  ** then we cannot use the "t1.a=t2.b" constraint, but we can code
  ** the implied "t1.a=123" constraint.
  */</comment>
  <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</init> <condition><expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pEAlt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pAlt</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_CODED</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_IS</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQUIV</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>!=</operator><name>iCur</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pE</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pAlt</name> <operator>=</operator> <call><name>sqlite3WhereFindTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leftColumn</name></name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>,
                    <argument><expr><name>WO_EQ</name><operator>|</operator><name>WO_IN</name><operator>|</operator><name>WO_IS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pAlt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pAlt</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_CODED</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pAlt</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pAlt</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pAlt</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"begin transitive constraint"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pEAlt</name> <operator>=</operator> <call><name>sqlite3StackAllocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pEAlt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pEAlt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pEAlt</name> <operator>=</operator> <operator>*</operator><name><name>pAlt</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pEAlt</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name><name>pE</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEAlt</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StackFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pEAlt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* For a LEFT OUTER JOIN, generate code that will record the fact that
  ** at least one row of the right table has matched the left table.  
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLevel</name><operator>-&gt;</operator><name>addrFirst</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pLevel</name><operator>-&gt;</operator><name>iLeftJoin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"record LEFT JOIN hit"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCacheClear</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pTerm</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_CODED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_CODED</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>&amp;</operator> <name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>untestedTerms</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name><name>pLevel</name><operator>-&gt;</operator><name>notReady</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
