<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/alter.c"><comment type="block">/*
** 2005 February 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that used to generate VDBE code
** that implements the ALTER TABLE command.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** The code in this file only exists if we are not omitting the
** ALTER TABLE logic from the build.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_ALTERTABLE</name></cpp:ifndef>


<comment type="block">/*
** This function is used by SQL generated to implement the 
** ALTER TABLE command. The first argument is the text of a CREATE TABLE or
** CREATE INDEX command. The second is a table name. The table name in 
** the CREATE TABLE or CREATE INDEX statement is replaced with the third
** argument and the result returned. Examples:
**
** sqlite_rename_table('CREATE TABLE abc(a, b, c)', 'def')
**     -&gt; 'CREATE TABLE def(a, b, c)'
**
** sqlite_rename_table('CREATE INDEX i ON abc(a)', 'def')
**     -&gt; 'CREATE INDEX i ON def(a, b, c)'
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameTableFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zTableName</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>tname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zCsr</name> <init>= <expr><name>zSql</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The principle used to locate the table name in the CREATE TABLE 
  ** statement is that the table name is the first non-space token that
  ** is immediately followed by a TK_LP or TK_USING token.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
    <do>do <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>*</operator><name>zCsr</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Ran out of input before finding an opening bracket. Return NULL. */</comment>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Store the token that zCsr points to in tname. */</comment>
      <expr_stmt><expr><name><name>tname</name><operator>.</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zCsr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tname</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

      <comment type="block">/* Advance zCsr to the next token. Store that token type in 'token',
      ** and its length in 'len' (to be used next iteration of this loop).
      */</comment>
      <do>do <block>{<block_content>
        <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAXSCALE</name></cpp:ifdef>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sqlite3GetToken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sqlite3GetToken</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block> while<condition>( <expr><name>token</name><operator>==</operator><name>TK_SPACE</name></expr> )</condition>;</do>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>len</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while<condition>( <expr><name>token</name><operator>!=</operator><name>TK_LP</name> <operator>&amp;&amp;</operator> <name>token</name><operator>!=</operator><name>TK_USING</name></expr> )</condition>;</do>

    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%.*s\"%w\"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>tname</name><operator>.</operator><name>z</name></name><operator>)</operator> <operator>-</operator> <name>zSql</name><operator>)</operator></expr></argument>,
       <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name><name>tname</name><operator>.</operator><name>z</name></name><operator>+</operator><name><name>tname</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This C function implements an SQL user function that is used by SQL code
** generated by the ALTER TABLE ... RENAME command to modify the definition
** of any foreign key constraints that use the table being renamed as the 
** parent table. It is passed three arguments:
**
**   1) The complete text of the CREATE TABLE statement being modified,
**   2) The old name of the table being renamed, and
**   3) The new name of the table being renamed.
**
** It returns the new CREATE TABLE statement. For example:
**
**   sqlite_rename_parent('CREATE TABLE t1(a REFERENCES t2)', 't2', 't3')
**       -&gt; 'CREATE TABLE t1(a REFERENCES t3)'
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameParentFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOutput</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zResult</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zInput</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zOld</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>         <comment type="block">/* Pointer to token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                          <comment type="block">/* Length of token z */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>token</name></decl>;</decl_stmt>                      <comment type="block">/* Type of token */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zInput</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zOld</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>z</name><operator>=</operator><name>zInput</name></expr>;</init> <condition><expr><operator>*</operator><name>z</name></expr>;</condition> <incr><expr><name>z</name><operator>=</operator><name>z</name><operator>+</operator><name>n</name></expr></incr>)</control><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAXSCALE</name></cpp:ifdef>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3GetToken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3GetToken</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name>token</name><operator>==</operator><name>TK_REFERENCES</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zParent</name></decl>;</decl_stmt>
      <do>do <block>{<block_content>
        <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAXSCALE</name></cpp:ifdef>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3GetToken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3GetToken</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block>while<condition>( <expr><name>token</name><operator>==</operator><name>TK_SPACE</name></expr> )</condition>;</do>

      <if_stmt><if>if<condition>( <expr><name>token</name><operator>==</operator><name>TK_ILLEGAL</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>zParent</name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zParent</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name>zParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>zOld</name></expr></argument>, <argument><expr><name>zParent</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s%.*s\"%w\""</literal></expr></argument>, 
            <argument><expr><operator>(</operator><ternary><condition><expr><name>zOutput</name></expr>?</condition><then><expr><name>zOutput</name></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z</name><operator>-</operator><name>zInput</name><operator>)</operator></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>zNew</name></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zOutput</name> <operator>=</operator> <name>zOut</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zInput</name> <operator>=</operator> <operator>&amp;</operator><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>zResult</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>zOutput</name></expr>?</condition><then><expr><name>zOutput</name></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>zInput</name></expr></argument>)</argument_list></call></expr><operator>,</operator> 
  <expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zResult</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
<comment type="block">/* This function is used by SQL generated to implement the
** ALTER TABLE command. The first argument is the text of a CREATE TRIGGER 
** statement. The second is a table name. The table name in the CREATE 
** TRIGGER statement is replaced with the third argument and the result 
** returned. This is analagous to renameTableFunc() above, except for CREATE
** TRIGGER, not CREATE INDEX and CREATE TABLE.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>renameTriggerFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zTableName</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>tname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>dist</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zCsr</name> <init>= <expr><name>zSql</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The principle used to locate the table name in the CREATE TRIGGER 
  ** statement is that the table name is the first token that is immediately
  ** preceded by either TK_ON or TK_DOT and immediately followed by one
  ** of TK_WHEN, TK_BEGIN or TK_FOR.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
    <do>do <block>{<block_content>

      <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>*</operator><name>zCsr</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Ran out of input before finding the table name. Return NULL. */</comment>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Store the token that zCsr points to in tname. */</comment>
      <expr_stmt><expr><name><name>tname</name><operator>.</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zCsr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tname</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

      <comment type="block">/* Advance zCsr to the next token. Store that token type in 'token',
      ** and its length in 'len' (to be used next iteration of this loop).
      */</comment>
      <do>do <block>{<block_content>
        <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAXSCALE</name></cpp:ifdef>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sqlite3GetToken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sqlite3GetToken</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block>while<condition>( <expr><name>token</name><operator>==</operator><name>TK_SPACE</name></expr> )</condition>;</do>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>len</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Variable 'dist' stores the number of tokens read since the most
      ** recent TK_DOT or TK_ON. This means that when a WHEN, FOR or BEGIN 
      ** token is read and 'dist' equals 2, the condition stated above
      ** to be met.
      **
      ** Note that ON cannot be a database, table or column name, so
      ** there is no need to worry about syntax like 
      ** "CREATE TRIGGER ... ON ON.ON BEGIN ..." etc.
      */</comment>
      <expr_stmt><expr><name>dist</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>token</name><operator>==</operator><name>TK_DOT</name> <operator>||</operator> <name>token</name><operator>==</operator><name>TK_ON</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block> while<condition>( <expr><name>dist</name><operator>!=</operator><literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>token</name><operator>!=</operator><name>TK_WHEN</name> <operator>&amp;&amp;</operator> <name>token</name><operator>!=</operator><name>TK_FOR</name> <operator>&amp;&amp;</operator> <name>token</name><operator>!=</operator><name>TK_BEGIN</name><operator>)</operator></expr> )</condition>;</do>

    <comment type="block">/* Variable tname now contains the token that is the old table-name
    ** in the CREATE TRIGGER statement.
    */</comment>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%.*s\"%w\"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>tname</name><operator>.</operator><name>z</name></name><operator>)</operator> <operator>-</operator> <name>zSql</name><operator>)</operator></expr></argument>,
       <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name><name>tname</name><operator>.</operator><name>z</name></name><operator>+</operator><name><name>tname</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* !SQLITE_OMIT_TRIGGER */</comment>

<comment type="block">/*
** Register built-in functions used to help implement ALTER TABLE
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterFunctions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>SQLITE_WSD</name> <name>FuncDef</name></type> <name><name>aAlterTableFuncs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>sqlite_rename_table</name></expr></argument>,   <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>renameTableFunc</name></expr></argument>)</argument_list></call></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>sqlite_rename_trigger</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>renameTriggerFunc</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>sqlite_rename_parent</name></expr></argument>,  <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>renameParentFunc</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDefHash</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>&amp;</operator><call><name>GLOBAL</name><argument_list>(<argument><expr><name>FuncDefHash</name></expr></argument>, <argument><expr><name>sqlite3GlobalFunctions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>aFunc</name> <init>= <expr><operator>(</operator><name>FuncDef</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><call><name>GLOBAL</name><argument_list>(<argument><expr><name>FuncDef</name></expr></argument>, <argument><expr><name>aAlterTableFuncs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aAlterTableFuncs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3FuncDefInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to create the text of expressions of the form:
**
**   name=&lt;constant1&gt; OR name=&lt;constant2&gt; OR ...
**
** If argument zWhere is NULL, then a pointer string containing the text 
** "name=&lt;constant&gt;" is returned, where &lt;constant&gt; is the quoted version
** of the string passed as argument zConstant. The returned buffer is
** allocated using sqlite3DbMalloc(). It is the responsibility of the
** caller to ensure that it is eventually freed.
**
** If argument zWhere is not NULL, then the string returned is 
** "&lt;where&gt; OR name=&lt;constant&gt;", where &lt;where&gt; is the contents of zWhere.
** In this case zWhere is passed to sqlite3DbFree() before returning.
** 
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>whereOrName</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zConstant</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zWhere</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"name=%Q"</literal></expr></argument>, <argument><expr><name>zConstant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s OR name=%Q"</literal></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name>zConstant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>zNew</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_FOREIGN_KEY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Generate the text of a WHERE expression which can be used to select all
** tables that have foreign key constraints that refer to table pTab (i.e.
** constraints for which pTab is the parent table) from the sqlite_master
** table.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>whereForeignKeys</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><call><name>sqlite3FkReferences</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextTo</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zWhere</name> <operator>=</operator> <call><name>whereOrName</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFrom</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>zWhere</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Generate the text of a WHERE expression which can be used to select all
** temporary triggers on table pTab from the sqlite_temp_master table. If
** table pTab has no temporary triggers, or is itself stored in the 
** temporary database, NULL is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>whereTempTriggers</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrig</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>Schema</name> <modifier>*</modifier></type><name>pTempSchema</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Temp db schema */</comment>

  <comment type="block">/* If the table is not located in the temp-db (in which case NULL is 
  ** returned, loop through the tables list of triggers. For each trigger
  ** that is not part of the temp-db schema, add a clause to the WHERE 
  ** expression being built up in zWhere.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name><operator>!=</operator><name>pTempSchema</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pTrig</name><operator>=</operator><call><name>sqlite3TriggerList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pTrig</name></expr>;</condition> <incr><expr><name>pTrig</name><operator>=</operator><name><name>pTrig</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTrig</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name>pTempSchema</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zWhere</name> <operator>=</operator> <call><name>whereOrName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name><name>pTrig</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zWhere</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"type='trigger' AND (%s)"</literal></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zWhere</name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zWhere</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to drop and reload the internal representation of table
** pTab from the database, including triggers and temporary triggers.
** Argument zName is the name of the table in the database schema at
** the time the generated code is executed. This can be different from
** pTab-&gt;zName if this function is being called to code part of an 
** "ALTER TABLE RENAME TO" statement.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>reloadTableSchema</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                   <comment type="block">/* Index of database containing pTab */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrig</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <comment type="block">/* Drop any table triggers from the internal schema. */</comment>
  <for>for<control>(<init><expr><name>pTrig</name><operator>=</operator><call><name>sqlite3TriggerList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pTrig</name></expr>;</condition> <incr><expr><name>pTrig</name><operator>=</operator><name><name>pTrig</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iTrigDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTrig</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTrigDb</name><operator>==</operator><name>iDb</name> <operator>||</operator> <name>iTrigDb</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DropTrigger</name></expr></argument>, <argument><expr><name>iTrigDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTrig</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Drop the table and index from the internal schema.  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DropTable</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reload the table, index and permanent trigger schemas. */</comment>
  <expr_stmt><expr><name>zWhere</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"tbl_name=%Q"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zWhere</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddParseSchemaOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <comment type="block">/* Now, if the table is not stored in the temp database, reload any temp 
  ** triggers. Don't use IN(...) in case SQLITE_OMIT_SUBQUERY is defined. 
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>zWhere</name><operator>=</operator><call><name>whereTempTriggers</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddParseSchemaOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Parameter zName is the name of a table that is about to be altered
** (either with ALTER TABLE ... RENAME TO or ALTER TABLE ... ADD COLUMN).
** If the table is a system table, this function leaves an error message
** in pParse-&gt;zErr (system tables may not be altered) and returns non-zero.
**
** Or, if zName is not a system table, zero is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isSystemTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">6</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"sqlite_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"table %s may not be altered"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to implement the "ALTER TABLE xxx RENAME TO yyy" 
** command. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterRenameTable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,            <comment type="block">/* Parser context. */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,            <comment type="block">/* The table to rename. */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>              <comment type="block">/* The new table name. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                  <comment type="block">/* Database that contains the table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                <comment type="block">/* Name of database iDb */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>              <comment type="block">/* Table being renamed */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* NULL-terminated version of pName */</comment> 
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTabName</name></decl>;</decl_stmt>             <comment type="block">/* Number of UTF-8 characters in zTabName */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTabName</name></decl>;</decl_stmt>     <comment type="block">/* Original name of the table */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Where clause to locate temp triggers */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Non-zero if this is a v-tab with an xRename() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>savedDbFlags</name></decl>;</decl_stmt>         <comment type="block">/* Saved value of db-&gt;flags */</comment>

  <expr_stmt><expr><name>savedDbFlags</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>  
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_table</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_table</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SQLITE_PreferBuiltin</name></expr>;</expr_stmt>

  <comment type="block">/* Get a NULL terminated version of the new table name. */</comment>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zName</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_rename_table</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Check that a table or index named 'zName' does not already exist
  ** in database iDb. If so, this is an error.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr><literal type="string">"there is already another table or index with this name: %s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure it is not a system table being altered, or a reserved name
  ** that the table is being renamed to.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>isSystemTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3CheckObjectName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <goto>goto
    <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"view %s may not be altered"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <comment type="block">/* Invoke the authorization callback. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_ALTER_TABLE</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pVTab</name> <operator>=</operator> <call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pVTab</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xRename</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pVTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Begin a transaction for database iDb. 
  ** Then modify the schema cookie (since the ALTER TABLE modifies the
  ** schema). Open a statement transaction if the table is a virtual
  ** table.
  */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_rename_table</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pVTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a virtual table, invoke the xRename() function if
  ** one is defined. The xRename() callback will modify the names
  ** of any resources used by the v-table implementation (including other
  ** SQLite tables) that are identified by the name of the virtual table.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>pVTab</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeLoadString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VRename</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* figure out how many UTF-8 characters are in zName */</comment>
  <expr_stmt><expr><name>zTabName</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTabName</name> <operator>=</operator> <call><name>sqlite3Utf8CharLen</name><argument_list>(<argument><expr><name>zTabName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_FOREIGN_KEY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ForeignKeys</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If foreign-key support is enabled, rewrite the CREATE TABLE 
    ** statements corresponding to all child tables of foreign key constraints
    ** for which the renamed table is the parent table.  */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>zWhere</name><operator>=</operator><call><name>whereForeignKeys</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
          <argument><expr><literal type="string">"UPDATE \"%w\".%s SET "</literal>
              <literal type="string">"sql = sqlite_rename_parent(sql, %Q, %Q) "</literal>
              <literal type="string">"WHERE %s;"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Modify the sqlite_master table to use the new table name. */</comment>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
      <argument><expr><literal type="string">"UPDATE %Q.%s SET "</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifdef>
          <literal type="string">"sql = sqlite_rename_table(sql, %Q), "</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <literal type="string">"sql = CASE "</literal>
            <literal type="string">"WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)"</literal>
            <literal type="string">"ELSE sqlite_rename_table(sql, %Q) END, "</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <literal type="string">"tbl_name = %Q, "</literal>
          <literal type="string">"name = CASE "</literal>
            <literal type="string">"WHEN type='table' THEN %Q "</literal>
            <literal type="string">"WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN "</literal>
             <literal type="string">"'sqlite_autoindex_' || %Q || substr(name,%d+18) "</literal>
            <literal type="string">"ELSE name END "</literal>
      <literal type="string">"WHERE tbl_name=%Q COLLATE nocase AND "</literal>
          <literal type="string">"(type='table' OR type='index' OR type='trigger');"</literal></expr></argument>, 
      <argument><expr><name>zDb</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
      <argument><expr><name>zName</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nTabName</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
  <comment type="block">/* If the sqlite_sequence table exists in this database, then update 
  ** it with the new table name.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sqlite_sequence"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr><literal type="string">"UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q"</literal></expr></argument>,
        <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <comment type="block">/* If there are TEMP triggers on this table, modify the sqlite_temp_master
  ** table. Don't do this if the table being ALTERed is itself located in
  ** the temp database.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>zWhere</name><operator>=</operator><call><name>whereTempTriggers</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr><literal type="string">"UPDATE sqlite_temp_master SET "</literal>
            <literal type="string">"sql = sqlite_rename_trigger(sql, %Q), "</literal>
            <literal type="string">"tbl_name = %Q "</literal>
            <literal type="string">"WHERE %s;"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_FOREIGN_KEY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ForeignKeys</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FKey</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><call><name>sqlite3FkReferences</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNextTo</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pFrom</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pFrom</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pFrom</name><operator>!=</operator><name>pTab</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>reloadTableSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFrom</name></name></expr></argument>, <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Drop and reload the internal table schema. */</comment>
  <expr_stmt><expr><call><name>reloadTableSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit_rename_table</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>savedDbFlags</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called after an "ALTER TABLE ... ADD" statement
** has been parsed. Argument pColDef contains the text of the new
** column definition.
**
** The Table structure pParse-&gt;pNewTable was extended to include
** the new column during parsing.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterFinishAddColumn</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pColDef</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>              <comment type="block">/* Copy of pParse-&gt;pNewTable */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>              <comment type="block">/* Table being altered */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                  <comment type="block">/* Database number */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>          <comment type="block">/* Database name */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>         <comment type="block">/* Table name */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCol</name></decl>;</decl_stmt>               <comment type="block">/* Null-terminated column definition */</comment>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>             <comment type="block">/* The new column */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDflt</name></decl>;</decl_stmt>              <comment type="block">/* Default value for the new column */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>              <comment type="block">/* The database connection; */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The prepared statement under construction */</comment>

  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTab</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>zName</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* Skip the "sqlite_altertab_" prefix on the name */</comment>
  <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDflt</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>pDflt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <comment type="block">/* Invoke the authorization callback. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_ALTER_TABLE</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the default value for the new column was specified with a 
  ** literal NULL, then set pDflt to 0. This simplifies checking
  ** for an SQL NULL default below.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pDflt</name> <operator>&amp;&amp;</operator> <name><name>pDflt</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pDflt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check that the new column is not specified as PRIMARY KEY or UNIQUE.
  ** If there is a NOT NULL constraint, then the default value for the
  ** column must not be NULL.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Cannot add a PRIMARY KEY column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>pIndex</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Cannot add a UNIQUE column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ForeignKeys</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>pFKey</name></name> <operator>&amp;&amp;</operator> <name>pDflt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr><literal type="string">"Cannot add a REFERENCES column with non-NULL default value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>notNull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pDflt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr><literal type="string">"Cannot add a NOT NULL column with default value NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Ensure the default expression is something that sqlite3ValueFromExpr()
  ** can handle (i.e. not CURRENT_TIME etc.)
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pDflt</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ValueFromExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDflt</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_AFF_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Cannot add a column with non-constant default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Modify the CREATE TABLE statement. */</comment>
  <expr_stmt><expr><name>zCol</name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>pColDef</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pColDef</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zCol</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>&amp;</operator><name><name>zCol</name><index>[<expr><name><name>pColDef</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>savedDbFlags</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>zEnd</name><operator>&gt;</operator><name>zCol</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>zEnd</name><operator>==</operator><literal type="char">';'</literal> <operator>||</operator> <call><name>sqlite3Isspace</name><argument_list>(<argument><expr><operator>*</operator><name>zEnd</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>zEnd</name><operator>--</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SQLITE_PreferBuiltin</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr><literal type="string">"UPDATE \"%w\".%s SET "</literal>
          <literal type="string">"sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) "</literal>
        <literal type="string">"WHERE type = 'table' AND name = %Q"</literal></expr></argument>, 
      <argument><expr><name>zDb</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>addColOffset</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>addColOffset</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,
      <argument><expr><name>zTab</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>savedDbFlags</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the default value of the new column is NULL, then the file
  ** format to 2. If the default value of the new column is not NULL,
  ** the file format be 3.  Back when this feature was first added
  ** in 2006, we went to the trouble to upgrade the file format to the
  ** minimum support values.  But 10-years on, we can assume that all
  ** extent versions of SQLite support file-format 4, so we always and
  ** unconditionally upgrade to 4.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>BTREE_FILE_FORMAT</name></expr></argument>, 
                    <argument><expr><name>SQLITE_MAX_FILE_FORMAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reload the schema of the modified table. */</comment>
  <expr_stmt><expr><call><name>reloadTableSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by the parser after the table-name in
** an "ALTER TABLE &lt;table-name&gt; ADD" statement is parsed. Argument 
** pSrc is the full-name of the table being altered.
**
** This routine makes a (partial) copy of the Table structure
** for the table being altered and sets Parse.pNewTable to point
** to it. Routines called by the parser as the column definition
** is parsed (i.e. sqlite3AddColumn()) add the new Column data to 
** the copy. The copy of the Table structure is deleted by tokenize.c 
** after parsing is finished.
**
** Routine sqlite3AlterFinishAddColumn() will be called to complete
** coding the "ALTER TABLE ... ADD" statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterBeginAddColumn</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Look up the table being altered. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_begin_add_column</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_begin_add_column</name>;</goto></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"virtual tables may not be altered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Make sure this is not an attempt to ALTER a view. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"Cannot add a column to a view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>isSystemTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>addColOffset</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Put a copy of the Table struct in Parse.pNewTable for the
  ** sqlite3AddColumn() function and friends to modify.  But modify
  ** the name by adding an "sqlite_altertab_" prefix.  By adding this
  ** prefix, we insure that the name will not collide with an existing
  ** table because user table are not allowed to have the "sqlite_"
  ** prefix on their name.
  */</comment>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>Table</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_begin_add_column</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">8</literal><operator>)</operator><operator>*</operator><literal type="number">8</literal><operator>)</operator><operator>+</operator><literal type="number">8</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nAlloc</name><operator>&gt;=</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>&amp;&amp;</operator> <name>nAlloc</name><operator>%</operator><literal type="number">8</literal><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nAlloc</name><operator>-</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name><operator>&lt;</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <operator>(</operator><name>Column</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Column</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sqlite_altertab_%s"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name></name> <operator>||</operator> <operator>!</operator><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Column</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>zColl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>zType</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pDflt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>zDflt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addColOffset</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>addColOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* Begin a transaction and increment the schema cookie.  */</comment>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>v</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>exit_begin_add_column</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit_begin_add_column</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SQLITE_ALTER_TABLE */</comment>
</unit>
