<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/main.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Main file for the SQLite library.  The routines in this file
** implement the programmer interface to the library.  Routines in
** other files are for internal use by SQLite and should not be
** accessed by users of the library.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"fts3.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_RTREE</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"rtree.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ICU</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"sqliteicu.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_JSON1</name></cpp:ifdef>
<function_decl><type><name>int</name></type> <name>sqlite3Json1Init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS5</name></cpp:ifdef>
<function_decl><type><name>int</name></type> <name>sqlite3Fts5Init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<comment type="block">/* IMPLEMENTATION-OF: R-46656-45156 The sqlite3_version[] string constant
** contains the text of SQLITE_VERSION macro. 
*/</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>sqlite3_version</name><index>[]</index></name> <init>= <expr><name>SQLITE_VERSION</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* IMPLEMENTATION-OF: R-53536-42575 The sqlite3_libversion() function returns
** a pointer to the to the sqlite3_version[] string constant. 
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_libversion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name>sqlite3_version</name></expr>;</return> </block_content>}</block></function>

<comment type="block">/* IMPLEMENTATION-OF: R-63124-39300 The sqlite3_sourceid() function returns a
** pointer to a string constant whose value is the same as the
** SQLITE_SOURCE_ID C preprocessor macro. 
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_sourceid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name>SQLITE_SOURCE_ID</name></expr>;</return> </block_content>}</block></function>

<comment type="block">/* IMPLEMENTATION-OF: R-35210-63508 The sqlite3_libversion_number() function
** returns an integer equal to SQLITE_VERSION_NUMBER.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_libversion_number</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name>SQLITE_VERSION_NUMBER</name></expr>;</return> </block_content>}</block></function>

<comment type="block">/* IMPLEMENTATION-OF: R-20790-14025 The sqlite3_threadsafe() function returns
** zero if and only if SQLite was compiled with mutexing code omitted due to
** the SQLITE_THREADSAFE compile-time option being set to 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_threadsafe</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name>SQLITE_THREADSAFE</name></expr>;</return> </block_content>}</block></function>

<comment type="block">/*
** When compiling the test fixture or with debugging enabled (on Win32),
** this variable being set to non-zero will cause OSTRACE macros to emit
** extra diagnostic information.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAVE_OS_TRACE</name></cpp:ifdef>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEBUG_OS_TRACE</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DEBUG_OS_TRACE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>sqlite3OSTrace</name> <init>= <expr><name>SQLITE_DEBUG_OS_TRACE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRACE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_IOTRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** If the following function pointer is not NULL and if
** SQLITE_ENABLE_IOTRACE is enabled, then messages describing
** I/O active are written using this function.  These messages
** are intended for debugging activity only.
*/</comment>
<function_decl><type><name>SQLITE_API</name> <name>void</name></type> (<name>SQLITE_CDECL</name> <modifier>*</modifier><name>sqlite3IoTrace</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If the following global variable points to a string which is the
** name of a directory, then that directory will be used to store
** temporary files.
**
** See also the "PRAGMA temp_store_directory" SQL command.
*/</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_temp_directory</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** If the following global variable points to a string which is the
** name of a directory, then that directory will be used to store
** all database files specified with a relative pathname.
**
** See also the "PRAGMA data_store_directory" SQL command.
*/</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_data_directory</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Initialize SQLite.  
**
** This routine must be called to initialize the memory allocation,
** VFS, and mutex subsystems prior to doing any serious work with
** SQLite.  But as long as you do not compile with SQLITE_OMIT_AUTOINIT
** this routine will be called automatically by key routines such as
** sqlite3_open().  
**
** This routine is a no-op except on its very first call for the process,
** or for the first call after a call to sqlite3_shutdown.
**
** The first thread to call this routine runs the initialization to
** completion.  If subsequent threads call this routine before the first
** thread has finished the initialization process, then the subsequent
** threads must block until the first thread finishes with the initialization.
**
** The first thread might call this routine recursively.  Recursive
** calls to this routine should not block, of course.  Otherwise the
** initialization process would never complete.
**
** Let X be the first thread to enter this routine.  Let Y be some other
** thread.  Then while the initial invocation of this routine by X is
** incomplete, it is required that:
**
**    *  Calls to this routine from Y must block until the outer-most
**       call by X completes.
**
**    *  Recursive calls to this routine from thread X return immediately
**       without blocking.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <macro><name>MUTEX_LOGIC</name><argument_list>( <argument>sqlite3_mutex *pMaster;</argument> )</argument_list></macro>       <comment type="block">/* The main static mutex */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                                      <comment type="block">/* Result code */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EXTRA_INIT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>bRunExtraInit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                       <comment type="block">/* Extra initialization needed */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WSD</name></cpp:ifdef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_wsd_init</name><argument_list>(<argument><expr><literal type="number">4096</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the following assert() fails on some obscure processor/compiler
  ** combination, the work-around is to set the correct pointer
  ** size at compile-time using -DSQLITE_PTRSIZE=n compile-time option */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_PTRSIZE</name><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If SQLite is already completely initialized, then this call
  ** to sqlite3_initialize() should be a no-op.  But the initialization
  ** must be complete.  So isInit must not be set until the very end
  ** of this routine.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Make sure the mutex subsystem is initialized.  If unable to 
  ** initialize the mutex subsystem, return early with the error.
  ** If the system is so sick that we are unable to allocate a mutex,
  ** there is not much SQLite is going to be able to do.
  **
  ** The mutex subsystem must take care of serializing its own
  ** initialization.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3MutexInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Initialize the malloc() system and the recursive pInitMutex mutex.
  ** This operation is protected by the STATIC_MASTER mutex.  Note that
  ** MutexAlloc() is called for a static mutex prior to initializing the
  ** malloc subsystem - this implies that the allocation of a static
  ** mutex must not require support from the malloc subsystem.
  */</comment>
  <macro><name>MUTEX_LOGIC</name><argument_list>( <argument>pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);</argument> )</argument_list></macro>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMutexInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMallocInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3MallocInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMallocInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name> <operator>=</operator>
           <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_RECURSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nRefInitMutex</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If rc is not SQLITE_OK at this point, then either the malloc
  ** subsystem could not be initialized or the system failed to allocate
  ** the pInitMutex mutex. Return an error in either case.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Do the rest of the initialization under the recursive mutex so
  ** that we will be able to handle recursive calls into
  ** sqlite3_initialize().  The recursive calls normally come through
  ** sqlite3_os_init() when it invokes sqlite3_vfs_register(), but other
  ** recursive calls might also be possible.
  **
  ** IMPLEMENTATION-OF: R-00140-37445 SQLite automatically serializes calls
  ** to the xInit method, so the xInit method need not be threadsafe.
  **
  ** The following mutex is what serializes access to the appdef pcache xInit
  ** methods.  The sqlite3_pcache_methods.xInit() all is embedded in the
  ** call to sqlite3PcacheInitialize().
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>inProgress</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FuncDefHash</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>&amp;</operator><call><name>GLOBAL</name><argument_list>(<argument><expr><name>FuncDefHash</name></expr></argument>, <argument><expr><name>sqlite3GlobalFunctions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>inProgress</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SQLLOG</name></cpp:ifdef>
    <block>{<block_content>
      <decl_stmt><decl><type><specifier>extern</specifier> <name>void</name></type> <name>sqlite3_init_sqllog</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_init_sqllog</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3GlobalFunctions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3RegisterGlobalFunctions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isPCacheInit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PcacheInitialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isPCacheInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PCacheBufferSetup</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pPage</name></name></expr></argument>, 
          <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szPage</name></name></expr></argument>, <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EXTRA_INIT</name></cpp:ifdef>
      <expr_stmt><expr><name>bRunExtraInit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>inProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Go back under the static mutex and clean up the recursive
  ** mutex to prevent a resource leak.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nRefInitMutex</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nRefInitMutex</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nRefInitMutex</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The following is just a sanity check to make sure SQLite has
  ** been compiled correctly.  It is important to run this code, but
  ** we don't want to run it too often and soak up CPU cycles for no
  ** reason.  So we run it once during initialization.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  <comment type="block">/* This section of code's only "output" is via assert() statements. */</comment>
  <if_stmt><if>if <condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>x</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">63</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>y</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Do extra initialization steps requested by the SQLITE_EXTRA_INIT
  ** compile-time option.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EXTRA_INIT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>bRunExtraInit</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>SQLITE_EXTRA_INIT</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SQLITE_EXTRA_INIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Undo the effects of sqlite3_initialize().  Must not be called while
** there are outstanding database connections or memory allocations or
** while any part of SQLite is otherwise in use in any thread.  This
** routine is not threadsafe.  But it is safe to invoke this routine
** on when SQLite is already shut down.  If SQLite is already shut down
** when this routine is invoked, then this routine is a harmless no-op.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WSD</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_wsd_init</name><argument_list>(<argument><expr><literal type="number">4096</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EXTRA_SHUTDOWN</name></cpp:ifdef>
    <decl_stmt><decl><type><name>void</name></type> <name>SQLITE_EXTRA_SHUTDOWN</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SQLITE_EXTRA_SHUTDOWN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3_os_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_reset_auto_extension</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isPCacheInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3PcacheShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isPCacheInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMallocInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3MallocEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMallocInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHUTDOWN_DIRECTORIES</name></cpp:ifndef>
    <comment type="block">/* The heap subsystem has now been shutdown and these values are supposed
    ** to be NULL or point to memory that was obtained from sqlite3_malloc(),
    ** which would rely on that heap subsystem; therefore, make sure these
    ** values cannot refer to heap memory that was just invalidated when the
    ** heap subsystem was shutdown.  This is only done if the current call to
    ** this function resulted in the heap subsystem actually being shutdown.
    */</comment>
    <expr_stmt><expr><name>sqlite3_data_directory</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>sqlite3_temp_directory</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMutexInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3MutexEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMutexInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This API allows applications to modify the global configuration of
** the SQLite library at run-time.
**
** This routine should only be called when there are no outstanding
** database connections or memory allocations.  This routine is not
** threadsafe.  Failure to heed these warnings can lead to unpredictable
** behavior.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_config</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* sqlite3_config() shall return SQLITE_MISUSE if it is invoked while
  ** the SQLite library is in use. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* Mutex configuration options are only available in a threadsafe
    ** compile.
    */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>  <comment type="block">/* IMP: R-54466-46756 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_SINGLETHREAD</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-02748-19096 This option sets the threading mode to
      ** Single-thread. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Disable mutex on core */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bFullMutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Disable mutex on connections */</comment>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* IMP: R-20520-54086 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_MULTITHREAD</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-14374-42468 This option sets the threading mode to
      ** Multi-thread. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Enable mutex on core */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bFullMutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Disable mutex on connections */</comment>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* IMP: R-59593-21810 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_SERIALIZED</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-41220-51800 This option sets the threading mode to
      ** Serialized. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Enable mutex on core */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bFullMutex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Enable mutex on connections */</comment>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* IMP: R-63666-48755 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_MUTEX</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* Specify an alternative mutex implementation */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mutex</name></name> <operator>=</operator> <operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mutex_methods</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* IMP: R-14450-37597 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_GETMUTEX</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* Retrieve the current mutex implementation */</comment>
      <expr_stmt><expr><operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mutex_methods</name><operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mutex</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>SQLITE_CONFIG_MALLOC</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-55594-21030 The SQLITE_CONFIG_MALLOC option takes a
      ** single argument which is a pointer to an instance of the
      ** sqlite3_mem_methods structure. The argument specifies alternative
      ** low-level memory allocation routines to be used in place of the memory
      ** allocation routines built into SQLite. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name> <operator>=</operator> <operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mem_methods</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_GETMALLOC</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-51213-46414 The SQLITE_CONFIG_GETMALLOC option takes a
      ** single argument which is a pointer to an instance of the
      ** sqlite3_mem_methods structure. The sqlite3_mem_methods structure is
      ** filled with the currently defined memory allocation routines. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name><operator>.</operator><name>xMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3MemSetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mem_methods</name><operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_MEMSTATUS</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-61275-35157 The SQLITE_CONFIG_MEMSTATUS option takes
      ** single argument of type int, interpreted as a boolean, which enables
      ** or disables the collection of memory allocation statistics. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bMemstat</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_SCRATCH</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-08404-60887 There are three arguments to
      ** SQLITE_CONFIG_SCRATCH: A pointer an 8-byte aligned memory buffer from
      ** which the scratch allocations will be drawn, the size of each scratch
      ** allocation (sz), and the maximum number of scratch allocations (N). */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pScratch</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szScratch</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nScratch</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_PAGECACHE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-18761-36601 There are three arguments to
      ** SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem),
      ** the size of each page cache line (sz), and the number of cache lines
      ** (N). */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pPage</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szPage</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nPage</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_PCACHE_HDRSZ</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-39100-27317 The SQLITE_CONFIG_PCACHE_HDRSZ option takes
      ** a single parameter which is a pointer to an integer and writes into
      ** that integer the number of extra bytes per page required for each page
      ** in SQLITE_CONFIG_PAGECACHE. */</comment>
      <expr_stmt><expr><operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> 
          <call><name>sqlite3HeaderSizeBtree</name><argument_list>()</argument_list></call> <operator>+</operator>
          <call><name>sqlite3HeaderSizePcache</name><argument_list>()</argument_list></call> <operator>+</operator>
          <call><name>sqlite3HeaderSizePcache1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>SQLITE_CONFIG_PCACHE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* no-op */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_GETPCACHE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* now an error */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>SQLITE_CONFIG_PCACHE2</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-63325-48378 The SQLITE_CONFIG_PCACHE2 option takes a
      ** single argument which is a pointer to an sqlite3_pcache_methods2
      ** object. This object specifies the interface to a custom page cache
      ** implementation. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name></name> <operator>=</operator> <operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_pcache_methods2</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_GETPCACHE2</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-22035-46182 The SQLITE_CONFIG_GETPCACHE2 option takes a
      ** single argument which is a pointer to an sqlite3_pcache_methods2
      ** object. SQLite copies of the current page cache implementation into
      ** that object. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xInit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3PCacheSetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_pcache_methods2</name><operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

<comment type="block">/* EVIDENCE-OF: R-06626-12911 The SQLITE_CONFIG_HEAP option is only
** available if SQLite is compiled with either SQLITE_ENABLE_MEMSYS3 or
** SQLITE_ENABLE_MEMSYS5 and returns SQLITE_ERROR if invoked otherwise. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMSYS3</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMSYS5</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <case>case <expr><name>SQLITE_CONFIG_HEAP</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-19854-42126 There are three arguments to
      ** SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the
      ** number of bytes in the memory buffer, and the minimum allocation size.
      */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pHeap</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nHeap</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name><operator>&gt;</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">12</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <comment type="block">/* cap min request size at 2^12 */</comment>
        <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pHeap</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* EVIDENCE-OF: R-49920-60189 If the first pointer (the memory pointer)
        ** is NULL, then SQLite reverts to using its default memory allocator
        ** (the system malloc() implementation), undoing any prior invocation of
        ** SQLITE_CONFIG_MALLOC.
        **
        ** Setting sqlite3GlobalConfig.m to all zeros will cause malloc to
        ** revert to its default implementation when sqlite3_initialize() is run
        */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* EVIDENCE-OF: R-61006-08918 If the memory pointer is not NULL then the
        ** alternative memory allocator is engaged to handle all of SQLites
        ** memory allocation needs. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMSYS3</name></cpp:ifdef>
        <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name> <operator>=</operator> <operator>*</operator><call><name>sqlite3MemGetMemsys3</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMSYS5</name></cpp:ifdef>
        <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name> <operator>=</operator> <operator>*</operator><call><name>sqlite3MemGetMemsys5</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>SQLITE_CONFIG_LOOKASIDE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szLookaside</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nLookaside</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    
    <comment type="block">/* Record a pointer to the logger function and its first argument.
    ** The default is NULL.  Logging is disabled if the function pointer is
    ** NULL.
    */</comment>
    <case>case <expr><name>SQLITE_CONFIG_LOG</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* MSVC is picky about pulling func ptrs from va lists.
      ** http://support.microsoft.com/kb/47961
      ** sqlite3GlobalConfig.xLog = va_arg(ap, void(*)(void*,int,const char*));
      */</comment>
      <typedef>typedef <function_decl><type><name>void</name></type>(<modifier>*</modifier><name>LOGFUNC_t</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>LOGFUNC_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pLogArg</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/* EVIDENCE-OF: R-55548-33817 The compile-time setting for URI filenames
    ** can be changed at start-time using the
    ** sqlite3_config(SQLITE_CONFIG_URI,1) or
    ** sqlite3_config(SQLITE_CONFIG_URI,0) configuration calls.
    */</comment>
    <case>case <expr><name>SQLITE_CONFIG_URI</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-25451-61125 The SQLITE_CONFIG_URI option takes a single
      ** argument of type int. If non-zero, then URI handling is globally
      ** enabled. If the parameter is zero, then URI handling is globally
      ** disabled. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bOpenUri</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>SQLITE_CONFIG_COVERING_INDEX_SCAN</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-36592-02772 The SQLITE_CONFIG_COVERING_INDEX_SCAN
      ** option takes a single integer argument which is interpreted as a
      ** boolean in order to enable or disable the use of covering indices for
      ** full table scans in the query optimizer. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bUseCis</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SQLLOG</name></cpp:ifdef>
    <case>case <expr><name>SQLITE_CONFIG_SQLLOG</name></expr>:</case> <block>{<block_content>
      <typedef>typedef <function_decl><type><name>void</name></type>(<modifier>*</modifier><name>SQLLOGFUNC_t</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>SQLLOGFUNC_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pSqllogArg</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>SQLITE_CONFIG_MMAP_SIZE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-58063-38258 SQLITE_CONFIG_MMAP_SIZE takes two 64-bit
      ** integer (sqlite3_int64) values that are the default mmap size limit
      ** (the default setting for PRAGMA mmap_size) and the maximum allowed
      ** mmap size limit. */</comment>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>szMmap</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>mxMmap</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* EVIDENCE-OF: R-53367-43190 If either argument to this option is
      ** negative, then that argument is changed to its compile-time default.
      **
      ** EVIDENCE-OF: R-34993-45031 The maximum allowed mmap size will be
      ** silently truncated if necessary so that it does not exceed the
      ** compile-time maximum mmap size set by the SQLITE_MAX_MMAP_SIZE
      ** compile-time option.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>mxMmap</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>mxMmap</name></expr></argument>&gt;</argument_list></name><name>SQLITE_MAX_MMAP_SIZE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>mxMmap</name> <operator>=</operator> <name>SQLITE_MAX_MMAP_SIZE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>szMmap</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szMmap</name> <operator>=</operator> <name>SQLITE_DEFAULT_MMAP_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>szMmap</name><operator>&gt;</operator><name>mxMmap</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szMmap</name> <operator>=</operator> <name>mxMmap</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mxMmap</name></name> <operator>=</operator> <name>mxMmap</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szMmap</name></name> <operator>=</operator> <name>szMmap</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_MALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if> <comment type="block">/* IMP: R-04780-55815 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_WIN32_HEAPSIZE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-34926-03360 SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit
      ** unsigned integer value that specifies the maximum size of the created
      ** heap. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nHeap</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>SQLITE_CONFIG_PMASZ</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szPma</name></name> <operator>=</operator> <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned int</argument>)</argument_list></macro></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set up the lookaside buffers for a database connection.
** Return SQLITE_OK on success.  
** If lookaside is already active, return SQLITE_BUSY.
**
** The sz parameter is the number of bytes in each lookaside slot.
** The cnt parameter is the number of slots.  If pStart is NULL the
** space for the lookaside memory is obtained from sqlite3_malloc().
** If pStart is not NULL then it is sz*cnt bytes of memory to use for
** the lookaside memory.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>setupLookaside</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOOKASIDE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pStart</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>nOut</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Free any existing lookaside buffer for this handle before
  ** allocating a new one so we don't have to have space for 
  ** both at the same time.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bMalloced</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* The size of a lookaside slot after ROUNDDOWN8 needs to be larger
  ** than a pointer to be useful.
  */</comment>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>ROUNDDOWN8</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* IMP: R-33038-09382 */</comment>
  <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&lt;=</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>LookasideSlot</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>sz</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>cnt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStart</name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name>sz</name><operator>*</operator><name>cnt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* IMP: R-61949-35727 */</comment>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pStart</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>pStart</name></expr></argument>)</argument_list></call><operator>/</operator><name>sz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pStart</name> <operator>=</operator> <name>pBuf</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pStart</name></name> <operator>=</operator> <name>pStart</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>sz</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStart</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LookasideSlot</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>LookasideSlot</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>LookasideSlot</name><operator>*</operator><operator>)</operator><name>pStart</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>cnt</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pFree</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pFree</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>LookasideSlot</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><name>sz</name></expr>]</index></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pEnd</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bDisable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bMalloced</name></name> <operator>=</operator> <ternary><condition><expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pStart</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pEnd</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bDisable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bMalloced</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_LOOKASIDE */</comment>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the mutex associated with a database connection.
*/</comment>
<function><type><name>sqlite3_mutex</name> <modifier>*</modifier></type><name>sqlite3_db_mutex</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free up as much memory as we can from the given database
** connection.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_db_release_memory</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerShrink</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Flush any dirty pages in the pager-cache for any attached database
** to disk.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_db_cacheflush</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bSeenBusy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBt</name> <operator>&amp;&amp;</operator> <call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerFlush</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bSeenBusy</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bSeenBusy</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_BUSY</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configuration settings for an individual database connection
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_db_config</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_DBCONFIG_LOOKASIDE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* IMP: R-26835-10964 */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>       <comment type="block">/* IMP: R-47871-25994 */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>      <comment type="block">/* IMP: R-04460-53386 */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>setupLookaside</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>      <comment type="block">/* The opcode */</comment>
        <decl_stmt><decl><type><name>u32</name></type> <name>mask</name></decl>;</decl_stmt>    <comment type="block">/* Mask of the bit in sqlite3.flags to set/clear */</comment>
      }</block> <decl><name><name>aFlagOp</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_ENABLE_FKEY</name></expr>,    <expr><name>SQLITE_ForeignKeys</name></expr>    }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_ENABLE_TRIGGER</name></expr>, <expr><name>SQLITE_EnableTrigger</name></expr>  }</block></expr>,
      }</block></expr></init></decl>;</struct>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt> <comment type="block">/* IMP: R-42790-23372 */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aFlagOp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aFlagOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>op</name><operator>==</operator><name>op</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>onoff</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>oldFlags</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>onoff</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name><name>aFlagOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mask</name></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>onoff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name><name>aFlagOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mask</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>oldFlags</name><operator>!=</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>pRes</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name><name>aFlagOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Return true if the buffer z[0..n-1] contains all spaces.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>allSpaces</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the default collating function named "BINARY" which is always
** available.
**
** If the padFlag argument is not NULL then space padding at the end
** of strings is ignored.  This implements the RTRIM collation.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>binCollFunc</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>padFlag</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name>nKey1</name><operator>&lt;</operator><name>nKey2</name></expr> ?</condition><then> <expr><name>nKey1</name></expr> </then><else>: <expr><name>nKey2</name></expr></else></ternary></expr>;</expr_stmt>
  <comment type="block">/* EVIDENCE-OF: R-65033-28449 The built-in BINARY collation compares
  ** strings byte by byte using the memcmp() function from the standard C
  ** library. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>padFlag</name>
     <operator>&amp;&amp;</operator> <call><name>allSpaces</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pKey1</name><operator>)</operator><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nKey1</name><operator>-</operator><name>n</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>allSpaces</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pKey2</name><operator>)</operator><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nKey2</name><operator>-</operator><name>n</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-31624-24737 RTRIM is like BINARY except that extra
      ** spaces at the end of either string do not change the result. In other
      ** words, strings will compare equal to one another as long as they
      ** differ only in the number of spaces at the end.
      */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>nKey1</name> <operator>-</operator> <name>nKey2</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Another built-in collating sequence: NOCASE. 
**
** This collating sequence is intended to be used for "case independent
** comparison". SQLite's knowledge of upper and lower case equivalents
** extends only to the 26 characters used in the English language.
**
** At the moment there is only a UTF-8 implementation.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nocaseCollatingFunc</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>sqlite3StrNICmp</name><argument_list>(
      <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey1</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey2</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>nKey1</name><operator>&lt;</operator><name>nKey2</name><operator>)</operator></expr>?</condition><then><expr><name>nKey1</name></expr></then><else>:<expr><name>nKey2</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>r</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <name>nKey1</name><operator>-</operator><name>nKey2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the ROWID of the most recent insert
*/</comment>
<function><type><name>sqlite_int64</name></type> <name>sqlite3_last_insert_rowid</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of changes in the most recent call to sqlite3_exec().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_changes</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of changes since the database handle was opened.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_total_changes</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>nTotalChange</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close all open savepoints. This function only manipulates fields of the
** database handle object, it does not close any savepoints that may be open
** at the b-tree/pager level.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CloseSavepoints</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Savepoint</name> <modifier>*</modifier></type><name>pTmp</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name> <operator>=</operator> <name><name>pTmp</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the destructor function associated with FuncDef p, if any. Except,
** if this is not the last copy of the function, do not invoke it. Multiple
** copies of a single function are created when create_function() is called
** with SQLITE_ANY as the encoding.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>functionDestroy</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FuncDestructor</name> <modifier>*</modifier></type><name>pDestructor</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pDestructor</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDestructor</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDestructor</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDestructor</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>pDestructor</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>pDestructor</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDestructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Disconnect all sqlite3_vtab objects that belong to database connection
** db. This is called when db is being closed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>disconnectAllVtab</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Table</name> <operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VtabDisconnect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name> <init>= <expr><operator>(</operator><name>Module</name> <operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VtabDisconnect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3VtabUnlockList</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if database connection db has unfinalized prepared
** statements or unfinished sqlite3_backup objects.  
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>connectionIsBusy</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBt</name> <operator>&amp;&amp;</operator> <call><name>sqlite3BtreeIsInBackup</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close an existing SQLite database
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3Close</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forceZombie</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* EVIDENCE-OF: R-63257-11740 Calling sqlite3_close() or
    ** sqlite3_close_v2() with a NULL pointer argument is a harmless no-op. */</comment>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Force xDisconnect calls on all virtual tables */</comment>
  <expr_stmt><expr><call><name>disconnectAllVtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If a transaction is open, the disconnectAllVtab() call above
  ** will not have called the xDisconnect() method on any virtual
  ** tables in the db-&gt;aVTrans[] array. The following sqlite3VtabRollback()
  ** call will do so. We need to do this before the check for active
  ** SQL statements below, as the v-table implementation may be storing
  ** some prepared statements internally.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VtabRollback</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Legacy behavior (sqlite3_close() behavior) is to return
  ** SQLITE_BUSY if the connection can not be closed immediately.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>forceZombie</name> <operator>&amp;&amp;</operator> <call><name>connectionIsBusy</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>, <argument><expr><literal type="string">"unable to close due to unfinalized "</literal>
       <literal type="string">"statements or unfinished backups"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SQLLOG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Closing the handle. Fourth parameter is passed the value 2. */</comment>
    <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pSqllogArg</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Convert the connection into a zombie and then close it.
  */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>SQLITE_MAGIC_ZOMBIE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3LeaveMutexAndCloseZombie</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Two variations on the public interface for closing a database
** connection. The sqlite3_close() version returns SQLITE_BUSY and
** leaves the connection option if there are unfinalized prepared
** statements or unfinished sqlite3_backups.  The sqlite3_close_v2()
** version forces the connection to become a zombie if there are
** unclosed resources, and arranges for deallocation when the last
** prepare statement or sqlite3_backup closes.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_close</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><call><name>sqlite3Close</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_close_v2</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><call><name>sqlite3Close</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>


<comment type="block">/*
** Close the mutex on database connection db.
**
** Furthermore, if database connection db is a zombie (meaning that there
** has been a prior call to sqlite3_close(db) or sqlite3_close_v2(db)) and
** every sqlite3_stmt has now been finalized and every sqlite3_backup has
** finished, then free all resources.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3LeaveMutexAndCloseZombie</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>                    <comment type="block">/* Hash table iterator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

  <comment type="block">/* If there are outstanding sqlite3_stmt or sqlite3_backup objects
  ** or if the connection has not yet been closed by sqlite3_close_v2(),
  ** then just leave the mutex and return.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>magic</name></name><operator>!=</operator><name>SQLITE_MAGIC_ZOMBIE</name> <operator>||</operator> <call><name>connectionIsBusy</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we reach this point, it means that the database connection has
  ** closed all sqlite3_stmt and sqlite3_backup objects and has been
  ** passed to sqlite3_close (meaning that it is a zombie).  Therefore,
  ** go ahead and free all resources.
  */</comment>

  <comment type="block">/* If a transaction is open, roll it back. This also ensures that if
  ** any database schemas have been modified by an uncommitted transaction
  ** they are reset. And that the required b-tree mutex is held to make
  ** the pager rollback and schema reset an atomic operation. */</comment>
  <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Free any outstanding Savepoint structures. */</comment>
  <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close all database connections */</comment>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>Db</name></name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BtreeClose</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <comment type="block">/* Clear the TEMP schema separately and last */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3SchemaClear</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabUnlockList</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Free up the array of auxiliary databases */</comment>
  <expr_stmt><expr><call><name>sqlite3CollapseDatabaseArray</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name><operator>&lt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name></name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aDbStatic</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Tell the code in notify.c that the connection no longer holds any
  ** locks and does not require any further unlock-notify callbacks.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3ConnectionClosed</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aFunc</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pNext</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pHash</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>db</name><operator>-&gt;</operator><name>aFunc</name><operator>.</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pHash</name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pHash</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pHash</name></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>functionDestroy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aCollSeq</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><operator>(</operator><name>CollSeq</name> <operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Invoke any destructors registered for collation sequence user data. */</comment>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pColl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>xDel</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pColl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><call><name>xDel</name><argument_list>(<argument><expr><name><name>pColl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aCollSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name> <init>= <expr><operator>(</operator><name>Module</name> <operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMod</name><operator>-&gt;</operator><name>xDestroy</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>pMod</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>pMod</name><operator>-&gt;</operator><name>pAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabEponymousTableClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Deallocates any cached error strings. */</comment>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3CloseExtensions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_USER_AUTHENTICATION</name></expr></cpp:if>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>auth</name><operator>.</operator><name>zAuthUser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>auth</name><operator>.</operator><name>zAuthPW</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>SQLITE_MAGIC_ERROR</name></expr>;</expr_stmt>

  <comment type="block">/* The temp-database schema is allocated differently from the other schema
  ** objects (using sqliteMalloc() directly, instead of sqlite3BtreeSchema()).
  ** So it needs to be freed here. Todo: Why not roll the temp schema into
  ** the same sqliteMalloc() as the one that allocates the database 
  ** structure?
  */</comment>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>SQLITE_MAGIC_CLOSED</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>nOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Fails on a lookaside memory leak */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bMalloced</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Rollback all database files.  If tripCode is not SQLITE_OK, then
** any write cursors are invalidated ("tripped" - as in "tripping a circuit
** breaker") and made to return tripCode if there are any further
** attempts to use that cursor.  Read cursors remain open and valid
** but are "saved" in case the table pages are moved around.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RollbackAll</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tripCode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>inTrans</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>schemaChange</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Obtain all b-tree mutexes before making any calls to BtreeRollback(). 
  ** This is important in case the transaction being rolled back has
  ** modified the database schema. If the b-tree mutexes are not taken
  ** here, then another shared-cache connection might sneak in between
  ** the database rollback and schema reset, which can cause false
  ** corruption reports in some cases.  */</comment>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>schemaChange</name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_InternChanges</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>inTrans</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeRollback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tripCode</name></expr></argument>, <argument><expr><operator>!</operator><name>schemaChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3VtabRollback</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_InternChanges</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ResetAllSchemasOfConnection</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Any deferred constraint violations have now been resolved. */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_DeferFKs</name></expr>;</expr_stmt>

  <comment type="block">/* If one has been configured, invoke the rollback-hook callback */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xRollbackCallback</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>inTrans</name> <operator>||</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xRollbackCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pRollbackArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a static string containing the name corresponding to the error code
** specified in the argument.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_NEED_ERR_NAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3ErrName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>origRc</name> <init>= <expr><name>rc</name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>rc</name> <operator>&amp;=</operator> <literal type="number">0xff</literal></expr></incr>)</control><block>{<block_content>
    <switch>switch<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_OK</name></expr>:</case>                 <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_OK"</literal></expr>;</expr_stmt>                <break>break;</break>
      <case>case <expr><name>SQLITE_ERROR</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_ERROR"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_INTERNAL</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_INTERNAL"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_PERM</name></expr>:</case>               <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_PERM"</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>SQLITE_ABORT</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_ABORT"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_ABORT_ROLLBACK</name></expr>:</case>     <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_ABORT_ROLLBACK"</literal></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><name>SQLITE_BUSY</name></expr>:</case>               <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_BUSY"</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>SQLITE_BUSY_RECOVERY</name></expr>:</case>      <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_BUSY_RECOVERY"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_BUSY_SNAPSHOT</name></expr>:</case>      <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_BUSY_SNAPSHOT"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_LOCKED</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_LOCKED"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_LOCKED_SHAREDCACHE</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_LOCKED_SHAREDCACHE"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_NOMEM</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOMEM"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY_RECOVERY</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY_RECOVERY"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY_CANTLOCK</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY_CANTLOCK"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY_ROLLBACK</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY_ROLLBACK"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY_DBMOVED</name></expr>:</case>   <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY_DBMOVED"</literal></expr>;</expr_stmt>  <break>break;</break>
      <case>case <expr><name>SQLITE_INTERRUPT</name></expr>:</case>          <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_INTERRUPT"</literal></expr>;</expr_stmt>         <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_READ</name></expr>:</case>         <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_READ"</literal></expr>;</expr_stmt>        <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>:</case>   <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SHORT_READ"</literal></expr>;</expr_stmt>  <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_WRITE</name></expr>:</case>        <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_WRITE"</literal></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_FSYNC</name></expr>:</case>        <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_FSYNC"</literal></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_DIR_FSYNC</name></expr>:</case>    <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_DIR_FSYNC"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_TRUNCATE</name></expr>:</case>     <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_TRUNCATE"</literal></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_FSTAT</name></expr>:</case>        <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_FSTAT"</literal></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_UNLOCK</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_UNLOCK"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_RDLOCK</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_RDLOCK"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_DELETE</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_DELETE"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_NOMEM</name></expr>:</case>        <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_NOMEM"</literal></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_ACCESS</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_ACCESS"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_CHECKRESERVEDLOCK</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_CHECKRESERVEDLOCK"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_LOCK</name></expr>:</case>         <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_LOCK"</literal></expr>;</expr_stmt>        <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_CLOSE</name></expr>:</case>        <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_CLOSE"</literal></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_DIR_CLOSE</name></expr>:</case>    <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_DIR_CLOSE"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SHMOPEN</name></expr>:</case>      <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SHMOPEN"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SHMSIZE</name></expr>:</case>      <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SHMSIZE"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SHMLOCK</name></expr>:</case>      <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SHMLOCK"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SHMMAP</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SHMMAP"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SEEK</name></expr>:</case>         <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SEEK"</literal></expr>;</expr_stmt>        <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_DELETE_NOENT</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_DELETE_NOENT"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_MMAP</name></expr>:</case>         <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_MMAP"</literal></expr>;</expr_stmt>        <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_GETTEMPPATH</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_GETTEMPPATH"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_CONVPATH</name></expr>:</case>     <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_CONVPATH"</literal></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><name>SQLITE_CORRUPT</name></expr>:</case>            <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CORRUPT"</literal></expr>;</expr_stmt>           <break>break;</break>
      <case>case <expr><name>SQLITE_CORRUPT_VTAB</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CORRUPT_VTAB"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_NOTFOUND</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOTFOUND"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_FULL</name></expr>:</case>               <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_FULL"</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN_NOTEMPDIR</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN_NOTEMPDIR"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN_ISDIR</name></expr>:</case>     <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN_ISDIR"</literal></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN_FULLPATH</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN_FULLPATH"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN_CONVPATH</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN_CONVPATH"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_PROTOCOL</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_PROTOCOL"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_EMPTY</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_EMPTY"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_SCHEMA</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_SCHEMA"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_TOOBIG</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_TOOBIG"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT</name></expr>:</case>         <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT"</literal></expr>;</expr_stmt>        <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_UNIQUE</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_UNIQUE"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_TRIGGER</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_TRIGGER"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_FOREIGNKEY</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_FOREIGNKEY"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_CHECK</name></expr>:</case>   <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_CHECK"</literal></expr>;</expr_stmt>  <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_PRIMARYKEY</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_PRIMARYKEY"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_NOTNULL</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_NOTNULL"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_COMMITHOOK</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_COMMITHOOK"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_VTAB</name></expr>:</case>    <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_VTAB"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_FUNCTION</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_FUNCTION"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_ROWID</name></expr>:</case>   <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_ROWID"</literal></expr>;</expr_stmt>  <break>break;</break>
      <case>case <expr><name>SQLITE_MISMATCH</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_MISMATCH"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_MISUSE</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_MISUSE"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_NOLFS</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOLFS"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_AUTH</name></expr>:</case>               <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_AUTH"</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>SQLITE_FORMAT</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_FORMAT"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_RANGE</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_RANGE"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_NOTADB</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOTADB"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_ROW</name></expr>:</case>                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_ROW"</literal></expr>;</expr_stmt>               <break>break;</break>
      <case>case <expr><name>SQLITE_NOTICE</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOTICE"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_NOTICE_RECOVER_WAL</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOTICE_RECOVER_WAL"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_NOTICE_RECOVER_ROLLBACK</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOTICE_RECOVER_ROLLBACK"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_WARNING</name></expr>:</case>            <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_WARNING"</literal></expr>;</expr_stmt>           <break>break;</break>
      <case>case <expr><name>SQLITE_WARNING_AUTOINDEX</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_WARNING_AUTOINDEX"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_DONE</name></expr>:</case>               <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_DONE"</literal></expr>;</expr_stmt>              <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"SQLITE_UNKNOWN(%d)"</literal></expr></argument>, <argument><expr><name>origRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zName</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return a static string that describes the kind of error specified in the
** argument.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3ErrStr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name><name>aMsg</name><index>[]</index></name> <init>= <expr><block>{
    <comment type="block">/* SQLITE_OK          */</comment> <expr><literal type="string">"not an error"</literal></expr>,
    <comment type="block">/* SQLITE_ERROR       */</comment> <expr><literal type="string">"SQL logic error or missing database"</literal></expr>,
    <comment type="block">/* SQLITE_INTERNAL    */</comment> <expr><literal type="number">0</literal></expr>,
    <comment type="block">/* SQLITE_PERM        */</comment> <expr><literal type="string">"access permission denied"</literal></expr>,
    <comment type="block">/* SQLITE_ABORT       */</comment> <expr><literal type="string">"callback requested query abort"</literal></expr>,
    <comment type="block">/* SQLITE_BUSY        */</comment> <expr><literal type="string">"database is locked"</literal></expr>,
    <comment type="block">/* SQLITE_LOCKED      */</comment> <expr><literal type="string">"database table is locked"</literal></expr>,
    <comment type="block">/* SQLITE_NOMEM       */</comment> <expr><literal type="string">"out of memory"</literal></expr>,
    <comment type="block">/* SQLITE_READONLY    */</comment> <expr><literal type="string">"attempt to write a readonly database"</literal></expr>,
    <comment type="block">/* SQLITE_INTERRUPT   */</comment> <expr><literal type="string">"interrupted"</literal></expr>,
    <comment type="block">/* SQLITE_IOERR       */</comment> <expr><literal type="string">"disk I/O error"</literal></expr>,
    <comment type="block">/* SQLITE_CORRUPT     */</comment> <expr><literal type="string">"database disk image is malformed"</literal></expr>,
    <comment type="block">/* SQLITE_NOTFOUND    */</comment> <expr><literal type="string">"unknown operation"</literal></expr>,
    <comment type="block">/* SQLITE_FULL        */</comment> <expr><literal type="string">"database or disk is full"</literal></expr>,
    <comment type="block">/* SQLITE_CANTOPEN    */</comment> <expr><literal type="string">"unable to open database file"</literal></expr>,
    <comment type="block">/* SQLITE_PROTOCOL    */</comment> <expr><literal type="string">"locking protocol"</literal></expr>,
    <comment type="block">/* SQLITE_EMPTY       */</comment> <expr><literal type="string">"table contains no data"</literal></expr>,
    <comment type="block">/* SQLITE_SCHEMA      */</comment> <expr><literal type="string">"database schema has changed"</literal></expr>,
    <comment type="block">/* SQLITE_TOOBIG      */</comment> <expr><literal type="string">"string or blob too big"</literal></expr>,
    <comment type="block">/* SQLITE_CONSTRAINT  */</comment> <expr><literal type="string">"constraint failed"</literal></expr>,
    <comment type="block">/* SQLITE_MISMATCH    */</comment> <expr><literal type="string">"datatype mismatch"</literal></expr>,
    <comment type="block">/* SQLITE_MISUSE      */</comment> <expr><literal type="string">"library routine called out of sequence"</literal></expr>,
    <comment type="block">/* SQLITE_NOLFS       */</comment> <expr><literal type="string">"large file support is disabled"</literal></expr>,
    <comment type="block">/* SQLITE_AUTH        */</comment> <expr><literal type="string">"authorization denied"</literal></expr>,
    <comment type="block">/* SQLITE_FORMAT      */</comment> <expr><literal type="string">"auxiliary database format error"</literal></expr>,
    <comment type="block">/* SQLITE_RANGE       */</comment> <expr><literal type="string">"bind or column index out of range"</literal></expr>,
    <comment type="block">/* SQLITE_NOTADB      */</comment> <expr><literal type="string">"file is encrypted or is not a database"</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="string">"unknown error"</literal></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_ABORT_ROLLBACK</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>zErr</name> <operator>=</operator> <literal type="string">"abort due to ROLLBACK"</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>&amp;=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>rc</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>rc</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aMsg</name><index>[<expr><name>rc</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zErr</name> <operator>=</operator> <name><name>aMsg</name><index>[<expr><name>rc</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>zErr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine implements a busy callback that sleeps and tries
** again until a timeout value is reached.  The timeout value is
** an integer number of milliseconds passed in as the first
** argument.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqliteDefaultBusyCallback</name><parameter_list>(
 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,               <comment type="block">/* Database connection */</comment>
 <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>                <comment type="block">/* Number of times table has been busy */</comment>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name> <operator>||</operator> <name>HAVE_USLEEP</name></expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>delays</name><index>[]</index></name> <init>=
     <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>,  <expr><literal type="number">25</literal></expr>,  <expr><literal type="number">50</literal></expr>,  <expr><literal type="number">50</literal></expr>, <expr><literal type="number">100</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>totals</name><index>[]</index></name> <init>=
     <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">8</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">33</literal></expr>, <expr><literal type="number">53</literal></expr>, <expr><literal type="number">78</literal></expr>, <expr><literal type="number">103</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">178</literal></expr>, <expr><literal type="number">228</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NDELAY</name></cpp:macro> <cpp:value>ArraySize(delays)</cpp:value></cpp:define>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><operator>(</operator><name>sqlite3</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>timeout</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>busyTimeout</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>delay</name></decl>, <decl><type ref="prev"/><name>prior</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>count</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>count</name> <operator>&lt;</operator> <name>NDELAY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>delay</name> <operator>=</operator> <name><name>delays</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prior</name> <operator>=</operator> <name><name>totals</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>delay</name> <operator>=</operator> <name><name>delays</name><index>[<expr><name>NDELAY</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prior</name> <operator>=</operator> <name><name>totals</name><index>[<expr><name>NDELAY</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>delay</name><operator>*</operator><operator>(</operator><name>count</name><operator>-</operator><operator>(</operator><name>NDELAY</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>prior</name> <operator>+</operator> <name>delay</name> <operator>&gt;</operator> <name>timeout</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>delay</name> <operator>=</operator> <name>timeout</name> <operator>-</operator> <name>prior</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>delay</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3OsSleep</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>delay</name><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><operator>(</operator><name>sqlite3</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>timeout</name> <init>= <expr><operator>(</operator><operator>(</operator><name>sqlite3</name> <operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>busyTimeout</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>count</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">1000</literal> <operator>&gt;</operator> <name>timeout</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3OsSleep</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the given busy handler.
**
** This routine is called when an operation failed with a lock.
** If this routine returns non-zero, the lock is retried.  If it
** returns 0, the operation aborts with an SQLITE_BUSY error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3InvokeBusyHandler</name><parameter_list>(<parameter><decl><type><name>BusyHandler</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>xFunc</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>nBusy</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xFunc</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pArg</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nBusy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBusy</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBusy</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block">/*
** This routine sets the busy callback for an Sqlite database to the
** given callback function with the given argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_busy_handler</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xBusy</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>xFunc</name></name> <operator>=</operator> <name>xBusy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>pArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>nBusy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyTimeout</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
<comment type="block">/*
** This routine sets the progress callback for an Sqlite database to the
** given callback function with the given argument. The progress callback will
** be invoked every nOps opcodes.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_progress_handler</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nOps</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xProgress</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOps</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name> <operator>=</operator> <name>xProgress</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>nOps</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pProgressArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pProgressArg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** This routine installs a default busy handler that waits for the
** specified number of milliseconds before returning 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_busy_timeout</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ms</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>ms</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_busy_handler</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sqliteDefaultBusyCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyTimeout</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_busy_handler</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Cause any pending operation to stop at its earliest opportunity.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_interrupt</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** This function is exactly the same as sqlite3_create_function(), except
** that it is designed to be called by internal code. The difference is
** that if a malloc() fails in sqlite3_create_function(), an error code
** is returned and the mallocFailed flag cleared. 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3CreateFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunctionName</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xSFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>FuncDestructor</name> <modifier>*</modifier></type><name>pDestructor</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>extraFlags</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFunctionName</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator>
      <operator>(</operator><name>xSFunc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>xFinal</name> <operator>||</operator> <name>xStep</name><operator>)</operator><operator>)</operator> <operator>||</operator> 
      <operator>(</operator><operator>!</operator><name>xSFunc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>xFinal</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>xStep</name><operator>)</operator><operator>)</operator> <operator>||</operator>
      <operator>(</operator><operator>!</operator><name>xSFunc</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>xFinal</name> <operator>&amp;&amp;</operator> <name>xStep</name><operator>)</operator><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name><name>nArg</name><argument_list type="generic">&lt;<argument><expr><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>nArg</name></expr></argument>&gt;</argument_list></name><name>SQLITE_MAX_FUNCTION_ARG</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><literal type="number">255</literal><operator>&lt;</operator><operator>(</operator><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>( <argument><expr><name>zFunctionName</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_CONSTANT</name><operator>==</operator><name>SQLITE_DETERMINISTIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>extraFlags</name> <operator>=</operator> <name>enc</name> <operator>&amp;</operator>  <name>SQLITE_DETERMINISTIC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>enc</name> <operator>&amp;=</operator> <operator>(</operator><name>SQLITE_FUNC_ENCMASK</name><operator>|</operator><name>SQLITE_ANY</name><operator>)</operator></expr>;</expr_stmt>
  
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <comment type="block">/* If SQLITE_UTF16 is specified as the encoding type, transform this
  ** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the
  ** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.
  **
  ** If SQLITE_ANY is specified, add three versions of the function
  ** to the hash table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>enc</name><operator>==</operator><name>SQLITE_UTF16</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>enc</name><operator>==</operator><name>SQLITE_ANY</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>extraFlags</name></expr></argument>,
         <argument><expr><name>pUserData</name></expr></argument>, <argument><expr><name>xSFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>, <argument><expr><name>xFinal</name></expr></argument>, <argument><expr><name>pDestructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF16LE</name><operator>|</operator><name>extraFlags</name></expr></argument>,
          <argument><expr><name>pUserData</name></expr></argument>, <argument><expr><name>xSFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>, <argument><expr><name>xFinal</name></expr></argument>, <argument><expr><name>pDestructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF16BE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <comment type="block">/* Check if an existing function is being overridden or deleted. If so,
  ** and there are active VMs, then return SQLITE_BUSY. If a function
  ** is being overridden/deleted but there are no active VMs, allow the
  ** operation to continue but invalidate all precompiled statements.
  */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_ENCMASK</name><operator>)</operator><operator>==</operator><name>enc</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nArg</name></name><operator>==</operator><name>nArg</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>, 
        <argument><expr><literal type="string">"unable to delete/modify user-function due to active statements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If an older version of the function with a configured destructor is
  ** being replaced invoke the destructor function here. */</comment>
  <expr_stmt><expr><call><name>functionDestroy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pDestructor</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDestructor</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDestructor</name></name> <operator>=</operator> <name>pDestructor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_ENCMASK</name><operator>)</operator> <operator>|</operator> <name>extraFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_DETERMINISTIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xSFunc</name></name> <operator>=</operator> <ternary><condition><expr><name>xSFunc</name></expr> ?</condition><then> <expr><name>xSFunc</name></expr> </then><else>: <expr><name>xStep</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xFinalize</name></name> <operator>=</operator> <name>xFinal</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pUserData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nArg</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nArg</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create new user functions.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_function</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xSFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_create_function_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xSFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>,
                                    <argument><expr><name>xFinal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3_create_function_v2</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xSFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDestructor</name> <modifier>*</modifier></type><name>pArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>xDestroy</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pArg</name> <operator>=</operator> <operator>(</operator><name>FuncDestructor</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuncDestructor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pArg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>xDestroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>xDestroy</name></name> <operator>=</operator> <name>xDestroy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xSFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>, <argument><expr><name>xFinal</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pArg</name> <operator>&amp;&amp;</operator> <name><name>pArg</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>xDestroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>out</name>:</label>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3_create_function16</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zFunctionName</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>eTextRep</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xSFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFunc8</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zFunctionName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFunc8</name> <operator>=</operator> <call><name>sqlite3Utf16to8</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc8</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>eTextRep</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xSFunc</name></expr></argument>,<argument><expr><name>xStep</name></expr></argument>,<argument><expr><name>xFinal</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Declare that a function has been overloaded by a virtual table.
**
** If the function already exists as a regular global function, then
** this routine is a no-op.  If the function does not exist, then create
** a new one that always throws a run-time error.  
**
** When virtual tables intend to provide an overloaded function, they
** should call this routine to make sure the global function exists.
** A global function must exist in order for name resolution to work
** properly.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_overload_function</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nArg</name><operator>&lt;</operator><operator>-</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>,
                           <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sqlite3InvalidFunction</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
<comment type="block">/*
** Register a trace function.  The pArg from the previously registered trace
** is returned.  
**
** A NULL trace function means that no tracing is executes.  A non-NULL
** trace is a pointer to a function that is invoked at the start of each
** SQL statement.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_trace</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xTrace</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOld</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xTrace</name></name> <operator>=</operator> <name>xTrace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pOld</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Register a profile function.  The pArg from the previously registered 
** profile function is returned.  
**
** A NULL profile function means that no profiling is executes.  A non-NULL
** profile is a pointer to a function that is invoked at the conclusion of
** each SQL statement that is run.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_profile</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xProfile</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite_uint64</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOld</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pProfileArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xProfile</name></name> <operator>=</operator> <name>xProfile</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pProfileArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pOld</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRACE */</comment>

<comment type="block">/*
** Register a function to be invoked when a transaction commits.
** If the invoked function returns non-zero, then the commit becomes a
** rollback.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_commit_hook</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,              <comment type="block">/* Attach the hook to this database */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,  <comment type="block">/* Function to invoke on each commit */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                <comment type="block">/* Argument to the function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOld</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pCommitArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xCommitCallback</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pCommitArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pOld</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register a callback to be invoked each time a row is updated,
** inserted or deleted using this database connection.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_update_hook</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,              <comment type="block">/* Attach the hook to this database */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite_int64</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                <comment type="block">/* Argument to the function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pUpdateArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pUpdateArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register a callback to be invoked each time a transaction is rolled
** back by this database connection.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_rollback_hook</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,              <comment type="block">/* Attach the hook to this database */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Callback function */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                <comment type="block">/* Argument to the function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pRollbackArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xRollbackCallback</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pRollbackArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<comment type="block">/*
** The sqlite3_wal_hook() callback registered by sqlite3_wal_autocheckpoint().
** Invoke sqlite3_wal_checkpoint if the number of frames in the log file
** is greater than sqlite3.pWalArg cast to an integer (the value configured by
** wal_autocheckpoint()).
*/</comment> 
<function><type><name>int</name></type> <name>sqlite3WalDefaultHook</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pClientData</name></decl></parameter>,     <comment type="block">/* Argument */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,           <comment type="block">/* Connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,       <comment type="block">/* Database */</comment>
  <parameter><decl><type><name>int</name></type> <name>nFrame</name></decl></parameter>             <comment type="block">/* Size of WAL */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nFrame</name><operator>&gt;=</operator><call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name>pClientData</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_wal_checkpoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WAL */</comment>

<comment type="block">/*
** Configure an sqlite3_wal_hook() callback to automatically checkpoint
** a database after committing a transaction if there are nFrame or
** more frames in the log file. Passing zero or a negative value as the
** nFrame parameter disables automatic checkpoints entirely.
**
** The callback registered by this function replaces any existing callback
** registered using sqlite3_wal_hook(). Likewise, registering a callback
** using sqlite3_wal_hook() disables the automatic checkpoint mechanism
** configured by this function.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_wal_autocheckpoint</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nFrame</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifdef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>nFrame</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_wal_hook</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sqlite3WalDefaultHook</name></expr></argument>, <argument><expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>nFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_wal_hook</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register a callback to be invoked each time a transaction is written
** into the write-ahead-log by this database connection.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_wal_hook</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Attach the hook to this db handle */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                      <comment type="block">/* First argument passed to xCallback() */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pWalArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xWalCallback</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pWalArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Checkpoint database zDb.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_wal_checkpoint_v2</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Name of attached database (or NULL) */</comment>
  <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>,                      <comment type="block">/* SQLITE_CHECKPOINT_* value */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnLog</name></decl></parameter>,                     <comment type="block">/* OUT: Size of WAL log in frames */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCkpt</name></decl></parameter>                     <comment type="block">/* OUT: Total number of frames checkpointed */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifdef>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><name>SQLITE_MAX_ATTACHED</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* sqlite3.aDb[] index of db to checkpoint */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Initialize the output variables to -1 in case an error occurs. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pnLog</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnLog</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnCkpt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnCkpt</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_CHECKPOINT_PASSIVE</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_CHECKPOINT_FULL</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_CHECKPOINT_RESTART</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_CHECKPOINT_TRUNCATE</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>eMode</name><argument_list type="generic">&lt;<argument><expr><name>SQLITE_CHECKPOINT_PASSIVE</name> <operator>||</operator> <name>eMode</name></expr></argument>&gt;</argument_list></name><name>SQLITE_CHECKPOINT_TRUNCATE</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* EVIDENCE-OF: R-03996-12088 The M parameter must be a valid checkpoint
    ** mode: */</comment>
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zDb</name> <operator>&amp;&amp;</operator> <name><name>zDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown database: %s"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>nBusy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Checkpoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>eMode</name></expr></argument>, <argument><expr><name>pnLog</name></expr></argument>, <argument><expr><name>pnCkpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
** Checkpoint database zDb. If zDb is NULL, or if the buffer zDb points
** to contains a zero-length string, all attached databases are 
** checkpointed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_wal_checkpoint</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* EVIDENCE-OF: R-41613-20553 The sqlite3_wal_checkpoint(D,X) is equivalent to
  ** sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0). */</comment>
  <return>return <expr><call><name>sqlite3_wal_checkpoint_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>zDb</name></expr></argument>,<argument><expr><name>SQLITE_CHECKPOINT_PASSIVE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<comment type="block">/*
** Run a checkpoint on database iDb. This is a no-op if database iDb is
** not currently open in WAL mode.
**
** If a transaction is open on the database being checkpointed, this 
** function returns SQLITE_LOCKED and a checkpoint is not attempted. If 
** an error occurs while running the checkpoint, an SQLite error code is 
** returned (i.e. SQLITE_IOERR). Otherwise, SQLITE_OK.
**
** The mutex on database handle db should be held by the caller. The mutex
** associated with the specific b-tree being checkpointed is taken by
** this function while the checkpoint is running.
**
** If iDb is passed SQLITE_MAX_ATTACHED, then all attached databases are
** checkpointed. If an error is encountered it is returned immediately -
** no attempt is made to checkpoint any remaining databases.
**
** Parameter eMode is one of SQLITE_CHECKPOINT_PASSIVE, FULL or RESTART.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Checkpoint</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnLog</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCkpt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Used to iterate through attached dbs */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bBusy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* True if SQLITE_BUSY has been encountered */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pnLog</name> <operator>||</operator> <operator>*</operator><name>pnLog</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pnCkpt</name> <operator>||</operator> <operator>*</operator><name>pnCkpt</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>iDb</name> <operator>||</operator> <name>iDb</name><operator>==</operator><name>SQLITE_MAX_ATTACHED</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCheckpoint</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name>eMode</name></expr></argument>, <argument><expr><name>pnLog</name></expr></argument>, <argument><expr><name>pnCkpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pnLog</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pnCkpt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bBusy</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><ternary><condition><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bBusy</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_BUSY</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WAL */</comment>

<comment type="block">/*
** This function returns true if main-memory should be used instead of
** a temporary file for transient pager files and statement journals.
** The value returned depends on the value of db-&gt;temp_store (runtime
** parameter) and the compile time value of SQLITE_TEMP_STORE. The
** following table describes the relationship between these two values
** and this functions return value.
**
**   SQLITE_TEMP_STORE     db-&gt;temp_store     Location of temporary database
**   -----------------     --------------     ------------------------------
**   0                     any                file      (return 0)
**   1                     1                  file      (return 0)
**   1                     2                  memory    (return 1)
**   1                     0                  file      (return 0)
**   2                     1                  file      (return 0)
**   2                     2                  memory    (return 1)
**   2                     0                  memory    (return 1)
**   3                     any                memory    (return 1)
*/</comment>
<function><type><name>int</name></type> <name>sqlite3TempInMemory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_TEMP_STORE</name><operator>==</operator><literal type="number">1</literal></expr></cpp:if>
  <return>return <expr><operator>(</operator> <name><name>db</name><operator>-&gt;</operator><name>temp_store</name></name><operator>==</operator><literal type="number">2</literal> <operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_TEMP_STORE</name><operator>==</operator><literal type="number">2</literal></expr></cpp:if>
  <return>return <expr><operator>(</operator> <name><name>db</name><operator>-&gt;</operator><name>temp_store</name></name><operator>!=</operator><literal type="number">1</literal> <operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_TEMP_STORE</name><operator>==</operator><literal type="number">3</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name><name>SQLITE_TEMP_STORE</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal> <operator>||</operator> <name>SQLITE_TEMP_STORE</name></expr></argument>&gt;</argument_list></name><literal type="number">3</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Return UTF-8 encoded English language explanation of the most recent
** error.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_errmsg</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>SQLITE_MISUSE_BKPT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Return UTF-16 encoded English language explanation of the most recent
** error.
*/</comment>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_errmsg16</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u16</name></type> <name><name>outOfMem</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'u'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'f'</literal></expr>, <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'m'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'m'</literal></expr>, <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="char">'y'</literal></expr>, <expr><literal type="number">0</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u16</name></type> <name><name>misuse</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="char">'l'</literal></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="char">'a'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="char">'y'</literal></expr>, <expr><literal type="char">' '</literal></expr>, 
    <expr><literal type="char">'r'</literal></expr>, <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'u'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'n'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">' '</literal></expr>, 
    <expr><literal type="char">'c'</literal></expr>, <expr><literal type="char">'a'</literal></expr>, <expr><literal type="char">'l'</literal></expr>, <expr><literal type="char">'l'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'d'</literal></expr>, <expr><literal type="char">' '</literal></expr>, 
    <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'u'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="char">' '</literal></expr>, 
    <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'f'</literal></expr>, <expr><literal type="char">' '</literal></expr>, 
    <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'q'</literal></expr>, <expr><literal type="char">'u'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'n'</literal></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="number">0</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>outOfMem</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>misuse</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>outOfMem</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* A malloc() may have failed within the call to sqlite3_value_text16()
    ** above. If this is the case, then the db-&gt;mallocFailed flag needs to
    ** be cleared before returning. Do this directly, instead of via
    ** sqlite3ApiExit(), to avoid setting the database handle error message.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3OomClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<comment type="block">/*
** Return the most recent error code generated by an SQLite routine. If NULL is
** passed to this function, we assume a malloc() failed during sqlite3_open().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_errcode</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>db</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>errMask</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_extended_errcode</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>db</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a string that describes the kind of error specified in the
** argument.  For now, this simply calls the internal sqlite3ErrStr()
** function.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_errstr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new collating function for database "db".  The name is zName
** and the encoding is enc.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>createCollation</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, 
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xCompare</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>enc2</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If SQLITE_UTF16 is specified as the encoding type, transform this
  ** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the
  ** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.
  */</comment>
  <expr_stmt><expr><name>enc2</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>enc2</name><operator>==</operator><name>SQLITE_UTF16</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>enc2</name><operator>==</operator><name>SQLITE_UTF16_ALIGNED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>enc2</name><operator>==</operator><name>SQLITE_UTF16</name> <operator>||</operator> <name>enc2</name><operator>==</operator><name>SQLITE_UTF16_ALIGNED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>enc2</name> <operator>=</operator> <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>enc2</name><argument_list type="generic">&lt;<argument><expr><name>SQLITE_UTF8</name> <operator>||</operator> <name>enc2</name></expr></argument>&gt;</argument_list></name><name>SQLITE_UTF16BE</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if this call is removing or replacing an existing collation 
  ** sequence. If so, and there are active VMs, return busy. If there
  ** are no active VMs, invalidate any pre-compiled statements.
  */</comment>
  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc2</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pColl</name> <operator>&amp;&amp;</operator> <name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>, 
        <argument><expr><literal type="string">"unable to delete/modify collation sequence due to active statements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If collation sequence pColl was created directly by a call to
    ** sqlite3_create_collation, and not generated by synthCollSeq(),
    ** then any copies made by synthCollSeq() need to be invalidated.
    ** Also, collation destructor - CollSeq.xDel() - function may need
    ** to be called.
    */</comment> 
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name> <operator>&amp;</operator> <operator>~</operator><name>SQLITE_UTF16_ALIGNED</name><operator>)</operator><operator>==</operator><name>enc2</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>aColl</name> <init>= <expr><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aCollSeq</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>aColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>xDel</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>xDel</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xCmp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc2</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pColl</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name> <operator>=</operator> <name>xCompare</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pColl</name><operator>-&gt;</operator><name>pUser</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pColl</name><operator>-&gt;</operator><name>xDel</name></name> <operator>=</operator> <name>xDel</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>enc2</name> <operator>|</operator> <operator>(</operator><name>enc</name> <operator>&amp;</operator> <name>SQLITE_UTF16_ALIGNED</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This array defines hard upper bounds on limit values.  The
** initializer must be kept in sync with the SQLITE_LIMIT_*
** #defines in sqlite3.h.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>aHardLimit</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>SQLITE_MAX_LENGTH</name></expr>,
  <expr><name>SQLITE_MAX_SQL_LENGTH</name></expr>,
  <expr><name>SQLITE_MAX_COLUMN</name></expr>,
  <expr><name>SQLITE_MAX_EXPR_DEPTH</name></expr>,
  <expr><name>SQLITE_MAX_COMPOUND_SELECT</name></expr>,
  <expr><name>SQLITE_MAX_VDBE_OP</name></expr>,
  <expr><name>SQLITE_MAX_FUNCTION_ARG</name></expr>,
  <expr><name>SQLITE_MAX_ATTACHED</name></expr>,
  <expr><name>SQLITE_MAX_LIKE_PATTERN_LENGTH</name></expr>,
  <expr><name>SQLITE_MAX_VARIABLE_NUMBER</name></expr>,      <comment type="block">/* IMP: R-38091-32352 */</comment>
  <expr><name>SQLITE_MAX_TRIGGER_DEPTH</name></expr>,
  <expr><name>SQLITE_MAX_WORKER_THREADS</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Make sure the hard limits are set to reasonable values
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_LENGTH</name><operator>&lt;</operator><literal type="number">100</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_LENGTH must be at least 100</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_SQL_LENGTH</name><operator>&lt;</operator><literal type="number">100</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_SQL_LENGTH must be at least 100</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_SQL_LENGTH</name><operator>&gt;</operator><name>SQLITE_MAX_LENGTH</name></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_SQL_LENGTH must not be greater than SQLITE_MAX_LENGTH</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_COMPOUND_SELECT</name><operator>&lt;</operator><literal type="number">2</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_COMPOUND_SELECT must be at least 2</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_VDBE_OP</name><operator>&lt;</operator><literal type="number">40</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_VDBE_OP must be at least 40</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name><name>SQLITE_MAX_FUNCTION_ARG</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>SQLITE_MAX_FUNCTION_ARG</name></expr></argument>&gt;</argument_list></name><literal type="number">1000</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_FUNCTION_ARG must be between 0 and 1000</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name><name>SQLITE_MAX_ATTACHED</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>SQLITE_MAX_ATTACHED</name></expr></argument>&gt;</argument_list></name><literal type="number">125</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_ATTACHED must be between 0 and 125</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_LIKE_PATTERN_LENGTH</name><operator>&lt;</operator><literal type="number">1</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_LIKE_PATTERN_LENGTH must be at least 1</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_COLUMN</name><operator>&gt;</operator><literal type="number">32767</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_COLUMN must not exceed 32767</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_TRIGGER_DEPTH</name><operator>&lt;</operator><literal type="number">1</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_TRIGGER_DEPTH must be at least 1</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name><name>SQLITE_MAX_WORKER_THREADS</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>SQLITE_MAX_WORKER_THREADS</name></expr></argument>&gt;</argument_list></name><literal type="number">50</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_WORKER_THREADS must be between 0 and 50</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Change the value of a limit.  Report the old value.
** If an invalid limit index is supplied, report -1.
** Make no changes but still report the old value if the
** new limit is negative.
**
** A new lower limit does not shrink existing constructs.
** It merely prevents new constructs that exceed the limit
** from forming.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_limit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limitId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newLimit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>oldLimit</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* EVIDENCE-OF: R-30189-54097 For each limit category SQLITE_LIMIT_NAME
  ** there is a hard upper bound set at compile-time by a C preprocessor
  ** macro called SQLITE_MAX_NAME. (The "_LIMIT_" in the name is changed to
  ** "_MAX_".)
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_SQL_LENGTH</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_SQL_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_EXPR_DEPTH</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_EXPR_DEPTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_COMPOUND_SELECT</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_COMPOUND_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_VDBE_OP</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_VDBE_OP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_FUNCTION_ARG</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_FUNCTION_ARG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_ATTACHED</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_ATTACHED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</name></expr>]</index></name><operator>==</operator>
                                               <name>SQLITE_MAX_LIKE_PATTERN_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_VARIABLE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_TRIGGER_DEPTH</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_TRIGGER_DEPTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_WORKER_THREADS</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_WORKER_THREADS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_LIMIT_WORKER_THREADS</name><operator>==</operator><operator>(</operator><name>SQLITE_N_LIMIT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>


  <if_stmt><if>if<condition>( <expr><name>limitId</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>limitId</name><operator>&gt;=</operator><name>SQLITE_N_LIMIT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>oldLimit</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>limitId</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>newLimit</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>                   <comment type="block">/* IMP: R-52476-28732 */</comment>
    <if_stmt><if>if<condition>( <expr><name>newLimit</name><operator>&gt;</operator><name><name>aHardLimit</name><index>[<expr><name>limitId</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>newLimit</name> <operator>=</operator> <name><name>aHardLimit</name><index>[<expr><name>limitId</name></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* IMP: R-51463-25634 */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>limitId</name></expr>]</index></name> <operator>=</operator> <name>newLimit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>oldLimit</name></expr>;</return>                     <comment type="block">/* IMP: R-53341-35419 */</comment>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to parse both URIs and non-URI filenames passed by the
** user to API functions sqlite3_open() or sqlite3_open_v2(), and for database
** URIs specified as part of ATTACH statements.
**
** The first argument to this function is the name of the VFS to use (or
** a NULL to signify the default VFS) if the URI does not contain a "vfs=xxx"
** query parameter. The second argument contains the URI (or non-URI filename)
** itself. When this function is called the *pFlags variable should contain
** the default flags to open the database handle with. The value stored in
** *pFlags may be updated before returning if the URI filename contains 
** "cache=xxx" or "mode=xxx" query parameters.
**
** If successful, SQLITE_OK is returned. In this case *ppVfs is set to point to
** the VFS that should be used to open the database file. *pzFile is set to
** point to a buffer containing the name of the file to open. It is the 
** responsibility of the caller to eventually call sqlite3_free() to release
** this buffer.
**
** If an error occurs, then an SQLite error code is returned and *pzErrMsg
** may be set to point to a buffer containing an English language error 
** message. It is the responsibility of the caller to eventually release
** this buffer by calling sqlite3_free().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ParseUri</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDefaultVfs</name></decl></parameter>,        <comment type="block">/* VFS to use if no "vfs=xxx" query option */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUri</name></decl></parameter>,               <comment type="block">/* Nul-terminated URI to parse */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>pFlags</name></decl></parameter>,           <comment type="block">/* IN/OUT: SQLITE_OPEN_XXX flags */</comment>
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVfs</name></decl></parameter>,            <comment type="block">/* OUT: VFS to use */</comment> 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzFile</name></decl></parameter>,                  <comment type="block">/* OUT: Filename component of URI */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>                 <comment type="block">/* OUT: Error message (if rc!=SQLITE_OK) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name> <init>= <expr><operator>*</operator><name>pFlags</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVfs</name> <init>= <expr><name>zDefaultVfs</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nUri</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pzErrMsg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_URI</name><operator>)</operator>             <comment type="block">/* IMP: R-48725-32206 */</comment>
            <operator>||</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bOpenUri</name></name><operator>)</operator> <comment type="block">/* IMP: R-51689-46548 */</comment>
   <operator>&amp;&amp;</operator> <name>nUri</name><operator>&gt;=</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>, <argument><expr><literal type="string">"file:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> <comment type="block">/* IMP: R-57884-37496 */</comment>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOpt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eState</name></decl>;</decl_stmt>                   <comment type="block">/* Parser state when parsing URI */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iIn</name></decl>;</decl_stmt>                      <comment type="block">/* Input character index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Output character index */</comment>
    <decl_stmt><decl><type><name>u64</name></type> <name>nByte</name> <init>= <expr><name>nUri</name><operator>+</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Bytes of space to allocate */</comment>

    <comment type="block">/* Make sure the SQLITE_OPEN_URI flag is set to indicate to the VFS xOpen 
    ** method that there may be extra parameters following the file-name.  */</comment>
    <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SQLITE_OPEN_URI</name></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>iIn</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iIn</name><operator>&lt;</operator><name>nUri</name></expr>;</condition> <incr><expr><name>iIn</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <operator>(</operator><name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>==</operator><literal type="char">'&amp;'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zFile</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>iIn</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ALLOW_URI_AUTHORITY</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zUri</name><operator>+</operator><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"///"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iIn</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
      <comment type="block">/* The following condition causes URIs with five leading / characters
      ** like file://///host/path to be converted into UNCs like //host/path.
      ** The correct URI for that UNC has only two or four leading / characters
      ** file://host/path or file:////host/path.  But 5 leading slashes is a 
      ** common error, we are told, so we handle it as a special case. */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zUri</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"///"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zUri</name><operator>+</operator><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"//localhost/"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iIn</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Discard the scheme and authority segments of the URI. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>zUri</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>zUri</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iIn</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if<condition>( <expr><name>iIn</name><operator>!=</operator><literal type="number">7</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>iIn</name><operator>!=</operator><literal type="number">16</literal> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"localhost"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zUri</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"invalid uri authority: %.*s"</literal></expr></argument>, 
            <argument><expr><name>iIn</name><operator>-</operator><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zUri</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        <goto>goto <name>parse_uri_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Copy the filename and any query parameters into the zFile buffer. 
    ** Decode %HH escape codes along the way. 
    **
    ** Within this loop, variable eState may be set to 0, 1 or 2, depending
    ** on the parsing context. As follows:
    **
    **   0: Parsing file-name.
    **   1: Parsing name section of a name=value query parameter.
    **   2: Parsing value section of a name=value query parameter.
    */</comment>
    <expr_stmt><expr><name>eState</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'#'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'%'</literal> 
       <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name></expr></argument>)</argument_list></call> 
       <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zUri</name><index>[<expr><name>iIn</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> 
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>octet</name> <init>= <expr><operator>(</operator><call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>zUri</name><index>[<expr><name>iIn</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>octet</name> <operator>+=</operator> <call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>zUri</name><index>[<expr><name>iIn</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>octet</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>octet</name><operator>&lt;</operator><literal type="number">256</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>octet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* This branch is taken when "%00" appears within the URI. In this
          ** case we ignore all text in the remainder of the path, name or
          ** value currently being parsed. So ignore the current character
          ** and skip to the next "?", "=" or "&amp;", as appropriate. */</comment>
          <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'#'</literal> 
              <operator>&amp;&amp;</operator> <operator>(</operator><name>eState</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>c</name><operator>!=</operator><literal type="char">'?'</literal><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator><name>eState</name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>c</name><operator>!=</operator><literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'&amp;'</literal><operator>)</operator><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator><name>eState</name><operator>!=</operator><literal type="number">2</literal> <operator>||</operator> <name>c</name><operator>!=</operator><literal type="char">'&amp;'</literal><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name>octet</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eState</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'&amp;'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'='</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zFile</name><index>[<expr><name>iOut</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* An empty option name. Ignore this option altogether. */</comment>
          <while>while<condition>( <expr><name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>!=</operator><literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>zUri</name><index>[<expr><name>iIn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'&amp;'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'&amp;'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zFile</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>eState</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>eState</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>==</operator><literal type="char">'?'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>eState</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>==</operator><literal type="char">'&amp;'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>eState</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>zFile</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>eState</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zFile</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>zFile</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zFile</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/* Check if there were any options specified that should be interpreted 
    ** here. Options that are interpreted here include "vfs" and those that
    ** correspond to flags that may be passed to the sqlite3_open_v2()
    ** method. */</comment>
    <expr_stmt><expr><name>zOpt</name> <operator>=</operator> <operator>&amp;</operator><name><name>zFile</name><index>[<expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>zOpt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nOpt</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zOpt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal</name> <init>= <expr><operator>&amp;</operator><name><name>zOpt</name><index>[<expr><name>nOpt</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>nOpt</name><operator>==</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"vfs"</literal></expr></argument>, <argument><expr><name>zOpt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zVfs</name> <operator>=</operator> <name>zVal</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <struct>struct <name>OpenMode</name> <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>
        }</block> <decl><modifier>*</modifier><name>aMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</struct>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zModeType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name>nOpt</name><operator>==</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"cache"</literal></expr></argument>, <argument><expr><name>zOpt</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>OpenMode</name></name></type> <name><name>aCacheMode</name><index>[]</index></name> <init>= <expr><block>{
            <expr><block>{ <expr><literal type="string">"shared"</literal></expr>,  <expr><name>SQLITE_OPEN_SHAREDCACHE</name></expr> }</block></expr>,
            <expr><block>{ <expr><literal type="string">"private"</literal></expr>, <expr><name>SQLITE_OPEN_PRIVATECACHE</name></expr> }</block></expr>,
            <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
          }</block></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>SQLITE_OPEN_SHAREDCACHE</name><operator>|</operator><name>SQLITE_OPEN_PRIVATECACHE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>aMode</name> <operator>=</operator> <name>aCacheMode</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>mask</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zModeType</name> <operator>=</operator> <literal type="string">"cache"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>nOpt</name><operator>==</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"mode"</literal></expr></argument>, <argument><expr><name>zOpt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>OpenMode</name></name></type> <name><name>aOpenMode</name><index>[]</index></name> <init>= <expr><block>{
            <expr><block>{ <expr><literal type="string">"ro"</literal></expr>,  <expr><name>SQLITE_OPEN_READONLY</name></expr> }</block></expr>,
            <expr><block>{ <expr><literal type="string">"rw"</literal></expr>,  <expr><name>SQLITE_OPEN_READWRITE</name></expr> }</block></expr>, 
            <expr><block>{ <expr><literal type="string">"rwc"</literal></expr>, <expr><name>SQLITE_OPEN_READWRITE</name> <operator>|</operator> <name>SQLITE_OPEN_CREATE</name></expr> }</block></expr>,
            <expr><block>{ <expr><literal type="string">"memory"</literal></expr>, <expr><name>SQLITE_OPEN_MEMORY</name></expr> }</block></expr>,
            <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
          }</block></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>SQLITE_OPEN_READONLY</name> <operator>|</operator> <name>SQLITE_OPEN_READWRITE</name>
                   <operator>|</operator> <name>SQLITE_OPEN_CREATE</name> <operator>|</operator> <name>SQLITE_OPEN_MEMORY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>aMode</name> <operator>=</operator> <name>aOpenMode</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>mask</name> <operator>&amp;</operator> <name>flags</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zModeType</name> <operator>=</operator> <literal type="string">"access"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>aMode</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aMode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>aMode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>==</operator><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>mode</name> <operator>=</operator> <name><name>aMode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mode</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name>mode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"no such %s mode: %s"</literal></expr></argument>, <argument><expr><name>zModeType</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            <goto>goto <name>parse_uri_out</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <operator>~</operator><name>SQLITE_OPEN_MEMORY</name><operator>)</operator><operator>&gt;</operator><name>limit</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s mode not allowed: %s"</literal></expr></argument>,
                                        <argument><expr><name>zModeType</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_PERM</name></expr>;</expr_stmt>
            <goto>goto <name>parse_uri_out</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>mask</name><operator>)</operator> <operator>|</operator> <name>mode</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>zOpt</name> <operator>=</operator> <operator>&amp;</operator><name><name>zVal</name><index>[<expr><name>nVal</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></while>

  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nUri</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zFile</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>zUri</name></expr></argument>, <argument><expr><name>nUri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zFile</name><index>[<expr><name>nUri</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zFile</name><index>[<expr><name>nUri</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_OPEN_URI</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>ppVfs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"no such vfs: %s"</literal></expr></argument>, <argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
 <label><name>parse_uri_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pFlags</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzFile</name> <operator>=</operator> <name>zFile</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This routine does the work of opening a database on behalf of
** sqlite3_open() and sqlite3_open16(). The database filename "zFilename"  
** is UTF-8 encoded.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>openDatabase</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <comment type="block">/* Database filename UTF-8 encoded */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>,        <comment type="block">/* OUT: Returned database handle */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>,    <comment type="block">/* Operational flags */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVfs</name></decl></parameter>       <comment type="block">/* Name of the VFS to use */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Store allocated handle here */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isThreadsafe</name></decl>;</decl_stmt>               <comment type="block">/* True for threadsafe connections */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOpen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Filename argument to pass to BtreeOpen() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Error message from sqlite3ParseUri() */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>ppDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Only allow sensible combinations of bits in the flags argument.  
  ** Throw an error if any non-sense combination is used.  If we
  ** do not block illegal combinations here, it could trigger
  ** assert() statements in deeper layers.  Sensible combinations
  ** are:
  **
  **  1:  SQLITE_OPEN_READONLY
  **  2:  SQLITE_OPEN_READWRITE
  **  6:  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_OPEN_READONLY</name>  <operator>==</operator> <literal type="number">0x01</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_OPEN_READWRITE</name> <operator>==</operator> <literal type="number">0x02</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_OPEN_CREATE</name>    <operator>==</operator> <literal type="number">0x04</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0x02</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* READONLY */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0x04</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* READWRITE */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0x40</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* READWRITE | CREATE */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x46</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>  <comment type="block">/* IMP: R-65497-44594 */</comment>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>isThreadsafe</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_NOMUTEX</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>isThreadsafe</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_FULLMUTEX</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>isThreadsafe</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>isThreadsafe</name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bFullMutex</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_PRIVATECACHE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_OPEN_SHAREDCACHE</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>sharedCacheEnabled</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SQLITE_OPEN_SHAREDCACHE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Remove harmful bits from the flags parameter
  **
  ** The SQLITE_OPEN_NOMUTEX and SQLITE_OPEN_FULLMUTEX flags were
  ** dealt with in the previous code block.  Besides these, the only
  ** valid input flags for sqlite3_open_v2() are SQLITE_OPEN_READONLY,
  ** SQLITE_OPEN_READWRITE, SQLITE_OPEN_CREATE, SQLITE_OPEN_SHAREDCACHE,
  ** SQLITE_OPEN_PRIVATECACHE, and some reserved bits.  Silently mask
  ** off all other flags.
  */</comment>
  <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator>  <operator>~</operator><operator>(</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name> <operator>|</operator>
               <name>SQLITE_OPEN_EXCLUSIVE</name> <operator>|</operator>
               <name>SQLITE_OPEN_MAIN_DB</name> <operator>|</operator>
               <name>SQLITE_OPEN_TEMP_DB</name> <operator>|</operator> 
               <name>SQLITE_OPEN_TRANSIENT_DB</name> <operator>|</operator> 
               <name>SQLITE_OPEN_MAIN_JOURNAL</name> <operator>|</operator> 
               <name>SQLITE_OPEN_TEMP_JOURNAL</name> <operator>|</operator> 
               <name>SQLITE_OPEN_SUBJOURNAL</name> <operator>|</operator> 
               <name>SQLITE_OPEN_MASTER_JOURNAL</name> <operator>|</operator>
               <name>SQLITE_OPEN_NOMUTEX</name> <operator>|</operator>
               <name>SQLITE_OPEN_FULLMUTEX</name> <operator>|</operator>
               <name>SQLITE_OPEN_WAL</name>
             <operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Allocate the sqlite data structure */</comment>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>db</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>opendb_out</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isThreadsafe</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name> <operator>=</operator> <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_RECURSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <goto>goto <name>opendb_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errMask</name></name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>SQLITE_MAGIC_BUSY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDbStatic</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name></name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aHardLimit</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name></name></expr></argument>, <argument><expr><name>aHardLimit</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_WORKER_THREADS</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_DEFAULT_WORKER_THREADS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nextAutovac</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>szMmap</name></name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szMmap</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nextPagesize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nMaxSorterMmap</name></name> <operator>=</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SQLITE_ShortColNames</name> <operator>|</operator> <name>SQLITE_EnableTrigger</name> <operator>|</operator> <name>SQLITE_CacheSpill</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEFAULT_AUTOMATIC_INDEX</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_DEFAULT_AUTOMATIC_INDEX</name></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_AutoIndex</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEFAULT_CKPTFULLFSYNC</name></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_CkptFullFSync</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEFAULT_FILE_FORMAT</name><operator>&lt;</operator><literal type="number">4</literal></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_LegacyFileFmt</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_LOAD_EXTENSION</name></cpp:ifdef>
                 <operator>|</operator> <name>SQLITE_LoadExtension</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEFAULT_RECURSIVE_TRIGGERS</name></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_RecTriggers</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEFAULT_FOREIGN_KEYS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_DEFAULT_FOREIGN_KEYS</name></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_ForeignKeys</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_REVERSE_UNORDERED_SELECTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_ReverseOrder</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_OVERSIZE_CELL_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_CellSizeCk</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      ;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aCollSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Add the default collation sequence BINARY. BINARY works for both UTF-8
  ** and UTF-16, so add a version for each to avoid any unnecessary
  ** conversions. The only error that can occur here is a malloc() failure.
  **
  ** EVIDENCE-OF: R-52786-44878 SQLite defines three built-in collating
  ** functions:
  */</comment>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><name>SQLITE_UTF16BE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><name>SQLITE_UTF16LE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"NOCASE"</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nocaseCollatingFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"RTRIM"</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>opendb_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* EVIDENCE-OF: R-08308-17224 The default collating function for all
  ** strings is BINARY. 
  */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Parse the filename/URI argument. */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ParseUri</name><argument_list>(<argument><expr><name>zVfs</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zOpen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zErrMsg</name></expr> ?</condition><then> <expr><literal type="string">"%s"</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>opendb_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Open the backend database driver */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeOpen</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>zOpen</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                        <argument><expr><name>flags</name> <operator>|</operator> <name>SQLITE_OPEN_MAIN_DB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_NOMEM</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>opendb_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSchema</name> <operator>=</operator> <call><name>sqlite3SchemaGet</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>SCHEMA_ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name> <operator>=</operator> <call><name>sqlite3SchemaGet</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The default safety_level for the main database is 'full'; for the temp
  ** database it is 'NONE'. This matches the pager layer defaults.  
  */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <literal type="string">"main"</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>safety_level</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <literal type="string">"temp"</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>safety_level</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>SQLITE_MAGIC_OPEN</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>opendb_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register all built-in functions, but do not attempt to read the
  ** database schema yet. This is delayed until the first time the database
  ** is accessed.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3RegisterBuiltinFunctions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load automatic extensions - extensions that have been registered
  ** using the sqlite3_automatic_extension() API.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3AutoLoadExtensions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>opendb_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS1</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlite3Fts1Init</name><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts1Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS2</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlite3Fts2Init</name><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts2Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3</name></cpp:ifdef> <comment type="block">/* automatically defined by SQLITE_ENABLE_FTS4 */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS5</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts5Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ICU</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3IcuInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_RTREE</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3RtreeInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_DBSTAT_VTAB</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3DbstatRegister</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_JSON1</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Json1Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* -DSQLITE_DEFAULT_LOCKING_MODE=1 makes EXCLUSIVE the default locking
  ** mode.  -DSQLITE_DEFAULT_LOCKING_MODE=0 make NORMAL the default locking
  ** mode.  Doing nothing at all also makes NORMAL the default.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEFAULT_LOCKING_MODE</name></cpp:ifdef>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>dfltLockMode</name></name> <operator>=</operator> <name>SQLITE_DEFAULT_LOCKING_MODE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerLockingMode</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>SQLITE_DEFAULT_LOCKING_MODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Enable the lookaside-malloc subsystem */</comment>
  <expr_stmt><expr><call><name>setupLookaside</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szLookaside</name></name></expr></argument>,
                        <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nLookaside</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_wal_autocheckpoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DEFAULT_WAL_AUTOCHECKPOINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>opendb_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>db</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>isThreadsafe</name><operator>==</operator><literal type="number">0</literal>
           <operator>||</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bFullMutex</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>SQLITE_MAGIC_SICK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SQLLOG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Opening a db handle. Fourth parameter is passed 0. */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name> <init>= <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pSqllogArg</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAS_CODEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zHexKey</name> <init>= <expr><call><name>sqlite3_uri_parameter</name><argument_list>(<argument><expr><name>zOpen</name></expr></argument>, <argument><expr><literal type="string">"hexkey"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zHexKey</name> <operator>&amp;&amp;</operator> <name><name>zHexKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name>iByte</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zKey</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>iByte</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zHexKey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>iByte</name> <operator>=</operator> <operator>(</operator><name>iByte</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>zHexKey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zKey</name><index>[<expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>iByte</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_key_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a new database handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_open</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter> 
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>openDatabase</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>,
                      <argument><expr><name>SQLITE_OPEN_READWRITE</name> <operator>|</operator> <name>SQLITE_OPEN_CREATE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_open_v2</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,   <comment type="block">/* Database filename (UTF-8) */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>,         <comment type="block">/* OUT: SQLite db handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,              <comment type="block">/* Flags */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVfs</name></decl></parameter>        <comment type="block">/* Name of VFS module to use */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>openDatabase</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>flags</name></expr></argument>, <argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Open a new database handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_open16</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFilename8</name></decl>;</decl_stmt>   <comment type="block">/* zFilename encoded in UTF-8 instead of UTF-16 */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>ppDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <literal type="string">"\000\000"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFilename8</name> <operator>=</operator> <call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFilename8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>openDatabase</name><argument_list>(<argument><expr><name>zFilename8</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>,
                      <argument><expr><name>SQLITE_OPEN_READWRITE</name> <operator>|</operator> <name>SQLITE_OPEN_CREATE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>ppDb</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>DbHasProperty</name><argument_list>(<argument><expr><operator>*</operator><name>ppDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DB_SchemaLoaded</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>SCHEMA_ENC</name><argument_list>(<argument><expr><operator>*</operator><name>ppDb</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><operator>*</operator><name>ppDb</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<comment type="block">/*
** Register a new collation sequence with the database handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_collation</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>, 
  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xCompare</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_create_collation_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>xCompare</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register a new collation sequence with the database handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_collation_v2</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>, 
  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xCompare</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>xCompare</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Register a new collation sequence with the database handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_collation16</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>, 
  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xCompare</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName8</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zName8</name> <operator>=</operator> <call><name>sqlite3Utf16to8</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName8</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>xCompare</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<comment type="block">/*
** Register a collation sequence factory callback with the database handle
** db. Replace any previously installed collation sequence factory.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_collation_needed</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCollNeededArg</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xCollNeeded</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>eTextRep</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded</name></name> <operator>=</operator> <name>xCollNeeded</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded16</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pCollNeededArg</name></name> <operator>=</operator> <name>pCollNeededArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Register a collation sequence factory callback with the database handle
** db. Replace any previously installed collation sequence factory.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_collation_needed16</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCollNeededArg</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xCollNeeded16</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>eTextRep</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded16</name></name> <operator>=</operator> <name>xCollNeeded16</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pCollNeededArg</name></name> <operator>=</operator> <name>pCollNeededArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** This function is now an anachronism. It used to be used to recover from a
** malloc() failure, but SQLite now does this automatically.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_global_recover</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Test to see whether or not the database connection is in autocommit
** mode.  Return TRUE if it is and FALSE if not.  Autocommit mode is on
** by default.  Autocommit is disabled by a BEGIN statement and reenabled
** by the next COMMIT or ROLLBACK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_get_autocommit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following routines are substitutes for constants SQLITE_CORRUPT,
** SQLITE_MISUSE, SQLITE_CANTOPEN, SQLITE_IOERR and possibly other error
** constants.  They serve two purposes:
**
**   1.  Serve as a convenient place to set a breakpoint in a debugger
**       to detect when version error conditions occurs.
**
**   2.  Invoke sqlite3_log() to provide the source code location where
**       a low-level error is first detected.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3CorruptError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_CORRUPT</name></expr></argument>,
              <argument><expr><literal type="string">"database corruption at line %d of [%.10s]"</literal></expr></argument>,
              <argument><expr><name>lineno</name></expr></argument>, <argument><expr><literal type="number">20</literal><operator>+</operator><call><name>sqlite3_sourceid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_CORRUPT</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3MisuseError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_MISUSE</name></expr></argument>, 
              <argument><expr><literal type="string">"misuse at line %d of [%.10s]"</literal></expr></argument>,
              <argument><expr><name>lineno</name></expr></argument>, <argument><expr><literal type="number">20</literal><operator>+</operator><call><name>sqlite3_sourceid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3CantopenError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN</name></expr></argument>, 
              <argument><expr><literal type="string">"cannot open file at line %d of [%.10s]"</literal></expr></argument>,
              <argument><expr><name>lineno</name></expr></argument>, <argument><expr><literal type="number">20</literal><operator>+</operator><call><name>sqlite3_sourceid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** This is a convenience routine that makes sure that all thread-specific
** data for this thread has been deallocated.
**
** SQLite no longer uses thread-specific data so this routine is now a
** no-op.  It is retained for historical compatibility.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_thread_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return meta information about a specific column of a database table.
** See comment in sqlite3.h (sqlite.h.in) for details.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_table_column_metadata</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                <comment type="block">/* Connection handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>,        <comment type="block">/* Database name or NULL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTableName</name></decl></parameter>,     <comment type="block">/* Table name */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColumnName</name></decl></parameter>,    <comment type="block">/* Column name */</comment>
  <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pzDataType</name></decl></parameter>,    <comment type="block">/* OUTPUT: Declared data type */</comment>
  <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pzCollSeq</name></decl></parameter>,     <comment type="block">/* OUTPUT: Collation sequence name */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pNotNull</name></decl></parameter>,              <comment type="block">/* OUTPUT: True if NOT NULL constraint exists */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pPrimaryKey</name></decl></parameter>,           <comment type="block">/* OUTPUT: True if column part of PK */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pAutoinc</name></decl></parameter>               <comment type="block">/* OUTPUT: True if column is auto-increment */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zDataType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zCollSeq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>notnull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>primarykey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>autoinc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zTableName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Ensure the database schema has been loaded */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><name>rc</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>error_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Locate the table in question */</comment>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name> <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <goto>goto <name>error_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Find the column for which info is requested */</comment>
  <if_stmt><if>if<condition>( <expr><name>zColumnName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Query for existance of table only */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zColumnName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name>zColumnName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCol</name> <operator>=</operator> <ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>error_out</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* The following block stores the meta information that will be returned
  ** to the caller in local variables zDataType, zCollSeq, notnull, primarykey
  ** and autoinc. At this point there are two possibilities:
  ** 
  **     1. The specified column name was rowid", "oid" or "_rowid_" 
  **        and there is no explicitly declared IPK column. 
  **
  **     2. The table is not a view and the column name identified an 
  **        explicitly declared column. Copy meta information from *pCol.
  */</comment> 
  <if_stmt><if>if<condition>( <expr><name>pCol</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zDataType</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>zType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCollSeq</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>zColl</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>notnull</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>notNull</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>primarykey</name>  <operator>=</operator> <operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>autoinc</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>==</operator><name>iCol</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Autoincrement</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zDataType</name> <operator>=</operator> <literal type="string">"INTEGER"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>primarykey</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zCollSeq</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zCollSeq</name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>error_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Whether the function call succeeded or failed, set the output parameters
  ** to whatever their local counterparts contain. If an error did occur,
  ** this has the effect of zeroing all output parameters.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pzDataType</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzDataType</name> <operator>=</operator> <name>zDataType</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pzCollSeq</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzCollSeq</name> <operator>=</operator> <name>zCollSeq</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNotNull</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pNotNull</name> <operator>=</operator> <name>notnull</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPrimaryKey</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pPrimaryKey</name> <operator>=</operator> <name>primarykey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pAutoinc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pAutoinc</name> <operator>=</operator> <name>autoinc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zErrMsg</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"no such table column: %s.%s"</literal></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>,
        <argument><expr><name>zColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>zErrMsg</name></expr>?</condition><then><expr><literal type="string">"%s"</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sleep for a little while.  Return the amount of time slept.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_sleep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ms</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pVfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVfs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* This function works in milliseconds, but the underlying OsSleep() 
  ** API uses microseconds. Hence the 1000's.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><call><name>sqlite3OsSleep</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><literal type="number">1000</literal><operator>*</operator><name>ms</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Enable or disable the extended result codes.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_extended_result_codes</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>onoff</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errMask</name></name> <operator>=</operator> <ternary><condition><expr><name>onoff</name></expr> ?</condition><then> <expr><literal type="number">0xffffffff</literal></expr> </then><else>: <expr><literal type="number">0xff</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the xFileControl method on a particular database.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_file_control</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBtree</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBtree</name> <operator>=</operator> <call><name>sqlite3DbNameToBtree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBtree</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name> <operator>=</operator> <call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>sqlite3PagerFile</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>fd</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_FILE_POINTER</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_VFS_POINTER</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sqlite3_vfs</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3PagerVfs</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_JOURNAL_POINTER</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3PagerJrnlFile</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>fd</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOTFOUND</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Interface to the testing logic.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_test_control</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_BUILTIN_TEST</name></cpp:ifdef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>

    <comment type="block">/*
    ** Save the current state of the PRNG.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_PRNG_SAVE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PrngSaveState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    ** Restore the state of the PRNG to the last state saved using
    ** PRNG_SAVE.  If PRNG_SAVE has never before been called, then
    ** this verb acts like PRNG_RESET.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_PRNG_RESTORE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PrngRestoreState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    ** Reset the PRNG back to its uninitialized state.  The next call
    ** to sqlite3_randomness() will reseed the PRNG using a single call
    ** to the xRandomness method of the default VFS.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_PRNG_RESET</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **  sqlite3_test_control(BITVEC_TEST, size, program)
    **
    ** Run a test against a Bitvec object of size.  The program argument
    ** is an array of integers that defines the test.  Return -1 on a
    ** memory allocation error, 0 on success, or non-zero for an error.
    ** See the sqlite3BitvecBuiltinTest() for additional information.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_BITVEC_TEST</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aProg</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BitvecBuiltinTest</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><name>aProg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **  sqlite3_test_control(FAULT_INSTALL, xCallback)
    **
    ** Arrange to invoke xCallback() whenever sqlite3FaultSim() is called,
    ** if xCallback is not NULL.
    **
    ** As a test of the fault simulator mechanism itself, sqlite3FaultSim(0)
    ** is called immediately after installing the new callback and the return
    ** value from sqlite3FaultSim(0) becomes the return from
    ** sqlite3_test_control().
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_FAULT_INSTALL</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* MSVC is picky about pulling func ptrs from va lists.
      ** http://support.microsoft.com/kb/47961
      ** sqlite3GlobalConfig.xTestCallback = va_arg(ap, int(*)(int));
      */</comment>
      <typedef>typedef <function_decl><type><name>int</name></type>(<modifier>*</modifier><name>TESTCALLBACKFUNC_t</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xTestCallback</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>TESTCALLBACKFUNC_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **  sqlite3_test_control(BENIGN_MALLOC_HOOKS, xBegin, xEnd)
    **
    ** Register hooks to call to indicate which malloc() failures 
    ** are benign.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS</name></expr>:</case> <block>{<block_content>
      <typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>void_function</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
      <decl_stmt><decl><type><name>void_function</name></type> <name>xBenignBegin</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void_function</name></type> <name>xBenignEnd</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>xBenignBegin</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>xBenignEnd</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BenignMallocHooks</name><argument_list>(<argument><expr><name>xBenignBegin</name></expr></argument>, <argument><expr><name>xBenignEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **  sqlite3_test_control(SQLITE_TESTCTRL_PENDING_BYTE, unsigned int X)
    **
    ** Set the PENDING byte to the value in the argument, if X&gt;0.
    ** Make no changes if X==0.  Return the value of the pending byte
    ** as it existing before this routine was called.
    **
    ** IMPORTANT:  Changing the PENDING byte from 0x40000000 results in
    ** an incompatible database file format.  Changing the PENDING byte
    ** while any database connection is open results in undefined and
    ** deleterious behavior.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_PENDING_BYTE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PENDING_BYTE</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WSD</name></cpp:ifndef>
      <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>newVal</name> <init>= <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned int</argument>)</argument_list></macro></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>newVal</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sqlite3PendingByte</name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **  sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, int X)
    **
    ** This action provides a run-time test to see whether or not
    ** assert() was enabled at compile-time.  If X is true and assert()
    ** is enabled, then the return value is true.  If X is true and
    ** assert() is disabled, then the return value is zero.  If X is
    ** false and assert() is enabled, then the assertion fires and the
    ** process aborts.  If X is false and assert() is disabled, then the
    ** return value is zero.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_ASSERT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <comment type="block">/*side-effects-ok*/</comment> <argument><expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>


    <comment type="block">/*
    **  sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, int X)
    **
    ** This action provides a run-time test to see how the ALWAYS and
    ** NEVER macros were defined at compile-time.
    **
    ** The return value is ALWAYS(X).  
    **
    ** The recommended test is X==2.  If the return value is 2, that means
    ** ALWAYS() and NEVER() are both no-op pass-through macros, which is the
    ** default setting.  If the return value is 1, then ALWAYS() is either
    ** hard-coded to true or else it asserts if its argument is false.
    ** The first behavior (hard-coded to true) is the case if
    ** SQLITE_TESTCTRL_ASSERT shows that assert() is disabled and the second
    ** behavior (assert if the argument to ALWAYS() is false) is the case if
    ** SQLITE_TESTCTRL_ASSERT shows that assert() is enabled.
    **
    ** The run-time test procedure might look something like this:
    **
    **    if( sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, 2)==2 ){
    **      // ALWAYS() and NEVER() are no-op pass-through macros
    **    }else if( sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, 1) ){
    **      // ALWAYS(x) asserts that x is true. NEVER(x) asserts x is false.
    **    }else{
    **      // ALWAYS(x) is a constant 1.  NEVER(x) is a constant 0.
    **    }
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_ALWAYS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **   sqlite3_test_control(SQLITE_TESTCTRL_BYTEORDER);
    **
    ** The integer returned reveals the byte-order of the computer on which
    ** SQLite is running:
    **
    **       1     big-endian,    determined at run-time
    **      10     little-endian, determined at run-time
    **  432101     big-endian,    determined at compile-time
    **  123410     little-endian, determined at compile-time
    */</comment> 
    <case>case <expr><name>SQLITE_TESTCTRL_BYTEORDER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BYTEORDER</name><operator>*</operator><literal type="number">100</literal> <operator>+</operator> <name>SQLITE_LITTLEENDIAN</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>SQLITE_BIGENDIAN</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_RESERVE, sqlite3 *db, int N)
    **
    ** Set the nReserve size to N for the main database on the database
    ** connection db.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_RESERVE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeSetPageSize</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*  sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS, sqlite3 *db, int N)
    **
    ** Enable or disable various optimizations for testing purposes.  The 
    ** argument N is a bitmask of optimizations to be disabled.  For normal
    ** operation N should be 0.  The idea is that a test program (like the
    ** SQL Logic Test or SLT test module) can run the same SQL multiple times
    ** with various optimizations disabled to verify that the same answer
    ** is obtained in every case.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_OPTIMIZATIONS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>dbOptFlags</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_N_KEYWORD</name></cpp:ifdef>
    <comment type="block">/* sqlite3_test_control(SQLITE_TESTCTRL_ISKEYWORD, const char *zWord)
    **
    ** If zWord is a keyword recognized by the parser, then return the
    ** number of keywords.  Or if zWord is not a keyword, return 0.
    ** 
    ** This test feature is only available in the amalgamation since
    ** the SQLITE_N_KEYWORD macro is not defined in this file if SQLite
    ** is built using separate source files.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_ISKEYWORD</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWord</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zWord</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>sqlite3KeywordCode</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>zWord</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>!=</operator><name>TK_ID</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_N_KEYWORD</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

    <comment type="block">/* sqlite3_test_control(SQLITE_TESTCTRL_SCRATCHMALLOC, sz, &amp;pNew, pFree);
    **
    ** Pass pFree into sqlite3ScratchFree(). 
    ** If sz&gt;0 then allocate a scratch buffer into pNew.  
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_SCRATCHMALLOC</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pFree</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>ppNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ppNew</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pFree</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>sz</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ppNew</name> <operator>=</operator> <call><name>sqlite3ScratchMalloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ScratchFree</name><argument_list>(<argument><expr><name>pFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_LOCALTIME_FAULT, int onoff);
    **
    ** If parameter onoff is non-zero, configure the wrappers so that all
    ** subsequent calls to localtime() and variants fail. If onoff is zero,
    ** undo this setting.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_LOCALTIME_FAULT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bLocaltimeFault</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_NEVER_CORRUPT, int);
    **
    ** Set or clear a flag that indicates that the database file is always well-
    ** formed and never corrupt.  This flag is clear by default, indicating that
    ** database files might have arbitrary corruption.  Setting the flag during
    ** testing causes certain assert() statements in the code to be activated
    ** that demonstrat invariants on well-formed database files.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_NEVER_CORRUPT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>neverCorrupt</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>


    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_VDBE_COVERAGE, xCallback, ptr);
    **
    ** Set the VDBE coverage callback function to xCallback with context 
    ** pointer ptr.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_VDBE_COVERAGE</name></expr>:</case> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_VDBE_COVERAGE</name></cpp:ifdef>
      <typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>branch_callback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>u8</name></type></decl></parameter>,<parameter><decl><type><name>u8</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xVdbeBranch</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>branch_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pVdbeBranchArg</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_SORTER_MMAP, db, nMax); */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_SORTER_MMAP</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nMaxSorterMmap</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_ISINIT);
    **
    ** Return SQLITE_OK if SQLite has been initialized and SQLITE_ERROR if
    ** not.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_ISINIT</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, db, dbName, onOff, tnum);
    **
    ** This test control is used to create imposter tables.  "db" is a pointer
    ** to the database connection.  dbName is the database name (ex: "main" or
    ** "temp") which will receive the imposter.  "onOff" turns imposter mode on
    ** or off.  "tnum" is the root page of the b-tree to which the imposter
    ** table should connect.
    **
    ** Enable imposter mode only when the schema has already been parsed.  Then
    ** run a single CREATE TABLE statement to construct the imposter table in
    ** the parsed schema.  Then turn imposter mode back off again.
    **
    ** If onOff==0 and tnum&gt;0 then reset the schema for all databases, causing
    ** the schema to be reparsed the next time it is needed.  This has the
    ** effect of erasing all imposter tables.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_IMPOSTER</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>iDb</name></name> <operator>=</operator> <call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>imposterTable</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>newTnum</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>newTnum</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ResetAllSchemasOfConnection</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_BUILTIN_TEST */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is a utility routine, useful to VFS implementations, that checks
** to see if a database file was a URI that contained a specific query 
** parameter, and if so obtains the value of the query parameter.
**
** The zFilename argument is the filename pointer passed into the xOpen()
** method of a VFS implementation.  The zParam argument is the name of the
** query parameter we seek.  This routine returns the value of the zParam
** parameter if it exists.  If the parameter does not exist, this routine
** returns a NULL pointer.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_uri_parameter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zParam</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zFilename</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a boolean value for a query parameter.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_uri_boolean</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bDflt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_uri_parameter</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>bDflt</name> <operator>=</operator> <name>bDflt</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>z</name></expr> ?</condition><then> <expr><call><name>sqlite3GetBoolean</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>bDflt</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>bDflt</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a 64-bit integer value for a query parameter.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3_uri_int64</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,    <comment type="block">/* Filename as passed to xOpen */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>,       <comment type="block">/* URI parameter sought */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>bDflt</name></decl></parameter>       <comment type="block">/* return if parameter is missing */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_uri_parameter</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>v</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name> <operator>&amp;&amp;</operator> <call><name>sqlite3DecOrHexToI64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bDflt</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>bDflt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the Btree pointer identified by zDbName.  Return NULL if not found.
*/</comment>
<function><type><name>Btree</name> <modifier>*</modifier></type><name>sqlite3DbNameToBtree</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name>zDbName</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zDbName</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the filename of the database associated with a database
** connection.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_db_filename</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <call><name>sqlite3DbNameToBtree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>pBt</name></expr> ?</condition><then> <expr><call><name>sqlite3BtreeGetFilename</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return 1 if database is read-only or 0 if read/write.  Return -1 if
** no such database exists.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_db_readonly</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <call><name>sqlite3DbNameToBtree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>pBt</name></expr> ?</condition><then> <expr><call><name>sqlite3BtreeIsReadonly</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
<comment type="block">/*
** Obtain a snapshot handle for the snapshot of database zDb currently 
** being read by handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_snapshot_get</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppSnapshot</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iDb</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSnapshotGet</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ppSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SQLITE_OMIT_WAL */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a read-transaction on the snapshot idendified by pSnapshot.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_snapshot_open</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iDb</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3BtreeIsInReadTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSnapshotOpen</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3PagerSnapshotOpen</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SQLITE_OMIT_WAL */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free a snapshot handle obtained from sqlite3_snapshot_get().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_snapshot_free</name><parameter_list>(<parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_SNAPSHOT */</comment>
</unit>
