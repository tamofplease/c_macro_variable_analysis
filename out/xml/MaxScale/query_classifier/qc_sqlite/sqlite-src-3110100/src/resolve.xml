<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/resolve.c"><comment type="block">/*
** 2008 August 18
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains routines used for walking the parser tree and
** resolve all identifiers by associating them with a particular
** table and column.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Walk the expression tree pExpr and increase the aggregate function
** depth (the Expr.op2 field) by N on every TK_AGG_FUNCTION node.
** This needs to occur when copying a TK_AGG_FUNCTION node from an
** outer query into an inner subquery.
**
** incrAggFunctionDepth(pExpr,n) is the main routine.  incrAggDepth(..)
** is a helper function - a callback for the tree walker.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>incrAggDepth</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name> <operator>+=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>incrAggFunctionDepth</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>incrAggDepth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Turn the pExpr expression into an alias for the iCol-th column of the
** result set in pEList.
**
** If the reference is followed by a COLLATE operator, then make sure
** the COLLATE operator is preserved.  For example:
**
**     SELECT a+b, c+d FROM t1 ORDER BY 1 COLLATE nocase;
**
** Should be transformed into:
**
**     SELECT a+b, c+d FROM t1 ORDER BY (a+b) COLLATE nocase;
**
** The nSubquery parameter specifies how many levels of subquery the
** alias is removed from the original expression.  The usual value is
** zero but it might be more if the alias is contained within a subquery
** of the original expression.  The Expr.op2 field of TK_AGG_FUNCTION
** structures must be increased by the nSubquery amount.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resolveAlias</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,      <comment type="block">/* A result set */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,              <comment type="block">/* A column in the result set.  0..pEList-&gt;nExpr-1 */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,           <comment type="block">/* Transform this into an alias to the result set */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>,     <comment type="block">/* "GROUP" or "ORDER" or "" */</comment>
  <parameter><decl><type><name>int</name></type> <name>nSubquery</name></decl></parameter>          <comment type="block">/* Number of subqueries that the label is moving */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOrig</name></decl>;</decl_stmt>           <comment type="block">/* The iCol-th column of the result set */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDup</name></decl>;</decl_stmt>            <comment type="block">/* Copy of pOrig */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>           <comment type="block">/* The database connection */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOrig</name> <operator>=</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrig</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDup</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDup</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zType</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'G'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>incrAggFunctionDepth</name><argument_list>(<argument><expr><name>pDup</name></expr></argument>, <argument><expr><name>nSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pDup</name> <operator>=</operator> <call><name>sqlite3ExprAddCollateString</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pDup</name></expr></argument>, <argument><expr><name>EP_Alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Before calling sqlite3ExprDelete(), set the EP_Static flag. This 
  ** prevents ExprDelete() from deleting the Expr structure itself,
  ** allowing it to be repopulated by the memcpy() on the following line.
  ** The pExpr-&gt;u.zToken might point into memory that will be freed by the
  ** sqlite3DbFree(db, pDup) on the last line of this block, so be sure to
  ** make a copy of the token before doing the sqlite3DbFree().
  */</comment>
  <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Static</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pExpr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_MemToken</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Return TRUE if the name zCol occurs anywhere in the USING clause.
**
** Return FALSE if the USING clause is NULL or if it does not contain
** zCol.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nameInUsingClause</name><parameter_list>(<parameter><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pUsing</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pUsing</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>pUsing</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pUsing</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Subqueries stores the original database, table and column names for their
** result sets in ExprList.a[].zSpan, in the form "DATABASE.TABLE.COLUMN".
** Check to see if the zSpan given to this routine matches the zDb, zTab,
** and zCol.  If any of zDb, zTab, and zCol are NULL then those fields will
** match anything.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3MatchSpanName</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSpan</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>zSpan</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zSpan</name><index>[<expr><name>n</name></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>zDb</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSpan</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zDb</name><index>[<expr><name>n</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zSpan</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>zSpan</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zSpan</name><index>[<expr><name>n</name></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>zTab</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSpan</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zTab</name><index>[<expr><name>n</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zSpan</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zCol</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zSpan</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given the name of a column of the form X.Y.Z or Y.Z or just Z, look up
** that name in the set of source tables in pSrcList and make the pExpr 
** expression node refer back to that source column.  The following changes
** are made to pExpr:
**
**    pExpr-&gt;iDb           Set the index in db-&gt;aDb[] of the database X
**                         (even if X is implied).
**    pExpr-&gt;iTable        Set to the cursor number for the table obtained
**                         from pSrcList.
**    pExpr-&gt;pTab          Points to the Table structure of X.Y (even if
**                         X and/or Y are implied.)
**    pExpr-&gt;iColumn       Set to the column number within the table.
**    pExpr-&gt;op            Set to TK_COLUMN.
**    pExpr-&gt;pLeft         Any expression this points to is deleted
**    pExpr-&gt;pRight        Any expression this points to is deleted.
**
** The zDb variable is the name of the database (the "X").  This value may be
** NULL meaning that name is of the form Y.Z or Z.  Any available database
** can be used.  The zTable variable is the name of the table (the "Y").  This
** value can be NULL if zDb is also NULL.  If zTable is NULL it
** means that the form of the name is Z and that columns from any table
** can be used.
**
** If the name cannot be resolved unambiguously, leave an error message
** in pParse and return WRC_Abort.  Return WRC_Prune on success.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lookupName</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,     <comment type="block">/* Name of the database containing table, or NULL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,    <comment type="block">/* Name of table containing column, or NULL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name></decl></parameter>,    <comment type="block">/* Name of the column. */</comment>
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>,    <comment type="block">/* The name context used to resolve the name */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>          <comment type="block">/* Make this EXPR node point to the selected column */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                         <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                      <comment type="block">/* Number of matching column names */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cntTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Number of matching table names */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSubquery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* How many levels of subquery */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>       <comment type="block">/* Use for looping over pSrcList items */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* The matching pSrcList item */</comment>
  <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pTopNC</name> <init>= <expr><name>pNC</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* First namecontext in the list */</comment>
  <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Schema of the expression */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isTrigger</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* True if resolved to a trigger column */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Table hold the row */</comment>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>                     <comment type="block">/* A column of pTab */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* the name context cannot be NULL. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* The Z in X.Y.Z cannot be NULL */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the node to no-match */</comment>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Translate the schema name in zDb into a pointer to the corresponding
  ** schema.  If not found, pSchema will remain NULL and nothing will match
  ** resulting in an appropriate error message toward the end of this routine
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>zDb</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_PartIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IsCheck</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_PartIdx</name><operator>|</operator><name>NC_IsCheck</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Silently ignore database qualifiers inside CHECK constraints and
      ** partial indices.  Do not raise errors because that might break
      ** legacy and because it does not hurt anything to just ignore the
      ** database name. */</comment>
      <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>,<argument><expr><name>zDb</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pSchema</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Start at the inner-most context and move outward until a match is found */</comment>
  <while>while<condition>( <expr><name>pNC</name> <operator>&amp;&amp;</operator> <name>cnt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrcList</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>pSrcList</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pSrcList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrcList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_NestedFrom</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><call><name>sqlite3MatchSpanName</name><argument_list>(<argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zSpan</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
              <expr_stmt><expr><name>cntTab</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <name>pItem</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>hit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name>hit</name> <operator>||</operator> <name>zTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>zDb</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name><operator>!=</operator><name>pSchema</name></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>zTab</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTabName</name> <init>= <expr><ternary><condition><expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> ?</condition><then> <expr><name><name>pItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr> </then><else>: <expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zTabName</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zTabName</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>cntTab</name><operator>++</operator><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <name>pItem</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pCol</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <comment type="block">/* If there has been exactly one prior match and this match
            ** is for the right-hand table of a NATURAL JOIN or is in a 
            ** USING clause, then skip this match.
            */</comment>
            <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_NATURAL</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><call><name>nameInUsingClause</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pUsing</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <name>pItem</name></expr>;</expr_stmt>
            <comment type="block">/* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY */</comment>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <ternary><condition><expr><name>j</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>i16</name><operator>)</operator><name>j</name></expr></else></ternary></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pMatch</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pMatch</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>pMatch</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
        <comment type="block">/* RIGHT JOIN not (yet) supported */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMatch</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_RIGHT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pMatch</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LEFT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_CanBeNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pSchema</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt> <comment type="block">/* if( pSrcList ) */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
    <comment type="block">/* If we have not already resolved the name, then maybe 
    ** it is a new.* or old.* trigger argument reference
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>zDb</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zTab</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cntTab</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>eTriggerOp</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_DELETE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_UPDATE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_INSERT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>!=</operator><name>TK_DELETE</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>!=</operator><name>TK_INSERT</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content> 
        <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pSchema</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cntTab</name><operator>++</operator></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pCol</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>iCol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>VisibleRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <comment type="block">/* IMP: R-51414-32910 */</comment>
          <expr_stmt><expr><name>iCol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name> <operator>=</operator> <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>oldmask</name></name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">32</literal></expr> ?</condition><then> <expr><literal type="number">0xffffffff</literal></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>iCol</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>newmask</name></name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">32</literal></expr> ?</condition><then> <expr><literal type="number">0xffffffff</literal></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>iCol</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name>iCol</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>isTrigger</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_TRIGGER) */</comment>

    <comment type="block">/*
    ** Perhaps the name is a reference to the ROWID
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name>cntTab</name><operator>==</operator><literal type="number">1</literal>
     <operator>&amp;&amp;</operator> <name>pMatch</name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IdxExpr</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>VisibleRowid</name><argument_list>(<argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name> <operator>=</operator> <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
    ** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z
    ** might refer to an result-set alias.  This happens, for example, when
    ** we are resolving names in the WHERE clause of the following command:
    **
    **     SELECT a+b AS x FROM table WHERE x&lt;10;
    **
    ** In cases like this, replace pExpr with a copy of the expression that
    ** forms the result set entry ("a+b" in the example) and return immediately.
    ** Note that the expression in the result set should have already been
    ** resolved by the time the WHERE clause is resolved.
    **
    ** The ability to use an output result-set column in the WHERE, GROUP BY,
    ** or HAVING clauses, or as part of a larger expression in the ORDER BY
    ** clause is not standard SQL.  This is a (goofy) SQLite extension, that
    ** is supported for backwards compatibility only. Hence, we issue a warning
    ** on sqlite3_log() whenever the capability is used.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pEList</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pEList</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name>zTab</name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name>cnt</name><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAs</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zAs</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zAs</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOrig</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOrig</name> <operator>=</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name><operator>&amp;</operator><name>NC_AllowAgg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pOrig</name></expr></argument>, <argument><expr><name>EP_Agg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"misuse of aliased aggregate %s"</literal></expr></argument>, <argument><expr><name>zAs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>WRC_Abort</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>resolveAlias</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>nSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zTab</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zDb</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>lookupname_end</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for> 
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Advance to the next name context.  The loop will exit when either
    ** we have a match (cnt&gt;0) or when we run out of name contexts.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pNC</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nSubquery</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/*
  ** If X and Y are NULL (in other words if only the column name Z is
  ** supplied) and the value of Z is enclosed in double-quotes, then
  ** Z is a string literal if it doesn't match any column names.  In that
  ** case, we need to return right away and not make any changes to
  ** pExpr.
  **
  ** Because no reference was made to outer contexts, the pNC-&gt;nRef
  ** fields are not changed in any context.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zTab</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_DblQuoted</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** cnt==0 means there was not match.  cnt&gt;1 means there were two or
  ** more matches.  Either way, we have an error.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <ternary><condition><expr><name>cnt</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"no such column"</literal></expr> </then><else>: <expr><literal type="string">"ambiguous column name"</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zDb</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s: %s.%s.%s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s: %s.%s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>checkSchema</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTopNC</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If a column from a table in pSrcList is referenced, then record
  ** this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes
  ** bit 0 to be set.  Column 1 sets bit 1.  And so forth.  If the
  ** column number is greater than the number of bits in the bitmask
  ** then set the high-order bit of the bitmask.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pMatch</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><name>BMS</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <name>BMS</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iCursor</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>n</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clean up and return
  */</comment>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>isTrigger</name></expr> ?</condition><then> <expr><name>TK_TRIGGER</name></expr> </then><else>: <expr><name>TK_COLUMN</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<label><name>lookupname_end</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Alias</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3AuthRead</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pSchema</name></expr></argument>, <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Increment the nRef value on all name contexts from TopNC up to
    ** the point where the name matched. */</comment>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTopNC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTopNC</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pTopNC</name><operator>==</operator><name>pNC</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pTopNC</name> <operator>=</operator> <name><name>pTopNC</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return a pointer to an expression to load the column iCol
** from datasource iSrc in SrcList pSrc.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3CreateColumnExpr</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSrc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_COLUMN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iSrc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>==</operator><name>iCol</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><name>iCol</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><operator>(</operator><ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><name>BMS</name></expr> ?</condition><then> <expr><name>BMS</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>iCol</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Resolved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Report an error that an expression is not valid for some set of
** pNC-&gt;ncFlags values determined by validMask.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>notValid</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Leave error message here */</comment>
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>,    <comment type="block">/* The name context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl></parameter>,    <comment type="block">/* Type of error */</comment>
  <parameter><decl><type><name>int</name></type> <name>validMask</name></decl></parameter>        <comment type="block">/* Set of contexts for which prohibited */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>validMask</name><operator>&amp;</operator><operator>~</operator><operator>(</operator><name>NC_IsCheck</name><operator>|</operator><name>NC_PartIdx</name><operator>|</operator><name>NC_IdxExpr</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>validMask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><literal type="string">"partial index WHERE clauses"</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IdxExpr</name></expr> )</condition><block type="pseudo"><block_content>      <expr_stmt><expr><name>zIn</name> <operator>=</operator> <literal type="string">"index expressions"</literal></expr>;</expr_stmt></block_content></block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
    <if type="elseif">else if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_IsCheck</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zIn</name> <operator>=</operator> <literal type="string">"CHECK constraints"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s prohibited in %s"</literal></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Expression p should encode a floating point value between 1.0 and 0.0.
** Return 1024 times this value.  Or return -1 if p is not a floating point
** value between 1.0 and 0.0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprProbability</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><operator>-</operator><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_FLOAT</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>r</name><operator>&gt;=</operator><literal type="number">0.0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>r</name><operator>&gt;</operator><literal type="number">1.0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>r</name><operator>*</operator><literal type="number">134217728.0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine is callback for sqlite3WalkExpr().
**
** Resolve symbolic names into TK_COLUMN operators for the current
** node in the expression tree.  Return 0 to continue the search down
** the tree or 2 to abort the tree walk.
**
** This routine also does error checking and name resolution for
** function names.  The operator for aggregate functions is changed
** to TK_AGG_FUNCTION.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveExprStep</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pNC</name> <operator>=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>==</operator><name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Resolved</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Prune</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Resolved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name> <operator>&amp;&amp;</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrcList</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrcList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSrcList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* The special operator TK_ROW means use the rowid for the first
    ** column in the FROM clause.  This is used by the LIMIT and ORDER BY
    ** clause processing on UPDATE and DELETE statements.
    */</comment>
    <case>case <expr><name>TK_ROW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrcList</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrcList</name> <operator>&amp;&amp;</operator> <name><name>pSrcList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pItem</name> <operator>=</operator> <name><name>pSrcList</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt> 
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_COLUMN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name> <operator>=</operator> <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)
          &amp;&amp; !defined(SQLITE_OMIT_SUBQUERY) */</comment>

    <comment type="block">/* A lone identifier is the name of a column.
    */</comment>
    <case>case <expr><name>TK_ID</name></expr>:</case> <block>{<block_content>
      <return>return <expr><call><name>lookupName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
  
    <comment type="block">/* A table name and column name:     ID.ID
    ** Or a database, table and column:  ID.ID.ID
    */</comment>
    <case>case <expr><name>TK_DOT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColumn</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTable</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>

      <comment type="block">/* if( pSrcList==0 ) break; */</comment>
      <expr_stmt><expr><call><name>notValid</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><literal type="string">"the \".\" operator"</literal></expr></argument>, <argument><expr><name>NC_IdxExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/*notValid(pParse, pNC, "the \".\" operator", NC_PartIdx|NC_IsCheck, 1);*/</comment>
      <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>zTable</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zColumn</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_DOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zTable</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zColumn</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><call><name>lookupName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zColumn</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>

    <comment type="block">/* Resolve function names
    */</comment>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* The argument list */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><ternary><condition><expr><name>pList</name></expr> ?</condition><then> <expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>    <comment type="block">/* Number of arguments */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>no_such_func</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* True if no such function exists */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>wrong_num_args</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* True if wrong number of arguments */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>is_agg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* True if is an aggregate function */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>auth</name></decl>;</decl_stmt>                   <comment type="block">/* Authorization to use the function */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nId</name></decl>;</decl_stmt>                    <comment type="block">/* Number of characters in function name */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zId</name></decl>;</decl_stmt>            <comment type="block">/* The function name. */</comment>
      <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl>;</decl_stmt>              <comment type="block">/* Information about the function */</comment>
      <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><call><name>ENC</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* The database encoding */</comment>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>notValid</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><literal type="string">"functions"</literal></expr></argument>, <argument><expr><name>NC_PartIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zId</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nId</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name>nId</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pDef</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name>nId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pDef</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>no_such_func</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>wrong_num_args</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>is_agg</name> <operator>=</operator> <name><name>pDef</name><operator>-&gt;</operator><name>xFinalize</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_UNLIKELY</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Unlikely</name><operator>|</operator><name>EP_Skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <call><name>exprProbability</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                <argument><expr><literal type="string">"second argument to likelihood() must be a "</literal>
                <literal type="string">"constant between 0.0 and 1.0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <comment type="block">/* EVIDENCE-OF: R-61304-29449 The unlikely(X) function is
            ** equivalent to likelihood(X, 0.0625).
            ** EVIDENCE-OF: R-01283-11636 The unlikely(X) function is
            ** short-hand for likelihood(X,0.0625).
            ** EVIDENCE-OF: R-36850-34127 The likely(X) function is short-hand
            ** for likelihood(X,0.9375).
            ** EVIDENCE-OF: R-53436-40973 The likely(X) function is equivalent
            ** to likelihood(X,0.9375). */</comment>
            <comment type="block">/* TUNING: unlikely() probability is 0.0625.  likely() is 0.9375 */</comment>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'u'</literal></expr> ?</condition><then> <expr><literal type="number">8388608</literal></expr> </then><else>: <expr><literal type="number">125829120</literal></expr></else></ternary></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>             
        </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
        <expr_stmt><expr><name>auth</name> <operator>=</operator> <call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_FUNCTION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>auth</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>auth</name><operator>==</operator><name>SQLITE_DENY</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"not authorized to use function: %s"</literal></expr></argument>,
                                    <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_NULL</name></expr>;</expr_stmt>
          <return>return <expr><name>WRC_Prune</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_FUNC_CONSTANT</name><operator>|</operator><name>SQLITE_FUNC_SLOCHNG</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <comment type="block">/* For the purposes of the EP_ConstFunc flag, date and time
          ** functions and other functions that change slowly are considered
          ** constant because they are constant for the duration of one query */</comment>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_ConstFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_CONSTANT</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Date/time functions that use 'now', and other functions like
          ** sqlite_version() that might change over time cannot be used
          ** in an index. */</comment>
          <expr_stmt><expr><call><name>notValid</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><literal type="string">"non-deterministic functions"</literal></expr></argument>, <argument><expr><name>NC_IdxExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>is_agg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_AllowAgg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"misuse of aggregate function %.*s()"</literal></expr></argument>, <argument><expr><name>nId</name></expr></argument>,<argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>is_agg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>no_such_func</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such function: %.*s"</literal></expr></argument>, <argument><expr><name>nId</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>wrong_num_args</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><literal type="string">"wrong number of arguments to function %.*s()"</literal></expr></argument>,
             <argument><expr><name>nId</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>is_agg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>NC_AllowAgg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>is_agg</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC2</name> <init>= <expr><name>pNC</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_AGG_FUNCTION</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>pNC2</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3FunctionUsesThisSrc</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pNC2</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pNC2</name> <operator>=</operator> <name><name>pNC2</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDef</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pNC2</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_MINMAX</name><operator>==</operator><name>NC_MinMaxAgg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_MINMAX</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNC2</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>|=</operator> <name>NC_HasAgg</name> <operator>|</operator> <operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_MINMAX</name><operator>)</operator></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>|=</operator> <name>NC_AllowAgg</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* FIX ME:  Compute pExpr-&gt;affinity based on the expected return
      ** type of the function 
      */</comment>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <case>case <expr><name>TK_SELECT</name></expr>:</case>
    <case>case <expr><name>TK_EXISTS</name></expr>:</case>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EXISTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>TK_IN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nRef</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>nRef</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>notValid</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><literal type="string">"subqueries"</literal></expr></argument>, <argument><expr><name>NC_IsCheck</name><operator>|</operator><name>NC_PartIdx</name><operator>|</operator><name>NC_IdxExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;=</operator><name>nRef</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nRef</name><operator>!=</operator><name><name>pNC</name><operator>-&gt;</operator><name>nRef</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_VarSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_VARIABLE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>notValid</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNC</name></expr></argument>, <argument><expr><literal type="string">"parameters"</literal></expr></argument>, <argument><expr><name>NC_IsCheck</name><operator>|</operator><name>NC_PartIdx</name><operator>|</operator><name>NC_IdxExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>WRC_Abort</name></expr> </then><else>: <expr><name>WRC_Continue</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pEList is a list of expressions which are really the result set of the
** a SELECT statement.  pE is a term in an ORDER BY or GROUP BY clause.
** This routine checks to see if pE is a simple identifier which corresponds
** to the AS-name of one of the terms of the expression list.  If it is,
** this routine return an integer between 1 and N where N is the number of
** elements in pEList, corresponding to the matching entry.  If there is
** no match, or if pE is not a simple identifier, then this routine
** return 0.
**
** pEList has been resolved.  pE has not.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveAsName</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context for error messages */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,  <comment type="block">/* List of expressions to scan */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl></parameter>           <comment type="block">/* Expression we are trying to match */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Loop counter */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><name><name>pE</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAs</name> <init>= <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zAs</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zAs</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pE is a pointer to an expression which is a single term in the
** ORDER BY of a compound SELECT.  The expression has not been
** name resolved.
**
** At the point this routine is called, we already know that the
** ORDER BY term is not an integer index into the result set.  That
** case is handled by the calling routine.
**
** Attempt to match pE against result set columns in the left-most
** SELECT statement.  Return the index i of the matching column,
** as an indication to the caller that it should sort by the i-th column.
** The left-most column is 1.  In other words, the value returned is the
** same integer value that would be used in the SQL statement to indicate
** the column.
**
** If there is no match, return 0.  Return -1 if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveOrderByTermToExprList</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context for error messages */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,   <comment type="block">/* The SELECT statement with the ORDER BY clause */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl></parameter>           <comment type="block">/* The specific ORDER BY term */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>  <comment type="block">/* The columns of the result set */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>nc</name></decl>;</decl_stmt>    <comment type="block">/* Name context for resolving pE */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>       <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>            <comment type="block">/* Return code from subprocedures */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>savedSuppErr</name></decl>;</decl_stmt>   <comment type="block">/* Saved value of db-&gt;suppressErr */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>

  <comment type="block">/* Resolve all names in the ORDER BY term expression
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nc</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nc</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nc</name><operator>.</operator><name>pEList</name></name> <operator>=</operator> <name>pEList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nc</name><operator>.</operator><name>ncFlags</name></name> <operator>=</operator> <name>NC_AllowAgg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nc</name><operator>.</operator><name>nErr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>savedSuppErr</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nc</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>suppressErr</name></name> <operator>=</operator> <name>savedSuppErr</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Try to match the ORDER BY expression against an expression
  ** in the result set.  Return an 1-based index of the matching
  ** result-set entry.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If no match, return 0. */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate an ORDER BY or GROUP BY term out-of-range error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resolveOutOfRangeError</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* The error context into which to write the error */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>,     <comment type="block">/* "ORDER" or "GROUP" */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>,                 <comment type="block">/* The index (1-based) of the term out of range */</comment>
  <parameter><decl><type><name>int</name></type> <name>mx</name></decl></parameter>                 <comment type="block">/* Largest permissible value of i */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
    <argument><expr><literal type="string">"%r %s BY term out of range - should be "</literal>
    <literal type="string">"between 1 and %d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>mx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Analyze the ORDER BY clause in a compound SELECT statement.   Modify
** each term of the ORDER BY clause is a constant integer between 1
** and N where N is the number of columns in the compound SELECT.
**
** ORDER BY terms that are already an integer between 1 and N are
** unmodified.  ORDER BY terms that are integers outside the range of
** 1 through N generate an error.  ORDER BY terms that are expressions
** are matched against result set expressions of compound SELECT
** beginning with the left-most SELECT and working toward the right.
** At the first match, the ORDER BY expression is transformed into
** the integer column number.
**
** Return the number of errors seen.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveCompoundOrderBy</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context.  Leave error messages here */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>       <comment type="block">/* The SELECT statement containing the ORDER BY */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>moreToDo</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOrderBy</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_COLUMN</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many terms in ORDER BY clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>done</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pSelect</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <while>while<condition>( <expr><name>pSelect</name> <operator>&amp;&amp;</operator> <name>moreToDo</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>moreToDo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pDup</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>done</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pE</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>&gt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>resolveOutOfRangeError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"ORDER"</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iCol</name> <operator>=</operator> <call><name>resolveAsName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pDup</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>iCol</name> <operator>=</operator> <call><name>resolveOrderByTermToExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Convert the ORDER BY term into an integer column number iCol,
        ** taking care to preserve the COLLATE clause if it exists */</comment>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_IntValue</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name><operator>==</operator><name>pE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <while>while<condition>( <expr><name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pParent</name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><name>pE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pParent</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iCol</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>moreToDo</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>done</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%r ORDER BY term does not match any "</literal>
            <literal type="string">"column in the result set"</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check every term in the ORDER BY or GROUP BY clause pOrderBy of
** the SELECT statement pSelect.  If any term is reference to a
** result set expression (as determined by the ExprList.a.u.x.iOrderByCol
** field) then convert that term into a copy of the corresponding result set
** column.
**
** If any errors are detected, add an error message to pParse and
** return non-zero.  Return zero if no errors are seen.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ResolveOrderGroupBy</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context.  Leave error messages here */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* The SELECT statement containing the clause */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,   <comment type="block">/* The ORDER BY or GROUP BY clause to be processed */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>     <comment type="block">/* "ORDER" or "GROUP" */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_COLUMN</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many terms in %s BY clause"</literal></expr></argument>, <argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* sqlite3SelectNew() guarantees this */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>&gt;</operator><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>resolveOutOfRangeError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>resolveAlias</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>,
                   <argument><expr><name>zType</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pOrderBy is an ORDER BY or GROUP BY clause in SELECT statement pSelect.
** The Name context of the SELECT statement is pNC.  zType is either
** "ORDER" or "GROUP" depending on which type of clause pOrderBy is.
**
** This routine resolves each term of the clause into an expression.
** If the order-by term is an integer I between 1 and N (where N is the
** number of columns in the result set of the SELECT) then the expression
** in the resolution is a copy of the I-th result-set expression.  If
** the order-by term is an identifier that corresponds to the AS-name of
** a result-set expression, then the term resolves to a copy of the
** result-set expression.  Otherwise, the expression is resolved in
** the usual way - using sqlite3ResolveExprNames().
**
** This routine returns the number of errors.  If errors occur, then
** an appropriate error message might be left in pParse.  (OOM errors
** excepted.)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveOrderGroupBy</name><parameter_list>(
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>,     <comment type="block">/* The name context of the SELECT statement */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* The SELECT statement holding pOrderBy */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,   <comment type="block">/* An ORDER BY or GROUP BY clause to resolve */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>     <comment type="block">/* Either "ORDER" or "GROUP", as appropriate */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                      <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                      <comment type="block">/* Column number */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>   <comment type="block">/* A term of the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>                 <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nResult</name></decl>;</decl_stmt>                   <comment type="block">/* Number of terms in the result set */</comment>

  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nResult</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE2</name> <init>= <expr><call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zType</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'G'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <call><name>resolveAsName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><name>pE2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If an AS-name match is found, mark this ORDER BY column as being
        ** a copy of the iCol-th result-set column.  The subsequent call to
        ** sqlite3ResolveOrderGroupBy() will convert the expression to a
        ** copy of the iCol-th result-set expression. */</comment>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iCol</name></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pE2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* The ORDER BY term is an integer constant.  Again, set the column
      ** number so that sqlite3ResolveOrderGroupBy() will convert the
      ** order-by term to a copy of the result-set expression */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>iCol</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal> <operator>||</operator> <name>iCol</name></expr></argument>&gt;</argument_list></name><literal type="number">0xffff</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>resolveOutOfRangeError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iCol</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Otherwise, treat the ORDER BY term as an ordinary expression */</comment>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><name>pNC</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name> <operator>=</operator> <name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <return>return <expr><call><name>sqlite3ResolveOrderGroupBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Resolve names in the SELECT statement p and all of its descendants.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resolveSelectStep</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pOuterNC</name></decl>;</decl_stmt>  <comment type="block">/* Context that contains this SELECT */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>        <comment type="block">/* Name context of this SELECT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isCompound</name></decl>;</decl_stmt>         <comment type="block">/* True if p is a compound select */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCompound</name></decl>;</decl_stmt>          <comment type="block">/* Number of compound terms processed so far */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>          <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                  <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pGroupBy</name></decl>;</decl_stmt>     <comment type="block">/* The GROUP BY clause */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pLeftmost</name></decl>;</decl_stmt>      <comment type="block">/* Left-most of SELECT of a compound */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>            <comment type="block">/* Database connection */</comment>
  

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Resolved</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pOuterNC</name> <operator>=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNC</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>

  <comment type="block">/* Normally sqlite3SelectExpand() will be called first and will have
  ** already expanded this SELECT.  However, if this is a subquery within
  ** an expression, sqlite3ResolveExprNames() will be called without a
  ** prior call to sqlite3SelectExpand().  When that happens, let
  ** sqlite3SelectPrep() do all of the processing for this SELECT.
  ** sqlite3SelectPrep() will invoke both sqlite3SelectExpand() and
  ** this routine in the correct order.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Expanded</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOuterNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>WRC_Abort</name></expr> </then><else>: <expr><name>WRC_Prune</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>isCompound</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCompound</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLeftmost</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Expanded</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Resolved</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_Resolved</name></expr>;</expr_stmt>

    <comment type="block">/* Resolve the expressions in the LIMIT and OFFSET clauses. These
    ** are not allowed to refer to any names, so pass an empty NameContext.
    */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOffset</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the SF_Converted flags is set, then this Select object was
    ** was created by the convertCompoundSelectToSubquery() function.
    ** In this case the ORDER BY clause (p-&gt;pOrderBy) should be resolved
    ** as if it were part of the sub-query, not the parent. This block
    ** moves the pOrderBy down to the sub-query. It will be moved back
    ** after the names have been resolved.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Converted</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>&amp;&amp;</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Recursively resolve names in all subqueries
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl>;</decl_stmt>         <comment type="block">/* Used to iterate name contexts */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nRef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Refcount for pOuterNC and outer contexts */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSavedContext</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Count the total number of references to pOuterNC and all of its
        ** parent contexts. After resolving references to expressions in
        ** pItem-&gt;pSelect, check if this value has changed. If so, then
        ** SELECT statement pItem-&gt;pSelect must be correlated. Set the
        ** pItem-&gt;fg.isCorrelated flag if this is the case. */</comment>
        <for>for<control>(<init><expr><name>pNC</name><operator>=</operator><name>pOuterNC</name></expr>;</init> <condition><expr><name>pNC</name></expr>;</condition> <incr><expr><name>pNC</name><operator>=</operator><name><name>pNC</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>nRef</name> <operator>+=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>nRef</name></name></expr>;</expr_stmt></block_content></block></for>

        <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3ResolveSelectNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>, <argument><expr><name>pOuterNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zAuthContext</name></name> <operator>=</operator> <name>zSavedContext</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>

        <for>for<control>(<init><expr><name>pNC</name><operator>=</operator><name>pOuterNC</name></expr>;</init> <condition><expr><name>pNC</name></expr>;</condition> <incr><expr><name>pNC</name><operator>=</operator><name><name>pNC</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>nRef</name> <operator>-=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>nRef</name></name></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCorrelated</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nRef</name><operator>&lt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isCorrelated</name></name> <operator>=</operator> <operator>(</operator><name>nRef</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  
    <comment type="block">/* Set up the local name-context to pass to sqlite3ResolveExprNames() to
    ** resolve the result-set expression list.
    */</comment>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>=</operator> <name>NC_AllowAgg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name>pOuterNC</name></expr>;</expr_stmt>
  
    <comment type="block">/* Resolve names in the result set. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
  
    <comment type="block">/* If there are no aggregate functions in the result-set, and no GROUP BY 
    ** expression, do not allow aggregates in any of the other expressions.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pGroupBy</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pGroupBy</name> <operator>||</operator> <operator>(</operator><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_HasAgg</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>NC_MinMaxAgg</name><operator>==</operator><name>SF_MinMaxAgg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_Aggregate</name> <operator>|</operator> <operator>(</operator><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name><operator>&amp;</operator><name>NC_MinMaxAgg</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>NC_AllowAgg</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  
    <comment type="block">/* If a HAVING clause is present, then there must be a GROUP BY clause.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pGroupBy</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"a GROUP BY clause is required before HAVING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Add the output column list to the name-context before parsing the
    ** other expressions in the SELECT statement. This is so that
    ** expressions in the WHERE clause (etc.) can refer to expressions by
    ** aliases in the result set.
    **
    ** Minor point: If this is the case, then the expression will be
    ** re-evaluated for each reference to it.
    */</comment>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pEList</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Resolve names in table-valued-function arguments */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name>
       <operator>&amp;&amp;</operator> <call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pFuncArg</name></name></expr></argument>)</argument_list></call></expr> 
      )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* The ORDER BY and GROUP BY clauses may not refer to terms in
    ** outer queries 
    */</comment>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>|=</operator> <name>NC_AllowAgg</name></expr>;</expr_stmt>

    <comment type="block">/* If this is a converted compound query, move the ORDER BY clause from 
    ** the sub-query back to the parent query. At this point each term
    ** within the ORDER BY clause has been transformed to an integer value.
    ** These integers will be replaced by copies of the corresponding result
    ** set expressions by the call to resolveOrderGroupBy() below.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Converted</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSub</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process the ORDER BY clause for singleton SELECT statements.
    ** The ORDER BY clause for compounds SELECT statements is handled
    ** below, after all of the result-sets for all of the elements of
    ** the compound have been resolved.
    **
    ** If there is an ORDER BY clause on a term of a compound-select other
    ** than the right-most term, then that is a syntax error.  But the error
    ** is not detected until much later, and so we need to go ahead and
    ** resolve those symbols on the incorrect ORDER BY for consistency.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>isCompound</name><operator>&lt;=</operator><name>nCompound</name>  <comment type="block">/* Defer right-most ORDER BY of a compound */</comment>
     <operator>&amp;&amp;</operator> <call><name>resolveOrderGroupBy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><literal type="string">"ORDER"</literal></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Resolve the GROUP BY clause.  At the same time, make sure 
    ** the GROUP BY clause does not contain aggregate functions.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pGroupBy</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    
      <if_stmt><if>if<condition>( <expr><call><name>resolveOrderGroupBy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pGroupBy</name></expr></argument>, <argument><expr><literal type="string">"GROUP"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGroupBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>EP_Agg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"aggregate functions are not allowed in "</literal>
              <literal type="string">"the GROUP BY clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>WRC_Abort</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this is part of a compound SELECT, check that it has the right
    ** number of expressions in the select list. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SelectWrongNumTermsError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Advance to the next term of the compound
    */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCompound</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Resolve the ORDER BY on a compound SELECT after all terms of
  ** the compound have been resolved.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isCompound</name> <operator>&amp;&amp;</operator> <call><name>resolveCompoundOrderBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeftmost</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>WRC_Prune</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine walks an expression tree and resolves references to
** table columns and result-set columns.  At the same time, do error
** checking on function usage and set a flag if any aggregate functions
** are seen.
**
** To resolve table columns references we look for nodes (or subtrees) of the 
** form X.Y.Z or Y.Z or just Z where
**
**      X:   The name of a database.  Ex:  "main" or "temp" or
**           the symbolic name assigned to an ATTACH-ed database.
**
**      Y:   The name of a table in a FROM clause.  Or in a trigger
**           one of the special names "old" or "new".
**
**      Z:   The name of a column in table Y.
**
** The node at the root of the subtree is modified as follows:
**
**    Expr.op        Changed to TK_COLUMN
**    Expr.pTab      Points to the Table object for X.Y
**    Expr.iColumn   The column index in X.Y.  -1 for the rowid.
**    Expr.iTable    The VDBE cursor number for X.Y
**
**
** To resolve result-set references, look for expression nodes of the
** form Z (with no X and Y prefix) where the Z matches the right-hand
** size of an AS clause in the result-set of a SELECT.  The Z expression
** is replaced by a copy of the left-hand side of the result-set expression.
** Table-name and function resolution occurs on the substituted expression
** tree.  For example, in:
**
**      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY x;
**
** The "x" term of the order by is replaced by "a+b" to render:
**
**      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY a+b;
**
** Function calls are checked to make sure that the function is 
** defined and that the correct number of arguments are specified.
** If the function is an aggregate function, then the NC_HasAgg flag is
** set and the opcode is changed from TK_FUNCTION to TK_AGG_FUNCTION.
** If an expression contains aggregate functions then the EP_Agg
** property on the expression is set.
**
** An error message is left in pParse if anything is amiss.  The number
** if errors is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ResolveExprNames</name><parameter_list>( 
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>,       <comment type="block">/* Namespace to resolve expressions in. */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>             <comment type="block">/* The expression to be analyzed. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>savedHasAgg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <block>{<block_content>
    <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCheckHeight</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>nHeight</name></name><operator>+</operator><name><name>pNC</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>+=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>savedHasAgg</name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_MinMaxAgg</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>NC_HasAgg</name><operator>|</operator><name>NC_MinMaxAgg</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>resolveExprStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>resolveSelectStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>walkerDepth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pNC</name></name> <operator>=</operator> <name>pNC</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>-=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>nErr</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>w</name><operator>.</operator><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_HasAgg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>|=</operator> <name>savedHasAgg</name></expr>;</expr_stmt>
  <return>return <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Error</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Resolve all names for all expression in an expression list.  This is
** just like sqlite3ResolveExprNames() except that it works for an expression
** list rather than a single expression.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ResolveExprListNames</name><parameter_list>( 
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>,       <comment type="block">/* Namespace to resolve expressions in. */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>         <comment type="block">/* The expression list to be analyzed. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><name>pNC</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>WRC_Abort</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Resolve all names in all expressions of a SELECT and in all
** decendents of the SELECT, including compounds off of p-&gt;pPrior,
** subqueries in expressions, and subqueries used as FROM clause
** terms.
**
** See sqlite3ResolveExprNames() for a description of the kinds of
** transformations that occur.
**
** All SELECT statements should have been expanded using
** sqlite3SelectExpand() prior to invoking this routine.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ResolveSelectNames</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* The SELECT statement being coded. */</comment>
  <parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pOuterNC</name></decl></parameter>  <comment type="block">/* Name context for parent SELECT statement */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>resolveExprStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>resolveSelectStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pNC</name></name> <operator>=</operator> <name>pOuterNC</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Resolve names in expressions that can only reference a single table:
**
**    *   CHECK constraints
**    *   WHERE clauses on partial indices
**
** The Expr.iTable value for Expr.op==TK_COLUMN nodes of the expression
** is set to -1 and the Expr.iColumn value is set to the column number.
**
** Any errors cause an error message to be set in pParse.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ResolveSelfReference</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,        <comment type="block">/* The table being referenced */</comment>
  <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,           <comment type="block">/* NC_IsCheck or NC_PartIdx or NC_IdxExpr */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,        <comment type="block">/* Expression to resolve.  May be NULL. */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>     <comment type="block">/* Expression list to resolve.  May be NUL. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcList</name></type> <name>sSrc</name></decl>;</decl_stmt>                   <comment type="block">/* Fake SrcList for pParse-&gt;pNewTable */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>                <comment type="block">/* Name context for pParse-&gt;pNewTable */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>type</name><operator>==</operator><name>NC_IsCheck</name> <operator>||</operator> <name>type</name><operator>==</operator><name>NC_PartIdx</name> <operator>||</operator> <name>type</name><operator>==</operator><name>NC_IdxExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sSrc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sSrc</name><operator>.</operator><name>nSrc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sSrc</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sSrc</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sSrc</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <operator>&amp;</operator><name>sSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
