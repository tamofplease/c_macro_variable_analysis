<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/insert.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** to handle INSERT statements in SQLite.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Generate code that will 
**
**   (1) acquire a lock for table pTab then
**   (2) open pTab as cursor iCur.
**
** If pTab is a WITHOUT ROWID table, then it is the PRIMARY KEY index
** for that table that is actually opened.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3OpenTable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,  <comment type="block">/* Generate code into this VDBE */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,       <comment type="block">/* The cursor number of the table */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>,        <comment type="block">/* The database index in sqlite3.aDb[] */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,    <comment type="block">/* The table to be opened */</comment>
  <parameter><decl><type><name>int</name></type> <name>opcode</name></decl></parameter>      <comment type="block">/* OP_OpenRead or OP_OpenWrite */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>opcode</name><operator>==</operator><name>OP_OpenWrite</name> <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_OpenRead</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, 
                   <argument><expr><ternary><condition><expr><operator>(</operator><name>opcode</name><operator>==</operator><name>OP_OpenWrite</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>tnum</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the column affinity string associated with index
** pIdx. A column affinity string has one character for each column in 
** the table, according to the affinity of the column:
**
**  Character      Column affinity
**  ------------------------------
**  'A'            BLOB
**  'B'            TEXT
**  'C'            NUMERIC
**  'D'            INTEGER
**  'F'            REAL
**
** An extra 'D' is appended to the end of the string to cover the
** rowid that appears as the last column in every index.
**
** Memory for the buffer containing the column index affinity string
** is managed along with the rest of the Index structure. It will be
** released when sqlite3DeleteIndex() is called.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3IndexAffinityStr</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The first time a column affinity string for a particular index is
    ** required, it is allocated and populated here. It is then stored as
    ** a member of the Index structure for subsequent use.
    **
    ** The column affinity string will eventually be deleted by
    ** sqliteDeleteIndex() when the Index structure itself is cleaned
    ** up.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>i16</name></type> <name>x</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>affinity</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>x</name><operator>==</operator><name>XN_ROWID</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name>aff</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>==</operator><name>XN_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>aff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>aff</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
 
  <return>return <expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute the affinity string for table pTab, if it has not already been
** computed.  As an optimization, omit trailing SQLITE_AFF_BLOB affinities.
**
** If the affinity exists (if it is no entirely SQLITE_AFF_BLOB values) and
** if iReg&gt;0 then code an OP_Affinity opcode that will set the affinities
** for register iReg and following.  Or if affinities exists and iReg==0,
** then just set the P4 operand of the previous opcode (which should  be
** an OP_MakeRecord) to the affinity string.
**
** A column affinity string has one character per column:
**
**  Character      Column affinity
**  ------------------------------
**  'A'            BLOB
**  'B'            TEXT
**  'C'            NUMERIC
**  'D'            INTEGER
**  'E'            REAL
*/</comment>
<function><type><name>void</name></type> <name>sqlite3TableAffinity</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zColAff</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>zColAff</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zColAff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zColAff</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zColAff</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>zColAff</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>affinity</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name><name>zColAff</name><index>[<expr><name>i</name><operator>--</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zColAff</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition>;</do>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>zColAff</name></name> <operator>=</operator> <name>zColAff</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zColAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iReg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Affinity</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zColAff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zColAff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return non-zero if the table pTab in database iDb or any of its indices
** have been opened at any point in the VDBE program. This is used to see if 
** a statement of the form  "INSERT INTO &lt;iDb, pTab&gt; SELECT ..." can 
** run without using a temporary table for the results of the SELECT. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>readsTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><ternary><condition><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iEnd</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenRead</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><name>iDb</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>tnum</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>tnum</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>pIndex</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIndex</name></expr>;</condition> <incr><expr><name>pIndex</name><operator>=</operator><name><name>pIndex</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>tnum</name><operator>==</operator><name><name>pIndex</name><operator>-&gt;</operator><name>tnum</name></name></expr> )</condition><block>{<block_content>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_VOpen</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name></name><operator>==</operator><name>pVTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
<comment type="block">/*
** Locate or create an AutoincInfo structure associated with table pTab
** which is in database iDb.  Return the register number for the register
** that holds the maximum rowid.
**
** There is at most one AutoincInfo structure per table even if the
** same table is autoincremented multiple times due to inserts within
** triggers.  A new AutoincInfo structure is created if this is the
** first use of table pTab.  On 2nd and subsequent uses, the original
** AutoincInfo structure is used.
**
** Three memory locations are allocated:
**
**   (1)  Register to hold the name of the pTab table.
**   (2)  Register to hold the maximum ROWID of pTab.
**   (3)  Register to hold the rowid in sqlite_sequence of pTab
**
** The 2nd register is the one that is returned.  That is all the
** insert routine needs to know about.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>autoIncBegin</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>,            <comment type="block">/* Index of the database holding pTab */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>         <comment type="block">/* The table we are writing to */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>memId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Register holding maximum rowid */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Autoincrement</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pToplevel</name> <init>= <expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AutoincInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <name><name>pToplevel</name><operator>-&gt;</operator><name>pAinc</name></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pInfo</name> <operator>&amp;&amp;</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pTab</name></name><operator>!=</operator><name>pTab</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt> </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>pInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pToplevel</name><operator>-&gt;</operator><name>pAinc</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>pAinc</name></name> <operator>=</operator> <name>pInfo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>iDb</name></name> <operator>=</operator> <name>iDb</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>nMem</name></name><operator>++</operator></expr>;</expr_stmt>                  <comment type="block">/* Register to hold name of table */</comment>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>regCtr</name></name> <operator>=</operator> <operator>++</operator><name><name>pToplevel</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>  <comment type="block">/* Max rowid register */</comment>
      <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>nMem</name></name><operator>++</operator></expr>;</expr_stmt>                  <comment type="block">/* Rowid in sqlite_sequence */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>memId</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>regCtr</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>memId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine generates code that will initialize all of the
** register used by the autoincrement tracker.  
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AutoincrementBegin</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AutoincInfo</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>            <comment type="block">/* Information about an AUTOINCREMENT */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                   <comment type="block">/* Database only autoinc table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>memId</name></decl>;</decl_stmt>                 <comment type="block">/* Register holding max rowid */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* VDBE under construction */</comment>

  <comment type="block">/* This routine is never called during trigger-generation.  It is
  ** only called from the top-level */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3IsToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* We failed long ago if this is not so */</comment>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pAinc</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>iLn</name> <init>= <expr><call><name>VDBE_OFFSET_LINENO</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>VdbeOpList</name></type> <name><name>autoInc</name><index>[]</index></name> <init>= <expr><block>{
      <comment type="block">/* 0  */</comment> <expr><block>{<expr><name>OP_Null</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 1  */</comment> <expr><block>{<expr><name>OP_Rewind</name></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">9</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 2  */</comment> <expr><block>{<expr><name>OP_Column</name></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 3  */</comment> <expr><block>{<expr><name>OP_Ne</name></expr>,      <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 4  */</comment> <expr><block>{<expr><name>OP_Rowid</name></expr>,   <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 5  */</comment> <expr><block>{<expr><name>OP_Column</name></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 6  */</comment> <expr><block>{<expr><name>OP_Goto</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">9</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 7  */</comment> <expr><block>{<expr><name>OP_Next</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 8  */</comment> <expr><block>{<expr><name>OP_Integer</name></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 9  */</comment> <expr><block>{<expr><name>OP_Close</name></expr>,   <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr> 
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>memId</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>regCtr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>pSeqTab</name></name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeLoadString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>memId</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aOp</name> <operator>=</operator> <call><name>sqlite3VdbeAddOpList</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>autoInc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>autoInc</name></expr></argument>, <argument><expr><name>iLn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aOp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p1</name> <operator>=</operator> <name>memId</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p5</name> <operator>=</operator> <name>SQLITE_JUMPIFNULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Update the maximum rowid for an autoincrement calculation.
**
** This routine should be called when the regRowid register holds a
** new rowid that is about to be inserted.  If that new rowid is
** larger than the maximum rowid in the memId memory cell, then the
** memory cell is updated.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>autoIncStep</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>memId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>memId</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_MemMax</name></expr></argument>, <argument><expr><name>memId</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine generates the code needed to write autoincrement
** maximum rowid values back into the sqlite_sequence register.
** Every statement that might do an INSERT into an autoincrement
** table (either directly or through triggers) needs to call this
** routine just before the "exit" code.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>autoIncrementEnd</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AutoincInfo</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pAinc</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>iLn</name> <init>= <expr><call><name>VDBE_OFFSET_LINENO</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>VdbeOpList</name></type> <name><name>autoIncEnd</name><index>[]</index></name> <init>= <expr><block>{
      <comment type="block">/* 0 */</comment> <expr><block>{<expr><name>OP_NotNull</name></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 1 */</comment> <expr><block>{<expr><name>OP_NewRowid</name></expr>,    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 2 */</comment> <expr><block>{<expr><name>OP_MakeRecord</name></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 3 */</comment> <expr><block>{<expr><name>OP_Insert</name></expr>,      <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 4 */</comment> <expr><block>{<expr><name>OP_Close</name></expr>,       <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iRec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>memId</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>regCtr</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>iRec</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>pSeqTab</name></name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aOp</name> <operator>=</operator> <call><name>sqlite3VdbeAddOpList</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>autoIncEnd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>autoIncEnd</name></expr></argument>, <argument><expr><name>iLn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aOp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p1</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>p1</name> <operator>=</operator> <name>memId</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>iRec</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>iRec</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p5</name> <operator>=</operator> <name>OPFLAG_APPEND</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3AutoincrementEnd</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pAinc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>autoIncrementEnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/*
** If SQLITE_OMIT_AUTOINCREMENT is defined, then the three routines
** above are all no-ops
*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>autoIncBegin</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>autoIncStep</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTOINCREMENT */</comment>


<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>xferOptimization</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parser context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>,         <comment type="block">/* The table we are inserting into */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* A SELECT statement to use as the data source */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,          <comment type="block">/* How to handle constraint errors */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDbDest</name></decl></parameter>           <comment type="block">/* The database of pDest */</comment>
)</parameter_list>;</function_decl>

<comment type="block">/*
** This routine is called to handle SQL of the following forms:
**
**    insert into TABLE (IDLIST) values(EXPRLIST),(EXPRLIST),...
**    insert into TABLE (IDLIST) select
**    insert into TABLE (IDLIST) default values
**
** The IDLIST following the table name is always optional.  If omitted,
** then a list of all (non-hidden) columns for the table is substituted.
** The IDLIST appears in the pColumn parameter.  pColumn is NULL if IDLIST
** is omitted.
**
** For the pSelect parameter holds the values to be inserted for the
** first two forms shown above.  A VALUES clause is really just short-hand
** for a SELECT statement that omits the FROM clause and everything else
** that follows.  If the pSelect parameter is NULL, that means that the
** DEFAULT VALUES form of the INSERT statement is intended.
**
** The code generated follows one of four templates.  For a simple
** insert with data coming from a single-row VALUES clause, the code executes
** once straight down through.  Pseudo-code follows (we call this
** the "1st template"):
**
**         open write cursor to &lt;table&gt; and its indices
**         put VALUES clause expressions into registers
**         write the resulting record into &lt;table&gt;
**         cleanup
**
** The three remaining templates assume the statement is of the form
**
**   INSERT INTO &lt;table&gt; SELECT ...
**
** If the SELECT clause is of the restricted form "SELECT * FROM &lt;table2&gt;" -
** in other words if the SELECT pulls all columns from a single table
** and there is no WHERE or LIMIT or GROUP BY or ORDER BY clauses, and
** if &lt;table2&gt; and &lt;table1&gt; are distinct tables but have identical
** schemas, including all the same indices, then a special optimization
** is invoked that copies raw records from &lt;table2&gt; over to &lt;table1&gt;.
** See the xferOptimization() function for the implementation of this
** template.  This is the 2nd template.
**
**         open a write cursor to &lt;table&gt;
**         open read cursor on &lt;table2&gt;
**         transfer all records in &lt;table2&gt; over to &lt;table&gt;
**         close cursors
**         foreach index on &lt;table&gt;
**           open a write cursor on the &lt;table&gt; index
**           open a read cursor on the corresponding &lt;table2&gt; index
**           transfer all records from the read to the write cursors
**           close cursors
**         end foreach
**
** The 3rd template is for when the second template does not apply
** and the SELECT clause does not read from &lt;table&gt; at any time.
** The generated code follows this template:
**
**         X &lt;- A
**         goto B
**      A: setup for the SELECT
**         loop over the rows in the SELECT
**           load values into registers R..R+n
**           yield X
**         end loop
**         cleanup after the SELECT
**         end-coroutine X
**      B: open write cursor to &lt;table&gt; and its indices
**      C: yield X, at EOF goto D
**         insert the select result into &lt;table&gt; from R..R+n
**         goto C
**      D: cleanup
**
** The 4th template is used if the insert statement takes its
** values from a SELECT but the data is being inserted into a table
** that is also read as part of the SELECT.  In the third form,
** we have to use an intermediate table to store the results of
** the select.  The template is like this:
**
**         X &lt;- A
**         goto B
**      A: setup for the SELECT
**         loop over the tables in the SELECT
**           load value into register R..R+n
**           yield X
**         end loop
**         cleanup after the SELECT
**         end co-routine R
**      B: open temp table
**      L: yield X, at EOF goto M
**         insert row from R..R+n into temp table
**         goto L
**      M: open write cursor to &lt;table&gt; and its indices
**         rewind temp table
**      C: loop over rows of intermediate table
**           transfer values form intermediate table into &lt;table&gt;
**         end loop
**      D: cleanup
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Insert</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parser context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,    <comment type="block">/* Name of table into which we are inserting */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* A SELECT statement to use as the data source */</comment>
  <parameter><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pColumn</name></decl></parameter>,      <comment type="block">/* Column names corresponding to IDLIST. */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>           <comment type="block">/* How to handle constraint errors */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>          <comment type="block">/* The main database structure */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>          <comment type="block">/* The table to insert into.  aka TABLE */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>           <comment type="block">/* Name of the table into which we are inserting */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>      <comment type="block">/* Name of the database holding this table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>;</decl_stmt>        <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>              <comment type="block">/* Generate code into this virtual machine */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>          <comment type="block">/* For looping over indices of the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name></decl>;</decl_stmt>          <comment type="block">/* Number of columns in the data */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nHidden</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Number of hidden columns if TABLE is virtual */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDataCur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* VDBE cursor that is the main data repository */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* First index cursor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ipkColumn</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Column that is the INTEGER PRIMARY KEY */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>endOfLoop</name></decl>;</decl_stmt>        <comment type="block">/* Label for the end of the insertion loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>srcTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Data comes from this temporary cursor if &gt;=0 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrInsTop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Jump to label "D" */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrCont</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Top of insert loop. Label "C" in templates 3 and 4 */</comment>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>      <comment type="block">/* Destination for SELECT on rhs of INSERT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>              <comment type="block">/* Index of database holding TABLE */</comment>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>              <comment type="block">/* The database containing table being inserted into */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>useTempTable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Store SELECT results in intermediate table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>appendFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* True if the insert is likely to be an append */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>withoutRowid</name></decl>;</decl_stmt>      <comment type="block">/* 0 for normal table.  1 for WITHOUT ROWID table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bIdListInOrder</name></decl>;</decl_stmt>    <comment type="block">/* True if IDLIST is in table order */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* List of VALUES() to be inserted  */</comment>

  <comment type="block">/* Register allocations */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFromSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt><comment type="block">/* Base register for data coming from SELECT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regAutoinc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Register holding the AUTOINCREMENT counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Memory cell used for the row counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regIns</name></decl>;</decl_stmt>           <comment type="block">/* Block of regs holding rowid+data being inserted */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name></decl>;</decl_stmt>         <comment type="block">/* registers holding insert rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regData</name></decl>;</decl_stmt>          <comment type="block">/* register holding first column to insert */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aRegIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* One register allocated to each index */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>isView</name></decl>;</decl_stmt>                 <comment type="block">/* True if attempting to insert into a view */</comment>
  <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name></decl>;</decl_stmt>          <comment type="block">/* List of triggers on pTab, if required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tmask</name></decl>;</decl_stmt>                  <comment type="block">/* Mask of trigger times */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the Select object is really just a simple VALUES() list with a
  ** single row (the common case) then keep that one row of values
  ** and discard the other (unused) parts of the pSelect object
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pSelect</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Values</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Locate the table into which we will be inserting new information.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTab</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>zTab</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>insert_cleanup</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3SrcListLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>withoutRowid</name> <operator>=</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out if we have any triggers and if the table being
  ** inserted into is a view
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <call><name>sqlite3TriggersExist</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>TK_INSERT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>isView</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pSelect</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pTrigger</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>tmask</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>isView</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>isView</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>pTrigger</name> <operator>&amp;&amp;</operator> <name>tmask</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pTrigger</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tmask</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If pTab is really a view, make sure it has been initialized.
  ** ViewGetColumnNames() is a no-op if pTab is not a view.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Cannot insert into a read-only table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>tmask</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate a VDBE
  */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>insert_cleanup</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeCountChanges</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name> <operator>||</operator> <name>pTrigger</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_XFER_OPT</name></cpp:ifndef>
  <comment type="block">/* If the statement is of the form
  **
  **       INSERT INTO &lt;table1&gt; SELECT * FROM &lt;table2&gt;;
  **
  ** Then special optimizations can be applied that make the transfer
  ** very fast and which reduce fragmentation of indices.
  **
  ** This is the 2nd template.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pColumn</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>xferOptimization</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pTrigger</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>insert_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_XFER_OPT */</comment>

  <comment type="block">/* If this is an AUTOINCREMENT table, look up the sequence number in the
  ** sqlite_sequence table and store it in memory cell regAutoinc.
  */</comment>
  <expr_stmt><expr><name>regAutoinc</name> <operator>=</operator> <call><name>autoIncBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate registers for holding the rowid of the new row,
  ** the content of the new row, and the assembled row record.
  */</comment>
  <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <name>regIns</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>regRowid</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>regData</name> <operator>=</operator> <name>regRowid</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* If the INSERT statement included an IDLIST term, then make sure
  ** all elements of the IDLIST really are columns of the table and 
  ** remember the column indices.
  **
  ** If the table has an INTEGER PRIMARY KEY column and that column
  ** is named in the IDLIST, then record in the ipkColumn variable
  ** the index into IDLIST of the primary key column.  ipkColumn is
  ** the index of the primary key as it appears in IDLIST, not as
  ** is appears in the original table.  (The index of the INTEGER
  ** PRIMARY KEY in the original table is pTab-&gt;iPKey.)
  */</comment>
  <expr_stmt><expr><name>bIdListInOrder</name> <operator>=</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_OOOHidden</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pColumn</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idx</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><name>j</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bIdListInOrder</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>ipkColumn</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>withoutRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>withoutRowid</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>ipkColumn</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bIdListInOrder</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"table %S has no column named %s"</literal></expr></argument>,
              <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>checkSchema</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <goto>goto <name>insert_cleanup</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Figure out how many columns of data are supplied.  If the data
  ** is coming from a SELECT statement, then generate a co-routine that
  ** produces a single row of the SELECT on each invocation.  The
  ** co-routine is the common header to the 3rd and 4th templates.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Data is coming from a SELECT or from a multi-row VALUES clause.
    ** Generate a co-routine to run the SELECT. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regYield</name></decl>;</decl_stmt>       <comment type="block">/* Register holding co-routine entry-point */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrTop</name></decl>;</decl_stmt>        <comment type="block">/* Top of the co-routine */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>             <comment type="block">/* Result code */</comment>

    <expr_stmt><expr><name>regYield</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrTop</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InitCoroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>SRT_Coroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>iSdst</name></name> <operator>=</operator> <ternary><condition><expr><name>bIdListInOrder</name></expr> ?</condition><then> <expr><name>regData</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>nSdst</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regFromSelect</name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>iSdst</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>insert_cleanup</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeEndCoroutine</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>                       <comment type="block">/* label B: */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>

    <comment type="block">/* Set useTempTable to TRUE if the result of the SELECT statement
    ** should be written into a temporary table (template 4).  Set to
    ** FALSE if each output row of the SELECT can be written directly into
    ** the destination table (template 3).
    **
    ** A temp table must be used if the table being updated is also one
    ** of the tables being read by the SELECT statement.  Also use a 
    ** temp table in the case of row triggers.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pTrigger</name> <operator>||</operator> <call><name>readsTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>useTempTable</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Invoke the coroutine to extract information from the SELECT
      ** and add it to a transient table srcTab.  The code generated
      ** here is from the 4th template:
      **
      **      B: open temp table
      **      L: yield X, goto M at EOF
      **         insert row from R..R+n into temp table
      **         goto L
      **      M: ...
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regRec</name></decl>;</decl_stmt>          <comment type="block">/* Register to hold packed record */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regTempRowid</name></decl>;</decl_stmt>    <comment type="block">/* Register to hold temp table ROWID */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrL</name></decl>;</decl_stmt>           <comment type="block">/* Label "L" */</comment>

      <expr_stmt><expr><name>srcTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>regRec</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>regTempRowid</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrL</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regFromSelect</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>regTempRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>, <argument><expr><name>regTempRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regTempRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* This is the case if the data for the INSERT is coming from a 
    ** single-row VALUES clause
    */</comment>
    <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>srcTab</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>useTempTable</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <goto>goto <name>insert_cleanup</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* If there is no IDLIST term but the table has an integer primary
  ** key, the set the ipkColumn variable to the integer primary key 
  ** column index in the original table definition.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pColumn</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nColumn</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>ipkColumn</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure the number of columns in the source data matches the number
  ** of columns to be inserted into the table.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nHidden</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><call><name>IsHiddenColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pColumn</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nColumn</name> <operator>&amp;&amp;</operator> <name>nColumn</name><operator>!=</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><name>nHidden</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
       <argument><expr><literal type="string">"table %S has %d columns but %d values were supplied"</literal></expr></argument>,
       <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><name>nHidden</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pColumn</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nColumn</name><operator>!=</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%d values for %d columns"</literal></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
    
  <comment type="block">/* Initialize the count of rows to be inserted
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_CountRows</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>regRowCount</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is not a view, open the table and and all indices */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nIdx</name> <operator>=</operator> <call><name>sqlite3OpenTableAndIndices</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>iDataCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aRegIdx</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nIdx</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aRegIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>insert_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nIdx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* This is the top of the main insertion loop */</comment>
  <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This block codes the top of loop only.  The complete loop is the
    ** following pseudocode (template 4):
    **
    **         rewind temp table, if empty goto D
    **      C: loop over rows of intermediate table
    **           transfer values form intermediate table into &lt;table&gt;
    **         end loop
    **      D: ...
    */</comment>
    <expr_stmt><expr><name>addrInsTop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrCont</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This block codes the top of loop only.  The complete loop is the
    ** following pseudocode (template 3):
    **
    **      C: yield X, at EOF goto D
    **         insert the select result into &lt;table&gt; from R..R+n
    **         goto C
    **      D: ...
    */</comment>
    <expr_stmt><expr><name>addrInsTop</name> <operator>=</operator> <name>addrCont</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Run the BEFORE and INSTEAD OF triggers, if there are any
  */</comment>
  <expr_stmt><expr><name>endOfLoop</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>tmask</name> <operator>&amp;</operator> <name>TRIGGER_BEFORE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regCols</name> <init>= <expr><call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* build the NEW.* reference row.  Note that if there is an INTEGER
    ** PRIMARY KEY into which a NULL is being inserted, that NULL will be
    ** translated into a unique ID for the row.  But on a BEFORE trigger,
    ** we do not know what the unique ID will be (because the insert has
    ** not happened yet) so we substitute a rowid of -1
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>ipkColumn</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>withoutRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>ipkColumn</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSelect</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Otherwise useTempTable is true */</comment>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ipkColumn</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Cannot have triggers on a virtual table. If it were possible,
    ** this block would have to account for hidden column.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create the new column data
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pColumn</name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>idx</name><operator>==</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>!</operator><name>useTempTable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pList</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pColumn</name> <operator>&amp;&amp;</operator> <name>j</name><operator>&gt;=</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name><operator>)</operator>
            <operator>||</operator> <operator>(</operator><name>pColumn</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IsOrdinaryHiddenColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pDflt</name></expr></argument>, <argument><expr><name>regCols</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>regCols</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSelect</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Otherwise useTempTable is true */</comment>
        <expr_stmt><expr><call><name>sqlite3ExprCodeAndCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regCols</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pColumn</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsOrdinaryHiddenColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If this is an INSERT on a view with an INSTEAD OF INSERT trigger,
    ** do not attempt any conversions before assembling the record.
    ** If this is a real table, attempt conversions as required by the
    ** table column affinities.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3TableAffinity</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regCols</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Fire BEFORE or INSTEAD OF triggers */</comment>
    <expr_stmt><expr><call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>TK_INSERT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRIGGER_BEFORE</name></expr></argument>, 
        <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regCols</name><operator>-</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>endOfLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compute the content of the next row to insert into a range of
  ** registers beginning at regIns.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* The row that the VUpdate opcode will delete: none */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>ipkColumn</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>ipkColumn</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regFromSelect</name><operator>+</operator><name>ipkColumn</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ipkColumn</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOp</name> <operator>=</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pOp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Null</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>appendFlag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_NewRowid</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>iDataCur</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name>regRowid</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <name>regAutoinc</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <comment type="block">/* If the PRIMARY KEY expression is NULL, then use OP_NewRowid
      ** to generate a unique primary key value.
      */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>appendFlag</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><name>regAutoinc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><name>addr1</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>withoutRowid</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><name>regAutoinc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>appendFlag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>autoIncStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regAutoinc</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute data for all columns of the new entry, beginning
    ** with the first column.
    */</comment>
    <expr_stmt><expr><name>nHidden</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iRegStore</name> <init>= <expr><name>regRowid</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The value of the INTEGER PRIMARY KEY column is always a NULL.
        ** Whenever this column is read, the rowid will be substituted
        ** in its place.  Hence, fill this column with a NULL to avoid
        ** taking up data space with information that will never be used.
        ** As there may be shallow copies of this value, make it a soft-NULL */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SoftNull</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pColumn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>IsHiddenColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>nHidden</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>-</operator> <name>nHidden</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>idx</name><operator>==</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>nColumn</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>pColumn</name> <operator>&amp;&amp;</operator> <name>j</name><operator>&gt;=</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCodeFactorable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pDflt</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>regFromSelect</name><operator>!=</operator><name>regData</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>regFromSelect</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Generate code to check constraints and generate index keys and
    ** do the insertion.
    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VtabMakeWritable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VUpdate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>regIns</name></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> ?</condition><then> <expr><name>OE_Abort</name></expr> </then><else>: <expr><name>onError</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>isReplace</name></decl>;</decl_stmt>    <comment type="block">/* Set to true if constraints may cause a replace */</comment>
      <expr_stmt><expr><call><name>sqlite3GenerateConstraintChecks</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,
          <argument><expr><name>regIns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ipkColumn</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>endOfLoop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isReplace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3FkCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regIns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3CompleteInsertion</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,
                               <argument><expr><name>regIns</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>appendFlag</name></expr></argument>, <argument><expr><name>isReplace</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Update the count of rows that are inserted
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_CountRows</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pTrigger</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Code AFTER triggers */</comment>
    <expr_stmt><expr><call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>TK_INSERT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRIGGER_AFTER</name></expr></argument>, 
        <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regData</name><operator>-</operator><literal type="number">2</literal><operator>-</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>endOfLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The bottom of the main insertion loop, if the data source
  ** is a SELECT statement.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>endOfLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrInsTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrInsTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Close all tables opened */</comment>
    <if_stmt><if>if<condition>( <expr><name>iDataCur</name><operator>&lt;</operator><name>iIdxCur</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>idx</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>idx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>idx</name><operator>+</operator><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

<label><name>insert_end</name>:</label>
  <comment type="block">/* Update the sqlite_sequence table by storing the content of the
  ** maximum rowid counter values recorded while inserting into
  ** autoincrement tables.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3AutoincrementEnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** Return the number of rows inserted. If this routine is 
  ** generating code because of a call to sqlite3NestedParse(), do not
  ** invoke the callback function.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_CountRows</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetNumCols</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr><literal type="string">"rows inserted"</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>insert_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Make sure "isView" and other macros defined above are undefined. Otherwise
** they may interfere with compilation of other functions in this file
** (or in another file, if this file becomes part of the amalgamation).  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>isView</name></cpp:ifdef>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>pTrigger</name></cpp:ifdef>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>pTrigger</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>tmask</name></cpp:ifdef>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>tmask</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Meanings of bits in of pWalker-&gt;eCode for checkConstraintUnchanged()
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CKCNSTRNT_COLUMN</name></cpp:macro>   <cpp:value>0x01</cpp:value></cpp:define>    <comment type="block">/* CHECK constraint uses a changing column */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CKCNSTRNT_ROWID</name></cpp:macro>    <cpp:value>0x02</cpp:value></cpp:define>    <comment type="block">/* CHECK constraint references the ROWID */</comment>

<comment type="block">/* This is the Walker callback from checkConstraintUnchanged().  Set
** bit 0x01 of pWalker-&gt;eCode if
** pWalker-&gt;eCode to 0 if this expression node references any of the
** columns that are being modifed by an UPDATE statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>checkConstraintExprNode</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aiCol</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>|=</operator> <name>CKCNSTRNT_COLUMN</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>|=</operator> <name>CKCNSTRNT_ROWID</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pExpr is a CHECK constraint on a row that is being UPDATE-ed.  The
** only columns that are modified by the UPDATE are those for which
** aiChng[i]&gt;=0, and also the ROWID is modified if chngRowid is true.
**
** Return true if CHECK constraint pExpr does not use any of the
** changing columns (or the rowid if it is changing).  In other words,
** return true if this CHECK constraint can be skipped when validating
** the new row in the UPDATE statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>checkConstraintUnchanged</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiChng</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chngRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>checkConstraintExprNode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>aiCol</name></name> <operator>=</operator> <name>aiChng</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>chngRowid</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>&amp;</operator> <name>CKCNSTRNT_ROWID</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CKCNSTRNT_ROWID</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>==</operator><name>CKCNSTRNT_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>==</operator><name>CKCNSTRNT_ROWID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>==</operator><operator>(</operator><name>CKCNSTRNT_ROWID</name><operator>|</operator><name>CKCNSTRNT_COLUMN</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>!</operator><name><name>w</name><operator>.</operator><name>eCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to do constraint checks prior to an INSERT or an UPDATE
** on table pTab.
**
** The regNewData parameter is the first register in a range that contains
** the data to be inserted or the data after the update.  There will be
** pTab-&gt;nCol+1 registers in this range.  The first register (the one
** that regNewData points to) will contain the new rowid, or NULL in the
** case of a WITHOUT ROWID table.  The second register in the range will
** contain the content of the first table column.  The third register will
** contain the content of the second table column.  And so forth.
**
** The regOldData parameter is similar to regNewData except that it contains
** the data prior to an UPDATE rather than afterwards.  regOldData is zero
** for an INSERT.  This routine can distinguish between UPDATE and INSERT by
** checking regOldData for zero.
**
** For an UPDATE, the pkChng boolean is true if the true primary key (the
** rowid for a normal table or the PRIMARY KEY for a WITHOUT ROWID table)
** might be modified by the UPDATE.  If pkChng is false, then the key of
** the iDataCur content table is guaranteed to be unchanged by the UPDATE.
**
** For an INSERT, the pkChng boolean indicates whether or not the rowid
** was explicitly specified as part of the INSERT statement.  If pkChng
** is zero, it means that the either rowid is computed automatically or
** that the table is a WITHOUT ROWID table and has no rowid.  On an INSERT,
** pkChng will only be true if the INSERT statement provides an integer
** value for either the rowid column or its INTEGER PRIMARY KEY alias.
**
** The code generated by this routine will store new index entries into
** registers identified by aRegIdx[].  No index entry is created for
** indices where aRegIdx[i]==0.  The order of indices in aRegIdx[] is
** the same as the order of indices on the linked list of indices
** at pTab-&gt;pIndex.
**
** The caller must have already opened writeable cursors on the main
** table and all applicable indices (that is to say, all indices for which
** aRegIdx[] is not zero).  iDataCur is the cursor for the main table when
** inserting or updating a rowid table, or the cursor for the PRIMARY KEY
** index when operating on a WITHOUT ROWID table.  iIdxCur is the cursor
** for the first index in the pTab-&gt;pIndex list.  Cursors for other indices
** are at iIdxCur+N for the N-th element of the pTab-&gt;pIndex list.
**
** This routine also generates code to check constraints.  NOT NULL,
** CHECK, and UNIQUE constraints are all checked.  If a constraint fails,
** then the appropriate action is performed.  There are five possible
** actions: ROLLBACK, ABORT, FAIL, REPLACE, and IGNORE.
**
**  Constraint type  Action       What Happens
**  ---------------  ----------   ----------------------------------------
**  any              ROLLBACK     The current transaction is rolled back and
**                                sqlite3_step() returns immediately with a
**                                return code of SQLITE_CONSTRAINT.
**
**  any              ABORT        Back out changes from the current command
**                                only (do not do a complete rollback) then
**                                cause sqlite3_step() to return immediately
**                                with SQLITE_CONSTRAINT.
**
**  any              FAIL         Sqlite3_step() returns immediately with a
**                                return code of SQLITE_CONSTRAINT.  The
**                                transaction is not rolled back and any
**                                changes to prior rows are retained.
**
**  any              IGNORE       The attempt in insert or update the current
**                                row is skipped, without throwing an error.
**                                Processing continues with the next row.
**                                (There is an immediate jump to ignoreDest.)
**
**  NOT NULL         REPLACE      The NULL value is replace by the default
**                                value for that column.  If the default value
**                                is NULL, the action is the same as ABORT.
**
**  UNIQUE           REPLACE      The other row that conflicts with the row
**                                being inserted is removed.
**
**  CHECK            REPLACE      Illegal.  The results in an exception.
**
** Which action to take is determined by the overrideError parameter.
** Or if overrideError==OE_Default, then the pParse-&gt;onError parameter
** is used.  Or if pParse-&gt;onError==OE_Default then the onError value
** for the constraint is used.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3GenerateConstraintChecks</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,         <comment type="block">/* The table being inserted or updated */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aRegIdx</name></decl></parameter>,        <comment type="block">/* Use register aRegIdx[i] for index i.  0 for unused */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDataCur</name></decl></parameter>,        <comment type="block">/* Canonical data cursor (main table or PK index) */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCur</name></decl></parameter>,         <comment type="block">/* First index cursor */</comment>
  <parameter><decl><type><name>int</name></type> <name>regNewData</name></decl></parameter>,      <comment type="block">/* First register in a range holding values to insert */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOldData</name></decl></parameter>,      <comment type="block">/* Previous content.  0 for INSERTs */</comment>
  <parameter><decl><type><name>u8</name></type> <name>pkChng</name></decl></parameter>,           <comment type="block">/* Non-zero if the rowid or PRIMARY KEY changed */</comment>
  <parameter><decl><type><name>u8</name></type> <name>overrideError</name></decl></parameter>,    <comment type="block">/* Override onError to this if not OE_Default */</comment>
  <parameter><decl><type><name>int</name></type> <name>ignoreDest</name></decl></parameter>,      <comment type="block">/* Jump to this label on an OE_Ignore resolution */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbMayReplace</name></decl></parameter>,   <comment type="block">/* OUT: Set to true if constraint may cause a replace */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiChng</name></decl></parameter>          <comment type="block">/* column i is unchanged if aiChng[i]&lt;0 */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>             <comment type="block">/* VDBE under constrution */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>         <comment type="block">/* Pointer to one of the indices */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* The PRIMARY KEY index */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>         <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>               <comment type="block">/* loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ix</name></decl>;</decl_stmt>              <comment type="block">/* Index loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>            <comment type="block">/* Number of columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>onError</name></decl>;</decl_stmt>         <comment type="block">/* Conflict resolution strategy */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>           <comment type="block">/* Address of jump instruction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>seenReplace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* True if REPLACE is used to resolve INT PK conflict */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPkField</name></decl>;</decl_stmt>        <comment type="block">/* Number of fields in PRIMARY KEY. 1 for ROWID tables */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ipkTop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Top of the rowid change constraint check */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ipkBottom</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Bottom of the rowid change constraint check */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isUpdate</name></decl>;</decl_stmt>         <comment type="block">/* True if this is an UPDATE operation */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bAffinityDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* True if the OP_Affinity operation has been run */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Register holding ROWID value */</comment>

  <expr_stmt><expr><name>isUpdate</name> <operator>=</operator> <name>regOldData</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* This table is not a VIEW */</comment>
  <expr_stmt><expr><name>nCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  
  <comment type="block">/* pPk is the PRIMARY KEY index for WITHOUT ROWID tables and NULL for
  ** normal rowid tables.  nPkField is the number of key fields in the 
  ** pPk index or 1 for a rowid table.  In other words, nPkField is the
  ** number of fields in the true primary key of the table. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pPk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPkField</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pPk</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPkField</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Record that this module has started */</comment>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"BEGIN: GenCnstCks(%d,%d,%d,%d,%d)"</literal><operator>,</operator>
                     <name>iDataCur</name><operator>,</operator> <name>iIdxCur</name><operator>,</operator> <name>regNewData</name><operator>,</operator> <name>regOldData</name><operator>,</operator> <name>pkChng</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Test all NOT NULL constraints.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
      <continue>continue;</continue>        <comment type="block">/* ROWID is never NULL */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>aiChng</name> <operator>&amp;&amp;</operator> <name><name>aiChng</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Don't bother checking for NOT NULL on columns that do not change */</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>onError</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>notNull</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_None</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* This column is allowed to be NULL */</comment>
    <if_stmt><if>if<condition>( <expr><name>overrideError</name><operator>!=</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>overrideError</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Replace</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pDflt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Rollback</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Abort</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Fail</name>
        <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Ignore</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Replace</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>onError</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OE_Abort</name></expr>:</case>
        <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OE_Rollback</name></expr>:</case>
      <case>case <expr><name>OE_Fail</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
                                    <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_HaltIfNull</name></expr></argument>, <argument><expr><name>SQLITE_CONSTRAINT_NOTNULL</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>,
                          <argument><expr><name>regNewData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>P5_ConstraintNotNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>OE_Ignore</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regNewData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>ignoreDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Replace</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>regNewData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pDflt</name></expr></argument>, <argument><expr><name>regNewData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></for>

  <comment type="block">/* Test all CHECK constraints
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pCheck</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_IgnoreChecks</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pCheck</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>pCheck</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>ckBase</name></name> <operator>=</operator> <name>regNewData</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>onError</name> <operator>=</operator> <ternary><condition><expr><name>overrideError</name><operator>!=</operator><name>OE_Default</name></expr> ?</condition><then> <expr><name>overrideError</name></expr> </then><else>: <expr><name>OE_Abort</name></expr></else></ternary></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCheck</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>allOk</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pCheck</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>aiChng</name> <operator>&amp;&amp;</operator> <call><name>checkConstraintUnchanged</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>aiChng</name></expr></argument>, <argument><expr><name>pkChng</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>allOk</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>allOk</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Ignore</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ignoreDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pCheck</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zName</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Replace</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* IMP: R-15569-63625 */</comment>
        <expr_stmt><expr><call><name>sqlite3HaltConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_CONSTRAINT_CHECK</name></expr></argument>,
                              <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>P4_TRANSIENT</name></expr></argument>,
                              <argument><expr><name>P5_ConstraintCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>allOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_CHECK) */</comment>

  <comment type="block">/* If rowid is changing, make sure the new rowid does not previously
  ** exist in the table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pkChng</name> <operator>&amp;&amp;</operator> <name>pPk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addrRowidOk</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Figure out what action to take in case of a rowid collision */</comment>
    <expr_stmt><expr><name>onError</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>keyConf</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>overrideError</name><operator>!=</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>overrideError</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>isUpdate</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* pkChng!=0 does not mean that the rowid has change, only that
      ** it might have changed.  Skip the conflict logic below if the rowid
      ** is unchanged. */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Eq</name></expr></argument>, <argument><expr><name>regNewData</name></expr></argument>, <argument><expr><name>addrRowidOk</name></expr></argument>, <argument><expr><name>regOldData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the response to a rowid conflict is REPLACE but the response
    ** to some other UNIQUE constraint is FAIL or IGNORE, then we need
    ** to defer the running of the rowid conflict checking until after
    ** the UNIQUE constraints have run.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Replace</name> <operator>&amp;&amp;</operator> <name>overrideError</name><operator>!=</operator><name>OE_Replace</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name><operator>==</operator><name>OE_Ignore</name> <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name><operator>==</operator><name>OE_Fail</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>ipkTop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check to see if the new rowid already exists in the table.  Skip
    ** the following conflict logic if it does not. */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>addrRowidOk</name></expr></argument>, <argument><expr><name>regNewData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate code that deals with a rowid collision */</comment>
    <switch>switch<condition>( <expr><name>onError</name></expr> )</condition><block>{<block_content>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
        <comment type="block">/* Fall thru into the next case */</comment>
      </block_content>}</block>
      <case>case <expr><name>OE_Rollback</name></expr>:</case>
      <case>case <expr><name>OE_Abort</name></expr>:</case>
      <case>case <expr><name>OE_Fail</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RowidConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>OE_Replace</name></expr>:</case> <block>{<block_content>
        <comment type="block">/* If there are DELETE triggers on this table and the
        ** recursive-triggers flag is set, call GenerateRowDelete() to
        ** remove the conflicting row from the table. This will fire
        ** the triggers and remove both the table and index b-tree entries.
        **
        ** Otherwise, if there are no triggers or the recursive-triggers
        ** flag is not set, but the table has one or more indexes, call 
        ** GenerateRowIndexDelete(). This removes the index b-tree entries 
        ** only. The table b-tree entry will be replaced by the new entry 
        ** when it is inserted.  
        **
        ** If either GenerateRowDelete() or GenerateRowIndexDelete() is called,
        ** also invoke MultiWrite() to indicate that this VDBE may require
        ** statement rollback (if the statement is aborted after the delete
        ** takes place). Earlier versions called sqlite3MultiWrite() regardless,
        ** but being more selective here allows statements like:
        **
        **   REPLACE INTO t(rowid) VALUES($newrowid)
        **
        ** to run without a statement journal if there are no indexes on the
        ** table.
        */</comment>
        <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_RecTriggers</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <call><name>sqlite3TriggersExist</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>TK_DELETE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pTrigger</name> <operator>||</operator> <call><name>sqlite3FkRequired</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3GenerateRowDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,
                                   <argument><expr><name>regNewData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OE_Replace</name></expr></argument>,
                                   <argument><expr><name>ONEPASS_SINGLE</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3GenerateRowIndexDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>seenReplace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>OE_Ignore</name></expr>:</case> <block>{<block_content>
        <comment type="block">/*assert( seenReplace==0 );*/</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ignoreDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrRowidOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>ipkTop</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>ipkBottom</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ipkTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Test all UNIQUE constraints by creating entries for each UNIQUE
  ** index and making sure that duplicate entries do not already exist.
  ** Compute the revised record entries for indices as we go.
  **
  ** This loop also handles the case of the PRIMARY KEY index for a
  ** WITHOUT ROWID table.
  */</comment>
  <for>for<control>(<init><expr><name>ix</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>ix</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regIdx</name></decl>;</decl_stmt>          <comment type="block">/* Range of registers hold conent for pIdx */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regR</name></decl>;</decl_stmt>            <comment type="block">/* Range of registers holding conflicting PK */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iThisCur</name></decl>;</decl_stmt>        <comment type="block">/* Cursor for this UNIQUE index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrUniqueOk</name></decl>;</decl_stmt>    <comment type="block">/* Jump here if the UNIQUE constraint is satisfied */</comment>

    <if_stmt><if>if<condition>( <expr><name><name>aRegIdx</name><index>[<expr><name>ix</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Skip indices that do not change */</comment>
    <if_stmt><if>if<condition>( <expr><name>bAffinityDone</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3TableAffinity</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regNewData</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bAffinityDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iThisCur</name> <operator>=</operator> <name>iIdxCur</name><operator>+</operator><name>ix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrUniqueOk</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Skip partial indices for which the WHERE clause is not true */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aRegIdx</name><index>[<expr><name>ix</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>ckBase</name></name> <operator>=</operator> <name>regNewData</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalseDup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>,
                            <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>ckBase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create a record for this index entry as it should appear after
    ** the insert or update.  Store that record in the aRegIdx[ix] register
    */</comment>
    <expr_stmt><expr><name>regIdx</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iField</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iField</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>ckBase</name></name> <operator>=</operator> <name>regNewData</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regIdx</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>ckBase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s column %d"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iField</name><operator>==</operator><name>XN_ROWID</name> <operator>||</operator> <name>iField</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>regRowid</name><operator>==</operator><name>regIdx</name><operator>+</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* ROWID already in regIdx+i */</comment>
          <expr_stmt><expr><name>x</name> <operator>=</operator> <name>regNewData</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>regRowid</name> <operator>=</operator>  <ternary><condition><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>regIdx</name><operator>+</operator><name>i</name></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>x</name> <operator>=</operator> <name>iField</name> <operator>+</operator> <name>regNewData</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>iField</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>OP_IntCopy</name></expr> </then><else>: <expr><name>OP_SCopy</name></expr></else></ternary></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>regIdx</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <ternary><condition><expr><name>iField</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"rowid"</literal></expr> </then><else>: <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name><name>aRegIdx</name><index>[<expr><name>ix</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"for %s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* In an UPDATE operation, if this index is the PRIMARY KEY index 
    ** of a WITHOUT ROWID table and there has been no change the
    ** primary key, then no collision is possible.  The collision detection
    ** logic below can all be skipped. */</comment>
    <if_stmt><if>if<condition>( <expr><name>isUpdate</name> <operator>&amp;&amp;</operator> <name>pPk</name><operator>==</operator><name>pIdx</name> <operator>&amp;&amp;</operator> <name>pkChng</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find out what action to take in case there is a uniqueness conflict */</comment>
    <expr_stmt><expr><name>onError</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_None</name></expr> )</condition><block>{<block_content> 
      <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>  <comment type="block">/* pIdx is not a UNIQUE index */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>overrideError</name><operator>!=</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>overrideError</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Check to see if the new index entry will be unique */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NoConflict</name></expr></argument>, <argument><expr><name>iThisCur</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>,
                         <argument><expr><name>regIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate code to handle collisions */</comment>
    <expr_stmt><expr><name>regR</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>pIdx</name><operator>==</operator><name>pPk</name><operator>)</operator></expr> ?</condition><then> <expr><name>regIdx</name></expr> </then><else>: <expr><call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nPkField</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isUpdate</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Replace</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxRowid</name></expr></argument>, <argument><expr><name>iThisCur</name></expr></argument>, <argument><expr><name>regR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Conflict only if the rowid of the existing index entry
        ** is different from old-rowid */</comment>
        <if_stmt><if>if<condition>( <expr><name>isUpdate</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Eq</name></expr></argument>, <argument><expr><name>regR</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>, <argument><expr><name>regOldData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
        <comment type="block">/* Extract the PRIMARY KEY from the end of the index entry and
        ** store it in registers regR..regR+nPk-1 */</comment>
        <if_stmt><if>if<condition>( <expr><name>pIdx</name><operator>!=</operator><name>pPk</name></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3ColumnOfIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iThisCur</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>regR</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s.%s"</literal><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator>
                         <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>zName</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>isUpdate</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* If currently processing the PRIMARY KEY of a WITHOUT ROWID 
          ** table, only conflict if the new PRIMARY KEY values are actually
          ** different from the old.
          **
          ** For a UNIQUE index, only conflict if the PRIMARY KEY values
          ** of the matched index row are different from the original PRIMARY
          ** KEY values of this row before the update.  */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>addrJump</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name>OP_Ne</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>regCmp</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>regIdx</name></expr> </then><else>: <expr><name>regR</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p4</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><operator>(</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>addrJump</name> <operator>=</operator> <name>addrUniqueOk</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_Eq</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, 
                <argument><expr><name>regOldData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>x</name></expr></argument>, <argument><expr><name>addrJump</name></expr></argument>, <argument><expr><name>regCmp</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>p4</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Generate code that executes if the new index entry is not unique */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Rollback</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Abort</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Fail</name>
        <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Ignore</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Replace</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>onError</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OE_Rollback</name></expr>:</case>
      <case>case <expr><name>OE_Abort</name></expr>:</case>
      <case>case <expr><name>OE_Fail</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3UniqueConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>OE_Ignore</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ignoreDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Replace</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_RecTriggers</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <call><name>sqlite3TriggersExist</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>TK_DELETE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3GenerateRowDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,
            <argument><expr><name>regR</name></expr></argument>, <argument><expr><name>nPkField</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OE_Replace</name></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name>pIdx</name><operator>==</operator><name>pPk</name></expr> ?</condition><then> <expr><name>ONEPASS_SINGLE</name></expr> </then><else>: <expr><name>ONEPASS_OFF</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>seenReplace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>regR</name><operator>!=</operator><name>regIdx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regR</name></expr></argument>, <argument><expr><name>nPkField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>ipkTop</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ipkTop</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ipkBottom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><operator>*</operator><name>pbMayReplace</name> <operator>=</operator> <name>seenReplace</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"END: GenCnstCks(%d)"</literal><operator>,</operator> <name>seenReplace</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine generates code to finish the INSERT or UPDATE operation
** that was started by a prior call to sqlite3GenerateConstraintChecks.
** A consecutive range of registers starting at regNewData contains the
** rowid and the content to be inserted.
**
** The arguments to this routine should be the same as the first six
** arguments to sqlite3GenerateConstraintChecks.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CompleteInsertion</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,        <comment type="block">/* the table into which we are inserting */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDataCur</name></decl></parameter>,       <comment type="block">/* Cursor of the canonical data source */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCur</name></decl></parameter>,        <comment type="block">/* First index cursor */</comment>
  <parameter><decl><type><name>int</name></type> <name>regNewData</name></decl></parameter>,     <comment type="block">/* Range of content */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aRegIdx</name></decl></parameter>,       <comment type="block">/* Register used by each index.  0 for unused indices */</comment>
  <parameter><decl><type><name>int</name></type> <name>isUpdate</name></decl></parameter>,       <comment type="block">/* True for UPDATE, False for INSERT */</comment>
  <parameter><decl><type><name>int</name></type> <name>appendBias</name></decl></parameter>,     <comment type="block">/* True if this is likely to be an append */</comment>
  <parameter><decl><type><name>int</name></type> <name>useSeekResult</name></decl></parameter>   <comment type="block">/* True to set the USESEEKRESULT flag on OP_[Idx]Insert */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>            <comment type="block">/* Prepared statements under construction */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>        <comment type="block">/* An index being inserted or updated */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>pik_flags</name></decl>;</decl_stmt>       <comment type="block">/* flag values passed to the btree insert */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regData</name></decl>;</decl_stmt>        <comment type="block">/* Content registers (after the rowid) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRec</name></decl>;</decl_stmt>         <comment type="block">/* Register holding assembled record for the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>              <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bAffinityDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* True if OP_Affinity has been run already */</comment>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* This table is not a VIEW */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>bAffinityDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iIdxCur</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pik_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>useSeekResult</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pik_flags</name> <operator>=</operator> <name>OPFLAG_USESEEKRESULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pik_flags</name> <operator>|=</operator> <name>OPFLAG_NCHANGE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pik_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>regData</name> <operator>=</operator> <name>regNewData</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>regRec</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bAffinityDone</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3TableAffinity</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pik_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pik_flags</name> <operator>=</operator> <name>OPFLAG_NCHANGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pik_flags</name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name>isUpdate</name></expr>?</condition><then><expr><name>OPFLAG_ISUPDATE</name></expr></then><else>:<expr><name>OPFLAG_LASTROWID</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>appendBias</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pik_flags</name> <operator>|=</operator> <name>OPFLAG_APPEND</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>useSeekResult</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pik_flags</name> <operator>|=</operator> <name>OPFLAG_USESEEKRESULT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>, <argument><expr><name>regNewData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>P4_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pik_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate cursors for the pTab table and all its indices and generate
** code to open and initialized those cursors.
**
** The cursor for the object that contains the complete data (normally
** the table itself, but the PRIMARY KEY index in the case of a WITHOUT
** ROWID table) is returned in *piDataCur.  The first index cursor is
** returned in *piIdxCur.  The number of indices is returned.
**
** Use iBase as the first cursor (either the *piDataCur for rowid tables
** or the first index for WITHOUT ROWID tables) if it is non-negative.
** If iBase is negative, then allocate the next available cursor.
**
** For a rowid table, *piDataCur will be exactly one less than *piIdxCur.
** For a WITHOUT ROWID table, *piDataCur will be somewhere in the range
** of *piIdxCurs, depending on where the PRIMARY KEY index appears on the
** pTab-&gt;pIndex list.
**
** If pTab is a virtual table, then this routine is a no-op and the
** *piDataCur and *piIdxCur values are left uninitialized.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3OpenTableAndIndices</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,   <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,     <comment type="block">/* Table to be opened */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,          <comment type="block">/* OP_OpenRead or OP_OpenWrite */</comment>
  <parameter><decl><type><name>u8</name></type> <name>p5</name></decl></parameter>,           <comment type="block">/* P5 value for OP_Open* opcodes (except on WITHOUT ROWID) */</comment>
  <parameter><decl><type><name>int</name></type> <name>iBase</name></decl></parameter>,       <comment type="block">/* Use this for the table cursor, if there is one */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aToOpen</name></decl></parameter>,     <comment type="block">/* If not NULL: boolean for each table and index */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piDataCur</name></decl></parameter>,  <comment type="block">/* Write the database source cursor number here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piIdxCur</name></decl></parameter>    <comment type="block">/* Write the first index cursor number here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDataCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_OpenRead</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_OpenWrite</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_OpenWrite</name> <operator>||</operator> <name>p5</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* This routine is a no-op for virtual tables. Leave the output
    ** variables *piDataCur and *piIdxCur uninitialized so that valgrind
    ** can detect if they are used by mistake in the caller. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iBase</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iBase</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iDataCur</name> <operator>=</operator> <name>iBase</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>piDataCur</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piDataCur</name> <operator>=</operator> <name>iDataCur</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>aToOpen</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>aToOpen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_OpenWrite</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>piIdxCur</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piIdxCur</name> <operator>=</operator> <name>iBase</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name> <init>= <expr><name>iBase</name><operator>++</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aToOpen</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>aToOpen</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>piDataCur</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piDataCur</name> <operator>=</operator> <name>iIdxCur</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>iBase</name><operator>&gt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name> <operator>=</operator> <name>iBase</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** The following global variable is incremented whenever the
** transfer optimization is used.  This is used for testing
** purposes only - to make sure the transfer optimization really
** is happening when it is supposed to.
*/</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_xferopt_count</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_TEST */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_XFER_OPT</name></cpp:ifndef>
<comment type="block">/*
** Check to see if index pSrc is compatible as a source of data
** for index pDest in an insert transfer optimization.  The rules
** for a compatible index:
**
**    *   The index is over the same set of columns
**    *   The same DESC and ASC markings occurs on all columns
**    *   The same onError processing (OE_Abort, OE_Ignore, etc)
**    *   The same collating sequence on each column
**    *   The index has the exact same WHERE clause
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>xferCompatibleIndex</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDest</name> <operator>&amp;&amp;</operator> <name>pSrc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pTable</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different number of columns */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>onError</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>onError</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different conflict resolution strategies */</comment>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>pDest</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different columns indexed */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDest</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>,
                             <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different expressions in the index */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>pDest</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different sort orders */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different collating sequences */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>     <comment type="block">/* Different WHERE clauses */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If no test above fails then the indices must be compatible */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt the transfer optimization on INSERTs of the form
**
**     INSERT INTO tab1 SELECT * FROM tab2;
**
** The xfer optimization transfers raw records from tab2 over to tab1.  
** Columns are not decoded and reassembled, which greatly improves
** performance.  Raw index records are transferred in the same way.
**
** The xfer optimization is only attempted if tab1 and tab2 are compatible.
** There are lots of rules for determining compatibility - see comments
** embedded in the code for details.
**
** This routine returns TRUE if the optimization is guaranteed to be used.
** Sometimes the xfer optimization will only work if the destination table
** is empty - a factor that can only be determined at run-time.  In that
** case, this routine generates code for the xfer optimization but also
** does a test to see if the destination table is empty and jumps over the
** xfer optimization code if the test fails.  In that case, this routine
** returns FALSE so that the caller will know to go ahead and generate
** an unoptimized transfer.  This routine also returns FALSE if there
** is no chance that the xfer optimization can be applied.
**
** This optimization is particularly useful at making VACUUM run faster.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>xferOptimization</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parser context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>,         <comment type="block">/* The table we are inserting into */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* A SELECT statement to use as the data source */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,          <comment type="block">/* How to handle constraint errors */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDbDest</name></decl></parameter>           <comment type="block">/* The database of pDest */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>                <comment type="block">/* The result set of the SELECT */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>                     <comment type="block">/* The table in the FROM clause of SELECT */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pSrcIdx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pDestIdx</name></decl>;</decl_stmt>       <comment type="block">/* Source and destination indices */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>      <comment type="block">/* An element of pSelect-&gt;pSrc */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                           <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDbSrc</name></decl>;</decl_stmt>                      <comment type="block">/* The database of pSrc */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSrc</name></decl>, <decl><type ref="prev"/><name>iDest</name></decl>;</decl_stmt>                 <comment type="block">/* Cursors from source and destination */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>, <decl><type ref="prev"/><name>addr2</name></decl>;</decl_stmt>                <comment type="block">/* Loop addresses */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>emptyDestTest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Address of test for empty pDest */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>emptySrcTest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Address of test for empty pSrc */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>                         <comment type="block">/* The VDBE we are building */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regAutoinc</name></decl>;</decl_stmt>                  <comment type="block">/* Memory register used by AUTOINC */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>destHasUniqueIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* True if pDest has a UNIQUE index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regData</name></decl>, <decl><type ref="prev"/><name>regRowid</name></decl>;</decl_stmt>           <comment type="block">/* Registers holding data and rowid */</comment>

  <if_stmt><if>if<condition>( <expr><name>pSelect</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Must be of the form  INSERT INTO ... SELECT ... */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>||</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pWith</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Do not attempt to process this query if there are an WITH clauses
    ** attached to it. Proceeding may generate a false "no such table: xxx"
    ** error if pSelect reads from a CTE named "xxx".  */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3TriggerList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* tab1 must not have triggers */</comment>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Virtual</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* tab1 must not be a virtual table */</comment>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>onError</name> <operator>=</operator> <name><name>pDest</name><operator>-&gt;</operator><name>keyConf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* allocated even if there is no FROM clause */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* FROM clause must have exactly one term */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* FROM clause cannot contain a subquery */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWhere</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not have a WHERE clause */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not have an ORDER BY clause */</comment>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Do not need to test for a HAVING clause.  If HAVING is present but
  ** there is no ORDER BY, we will get an error. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not have a GROUP BY clause */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not have a LIMIT clause */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pOffset</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Must be so if pLimit==0 */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not be a compound query */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not be DISTINCT */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* The result set must have exactly one column */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_ASTERISK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* The result set must be the special operator "*" */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* At this point we have established that the statement is of the
  ** correct syntactic form to participate in this optimization.  Now
  ** we have to check the semantics.
  */</comment>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSrc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* FROM clause does not contain a real table */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSrc</name><operator>==</operator><name>pDest</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* tab1 and tab2 may not be the same table */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* source and destination must both be WITHOUT ROWID or not */</comment>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Virtual</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* tab2 must not be a virtual table */</comment>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>pSelect</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* tab2 may not be a view */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>nCol</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Number of columns must be the same in tab1 and tab2 */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>iPKey</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Both tables must have the same INTEGER PRIMARY KEY */</comment>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pDest</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pDestCol</name> <init>= <expr><operator>&amp;</operator><name><name>pDest</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pSrcCol</name> <init>= <expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_HIDDEN_COLUMNS</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_Vacuum</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pDestCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|</operator> <name><name>pSrcCol</name><operator>-&gt;</operator><name>colFlags</name></name><operator>)</operator> <operator>&amp;</operator> <name>COLFLAG_HIDDEN</name></expr> 
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Neither table may have __hidden__ columns */</comment>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pDestCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>!=</operator><name><name>pSrcCol</name><operator>-&gt;</operator><name>affinity</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Affinity must be the same on all columns */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pDestCol</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>, <argument><expr><name><name>pSrcCol</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Collating sequence must be the same on all columns */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDestCol</name><operator>-&gt;</operator><name>notNull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pSrcCol</name><operator>-&gt;</operator><name>notNull</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* tab2 must be NOT NULL if tab1 is */</comment>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Default values for second and subsequent columns need to match. */</comment>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>pDestCol</name><operator>-&gt;</operator><name>zDflt</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>!=</operator><operator>(</operator><name><name>pSrcCol</name><operator>-&gt;</operator><name>zDflt</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> 
         <operator>||</operator> <operator>(</operator><name><name>pDestCol</name><operator>-&gt;</operator><name>zDflt</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pDestCol</name><operator>-&gt;</operator><name>zDflt</name></name></expr></argument>, <argument><expr><name><name>pSrcCol</name><operator>-&gt;</operator><name>zDflt</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Default values must be the same for all columns */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>pDestIdx</name><operator>=</operator><name><name>pDest</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pDestIdx</name></expr>;</condition> <incr><expr><name>pDestIdx</name><operator>=</operator><name><name>pDestIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pDestIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>destHasUniqueIdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>pSrcIdx</name><operator>=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pSrcIdx</name></expr>;</condition> <incr><expr><name>pSrcIdx</name><operator>=</operator><name><name>pSrcIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>xferCompatibleIndex</name><argument_list>(<argument><expr><name>pDestIdx</name></expr></argument>, <argument><expr><name>pSrcIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pSrcIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* pDestIdx has no corresponding index in pSrc */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>pCheck</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprListCompare</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>,<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Tables have different CHECK constraints.  Ticket #2252 */</comment>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
  <comment type="block">/* Disallow the transfer optimization if the destination table constains
  ** any foreign key constraints.  This is more restrictive than necessary.
  ** But the main beneficiary of the transfer optimization is the VACUUM 
  ** command, and the VACUUM command disables foreign key constraints.  So
  ** the extra complication to make this rule less restrictive is probably
  ** not worth the effort.  Ticket [6284df89debdfa61db8073e062908af0c9b6118e]
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_ForeignKeys</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDest</name><operator>-&gt;</operator><name>pFKey</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_CountRows</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* xfer opt does not play well with PRAGMA count_changes */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we get this far, it means that the xfer optimization is at
  ** least a possibility, though it might only work if the destination
  ** table (tab1) is initially empty.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_xferopt_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>iDbSrc</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDbSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iSrc</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDest</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>regAutoinc</name> <operator>=</operator> <call><name>autoIncBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDbDest</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regData</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>iDbDest</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>destHasUniqueIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_Vacuum</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator>
      <operator>(</operator><name><name>pDest</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDest</name><operator>-&gt;</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator>          <comment type="block">/* (1) */</comment>
   <operator>||</operator> <name>destHasUniqueIdx</name>                              <comment type="block">/* (2) */</comment>
   <operator>||</operator> <operator>(</operator><name>onError</name><operator>!=</operator><name>OE_Abort</name> <operator>&amp;&amp;</operator> <name>onError</name><operator>!=</operator><name>OE_Rollback</name><operator>)</operator>   <comment type="block">/* (3) */</comment>
  <operator>)</operator></expr>)</condition><block>{<block_content>
    <comment type="block">/* In some circumstances, we are able to run the xfer optimization
    ** only if the destination table is initially empty. Unless the
    ** SQLITE_Vacuum flag is set, this block generates code to make
    ** that determination. If SQLITE_Vacuum is set, then the destination
    ** table is always empty.
    **
    ** Conditions under which the destination must be empty:
    **
    ** (1) There is no INTEGER PRIMARY KEY but there are indices.
    **     (If the destination is not initially empty, the rowid fields
    **     of index entries might need to change.)
    **
    ** (2) The destination has a unique index.  (The xfer optimization 
    **     is unable to test uniqueness.)
    **
    ** (3) onError is something other than OE_Abort and OE_Rollback.
    */</comment>
    <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>emptyDestTest</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>iDbSrc</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>emptySrcTest</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addr2</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3RowidConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>autoIncStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regAutoinc</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>pIndex</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDest</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Autoincrement</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowData</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>,
                      <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_NCHANGE</name><operator>|</operator><name>OPFLAG_LASTROWID</name><operator>|</operator><name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDbDest</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDbSrc</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>pDestIdx</name><operator>=</operator><name><name>pDest</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pDestIdx</name></expr>;</condition> <incr><expr><name>pDestIdx</name><operator>=</operator><name><name>pDestIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>idxInsFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pSrcIdx</name><operator>=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pSrcIdx</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pSrcIdx</name><operator>=</operator><name><name>pSrcIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>xferCompatibleIndex</name><argument_list>(<argument><expr><name>pDestIdx</name></expr></argument>, <argument><expr><name>pSrcIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrcIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name><name>pSrcIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDbSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrcIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pSrcIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name><name>pDestIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDbDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDestIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_BULKCSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pDestIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowKey</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_Vacuum</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This INSERT command is part of a VACUUM operation, which guarantees
      ** that the destination table is empty. If all indexed columns use
      ** collation sequence BINARY, then it can also be assumed that the
      ** index will be populated by inserting keys in strictly sorted 
      ** order. In this case, instead of seeking within the b-tree as part
      ** of every OP_IdxInsert opcode, an OP_Last is added before the
      ** OP_IdxInsert to seek to the point within the b-tree where each key 
      ** should be inserted. This is faster.
      **
      ** If any of the indexed columns use a collation sequence other than
      ** BINARY, this optimization is disabled. This is because the user 
      ** might change the definition of a collation sequence and then run
      ** a VACUUM command. In that case keys may not be written in strictly
      ** sorted order.  */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrcIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><name><name>pSrcIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal>
                    <operator>||</operator> <name>sqlite3StrBINARY</name><operator>==</operator><name>zColl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pSrcIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>idxInsFlags</name> <operator>=</operator> <name>OPFLAG_USESEEKRESULT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Last</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pDestIdx</name><operator>-&gt;</operator><name>idxType</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>idxInsFlags</name> <operator>|=</operator> <name>OPFLAG_NCHANGE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>idxInsFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>addr1</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>emptySrcTest</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>emptySrcTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>emptyDestTest</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>emptyDestTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_XFER_OPT */</comment>
</unit>
