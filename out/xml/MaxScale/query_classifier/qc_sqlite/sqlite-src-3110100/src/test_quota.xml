<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/test_quota.c"><comment type="block">/*
** 2010 September 31
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains a VFS "shim" - a layer that sits in between the
** pager and the real VFS.
**
** This particular shim enforces a quota system on files.  One or more
** database files are in a "quota group" that is defined by a GLOB
** pattern.  A quota is set for the combined size of all files in the
** the group.  A quota of zero means "no limit".  If the total size
** of all files in the quota group is greater than the limit, then
** write requests that attempt to enlarge a file fail with SQLITE_FULL.
**
** However, before returning SQLITE_FULL, the write requests invoke
** a callback function that is configurable for each quota group.
** This callback has the opportunity to enlarge the quota.  If the
** callback does enlarge the quota such that the total size of all
** files within the group is less than the new quota, then the write
** continues as if nothing had happened.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"test_quota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** For an build without mutexes, no-op the mutex calls.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>==</operator><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_mutex_alloc</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>((sqlite3_mutex*)8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_mutex_free</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_mutex_enter</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_mutex_try</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>SQLITE_OK</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_mutex_leave</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_mutex_held</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>((void)(X),1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_mutex_notheld</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((void)(X),1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_THREADSAFE==0 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os_setup.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_UNIX</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"os_win.h"</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block" format="doxygen">/************************ Object Definitions ******************************/</comment>

<comment type="block">/* Forward declaration of all object types */</comment>
<typedef>typedef <type><name><name>struct</name> <name>quotaGroup</name></name></type> <name>quotaGroup</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>quotaConn</name></name></type> <name>quotaConn</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>quotaFile</name></name></type> <name>quotaFile</name>;</typedef>

<comment type="block">/*
** A "quota group" is a collection of files whose collective size we want
** to limit.  Each quota group is defined by a GLOB pattern.
**
** There is an instance of the following object for each defined quota
** group.  This object records the GLOB pattern that defines which files
** belong to the quota group.  The object also remembers the size limit
** for the group (the quota) and the callback to be invoked when the
** sum of the sizes of the files within the group goes over the limit.
**
** A quota group must be established (using sqlite3_quota_set(...))
** prior to opening any of the database connections that access files
** within the quota group.
*/</comment>
<struct>struct <name>quotaGroup</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>          <comment type="block">/* Filename pattern to be quotaed */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iLimit</name></decl>;</decl_stmt>          <comment type="block">/* Upper bound on total file size */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iSize</name></decl>;</decl_stmt>           <comment type="block">/* Current size of all files */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(             <comment type="block">/* Callback invoked when going over quota */</comment>
     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,         <comment type="block">/* Name of file whose size increases */</comment>
     <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piLimit</name></decl></parameter>,        <comment type="block">/* IN/OUT: The current limit */</comment>
     <parameter><decl><type><name>sqlite3_int64</name></type> <name>iSize</name></decl></parameter>,           <comment type="block">/* Total size of all files in the group */</comment>
     <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                     <comment type="block">/* Client data */</comment>
  )</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl>;</decl_stmt>                    <comment type="block">/* Third argument to the xCallback() */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>       <comment type="block">/* Optional destructor for pArg */</comment>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pNext</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>ppPrev</name></decl>;</decl_stmt>   <comment type="block">/* Doubly linked list of all quota objects */</comment>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFiles</name></decl>;</decl_stmt>             <comment type="block">/* Files within this group */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of this structure represents a single file that is part
** of a quota group.  A single file can be opened multiple times.  In
** order keep multiple openings of the same file from causing the size
** of the file to count against the quota multiple times, each file
** has a unique instance of this object and multiple open connections
** to the same file each point to a single instance of this object.
*/</comment>
<struct>struct <name>quotaFile</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>                <comment type="block">/* Name of this file */</comment>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>             <comment type="block">/* Quota group to which this file belongs */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iSize</name></decl>;</decl_stmt>            <comment type="block">/* Current size of this file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                       <comment type="block">/* Number of times this file is open */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>deleteOnClose</name></decl>;</decl_stmt>              <comment type="block">/* True to delete this file when it closes */</comment>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pNext</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>ppPrev</name></decl>;</decl_stmt>     <comment type="block">/* Linked list of files in the same group */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of the following object represents each open connection
** to a file that participates in quota tracking.  This object is a 
** subclass of sqlite3_file.  The sqlite3_file object for the underlying
** VFS is appended to this structure.
*/</comment>
<struct>struct <name>quotaConn</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_file</name></type> <name>base</name></decl>;</decl_stmt>              <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>               <comment type="block">/* The underlying file */</comment>
  <comment type="block">/* The underlying VFS sqlite3_file is appended to this object */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of the following object records the state of an
** open file.  This object is opaque to all users - the internal
** structure is only visible to the functions below.
*/</comment>
<struct>struct <name>quota_FILE</name> <block>{
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>                <comment type="block">/* Open stdio file pointer */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl>;</decl_stmt>    <comment type="block">/* Current offset into the file */</comment>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>       <comment type="block">/* The file record in the quota system */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMbcsName</name></decl>;</decl_stmt>        <comment type="block">/* Full MBCS pathname of the file */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>


<comment type="block" format="doxygen">/************************* Global Variables **********************************/</comment>
<comment type="block">/*
** All global variables used by this file are containing within the following
** gQuota structure.
*/</comment>
<struct><specifier>static</specifier> struct <block>{
  <comment type="block">/* The pOrigVfs is the real, original underlying VFS implementation.
  ** Most operations pass-through to the real VFS.  This value is read-only
  ** during operation.  It is only modified at start-time and thus does not
  ** require a mutex.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name></decl>;</decl_stmt>

  <comment type="block">/* The sThisVfs is the VFS structure used by this shim.  It is initialized
  ** at start-time and thus does not require a mutex
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_vfs</name></type> <name>sThisVfs</name></decl>;</decl_stmt>

  <comment type="block">/* The sIoMethods defines the methods used by sqlite3_file objects 
  ** associated with this shim.  It is initialized at start-time and does
  ** not require a mutex.
  **
  ** When the underlying VFS is called to open a file, it might return 
  ** either a version 1 or a version 2 sqlite3_file object.  This shim
  ** has to create a wrapper sqlite3_file of the same version.  Hence
  ** there are two I/O method structures, one for version 1 and the other
  ** for version 2.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_io_methods</name></type> <name>sIoMethodsV1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_io_methods</name></type> <name>sIoMethodsV2</name></decl>;</decl_stmt>

  <comment type="block">/* True when this shim as been initialized.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isInitialized</name></decl>;</decl_stmt>

  <comment type="block">/* For run-time access any of the other global data structures in this
  ** shim, the following mutex must be held.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_mutex</name> <modifier>*</modifier></type><name>pMutex</name></decl>;</decl_stmt>

  <comment type="block">/* List of quotaGroup objects.
  */</comment>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>

}</block> <decl><name>gQuota</name></decl>;</struct>

<comment type="block" format="doxygen">/************************* Utility Routines *********************************/</comment>
<comment type="block">/*
** Acquire and release the mutex used to serialize access to the
** list of quotaGroups.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>quotaEnter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>quotaLeave</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<comment type="block">/* Count the number of open files in a quotaGroup 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaGroupOpenFileCount</name><parameter_list>(<parameter><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>N</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name></name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>pFile</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>N</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pFile</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>N</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove a file from a quota group.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>quotaRemoveFile</name><parameter_list>(<parameter><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>-=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name><name>pFile</name><operator>-&gt;</operator><name>ppPrev</name></name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>ppPrev</name></name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>ppPrev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Remove all files from a quota group.  It is always the case that
** all files will be closed when this routine is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>quotaRemoveAllFiles</name><parameter_list>(<parameter><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaRemoveFile</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/* If the reference count and threshold for a quotaGroup are both
** zero, then destroy the quotaGroup.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>quotaGroupDeref</name><parameter_list>(<parameter><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>quotaGroupOpenFileCount</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>quotaRemoveAllFiles</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name><name>pGroup</name><operator>-&gt;</operator><name>ppPrev</name></name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>ppPrev</name></name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>ppPrev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>xDestroy</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pGroup</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if string z matches glob pattern zGlob.
**
** Globbing rules:
**
**      '*'       Matches any sequence of zero or more characters.
**
**      '?'       Matches exactly one character.
**
**     [...]      Matches one character from the enclosed list of
**                characters.
**
**     [^...]     Matches one character not in the enclosed list.
**
**     /          Matches "/" or "\\"
**
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaStrglob</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zGlob</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>, <decl><type ref="prev"/><name>cx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>invert</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>seen</name></decl>;</decl_stmt>

  <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'?'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><operator>*</operator><name>z</name> <operator>&amp;&amp;</operator> <call><name>quotaStrglob</name><argument_list>(<argument><expr><name>zGlob</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <return>return <expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>cx</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c</name><operator>==</operator><literal type="char">'/'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'\\'</literal></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>c2</name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name>c2</name><operator>!=</operator><name>c</name> <operator>&amp;&amp;</operator> <name>c2</name><operator>!=</operator><name>cx</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><call><name>quotaStrglob</name><argument_list>(<argument><expr><name>zGlob</name></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></while>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'?'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>prior_c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>invert</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="char">'^'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>invert</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <while>while<condition>( <expr><name>c2</name> <operator>&amp;&amp;</operator> <name>c2</name><operator>!=</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>zGlob</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">']'</literal> <operator>&amp;&amp;</operator> <name><name>zGlob</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>prior_c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><name>prior_c</name> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><name>c2</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>prior_c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>c2</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>prior_c</name> <operator>=</operator> <name>c2</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>seen</name> <operator>^</operator> <name>invert</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\\'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Find a quotaGroup given the filename.
**
** Return a pointer to the quotaGroup object. Return NULL if not found.
*/</comment>
<function><type><specifier>static</specifier> <name>quotaGroup</name> <modifier>*</modifier></type><name>quotaGroupFind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>gQuota</name><operator>.</operator><name>pGroup</name></name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <call><name>quotaStrglob</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zPattern</name></name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</condition>
      <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content/>}</block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Translate an sqlite3_file* that is really a quotaConn* into
** the sqlite3_file* for the underlying original VFS.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_file</name> <modifier>*</modifier></type><name>quotaSubOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>quotaConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find a file in a quota group and return a pointer to that file.
** Return NULL if the file is not in the group.
*/</comment>
<function><type><specifier>static</specifier> <name>quotaFile</name> <modifier>*</modifier></type><name>quotaFindFile</name><parameter_list>(
  <parameter><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl></parameter>,     <comment type="block">/* Group in which to look for the file */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,      <comment type="block">/* Full pathname of the file */</comment>
  <parameter><decl><type><name>int</name></type> <name>createFlag</name></decl></parameter>          <comment type="block">/* Try to create the file if not found */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name></name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>pFile</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pFile</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pFile</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>createFlag</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x3fffffff</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pFile</name> <operator>=</operator> <operator>(</operator><name>quotaFile</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pFile</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nName</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pFile</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name><operator>-&gt;</operator><name>ppPrev</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>ppPrev</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name></name> <operator>=</operator> <name>pFile</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name></name> <operator>=</operator> <name>pGroup</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pFile</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Translate UTF8 to MBCS for use in fopen() calls.  Return a pointer to the
** translated text..  Call quota_mbcs_free() to deallocate any memory
** used to store the returned pointer when done.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>quota_utf8_to_mbcs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUtf8</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>
  <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>          <comment type="block">/* Bytes in zUtf8 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWide</name></decl>;</decl_stmt>         <comment type="block">/* number of UTF-16 characters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMbcs</name></decl>;</decl_stmt>         <comment type="block">/* Bytes of MBCS */</comment>
  <decl_stmt><decl><type><name>LPWSTR</name></type> <name>zTmpWide</name></decl>;</decl_stmt>   <comment type="block">/* The UTF16 text */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMbcs</name></decl>;</decl_stmt>       <comment type="block">/* The MBCS text */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>codepage</name></decl>;</decl_stmt>      <comment type="block">/* Code page used by fopen() */</comment>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zUtf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nWide</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zUtf8</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nWide</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zTmpWide</name> <operator>=</operator> <operator>(</operator><name>LPWSTR</name><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>( <argument><expr><operator>(</operator><name>nWide</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>zTmpWide</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTmpWide</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zUtf8</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zTmpWide</name></expr></argument>, <argument><expr><name>nWide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>codepage</name> <operator>=</operator> <ternary><condition><expr><call><name>AreFileApisANSI</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>CP_ACP</name></expr> </then><else>: <expr><name>CP_OEMCP</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>nMbcs</name> <operator>=</operator> <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>codepage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zTmpWide</name></expr></argument>, <argument><expr><name>nWide</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMbcs</name> <operator>=</operator> <ternary><condition><expr><name>nMbcs</name></expr> ?</condition><then> <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>nMbcs</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zMbcs</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>codepage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zTmpWide</name></expr></argument>, <argument><expr><name>nWide</name></expr></argument>, <argument><expr><name>zMbcs</name></expr></argument>, <argument><expr><name>nMbcs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTmpWide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zMbcs</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zUtf8</name></expr>;</return>  <comment type="block">/* No-op on unix */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
</block_content>}</block></function>

<comment type="block">/*
** Deallocate any memory allocated by quota_utf8_to_mbcs().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>quota_mbcs_free</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOld</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* No-op on unix */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* VFS Method Wrappers *****************************/</comment>
<comment type="block">/*
** This is the xOpen method used for the "quota" VFS.
**
** Most of the work is done by the underlying original VFS.  This method
** simply links the new file into the appropriate quota group if it is a
** file that needs to be tracked.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,          <comment type="block">/* The quota VFS */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,          <comment type="block">/* Name of file to be opened */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>,        <comment type="block">/* Fill in this file descriptor */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                  <comment type="block">/* Flags to control the opening */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutFlags</name></decl></parameter>              <comment type="block">/* Flags showing results of opening */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                                    <comment type="block">/* Result code */</comment>         
  <decl_stmt><decl><type><name>quotaConn</name> <modifier>*</modifier></type><name>pQuotaOpen</name></decl>;</decl_stmt>                     <comment type="block">/* The new quota file descriptor */</comment>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>                          <comment type="block">/* Corresponding quotaFile obj */</comment>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>                        <comment type="block">/* The group file belongs to */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name></decl>;</decl_stmt>                    <comment type="block">/* Real file descriptor */</comment>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name> <init>= <expr><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Real VFS */</comment>

  <comment type="block">/* If the file is not a main database file or a WAL, then use the
  ** normal xOpen method.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_OPEN_MAIN_DB</name><operator>|</operator><name>SQLITE_OPEN_WAL</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pConn</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pOutFlags</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the name of the file does not match any quota group, then
  ** use the normal xOpen method.
  */</comment>
  <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <call><name>quotaGroupFind</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pGroup</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pConn</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pOutFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If we get to this point, it means the file needs to be quota tracked.
    */</comment>
    <expr_stmt><expr><name>pQuotaOpen</name> <operator>=</operator> <operator>(</operator><name>quotaConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSubOpen</name> <operator>=</operator> <call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pOutFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>quotaFindFile</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deleteOnClose</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pQuotaOpen</name><operator>-&gt;</operator><name>pFile</name></name> <operator>=</operator> <name>pFile</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>iVersion</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pQuotaOpen</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pQuotaOpen</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV2</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the xDelete method used for the "quota" VFS.
**
** If the file being deleted is part of the quota group, then reduce
** the size of the quota group accordingly.  And remove the file from
** the set of files in the quota group.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaDelete</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,          <comment type="block">/* The quota VFS */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,          <comment type="block">/* Name of file to be deleted */</comment>
  <parameter><decl><type><name>int</name></type> <name>syncDir</name></decl></parameter>                 <comment type="block">/* Do a directory sync after deleting */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                                    <comment type="block">/* Result code */</comment>         
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>                          <comment type="block">/* Files in the quota */</comment>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>                        <comment type="block">/* The group file belongs to */</comment>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name> <init>= <expr><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Real VFS */</comment>

  <comment type="block">/* Do the actual file delete */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>syncDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the file just deleted is a member of a quota group, then remove
  ** it from that quota group.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <call><name>quotaGroupFind</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pGroup</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>quotaFindFile</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pFile</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deleteOnClose</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>quotaRemoveFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>quotaGroupDeref</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/************************ I/O Method Wrappers *******************************/</comment>

<comment type="block">/* xClose requests get passed through to the original VFS.  But we
** also have to unlink the quotaConn from the quotaFile and quotaGroup.
** The quotaFile and/or quotaGroup are freed if they are no longer in use.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>quotaConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>deleteOnClose</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>quotaRemoveFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>quotaGroupDeref</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xRead requests directory thru to the original VFS without
** further processing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaRead</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check xWrite requests to see if they expand the file.  If they do,
** the perform a quota check before passing them through to the
** original VFS.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaWrite</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>quotaConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iEnd</name> <init>= <expr><name>iOfst</name><operator>+</operator><name>iAmt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>szNew</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name><operator>&lt;</operator><name>iEnd</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>szNew</name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>-</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name> <operator>+</operator> <name>iEnd</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>szNew</name><operator>&gt;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>&amp;&amp;</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>xCallback</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name><name>pGroup</name><operator>-&gt;</operator><name>xCallback</name></name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name></expr></argument>, <argument><expr><name>szNew</name></expr></argument>, 
                          <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>szNew</name><operator>&gt;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>&amp;&amp;</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_FULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>=</operator> <name>szNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name> <operator>=</operator> <name>iEnd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xTruncate requests thru to the original VFS.  If the
** success, update the file size.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>quotaConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>-=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xSync requests through to the original VFS without change
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xFileSize requests through to the original VFS but then
** update the quotaGroup with the new size before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>quotaConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>-=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xLock requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xUnlock requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xCheckReservedLock requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xCheckReservedLock</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>pResOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xFileControl requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileControl</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_FCNTL_VFSNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_VFSNAME</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"quota/%z"</literal></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xSectorSize requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSectorSize</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xDeviceCharacteristics requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xDeviceCharacteristics</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xShmMap requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaShmMap</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>,            <comment type="block">/* Handle open on database file */</comment>
  <parameter><decl><type><name>int</name></type> <name>iRegion</name></decl></parameter>,                    <comment type="block">/* Region to retrieve */</comment>
  <parameter><decl><type><name>int</name></type> <name>szRegion</name></decl></parameter>,                   <comment type="block">/* Size of regions */</comment>
  <parameter><decl><type><name>int</name></type> <name>bExtend</name></decl></parameter>,                    <comment type="block">/* True to extend file if necessary */</comment>
  <parameter><decl><type><name>void</name> <specifier>volatile</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>              <comment type="block">/* OUT: Mapped memory */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmMap</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>iRegion</name></expr></argument>, <argument><expr><name>szRegion</name></expr></argument>, <argument><expr><name>bExtend</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xShmLock requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaShmLock</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>,       <comment type="block">/* Database file holding the shared memory */</comment>
  <parameter><decl><type><name>int</name></type> <name>ofst</name></decl></parameter>,                  <comment type="block">/* First lock to acquire or release */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                     <comment type="block">/* Number of locks to acquire or release */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>                  <comment type="block">/* What to do with the lock */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmLock</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>ofst</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xShmBarrier requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>quotaShmBarrier</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmBarrier</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Pass xShmUnmap requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>quotaShmUnmap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>quotaSubOpen</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmUnmap</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>deleteFlag</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************** Public Interfaces *****************************/</comment>
<comment type="block">/*
** Initialize the quota VFS shim.  Use the VFS named zOrigVfsName
** as the VFS that does the actual work.  Use the default if
** zOrigVfsName==NULL.  
**
** The quota VFS shim is named "quota".  It will become the default
** VFS if makeDefault is non-zero.
**
** THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once
** during start-up.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_initialize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOrigVfsName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>makeDefault</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>gQuota</name><operator>.</operator><name>isInitialized</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pOrigVfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name>zOrigVfsName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrigVfs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrigVfs</name><operator>!=</operator><operator>&amp;</operator><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>pMutex</name></name> <operator>=</operator> <call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_FAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>gQuota</name><operator>.</operator><name>pMutex</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>isInitialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name></name> <operator>=</operator> <name>pOrigVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name></name> <operator>=</operator> <operator>*</operator><name>pOrigVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xOpen</name></name> <operator>=</operator> <name>quotaOpen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xDelete</name></name> <operator>=</operator> <name>quotaDelete</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>szOsFile</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>quotaConn</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>zName</name></name> <operator>=</operator> <literal type="string">"quota"</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>iVersion</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xClose</name></name> <operator>=</operator> <name>quotaClose</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xRead</name></name> <operator>=</operator> <name>quotaRead</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xWrite</name></name> <operator>=</operator> <name>quotaWrite</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xTruncate</name></name> <operator>=</operator> <name>quotaTruncate</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xSync</name></name> <operator>=</operator> <name>quotaSync</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xFileSize</name></name> <operator>=</operator> <name>quotaFileSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xLock</name></name> <operator>=</operator> <name>quotaLock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xUnlock</name></name> <operator>=</operator> <name>quotaUnlock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xCheckReservedLock</name></name> <operator>=</operator> <name>quotaCheckReservedLock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xFileControl</name></name> <operator>=</operator> <name>quotaFileControl</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xSectorSize</name></name> <operator>=</operator> <name>quotaSectorSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xDeviceCharacteristics</name></name> <operator>=</operator> <name>quotaDeviceCharacteristics</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV2</name></name> <operator>=</operator> <name><name>gQuota</name><operator>.</operator><name>sIoMethodsV1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV2</name><operator>.</operator><name>iVersion</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV2</name><operator>.</operator><name>xShmMap</name></name> <operator>=</operator> <name>quotaShmMap</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV2</name><operator>.</operator><name>xShmLock</name></name> <operator>=</operator> <name>quotaShmLock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV2</name><operator>.</operator><name>xShmBarrier</name></name> <operator>=</operator> <name>quotaShmBarrier</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>sIoMethodsV2</name><operator>.</operator><name>xShmUnmap</name></name> <operator>=</operator> <name>quotaShmUnmap</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name></name></expr></argument>, <argument><expr><name>makeDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Shutdown the quota system.
**
** All SQLite database connections must be closed before calling this
** routine.
**
** THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once while
** shutting down in order to free all remaining quota groups.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>gQuota</name><operator>.</operator><name>isInitialized</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>pGroup</name><operator>=</operator><name><name>gQuota</name><operator>.</operator><name>pGroup</name></name></expr>;</init> <condition><expr><name>pGroup</name></expr>;</condition> <incr><expr><name>pGroup</name><operator>=</operator><name><name>pGroup</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>quotaGroupOpenFileCount</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <while>while<condition>( <expr><name><name>gQuota</name><operator>.</operator><name>pGroup</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <name><name>gQuota</name><operator>.</operator><name>pGroup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>pGroup</name></name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>quotaGroupOpenFileCount</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaGroupDeref</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>isInitialized</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>pMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_vfs_unregister</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gQuota</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>gQuota</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create or destroy a quota group.
**
** The quota group is defined by the zPattern.  When calling this routine
** with a zPattern for a quota group that already exists, this routine
** merely updates the iLimit, xCallback, and pArg values for that quota
** group.  If zPattern is new, then a new quota group is created.
**
** If the iLimit for a quota group is set to zero, then the quota group
** is disabled and will be deleted when the last database connection using
** the quota group is closed.
**
** Calling this routine on a zPattern that does not exist and with a
** zero iLimit is a no-op.
**
** A quota group must exist with a non-zero iLimit prior to opening
** database connections if those connections are to participate in the
** quota group.  Creating a quota group does not affect database connections
** that are already open.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_set</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl></parameter>,           <comment type="block">/* The filename pattern */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iLimit</name></decl></parameter>,           <comment type="block">/* New quota to set for this quota group */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(              <comment type="block">/* Callback invoked when going over quota */</comment>
     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,         <comment type="block">/* Name of file whose size increases */</comment>
     <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piLimit</name></decl></parameter>,        <comment type="block">/* IN/OUT: The current limit */</comment>
     <parameter><decl><type><name>sqlite3_int64</name></type> <name>iSize</name></decl></parameter>,           <comment type="block">/* Total size of all files in the group */</comment>
     <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                     <comment type="block">/* Client data */</comment>
  )</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>,                     <comment type="block">/* client data passed thru to callback */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>         <comment type="block">/* Optional destructor for pArg */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <name><name>gQuota</name><operator>.</operator><name>pGroup</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pGroup</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>zPattern</name></name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pGroup</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nPattern</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x3fffffff</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iLimit</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <operator>(</operator><name>quotaGroup</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pGroup</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nPattern</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pGroup</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pGroup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>zPattern</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pGroup</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pGroup</name><operator>-&gt;</operator><name>zPattern</name></name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><name>nPattern</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>gQuota</name><operator>.</operator><name>pGroup</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>pGroup</name><operator>-&gt;</operator><name>ppPrev</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>gQuota</name><operator>.</operator><name>pGroup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>ppPrev</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>gQuota</name><operator>.</operator><name>pGroup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gQuota</name><operator>.</operator><name>pGroup</name></name> <operator>=</operator> <name>pGroup</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <name>iLimit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>xCallback</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>xDestroy</name></name> <operator>&amp;&amp;</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>pArg</name></name><operator>!=</operator><name>pArg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pGroup</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>xDestroy</name></name> <operator>=</operator> <name>xDestroy</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>quotaGroupDeref</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Bring the named file under quota management.  Or if it is already under
** management, update its size.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>outFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> <init>= <expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>szOsFile</name></name> <operator>+</operator> <name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Allocate space for a file-handle and the full path for file zFilename */</comment>
  <expr_stmt><expr><name>fd</name> <operator>=</operator> <operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zFull</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fd</name><operator>)</operator><index>[<expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>szOsFile</name></name></expr>]</index></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xFullPathname</name></name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>,
        <argument><expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>zFull</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>quotaOpen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name></name></expr></argument>, <argument><expr><name>zFull</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, 
                   <argument><expr><name>SQLITE_OPEN_READONLY</name> <operator>|</operator> <name>SQLITE_OPEN_MAIN_DB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>fd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>fd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_CANTOPEN</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <call><name>quotaGroupFind</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pGroup</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>quotaFindFile</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>zFull</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pFile</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>quotaRemoveFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a potentially quotaed file for I/O.
*/</comment>
<function><type><name>quota_FILE</name> <modifier>*</modifier></type><name>sqlite3_quota_fopen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFullTranslated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zFull</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>mxPathname</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFull</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xFullPathname</name></name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>,
                                      <argument><expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>quota_fopen_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>quota_FILE</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>quota_fopen_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFullTranslated</name> <operator>=</operator> <call><name>quota_utf8_to_mbcs</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFullTranslated</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>quota_fopen_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zFullTranslated</name></expr></argument>, <argument><expr><name>zMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>quota_fopen_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <call><name>quotaGroupFind</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pGroup</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>quotaFindFile</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>zFull</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>quota_fopen_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name> <operator>=</operator> <name>pFile</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zMbcsName</name></name> <operator>=</operator> <name>zFullTranslated</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>p</name></expr>;</return>

<label><name>quota_fopen_error</name>:</label>
  <expr_stmt><expr><call><name>quota_mbcs_free</name><argument_list>(<argument><expr><name>zFullTranslated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read content from a quota_FILE
*/</comment>
<function><type><name>size_t</name></type> <name>sqlite3_quota_fread</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,            <comment type="block">/* Store the content here */</comment>
  <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,           <comment type="block">/* Size of each element */</comment>
  <parameter><decl><type><name>size_t</name></type> <name>nmemb</name></decl></parameter>,          <comment type="block">/* Number of elements to read */</comment>
  <parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>          <comment type="block">/* Read from this quota_FILE object */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>fread</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>nmemb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write content into a quota_FILE.  Invoke the quota callback and block
** the write if we exceed quota.
*/</comment>
<function><type><name>size_t</name></type> <name>sqlite3_quota_fwrite</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,      <comment type="block">/* Take content to write from here */</comment>
  <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,           <comment type="block">/* Size of each element */</comment>
  <parameter><decl><type><name>size_t</name></type> <name>nmemb</name></decl></parameter>,          <comment type="block">/* Number of elements */</comment>
  <parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>          <comment type="block">/* Write to this quota_FILE objecct */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>szNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>iOfst</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name>iOfst</name> <operator>+</operator> <name>size</name><operator>*</operator><name>nmemb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFile</name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name><operator>&lt;</operator><name>iEnd</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>szNew</name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>-</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name> <operator>+</operator> <name>iEnd</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>szNew</name><operator>&gt;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>&amp;&amp;</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>xCallback</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name><name>pGroup</name><operator>-&gt;</operator><name>xCallback</name></name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name></expr></argument>, <argument><expr><name>szNew</name></expr></argument>, 
                          <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>pArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>szNew</name><operator>&gt;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>&amp;&amp;</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>-</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>+</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nmemb</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>iEnd</name> <operator>-</operator> <name>iOfst</name><operator>)</operator><operator>/</operator><name>size</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name>iOfst</name> <operator>+</operator> <name>size</name><operator>*</operator><name>nmemb</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>szNew</name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>-</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name> <operator>+</operator> <name>iEnd</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>=</operator> <name>szNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name> <operator>=</operator> <name>iEnd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pFile</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>nmemb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the write was incomplete, adjust the file size and group size
  ** downward */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;</operator><name>nmemb</name> <operator>&amp;&amp;</operator> <name>pFile</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nWritten</name> <init>= <expr><name>rc</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iNewEnd</name> <init>= <expr><name>iOfst</name> <operator>+</operator> <name>size</name><operator>*</operator><name>nWritten</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iNewEnd</name><operator>&lt;</operator><name>iEnd</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iNewEnd</name> <operator>=</operator> <name>iEnd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>+=</operator> <name>iNewEnd</name> <operator>-</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name> <operator>=</operator> <name>iNewEnd</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close an open quota_FILE stream.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_fclose</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fclose</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFile</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>deleteOnClose</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>quotaRemoveFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>quotaGroupDeref</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>
  <expr_stmt><expr><call><name>quota_mbcs_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMbcsName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Flush memory buffers for a quota_FILE to disk.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_fflush</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>doFsync</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fflush</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>doFsync</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_UNIX</name></expr></cpp:if>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsync</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>_commit</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Seek on a quota_FILE stream.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_fseek</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>whence</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** rewind a quota_FILE stream.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_quota_rewind</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Tell the current location of a quota_FILE stream.
*/</comment>
<function><type><name>long</name></type> <name>sqlite3_quota_ftell</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ftell</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Test the error indicator for the given file.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_ferror</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate a file to szNew bytes.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_ftruncate</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>szNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pFile</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFile</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name><operator>&lt;</operator><name>szNew</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name><operator>&lt;</operator><name>szNew</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This routine cannot be used to extend a file that is under
      ** quota management.  Only true truncation is allowed. */</comment>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>+=</operator> <name>szNew</name> <operator>-</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_UNIX</name></expr></cpp:if>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ftruncate</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>szNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
     <comment type="block">/* _chsize_s() is missing from MingW (as of 2012-11-06).  Use
     ** _chsize() as a work-around for testing purposes. */</comment>
     <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>_chsize</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>szNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
     <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>_chsize_s</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>szNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>pFile</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name> <operator>+=</operator> <name>szNew</name> <operator>-</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name> <operator>=</operator> <name>szNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Determine the time that the given file was last modified, in
** seconds size 1970.  Write the result into *pTime.  Return 0 on
** success and non-zero on any kind of error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_file_mtime</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>time_t</name> <modifier>*</modifier></type><name>pTime</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_UNIX</name></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>_stati64</name></name></type> <name>buf</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>_stati64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMbcsName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pTime</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>st_mtime</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the true size of the file, as reported by the operating
** system.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3_quota_file_truesize</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_UNIX</name></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>_stati64</name></name></type> <name>buf</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>_stati64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMbcsName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>buf</name><operator>.</operator><name>st_size</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the size of the file, as it is known to the quota subsystem.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3_quota_file_size</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
 
<comment type="block">/*
** Determine the amount of data in bytes available for reading
** in the given file.
*/</comment>
<function><type><name>long</name></type> <name>sqlite3_quota_file_available</name><parameter_list>(<parameter><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>pos1</name></decl>, <decl><type ref="prev"/><name>pos2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pos1</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>( <expr><name>pos1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fseek</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>( <expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pos2</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>( <expr><name>pos2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fseek</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>pos1</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>( <expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>pos2</name> <operator>-</operator> <name>pos1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Remove a managed file.  Update quotas accordingly.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_quota_remove</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFull</name></decl>;</decl_stmt>            <comment type="block">/* Full pathname for zFilename */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nFull</name></decl>;</decl_stmt>           <comment type="block">/* Number of bytes in zFilename */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                 <comment type="block">/* Result code */</comment>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>     <comment type="block">/* Group containing zFilename */</comment>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>       <comment type="block">/* A file in the group */</comment>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pNextFile</name></decl>;</decl_stmt>   <comment type="block">/* next file in the group */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>;</decl_stmt>               <comment type="block">/* Difference between filenames */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>                 <comment type="block">/* First character past end of pattern */</comment>

  <expr_stmt><expr><name>zFull</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>mxPathname</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFull</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xFullPathname</name></name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>,
                                      <argument><expr><name><name>gQuota</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Figure out the length of the full pathname.  If the name ends with
  ** / (or \ on windows) then remove the trailing /.
  */</comment>
  <expr_stmt><expr><name>nFull</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nFull</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zFull</name><index>[<expr><name>nFull</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal> <operator>||</operator> <name><name>zFull</name><index>[<expr><name>nFull</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\\'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nFull</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zFull</name><index>[<expr><name>nFull</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <call><name>quotaGroupFind</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pGroup</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>pFile</name><operator>=</operator><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name></name></expr>;</init> <condition><expr><name>pFile</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>pFile</name><operator>=</operator><name>pNextFile</name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pNextFile</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><name>nFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>diff</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name><index>[<expr><name>nFull</name></expr>]</index></name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'/'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\\'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>deleteOnClose</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name><name>gQuota</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>quotaRemoveFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>quotaGroupDeref</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
  
<comment type="block" format="doxygen">/***************************** Test Code ***********************************/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcl.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Argument passed to a TCL quota-over-limit callback.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>TclQuotaCallback</name></name></type> <name>TclQuotaCallback</name>;</typedef>
<struct>struct <name>TclQuotaCallback</name> <block>{
  <decl_stmt><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl>;</decl_stmt>    <comment type="block">/* Interpreter in which to run the script */</comment>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pScript</name></decl>;</decl_stmt>      <comment type="block">/* Script to be run */</comment>
}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3ErrName</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
** This is the callback from a quota-over-limit.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tclQuotaCallback</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,          <comment type="block">/* Name of file whose size increases */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piLimit</name></decl></parameter>,         <comment type="block">/* IN/OUT: The current limit */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iSize</name></decl></parameter>,            <comment type="block">/* Total size of all files in the group */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                      <comment type="block">/* Client data */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TclQuotaCallback</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>            <comment type="block">/* Callback script object */</comment>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pEval</name></decl>;</decl_stmt>                 <comment type="block">/* Script to evaluate */</comment>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pVarname</name></decl>;</decl_stmt>              <comment type="block">/* Name of variable to pass as 2nd arg */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>rnd</name></decl>;</decl_stmt>               <comment type="block">/* Random part of pVarname */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Tcl error code */</comment>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>TclQuotaCallback</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>pVarname</name> <operator>=</operator> <call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"::piLimit_"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pVarname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rnd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_AppendObjToObj</name><argument_list>(<argument><expr><name>pVarname</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>rnd</name><operator>&amp;</operator><literal type="number">0x7FFFFFFF</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ObjSetVar2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>, <argument><expr><name>pVarname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><operator>*</operator><name>piLimit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pEval</name> <operator>=</operator> <call><name>Tcl_DuplicateObj</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pScript</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pEval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pEval</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pEval</name></expr></argument>, <argument><expr><name>pVarname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pEval</name></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>, <argument><expr><name>pEval</name></expr></argument>, <argument><expr><name>TCL_EVAL_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>TCL_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Tcl_WideInt</name></type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pLimit</name> <init>= <expr><call><name>Tcl_ObjGetVar2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>, <argument><expr><name>pVarname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Tcl_GetWideIntFromObj</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piLimit</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_UnsetVar</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name>pVarname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pEval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pVarname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>TCL_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Tcl_BackgroundError</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for a TCL quota-over-limit callback.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tclCallbackDestructor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pObj</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TclQuotaCallback</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>TclQuotaCallback</name><operator>*</operator><operator>)</operator><name>pObj</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pScript</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_initialize NAME MAKEDEFAULT
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_initialize</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>              <comment type="block">/* Name of new quota VFS */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>makeDefault</name></decl>;</decl_stmt>                <comment type="block">/* True to make the new VFS the default */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Value returned by quota_initialize() */</comment>

  <comment type="block">/* Process arguments */</comment>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"NAME MAKEDEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetBooleanFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>makeDefault</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Call sqlite3_quota_initialize() */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_quota_initialize</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>makeDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_shutdown
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_shutdown</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Value returned by quota_shutdown() */</comment>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Call sqlite3_quota_shutdown() */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_quota_shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_set PATTERN LIMIT SCRIPT
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_set</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>           <comment type="block">/* File pattern to configure */</comment>
  <decl_stmt><decl><type><name>Tcl_WideInt</name></type> <name>iLimit</name></decl>;</decl_stmt>             <comment type="block">/* Initial quota in bytes */</comment>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pScript</name></decl>;</decl_stmt>               <comment type="block">/* Tcl script to invoke to increase quota */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Value returned by quota_set() */</comment>
  <decl_stmt><decl><type><name>TclQuotaCallback</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>            <comment type="block">/* Callback object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nScript</name></decl>;</decl_stmt>                    <comment type="block">/* Length of callback script */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>        <comment type="block">/* Optional destructor for pArg */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

  <comment type="block">/* Process arguments */</comment>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"PATTERN LIMIT SCRIPT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetWideIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLimit</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pScript</name> <operator>=</operator> <name><name>objv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name>pScript</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nScript</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Allocate a TclQuotaCallback object */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>TclQuotaCallback</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TclQuotaCallback</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"SQLITE_NOMEM"</literal></expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TclQuotaCallback</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>interp</name></name> <operator>=</operator> <name>interp</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pScript</name></name> <operator>=</operator> <name>pScript</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xDestroy</name> <operator>=</operator> <name>tclCallbackDestructor</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xCallback</name> <operator>=</operator> <name>tclQuotaCallback</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>xDestroy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>xCallback</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Invoke sqlite3_quota_set() */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_quota_set</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>xCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>xDestroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_file FILENAME
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_file</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>          <comment type="block">/* File pattern to configure */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Value returned by quota_file() */</comment>

  <comment type="block">/* Process arguments */</comment>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"FILENAME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Invoke sqlite3_quota_file() */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_quota_file</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd:  sqlite3_quota_dump
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_dump</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pResult</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pGroupTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>pFileTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>quotaFile</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pResult</name> <operator>=</operator> <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>quotaEnter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pGroup</name><operator>=</operator><name><name>gQuota</name><operator>.</operator><name>pGroup</name></name></expr>;</init> <condition><expr><name>pGroup</name></expr>;</condition> <incr><expr><name>pGroup</name><operator>=</operator><name><name>pGroup</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pGroupTerm</name> <operator>=</operator> <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pGroupTerm</name></expr></argument>,
          <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>zPattern</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pGroupTerm</name></expr></argument>,
          <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iLimit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pGroupTerm</name></expr></argument>,
          <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>iSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pFile</name><operator>=</operator><name><name>pGroup</name><operator>-&gt;</operator><name>pFiles</name></name></expr>;</init> <condition><expr><name>pFile</name></expr>;</condition> <incr><expr><name>pFile</name><operator>=</operator><name><name>pFile</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zTemp</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pFileTerm</name> <operator>=</operator> <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zTemp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <if_stmt><if>if<condition>( <expr><name><name>zTemp</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zTemp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> </block_content>}</block></for>
      <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pFileTerm</name></expr></argument>,
            <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pFileTerm</name></expr></argument>,
            <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>iSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pFileTerm</name></expr></argument>,
            <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pFileTerm</name></expr></argument>,
            <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>deleteOnClose</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pGroupTerm</name></expr></argument>, <argument><expr><name>pFileTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pResult</name></expr></argument>, <argument><expr><name>pGroupTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>quotaLeave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_fopen FILENAME MODE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_fopen</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>          <comment type="block">/* File pattern to configure */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMode</name></decl>;</decl_stmt>              <comment type="block">/* Mode string */</comment>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                  <comment type="block">/* Open string object */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zReturn</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>               <comment type="block">/* Name of pointer to return */</comment>

  <comment type="block">/* Process arguments */</comment>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"FILENAME MODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMode</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_quota_fopen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zReturn</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zReturn</name></expr></argument>, <argument><expr><literal type="string">"%p"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zReturn</name></expr></argument>, <argument><expr><name>TCL_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Defined in test1.c */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3TestTextToPtr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** tclcmd: sqlite3_quota_fread HANDLE SIZE NELEM
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_fread</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nElem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>got</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE SIZE NELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nElem</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>sz</name><operator>*</operator><name>nElem</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>sqlite3_quota_fread</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>nElem</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>got</name><operator>*</operator><name>sz</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>TCL_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_fwrite HANDLE SIZE NELEM CONTENT
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_fwrite</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nElem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>got</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE SIZE NELEM CONTENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nElem</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>got</name> <operator>=</operator> <call><name>sqlite3_quota_fwrite</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>nElem</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>got</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_fclose HANDLE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_fclose</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_quota_fclose</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_fflush HANDLE ?HARDSYNC?
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_fflush</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>doSync</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>objc</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE ?HARDSYNC?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetBooleanFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doSync</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_quota_fflush</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>doSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_fseek HANDLE OFFSET WHENCE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_fseek</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ofst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWhence</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>whence</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE OFFSET WHENCE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofst</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zWhence</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zWhence</name></expr></argument>, <argument><expr><literal type="string">"SEEK_SET"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>whence</name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zWhence</name></expr></argument>, <argument><expr><literal type="string">"SEEK_CUR"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>whence</name> <operator>=</operator> <name>SEEK_CUR</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zWhence</name></expr></argument>, <argument><expr><literal type="string">"SEEK_END"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>whence</name> <operator>=</operator> <name>SEEK_END</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
           <argument><expr><literal type="string">"WHENCE should be SEEK_SET, SEEK_CUR, or SEEK_END"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_quota_fseek</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ofst</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_rewind HANDLE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_rewind</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_quota_rewind</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_ftell HANDLE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_ftell</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>x</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3_quota_ftell</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_ftruncate HANDLE SIZE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_ftruncate</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_WideInt</name></type> <name>w</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE SIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetWideIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_quota_ftruncate</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_file_size HANDLE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_file_size</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>x</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3_quota_file_size</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_file_truesize HANDLE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_file_truesize</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>x</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3_quota_file_truesize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_file_mtime HANDLE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_file_mtime</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_quota_file_mtime</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** tclcmd: sqlite3_quota_remove FILENAME
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_remove</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>          <comment type="block">/* File pattern to configure */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"FILENAME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_quota_remove</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_glob PATTERN TEXT
**
** Test the glob pattern matching.  Return 1 if TEXT matches PATTERN
** and return 0 if it does not.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_glob</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>          <comment type="block">/* The glob pattern */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl>;</decl_stmt>             <comment type="block">/* Text to compare agains the pattern */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"PATTERN TEXT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zText</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>quotaStrglob</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_file_available HANDLE
**
** Return the number of bytes from the current file point to the end of
** the file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_file_available</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>x</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3_quota_file_available</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_quota_ferror HANDLE
**
** Return true if the file handle is in the error state.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_quota_ferror</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>quota_FILE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3TestTextToPtr</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3_quota_ferror</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine registers the custom TCL commands defined in this
** module.  This should be the only procedure visible from outside
** of this module.
*/</comment>
<function><type><name>int</name></type> <name>Sqlitequota_Init</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <struct><specifier>static</specifier> struct <block>{
     <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>Tcl_ObjCmdProc</name> <modifier>*</modifier></type><name>xProc</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aCmd</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_initialize"</literal></expr>,    <expr><name>test_quota_initialize</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_shutdown"</literal></expr>,      <expr><name>test_quota_shutdown</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_set"</literal></expr>,           <expr><name>test_quota_set</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_file"</literal></expr>,          <expr><name>test_quota_file</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_dump"</literal></expr>,          <expr><name>test_quota_dump</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_fopen"</literal></expr>,         <expr><name>test_quota_fopen</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_fread"</literal></expr>,         <expr><name>test_quota_fread</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_fwrite"</literal></expr>,        <expr><name>test_quota_fwrite</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_fclose"</literal></expr>,        <expr><name>test_quota_fclose</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_fflush"</literal></expr>,        <expr><name>test_quota_fflush</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_fseek"</literal></expr>,         <expr><name>test_quota_fseek</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_rewind"</literal></expr>,        <expr><name>test_quota_rewind</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_ftell"</literal></expr>,         <expr><name>test_quota_ftell</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_ftruncate"</literal></expr>,     <expr><name>test_quota_ftruncate</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_file_size"</literal></expr>,     <expr><name>test_quota_file_size</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_file_truesize"</literal></expr>, <expr><name>test_quota_file_truesize</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_file_mtime"</literal></expr>,    <expr><name>test_quota_file_mtime</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_remove"</literal></expr>,        <expr><name>test_quota_remove</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_glob"</literal></expr>,          <expr><name>test_quota_glob</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_file_available"</literal></expr>,<expr><name>test_quota_file_available</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_quota_ferror"</literal></expr>,        <expr><name>test_quota_ferror</name></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aCmd</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>aCmd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aCmd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xProc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
