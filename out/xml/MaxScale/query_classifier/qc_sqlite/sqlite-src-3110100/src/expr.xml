<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/expr.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains routines used for analyzing expressions and
** for generating VDBE code that evaluates expressions in SQLite.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Return the 'affinity' of the expression pExpr if any.
**
** If pExpr is a column, a reference to a column via an 'AS' alias,
** or a sub-select with a column as the return value, then the 
** affinity of that column is returned. Otherwise, 0x00 is returned,
** indicating no affinity for the expression.
**
** i.e. the WHERE clause expressions in the following statements all
** have an affinity:
**
** CREATE TABLE t1(a);
** SELECT * FROM t1 WHERE a;
** SELECT a AS b FROM t1 WHERE b;
** SELECT * FROM t1 WHERE (select a from t1);
*/</comment>
<function><type><name>char</name></type> <name>sqlite3ExprAffinity</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Generic</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>EP_xIsSelect</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CAST</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_CAST</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3AffinityType</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>op</name><operator>==</operator><name>TK_AGG_COLUMN</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_COLUMN</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_REGISTER</name><operator>)</operator> 
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* op==TK_REGISTER &amp;&amp; pExpr-&gt;pTab!=0 happens when pExpr was originally
    ** a TK_COLUMN but was previously evaluated and cached in a register */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_AFF_INTEGER</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>affinity</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the collating sequence for expression pExpr to be the collating
** sequence named by pToken.   Return a pointer to a new Expr node that
** implements the COLLATE operator.
**
** If a memory allocation error occurs, that fact is recorded in pParse-&gt;db
** and the pExpr parameter is returned unchanged.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprAddCollateToken</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,           <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,             <comment type="block">/* Add the "COLLATE" clause to this expression */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>pCollName</name></decl></parameter>,  <comment type="block">/* Name of collating sequence */</comment>
  <parameter><decl><type><name>int</name></type> <name>dequote</name></decl></parameter>              <comment type="block">/* True to dequote pCollName */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCollName</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>TK_COLLATE</name></expr></argument>, <argument><expr><name>pCollName</name></expr></argument>, <argument><expr><name>dequote</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_Collate</name><operator>|</operator><name>EP_Skip</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprAddCollateString</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Token</name></type> <name>s</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3TokenInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ExprAddCollateToken</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Skip over any TK_COLLATE operators and any unlikely()
** or likelihood() function at the root of an expression.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprSkipCollate</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>pExpr</name> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Skip</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Unlikely</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>   
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the collation sequence for the expression pExpr. If
** there is no defined collating sequence, return NULL.
**
** The collating sequence might be determined by a COLLATE operator
** or by the presence of a column with a defined collating sequence.
** COLLATE operators take first precedence.  Left operands take
** precedence over right operands.
*/</comment>
<function><type><name>CollSeq</name> <modifier>*</modifier></type><name>sqlite3ExprCollSeq</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pExpr</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Generic</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_CAST</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_UPLUS</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_COLLATE</name> <operator>||</operator> <operator>(</operator><name>op</name><operator>==</operator><name>TK_REGISTER</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op2</name></name><operator>==</operator><name>TK_COLLATE</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3GetCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>op</name><operator>==</operator><name>TK_AGG_COLUMN</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_COLUMN</name>
          <operator>||</operator> <name>op</name><operator>==</operator><name>TK_REGISTER</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_TRIGGER</name><operator>)</operator>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* op==TK_REGISTER &amp;&amp; p-&gt;pTab!=0 happens when pExpr was originally
      ** a TK_COLUMN but was previously evaluated and cached in a register */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zColl</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNext</name>  <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* The Expr.x union is never used at the same time as Expr.pRight */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* p-&gt;flags holds EP_Collate and p-&gt;pLeft-&gt;flags does not.  And
        ** p-&gt;x.pSelect cannot.  So if p-&gt;x.pLeft exists, it must hold at
        ** least one EP_Collate. Thus the following two ALWAYS. */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>EP_Collate</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3CheckCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pColl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pExpr is an operand of a comparison operator.  aff2 is the
** type affinity of the other operand.  This routine returns the
** type affinity that should be used for the comparison operator.
*/</comment>
<function><type><name>char</name></type> <name>sqlite3CompareAffinity</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>aff2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>aff1</name> <init>= <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>aff1</name> <operator>&amp;&amp;</operator> <name>aff2</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Both sides of the comparison are columns. If one has numeric
    ** affinity, use that. Otherwise use no affinity.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>aff1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>aff2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_AFF_NUMERIC</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>SQLITE_AFF_BLOB</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name>aff1</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>aff2</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Neither side of the comparison is a column.  Compare the
    ** results directly.
    */</comment>
    <return>return <expr><name>SQLITE_AFF_BLOB</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* One side is a column, the other is not. Use the columns affinity. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aff1</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>aff2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>aff1</name> <operator>+</operator> <name>aff2</name><operator>)</operator></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** pExpr is a comparison operator.  Return the type affinity that should
** be applied to both operands prior to doing the comparison.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name></type> <name>comparisonAffinity</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>aff</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EQ</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LT</name> <operator>||</operator>
          <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GT</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_GE</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LE</name> <operator>||</operator>
          <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NE</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name>aff</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>aff</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pExpr is a comparison expression, eg. '=', '&lt;', IN(...) etc.
** idx_affinity is the affinity of an indexed column. Return true
** if the index with affinity idx_affinity may be used to implement
** the comparison in pExpr.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IndexAffinityOk</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>idx_affinity</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>aff</name> <init>= <expr><call><name>comparisonAffinity</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>aff</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_AFF_BLOB</name></expr>:</case>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>SQLITE_AFF_TEXT</name></expr>:</case>
      <return>return <expr><name>idx_affinity</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr>;</return>
    <default>default:</default>
      <return>return <expr><call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>idx_affinity</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Return the P5 value that should be used for a binary comparison
** opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2.
*/</comment>
<function><type><specifier>static</specifier> <name>u8</name></type> <name>binaryCompareP5</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr1</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>aff</name> <init>= <expr><operator>(</operator><name>char</name><operator>)</operator><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pExpr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>aff</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pExpr1</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>jumpIfNull</name></expr>;</expr_stmt>
  <return>return <expr><name>aff</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the collation sequence that should be used by
** a binary comparison operator comparing pLeft and pRight.
**
** If the left hand expression has a collating sequence type, then it is
** used. Otherwise the collation sequence for the right hand expression
** is used, or the default (BINARY) if neither expression has a collating
** type.
**
** Argument pRight (but not pLeft) may be a null pointer. In this case,
** it is not considered.
*/</comment>
<function><type><name>CollSeq</name> <modifier>*</modifier></type><name>sqlite3BinaryCompareCollSeq</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, 
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, 
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pRight</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRight</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Collate</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pColl</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pColl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code for a comparison operator.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeCompare</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* The parsing (and code generating) context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,      <comment type="block">/* The left operand */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,     <comment type="block">/* The right operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>opcode</name></decl></parameter>,       <comment type="block">/* The comparison opcode */</comment>
  <parameter><decl><type><name>int</name></type> <name>in1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in2</name></decl></parameter>, <comment type="block">/* Register holding operands */</comment>
  <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>,         <comment type="block">/* Jump here if true.  */</comment>
  <parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>    <comment type="block">/* If true, jump if either operand is NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>p5</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>p4</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p4</name> <operator>=</operator> <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p5</name> <operator>=</operator> <call><name>binaryCompareP5</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>in2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>in1</name></expr></argument>,
                           <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Check that argument nHeight is less than or equal to the maximum
** expression depth allowed. If it is not, leave an error message in
** pParse.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCheckHeight</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mxHeight</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_EXPR_DEPTH</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nHeight</name><operator>&gt;</operator><name>mxHeight</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
       <argument><expr><literal type="string">"Expression tree is too large (maximum depth %d)"</literal></expr></argument>, <argument><expr><name>mxHeight</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The following three functions, heightOfExpr(), heightOfExprList()
** and heightOfSelect(), are used to determine the maximum height
** of any expression tree referenced by the structure passed as the
** first argument.
**
** If this maximum height is greater than the current value pointed
** to by pnHeight, the second parameter, then set *pnHeight to that
** value.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>heightOfExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name><operator>&gt;</operator><operator>*</operator><name>pnHeight</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pnHeight</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>heightOfExprList</name><parameter_list>(<parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>heightOfSelect</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOffset</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfSelect</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the Expr.nHeight variable in the structure passed as an 
** argument. An expression with no children, Expr.pList or 
** Expr.pSelect member has a height of 1. Any other expression
** has a height equal to the maximum height of any other 
** referenced Expr plus one.
**
** Also propagate EP_Propagate flags up from Expr.x.pList to Expr.flags,
** if appropriate.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exprSetHeight</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nHeight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>heightOfSelect</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_Propagate</name> <operator>&amp;</operator> <call><name>sqlite3ExprListFlags</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>=</operator> <name>nHeight</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the Expr.nHeight variable using the exprSetHeight() function. If
** the height is greater than the maximum allowed expression depth,
** leave an error in pParse.
**
** Also propagate all EP_Propagate flags from the Expr.x.pList into
** Expr.flags. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprSetHeightAndFlags</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>exprSetHeight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCheckHeight</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the maximum height of any expression tree referenced
** by the select statement passed as an argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3SelectExprHeight</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nHeight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>heightOfSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nHeight</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* ABOVE:  Height enforcement enabled.  BELOW: Height enforcement off */</comment>
<comment type="block">/*
** Propagate all EP_Propagate flags from the Expr.x.pList into
** Expr.flags. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprSetHeightAndFlags</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_Propagate</name> <operator>&amp;</operator> <call><name>sqlite3ExprListFlags</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>exprSetHeight</name><parameter_list>(<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_EXPR_DEPTH&gt;0 */</comment>

<comment type="block">/*
** This routine is the core allocator for Expr nodes.
**
** Construct a new expression node and return a pointer to it.  Memory
** for this node and for the pToken argument is a single allocation
** obtained from sqlite3DbMalloc().  The calling function
** is responsible for making sure the node eventually gets freed.
**
** If dequote is true, then the token (if it exists) is dequoted.
** If dequote is false, no dequoting is performed.  The deQuote
** parameter is ignored if pToken is NULL or if the token does not
** appear to be quoted.  If the quotes were of the form "..." (double-quotes)
** then the EP_DblQuoted flag is set on the expression node.
**
** Special case:  If op==TK_INTEGER and pToken points to a string that
** can be translated into a 32-bit integer, then the token is not
** stored in u.zToken.  Instead, the integer values is written
** into u.iValue and the EP_IntValue flag is set.  No extra storage
** is allocated to hold the integer text and the dequote flag is ignored.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprAlloc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,            <comment type="block">/* Handle for sqlite3DbMallocZero() (may be null) */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                 <comment type="block">/* Expression opcode */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>,    <comment type="block">/* Token argument.  Might be NULL */</comment>
  <parameter><decl><type><name>int</name></type> <name>dequote</name></decl></parameter>             <comment type="block">/* True to dequote */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pToken</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>!=</operator><name>TK_INTEGER</name> <operator>||</operator> <name><name>pToken</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal>
          <operator>||</operator> <call><name>sqlite3GetInt32</name><argument_list>(<argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iValue</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nExtra</name> <operator>=</operator> <name><name>pToken</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iValue</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>op</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iAgg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pToken</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nExtra</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_IntValue</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name> <operator>=</operator> <name>iValue</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pToken</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><name><name>pToken</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>dequote</name> <operator>&amp;&amp;</operator> <name>nExtra</name><operator>&gt;=</operator><literal type="number">3</literal> 
             <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>=</operator> <name><name>pToken</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>==</operator><literal type="char">'\''</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'['</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'`'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_DblQuoted</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new expression node from a zero-terminated token that has
** already been dequoted.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3Expr</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,            <comment type="block">/* Handle for sqlite3DbMallocZero() (may be null) */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                 <comment type="block">/* Expression opcode */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zToken</name></decl></parameter>      <comment type="block">/* Token argument.  Might be NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Token</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name>zToken</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>n</name></name> <operator>=</operator> <ternary><condition><expr><name>zToken</name></expr> ?</condition><then> <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zToken</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attach subtrees pLeft and pRight to the Expr node pRoot.
**
** If pRoot==NULL that means that a memory allocation error has occurred.
** In that case, delete the subtrees pLeft and pRight.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAttachSubtrees</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRoot</name></decl></parameter>,
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pRoot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pRight</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_Propagate</name> <operator>&amp;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pLeft</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_Propagate</name> <operator>&amp;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>exprSetHeight</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate an Expr node which joins as many as two subtrees.
**
** One or both of the subtrees can be NULL.  Return a pointer to the new
** Expr node.  Or, if an OOM error occurs, set pParse-&gt;db-&gt;mallocFailed,
** free the subtrees and return NULL.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3PExpr</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                 <comment type="block">/* Expression opcode */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,            <comment type="block">/* Left operand */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,           <comment type="block">/* Right operand */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>     <comment type="block">/* Argument token */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_AND</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Take advantage of short-circuit false optimization for AND */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>TKFLG_MASK</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprAttachSubtrees</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCheckHeight</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the expression is always either TRUE or FALSE (respectively),
** then return 1.  If one cannot determine the truth value of the
** expression at compile-time return 0.
**
** This is an optimization.  If is OK to return 0 here even if
** the expression really is always false or false (a false negative).
** But it is a bug to return 1 if the expression might have different
** boolean values in different circumstances (a false positive.)
**
** Note that if the expression is part of conditional for a
** LEFT JOIN, then we cannot determine at compile-time whether or not
** is it true or false, so always return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprAlwaysTrue</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprAlwaysFalse</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Join two expressions using an AND operator.  If either expression is
** NULL, then just return the other expression.
**
** If one side or the other of the AND is known to be false, then instead
** of returning an AND expression, just return a constant expression with
** a value of false.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprAnd</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>pRight</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>pLeft</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>exprAlwaysFalse</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>exprAlwaysFalse</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sqlite3IntTokens</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_AND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprAttachSubtrees</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pNew</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Construct a new expression node for a function with multiple
** arguments.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprFunction</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToken</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_FUNCTION</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Avoid memory leak when malloc fails */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprSetHeightAndFlags</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Assign a variable number to an expression that encodes a wildcard
** in the original SQL statement.  
**
** Wildcards consisting of a single "?" are assigned the next sequential
** variable number.
**
** Wildcards of the form "?nnn" are assigned the number "nnn".  We make
** sure "nnn" is not too be to avoid a denial of service attack when
** the SQL statement comes from an external source.
**
** Wildcards of the form ":aaa", "@aaa", or "$aaa" are assigned the same number
** as the previous instance of the same wildcard.  Or if this is the first
** instance of the wildcard, the next sequential variable number is
** assigned.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAssignVarNumber</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name><operator>|</operator><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Wildcard of the form "?".  Assign the next variable number */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><operator>(</operator><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>ynVar</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>n</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Wildcard of the form "?nnn".  Convert "nnn" to an integer and
      ** use it as the variable number */</comment>
      <decl_stmt><decl><type><name>i64</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bOk</name> <init>= <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>x</name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bOk</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>i</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal> <operator>||</operator> <name>i</name></expr></argument>&gt;</argument_list></name><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"variable number must be between ?1 and ?%d"</literal></expr></argument>,
            <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Wildcards like ":aaa", "$aaa" or "@aaa".  Reuse the same variable
      ** number as the prior appearance of the same name, or if the name
      ** has never appeared before, reuse the same variable number
      */</comment>
      <decl_stmt><decl><type><name>ynVar</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nzVar</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>azVar</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>azVar</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>x</name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><operator>(</operator><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nzVar</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>azVar</name></name></expr></argument>, <argument><expr><name>x</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Error reported through mallocFailed */</comment>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>azVar</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nzVar</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>x</name><operator>-</operator><name><name>pParse</name><operator>-&gt;</operator><name>nzVar</name></name><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nzVar</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'?'</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>azVar</name><index>[<expr><name>x</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>azVar</name><index>[<expr><name>x</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>azVar</name><index>[<expr><name>x</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt> 
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many SQL variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Recursively delete an expression tree.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Sanity check: Assert that the IntValue is non-negative if it exists */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* The Expr.x union is never used at the same time as Expr.pRight */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_MemToken</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Static</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of bytes allocated for the expression structure 
** passed as the first argument. This is always one of EXPR_FULLSIZE,
** EXPR_REDUCEDSIZE or EXPR_TOKENONLYSIZE.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprStructSize</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>EXPR_TOKENONLYSIZE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>EXPR_REDUCEDSIZE</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>EXPR_FULLSIZE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The dupedExpr*Size() routines each return the number of bytes required
** to store a copy of an expression or expression tree.  They differ in
** how much of the tree is measured.
**
**     dupedExprStructSize()     Size of only the Expr structure 
**     dupedExprNodeSize()       Size of Expr + space for token
**     dupedExprSize()           Expr + token + subtree components
**
***************************************************************************
**
** The dupedExprStructSize() function returns two values OR-ed together:  
** (1) the space required for a copy of the Expr structure only and 
** (2) the EP_xxx flags that indicate what the structure size should be.
** The return values is always one of:
**
**      EXPR_FULLSIZE
**      EXPR_REDUCEDSIZE   | EP_Reduced
**      EXPR_TOKENONLYSIZE | EP_TokenOnly
**
** The size of the structure can be found by masking the return value
** of this routine with 0xfff.  The flags can be found by masking the
** return value with EP_Reduced|EP_TokenOnly.
**
** Note that with flags==EXPRDUP_REDUCE, this routines works on full-size
** (unreduced) Expr objects as they or originally constructed by the parser.
** During expression analysis, extra information is computed and moved into
** later parts of teh Expr object and that extra information might get chopped
** off if the expression is reduced.  Note also that it does not work to
** make an EXPRDUP_REDUCE copy of a reduced expression.  It is only legal
** to reduce a pristine expression tree from the parser.  The implementation
** of dupedExprStructSize() contain multiple assert() statements that attempt
** to enforce this constraint.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dupedExprStructSize</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nSize</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><name>EXPRDUP_REDUCE</name> <operator>||</operator> <name>flags</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Only one flag value allowed */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>EXPR_FULLSIZE</name><operator>&lt;=</operator><literal type="number">0xfff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><literal type="number">0xfff</literal> <operator>&amp;</operator> <operator>(</operator><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><name>EXPRDUP_REDUCE</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nSize</name> <operator>=</operator> <name>EXPR_FULLSIZE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_MemToken</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nSize</name> <operator>=</operator> <name>EXPR_REDUCEDSIZE</name> <operator>|</operator> <name>EP_Reduced</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nSize</name> <operator>=</operator> <name>EXPR_TOKENONLYSIZE</name> <operator>|</operator> <name>EP_TokenOnly</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>nSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function returns the space in bytes required to store the copy 
** of the Expr structure and a copy of the Expr.u.zToken string (if that
** string is defined.)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dupedExprNodeSize</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><call><name>dupedExprStructSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xfff</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>ROUND8</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of bytes required to create a duplicate of the 
** expression passed as the first argument. The second argument is a
** mask containing EXPRDUP_XXX flags.
**
** The value returned includes space to create a copy of the Expr struct
** itself and the buffer referred to by Expr.u.zToken, if any.
**
** If the EXPRDUP_REDUCE flag is set, then the return value includes 
** space to duplicate all Expr nodes in the tree formed by Expr.pLeft 
** and Expr.pRight variables (but not for any structures pointed to or 
** descended from the Expr.x.pList or Expr.x.pSelect variables).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dupedExprSize</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>dupedExprNodeSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>flags</name><operator>&amp;</operator><name>EXPRDUP_REDUCE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>dupedExprSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>dupedExprSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>nByte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is similar to sqlite3ExprDup(), except that if pzBuffer 
** is not NULL then *pzBuffer is assumed to point to a buffer large enough 
** to store the copy of expression p, the copies of p-&gt;u.zToken
** (if applicable), and the copies of the p-&gt;pLeft and p-&gt;pRight expressions,
** if any. Before returning, *pzBuffer is set to the first byte past the
** portion of the buffer copied into by this function.
*/</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>exprDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzBuffer</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                      <comment type="block">/* Value to return */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>flags</name><operator>==</operator><name>EXPRDUP_REDUCE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>isReduced</name> <init>= <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><name>EXPRDUP_REDUCE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zAlloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>staticFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pzBuffer</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isReduced</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Figure out where to write the new Expr structure. */</comment>
    <if_stmt><if>if<condition>( <expr><name>pzBuffer</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zAlloc</name> <operator>=</operator> <operator>*</operator><name>pzBuffer</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>staticFlag</name> <operator>=</operator> <name>EP_Static</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zAlloc</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>dupedExprSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>zAlloc</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Set nNewSize to the size allocated for the structure pointed to
      ** by pNew. This is either EXPR_FULLSIZE, EXPR_REDUCEDSIZE or
      ** EXPR_TOKENONLYSIZE. nToken is set to the number of bytes consumed
      ** by the copy of the p-&gt;u.zToken string (if any).
      */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>nStructSize</name> <init>= <expr><call><name>dupedExprStructSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nNewSize</name> <init>= <expr><name>nStructSize</name> <operator>&amp;</operator> <literal type="number">0xfff</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nToken</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nToken</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>isReduced</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Reduced</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zAlloc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nNewSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>u32</name></type> <name>nSize</name> <init>= <expr><operator>(</operator><name>u32</name><operator>)</operator><call><name>exprStructSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zAlloc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&lt;</operator><name>EXPR_FULLSIZE</name></expr> )</condition><block>{<block_content> 
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zAlloc</name><index>[<expr><name>nSize</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EXPR_FULLSIZE</name><operator>-</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Set the EP_Reduced, EP_TokenOnly, and EP_Static flags appropriately. */</comment>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name><operator>|</operator><name>EP_Static</name><operator>|</operator><name>EP_MemToken</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>nStructSize</name> <operator>&amp;</operator> <operator>(</operator><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>staticFlag</name></expr>;</expr_stmt>

      <comment type="block">/* Copy the p-&gt;u.zToken string, if any. */</comment>
      <if_stmt><if>if<condition>( <expr><name>nToken</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zToken</name> <init>= <expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zAlloc</name><index>[<expr><name>nNewSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zToken</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>|</operator><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name><operator>)</operator> <operator>&amp;</operator> <name>EP_TokenOnly</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <comment type="block">/* Fill in the pNew-&gt;x.pSelect or pNew-&gt;x.pList member. */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>, <argument><expr><name>isReduced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><name>isReduced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Fill in pNew-&gt;pLeft and pNew-&gt;pRight. */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_Reduced</name><operator>|</operator><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zAlloc</name> <operator>+=</operator> <call><name>dupedExprNodeSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <call><name>exprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <call><name>exprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>EXPRDUP_REDUCE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pzBuffer</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pzBuffer</name> <operator>=</operator> <name>zAlloc</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create and return a deep copy of the object passed as the second 
** argument. If an OOM condition is encountered, NULL is returned
** and the db-&gt;mallocFailed flag set.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CTE</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>With</name> <modifier>*</modifier></type><name>withDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>With</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>With</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nCte</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>nCte</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nCte</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCte</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSelect</name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCols</name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCols</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>withDup</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following group of routines make deep copies of expressions,
** expression lists, ID lists, and select statements.  The copies can
** be deleted (by being passed to their respective ...Delete() routines)
** without effecting the originals.
**
** The expression list, ID, and source lists return by sqlite3ExprListDup(),
** sqlite3IdListDup(), and sqlite3SrcListDup() can not be further expanded 
** by subsequent calls to sqlite*ListAppend() routines.
**
** Any tables that the SrcList might point to are not duplicated.
**
** The flags parameter contains a combination of the EXPRDUP_XXX flags.
** If the EXPRDUP_REDUCE flag is set, then the structure returned is a
** truncated version of the usual Expr structure that will be stored as
** part of the in-memory representation of the database schema.
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3ExprDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>flags</name><operator>==</operator><name>EXPRDUP_REDUCE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>exprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>ExprList</name> <modifier>*</modifier></type><name>sqlite3ExprListDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pOldItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>=</operator> <name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EXPRDUP_REDUCE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>i</name></expr></incr>)</control><block>{<block_content/>}</block></for></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>pItem</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>,  <argument><expr><name>i</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pItem</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt> 
  <expr_stmt><expr><name>pOldItem</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr><operator>,</operator> <expr><name>pOldItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pOldExpr</name> <init>= <expr><name><name>pOldItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldExpr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zSpan</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zSpan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>sortOrder</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>sortOrder</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>bSpanIsTab</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>bSpanIsTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>u</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If cursors, triggers, views and subqueries are all omitted from
** the build, then none of the following routines, except for 
** sqlite3SelectDup(), can be called. sqlite3SelectDup() is sometimes
** called with a NULL argument.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call> \
 <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>SrcList</name> <modifier>*</modifier></type><name>sqlite3SrcListDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSrc</name></name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pNewItem</name> <init>= <expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pOldItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>pSchema</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>zDatabase</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zDatabase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>zAlias</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zAlias</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>fg</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>fg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>iCursor</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>addrFillSub</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>addrFillSub</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>regReturn</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>regReturn</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNewItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>zIndexedBy</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>zIndexedBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>pIBIndex</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>pIBIndex</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNewItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pFuncArg</name></name> <operator>=</operator> 
          <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pFuncArg</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pNewItem</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>pSelect</name></name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>pSelect</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>pOn</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>pOn</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>pUsing</name></name> <operator>=</operator> <call><name>sqlite3IdListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>pUsing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>colUsed</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>IdList</name> <modifier>*</modifier></type><name>sqlite3IdListDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>IdList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nId</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nId</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Note that because the size of the allocation for p-&gt;a[] is not
  ** necessarily a power of two, sqlite3IdListAppend() may not be called
  ** on the duplicate created by this function. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>IdList_item</name></name> <modifier>*</modifier></type><name>pNewItem</name> <init>= <expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>IdList_item</name></name> <modifier>*</modifier></type><name>pOldItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOldItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNewItem</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <name><name>pOldItem</name><operator>-&gt;</operator><name>idx</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>Select</name> <modifier>*</modifier></type><name>sqlite3SelectDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pNew</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pPrior</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pEList</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pSrc</name></name> <operator>=</operator> <call><name>sqlite3SrcListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pGroupBy</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pHaving</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pOrderBy</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pPrior</name></name> <operator>=</operator> <name>pPrior</name> <operator>=</operator> <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPrior</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pPrior</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pOffset</name></name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOffset</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>~</operator><name>SF_UsesEphemeral</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrOpenEphm</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nSelectRow</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nSelectRow</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pWith</name></name> <operator>=</operator> <call><name>withDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWith</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAXSCALE</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pInto</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pInto</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3SelectSetName</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSelName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>Select</name> <modifier>*</modifier></type><name>sqlite3SelectDup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Add a new element to the end of an expression list.  If pList is
** initially NULL, then create a new expression list.
**
** If a memory allocation error occurs, the entire list is freed and
** NULL is returned.  If non-NULL is returned, then it is guaranteed
** that the new entry was successfully appended.
*/</comment>
<function><type><name>ExprList</name> <modifier>*</modifier></type><name>sqlite3ExprListAppend</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,        <comment type="block">/* List to which to append. Might be NULL */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>             <comment type="block">/* Expression to be appended. Might be NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprList</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>no_mem</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>no_mem</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pItem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pList</name></expr>;</return>

<label><name>no_mem</name>:</label>     
  <comment type="block">/* Avoid leaking memory if malloc has failed. */</comment>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAXSCALE</name></cpp:ifdef>
<comment type="block">/*
** Add an expression list to the end of an expression list. If pList
** is initially NULL, then create a new expression list.
**
** If a memory allocation error occurs, the entire list is freed and
** NULL is returned.  If non-NULL is returned, then it is guaranteed
** that the list was successfully appended.
*/</comment>
<function><type><name>ExprList</name> <modifier>*</modifier></type><name>sqlite3ExprListAppendList</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,        <comment type="block">/* List to which to append. Might be NULL */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pAppend</name></decl></parameter>       <comment type="block">/* List to be appended. Might be NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pAppend</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>pList</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pList</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>pAppend</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pAppend</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name><name>pAppend</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pList</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pAppend</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
      <goto>goto <name>no_mem</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pList</name></expr>;</return>

<label><name>no_mem</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
** Set the sort order for the last element on the given ExprList.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListSetSortOrder</name><parameter_list>(<parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSortOrder</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>SQLITE_SO_UNDEFINED</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SQLITE_SO_ASC</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SQLITE_SO_DESC</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iSortOrder</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sortOrder</name><operator>==</operator><name>SQLITE_SO_ASC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sortOrder</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iSortOrder</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the ExprList.a[].zName element of the most recently added item
** on the expression list.
**
** pList might be NULL following an OOM error.  But pName should never be
** NULL.  If a memory allocation fails, the pParse-&gt;db-&gt;mallocFailed flag
** is set.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListSetName</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,        <comment type="block">/* List to which to add the span. */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName</name></decl></parameter>,           <comment type="block">/* Name to be added */</comment>
  <parameter><decl><type><name>int</name></type> <name>dequote</name></decl></parameter>             <comment type="block">/* True to cause the name to be dequoted */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>dequote</name> <operator>&amp;&amp;</operator> <name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the ExprList.a[].zSpan element of the most recently added item
** on the expression list.
**
** pList might be NULL following an OOM error.  But pSpan should never be
** NULL.  If a memory allocation fails, the pParse-&gt;db-&gt;mallocFailed flag
** is set.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListSetSpan</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,        <comment type="block">/* List to which to add the span. */</comment>
  <parameter><decl><type><name>ExprSpan</name> <modifier>*</modifier></type><name>pSpan</name></decl></parameter>         <comment type="block">/* The span to be added */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>||</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name><operator>==</operator><name><name>pSpan</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zSpan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>zSpan</name></name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>pSpan</name><operator>-&gt;</operator><name>zStart</name></name></expr></argument>,
                                    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pSpan</name><operator>-&gt;</operator><name>zEnd</name></name> <operator>-</operator> <name><name>pSpan</name><operator>-&gt;</operator><name>zStart</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If the expression list pEList contains more than iLimit elements,
** leave an error message in pParse.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListCheckLength</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zObject</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>mx</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pEList</name> <operator>&amp;&amp;</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name>mx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pEList</name> <operator>&amp;&amp;</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><name>mx</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pEList</name> <operator>&amp;&amp;</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name>mx</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many columns in %s"</literal></expr></argument>, <argument><expr><name>zObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Delete an entire expression list.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>zSpan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the bitwise-OR of all Expr.flags fields in the given
** ExprList.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3ExprListFlags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
       <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
       <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>|=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** These routines are Walker callbacks used to check expressions to
** see if they are "constant" for some definition of constant.  The
** Walker.eCode value determines the type of "constant" we are looking
** for.
**
** These callback routines are used to implement the following:
**
**     sqlite3ExprIsConstant()                  pWalker-&gt;eCode==1
**     sqlite3ExprIsConstantNotJoin()           pWalker-&gt;eCode==2
**     sqlite3ExprIsTableConstant()             pWalker-&gt;eCode==3
**     sqlite3ExprIsConstantOrFunction()        pWalker-&gt;eCode==4 or 5
**
** In all cases, the callbacks set Walker.eCode=0 and abort if the expression
** is found to not be a constant.
**
** The sqlite3ExprIsConstantOrFunction() is used for evaluating expressions
** in a CREATE TABLE statement.  The Walker.eCode value is 5 when parsing
** an existing schema and 4 when processing a new statement.  A bound
** parameter raises an error for new statements, but is silently converted
** to NULL for existing schemas.  This allows sqlite_master tables that 
** contain a bound parameter because they were generated by older versions
** of SQLite to be parsed by newer versions of SQLite without raising a
** malformed schema error.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprNodeIsConstant</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>

  <comment type="block">/* If pWalker-&gt;eCode is 2 then any term of the expression that comes from
  ** the ON or USING clauses of a left join disqualifies the expression
  ** from being considered constant. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Consider functions to be constant if all their arguments are constant
    ** and either pWalker-&gt;eCode==4 or 5 or the function has the
    ** SQLITE_FUNC_CONST flag. */</comment>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>&gt;=</operator><literal type="number">4</literal> <operator>||</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_ConstFunc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Continue</name></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    <case>case <expr><name>TK_ID</name></expr>:</case>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case>
    <case>case <expr><name>TK_AGG_FUNCTION</name></expr>:</case>
    <case>case <expr><name>TK_AGG_COLUMN</name></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>==</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iCur</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>WRC_Continue</name></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    <case>case <expr><name>TK_VARIABLE</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>==</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Silently convert bound parameters that appear inside of CREATE
        ** statements into a NULL when parsing the CREATE statement text out
        ** of the sqlite_master table */</comment>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_NULL</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name><operator>==</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* A bound parameter in a CREATE statement that originates from
        ** sqlite3_prepare() causes an error */</comment>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Abort</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Fall through */</comment>
    <default>default:</default>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* selectNodeIsConstant will disallow */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EXISTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* selectNodeIsConstant will disallow */</comment>
      <return>return <expr><name>WRC_Continue</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>selectNodeIsConstant</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Abort</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprIsConst</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>initFlag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <name>initFlag</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>exprNodeIsConstant</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>selectNodeIsConstant</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>iCur</name></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>w</name><operator>.</operator><name>eCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Walk an expression tree.  Return non-zero if the expression is constant
** and 0 if it involves variables or function calls.
**
** For the purposes of this function, a double-quoted string (ex: "abc")
** is considered a variable but a single-quoted string (ex: 'abc') is
** a constant.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsConstant</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Walk an expression tree.  Return non-zero if the expression is constant
** that does no originate from the ON or USING clauses of a join.
** Return 0 if it involves variables or function calls or terms from
** an ON or USING clause.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsConstantNotJoin</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Walk an expression tree.  Return non-zero if the expression is constant
** for any single row of the table with cursor iCur.  In other words, the
** expression must not refer to any non-deterministic function nor any
** table other than iCur.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsTableConstant</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Walk an expression tree.  Return non-zero if the expression is constant
** or a function call with constant arguments.  Return and 0 if there
** are any variables.
**
** For the purposes of this function, a double-quoted string (ex: "abc")
** is considered a variable but a single-quoted string (ex: 'abc') is
** a constant.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsConstantOrFunction</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>isInit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isInit</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isInit</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>+</operator><name>isInit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
<comment type="block">/*
** Walk an expression tree.  Return 1 if the expression contains a
** subquery of some kind.  Return 0 if there are no subqueries.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprContainsSubquery</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>sqlite3ExprWalkNoop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>selectNodeIsConstant</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If the expression p codes a constant integer that is small enough
** to fit in a 32-bit integer, return 1 and put the value of the integer
** in *pValue.  If the expression is not an integer or if it is too big
** to fit in a signed 32-bit integer, return 0 and leave *pValue unchanged.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsInteger</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If an expression is an integer literal that fits in a signed 32-bit
  ** integer, then the EP_IntValue flag will have already been set */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_INTEGER</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_IntValue</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
           <operator>||</operator> <call><name>sqlite3GetInt32</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_IntValue</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pValue</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_UPLUS</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_UMINUS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><operator>(</operator><operator>-</operator><literal type="number">2147483647</literal><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pValue</name> <operator>=</operator> <operator>-</operator><name>v</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return FALSE if there is no chance that the expression can be NULL.
**
** If the expression might be NULL or if the expression is too complex
** to tell return TRUE.  
**
** This routine is used as an optimization, to skip OP_IsNull opcodes
** when we know that a value cannot be NULL.  Hence, a false positive
** (returning TRUE when in fact the expression can never be NULL) might
** be a small performance hit but is otherwise harmless.  On the other
** hand, a false negative (returning FALSE when the result could be NULL)
** will likely result in an incorrect answer.  So when in doubt, return
** TRUE.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCanBeNull</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>op</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UPLUS</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UMINUS</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt> </block_content>}</block></while>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_REGISTER</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_INTEGER</name></expr>:</case>
    <case>case <expr><name>TK_STRING</name></expr>:</case>
    <case>case <expr><name>TK_FLOAT</name></expr>:</case>
    <case>case <expr><name>TK_BLOB</name></expr>:</case>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_CanBeNull</name></expr></argument>)</argument_list></call> <operator>||</operator>
             <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>notNull</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    <default>default:</default>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the given expression is a constant which would be
** unchanged by OP_Affinity with the affinity given in the second
** argument.
**
** This routine is used to determine if the OP_Affinity operation
** can be omitted.  When in doubt return FALSE.  A false negative
** is harmless.  A false positive, however, can result in the wrong
** answer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprNeedsNoAffinityChange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>aff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>op</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>aff</name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UPLUS</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_UMINUS</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt> </block_content>}</block></while>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_REGISTER</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_INTEGER</name></expr>:</case> <block>{<block_content>
      <return>return <expr><name>aff</name><operator>==</operator><name>SQLITE_AFF_INTEGER</name> <operator>||</operator> <name>aff</name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_FLOAT</name></expr>:</case> <block>{<block_content>
      <return>return <expr><name>aff</name><operator>==</operator><name>SQLITE_AFF_REAL</name> <operator>||</operator> <name>aff</name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_STRING</name></expr>:</case> <block>{<block_content>
      <return>return <expr><name>aff</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_BLOB</name></expr>:</case> <block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* p cannot be part of a CHECK constraint */</comment>
      <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal>
          <operator>&amp;&amp;</operator> <operator>(</operator><name>aff</name><operator>==</operator><name>SQLITE_AFF_INTEGER</name> <operator>||</operator> <name>aff</name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name><operator>)</operator></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the given string is a row-id column name.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsRowid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"_ROWID_"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"ROWID"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"OID"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if we are able to the IN operator optimization on a
** query of the form
**
**       x IN (SELECT ...)
**
** Where the SELECT... clause is as specified by the parameter to this
** routine.
**
** The Select object passed in has already been preprocessed and no
** errors have been found.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isCandidateForInOpt</name><parameter_list>(<parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                   <comment type="block">/* right-hand side of IN is SELECT */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>              <comment type="block">/* Not a compound SELECT */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator><operator>)</operator><operator>==</operator><name>SF_Distinct</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator><operator>)</operator><operator>==</operator><name>SF_Aggregate</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* No DISTINCT keyword and no aggregate functions */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>              <comment type="block">/* Has no GROUP BY clause */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>              <comment type="block">/* Has no LIMIT clause */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOffset</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>               <comment type="block">/* No LIMIT means no OFFSET */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pWhere</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>              <comment type="block">/* Has no WHERE clause */</comment>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>          <comment type="block">/* Single term in FROM clause */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>     <comment type="block">/* FROM is not a subquery or view */</comment>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSelect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* FROM clause is not a view */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* FROM clause not a virtual table */</comment>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>       <comment type="block">/* One column in the result set */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Result is a column */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>

<comment type="block">/*
** Code an OP_Once instruction and allocate space for its flag. Return the 
** address of the new instruction.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3CodeOnce</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>      <comment type="block">/* Virtual machine being coded */</comment>
  <return>return <expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nOnce</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that checks the left-most column of index table iCur to see if
** it contains any NULL entries.  Cause the register at regHasNull to be set
** to a non-NULL value if iCur contains no NULLs.  Cause register regHasNull
** to be set to NULL if iCur contains one or more NULL values.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3SetHasNullFlag</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regHasNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regHasNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regHasNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_TYPEOFARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"first_entry_in(%d)"</literal><operator>,</operator> <name>iCur</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** The argument is an IN operator with a list (not a subquery) on the 
** right-hand side.  Return TRUE if that list is constant.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3InRhsIsConstant</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLHS</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLHS</name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>=</operator> <name>pLHS</name></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function is used by the implementation of the IN (...) operator.
** The pX parameter is the expression on the RHS of the IN operator, which
** might be either a list of expressions or a subquery.
**
** The job of this routine is to find or create a b-tree object that can
** be used either to test for membership in the RHS set or to iterate through
** all members of the RHS set, skipping duplicates.
**
** A cursor is opened on the b-tree object that is the RHS of the IN operator
** and pX-&gt;iTable is set to the index of that cursor.
**
** The returned value of this function indicates the b-tree type, as follows:
**
**   IN_INDEX_ROWID      - The cursor was opened on a database table.
**   IN_INDEX_INDEX_ASC  - The cursor was opened on an ascending index.
**   IN_INDEX_INDEX_DESC - The cursor was opened on a descending index.
**   IN_INDEX_EPH        - The cursor was opened on a specially created and
**                         populated epheremal table.
**   IN_INDEX_NOOP       - No cursor was allocated.  The IN operator must be
**                         implemented as a sequence of comparisons.
**
** An existing b-tree might be used if the RHS expression pX is a simple
** subquery such as:
**
**     SELECT &lt;column&gt; FROM &lt;table&gt;
**
** If the RHS of the IN operator is a list or a more complex subquery, then
** an ephemeral table might need to be generated from the RHS and then
** pX-&gt;iTable made to point to the ephemeral table instead of an
** existing table.
**
** The inFlags parameter must contain exactly one of the bits
** IN_INDEX_MEMBERSHIP or IN_INDEX_LOOP.  If inFlags contains
** IN_INDEX_MEMBERSHIP, then the generated table will be used for a
** fast membership test.  When the IN_INDEX_LOOP bit is set, the
** IN index will be used to loop over all values of the RHS of the
** IN operator.
**
** When IN_INDEX_LOOP is used (and the b-tree will be used to iterate
** through the set members) then the b-tree must not contain duplicates.
** An epheremal table must be used unless the selected &lt;column&gt; is guaranteed
** to be unique - either because it is an INTEGER PRIMARY KEY or it
** has a UNIQUE constraint or UNIQUE index.
**
** When IN_INDEX_MEMBERSHIP is used (and the b-tree will be used 
** for fast set membership tests) then an epheremal table must 
** be used unless &lt;column&gt; is an INTEGER PRIMARY KEY or an index can 
** be found with &lt;column&gt; as its left-most column.
**
** If the IN_INDEX_NOOP_OK and IN_INDEX_MEMBERSHIP are both set and
** if the RHS of the IN operator is a list (not a subquery) then this
** routine might decide that creating an ephemeral b-tree for membership
** testing is too expensive and return IN_INDEX_NOOP.  In that case, the
** calling routine should implement the IN operator using a sequence
** of Eq or Ne comparison operations.
**
** When the b-tree is being used for membership tests, the calling function
** might need to know whether or not the RHS side of the IN operator
** contains a NULL.  If prRhsHasNull is not a NULL pointer and 
** if there is any chance that the (...) might contain a NULL value at
** runtime, then a register is allocated and the register number written
** to *prRhsHasNull. If there is no chance that the (...) contains a
** NULL value, then *prRhsHasNull is left unchanged.
**
** If a register is allocated and its location stored in *prRhsHasNull, then
** the value in that register will be NULL if the b-tree contains one or more
** NULL values, and it will be some non-NULL value if the b-tree contains no
** NULL values.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3FindInIndex</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>inFlags</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>prRhsHasNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                            <comment type="block">/* SELECT to the right of IN operator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                        <comment type="block">/* Type of RHS table. IN_INDEX_* */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>            <comment type="block">/* Cursor of the RHS table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mustBeUnique</name></decl>;</decl_stmt>                     <comment type="block">/* True if RHS must be unique */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>     <comment type="block">/* Virtual machine being coded */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mustBeUnique</name> <operator>=</operator> <operator>(</operator><name>inFlags</name> <operator>&amp;</operator> <name>IN_INDEX_LOOP</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Check to see if an existing table or index can be used to
  ** satisfy the query.  This is preferable to generating a new 
  ** ephemeral table.
  */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>pX</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isCandidateForInOpt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Database connection */</comment>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                           <comment type="block">/* Table &lt;table&gt;. */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>                           <comment type="block">/* Expression &lt;column&gt; */</comment>
    <decl_stmt><decl><type><name>i16</name></type> <name>iCol</name></decl>;</decl_stmt>                              <comment type="block">/* Index of column &lt;column&gt; */</comment>
    <decl_stmt><decl><type><name>i16</name></type> <name>iDb</name></decl>;</decl_stmt>                               <comment type="block">/* Database idx for pTab */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>                        <comment type="block">/* Because of isCandidateForInOpt(p) */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>             <comment type="block">/* Because of isCandidateForInOpt(p) */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Because of isCandidateForInOpt(p) */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>               <comment type="block">/* Because of isCandidateForInOpt(p) */</comment>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCol</name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
   
    <comment type="block">/* Code an OP_Transaction and OP_TableLock for &lt;table&gt;. */</comment>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This function is only called from two places. In both cases the vdbe
    ** has already been allocated. So assume sqlite3GetVdbe() is always
    ** successful here.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name> <init>= <expr><call><name>sqlite3CodeOnce</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>IN_INDEX_ROWID</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>                         <comment type="block">/* Iterator variable */</comment>

      <comment type="block">/* The collation sequence used by the comparison. If an index is to
      ** be used in place of a temp-table, it must be ordered according
      ** to this collation sequence.  */</comment>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pReq</name> <init>= <expr><call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Check that the affinity that will be used to perform the 
      ** comparison is the same as the affinity of the column. If
      ** it is not, it is not possible to use any index.
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>affinity_ok</name> <init>= <expr><call><name>sqlite3IndexAffinityOk</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>affinity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>affinity_ok</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>iCol</name><operator>)</operator>
         <operator>&amp;&amp;</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><name>pReq</name>
         <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>mustBeUnique</name> <operator>||</operator> <operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name> <init>= <expr><call><name>sqlite3CodeOnce</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>IN_INDEX_INDEX_DESC</name> <operator>==</operator> <name>IN_INDEX_INDEX_ASC</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>IN_INDEX_INDEX_ASC</name> <operator>+</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

          <if_stmt><if>if<condition>( <expr><name>prRhsHasNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>notNull</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>prRhsHasNull</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3SetHasNullFlag</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><operator>*</operator><name>prRhsHasNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If no preexisting index is available for the IN clause
  ** and IN_INDEX_NOOP is an allowed reply
  ** and the RHS of the IN operator is a list, not a subquery
  ** and the RHS is not contant or has two or fewer terms,
  ** then it is not worth creating an ephemeral table to evaluate
  ** the IN operator so return IN_INDEX_NOOP.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>inFlags</name> <operator>&amp;</operator> <name>IN_INDEX_NOOP_OK</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>sqlite3InRhsIsConstant</name><argument_list>(<argument><expr><name>pX</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pX</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&lt;=</operator><literal type="number">2</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>IN_INDEX_NOOP</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
     

  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Could not find an existing table or index to use as the RHS b-tree.
    ** We will have to generate an ephemeral table to do the job.
    */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>savedNQueryLoop</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rMayHaveNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>IN_INDEX_EPH</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>inFlags</name> <operator>&amp;</operator> <name>IN_INDEX_LOOP</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>IN_INDEX_ROWID</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>prRhsHasNull</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>prRhsHasNull</name> <operator>=</operator> <name>rMayHaveNull</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3CodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><name>rMayHaveNull</name></expr></argument>, <argument><expr><name>eType</name><operator>==</operator><name>IN_INDEX_ROWID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>=</operator> <name>savedNQueryLoop</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>eType</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Generate code for scalar subqueries used as a subquery expression, EXISTS,
** or IN operators.  Examples:
**
**     (SELECT a FROM b)          -- subquery
**     EXISTS (SELECT a FROM b)   -- EXISTS subquery
**     x IN (4,5,11)              -- IN operator with list on right-hand side
**     x IN (SELECT a FROM b)     -- IN operator with subquery on the right
**
** The pExpr parameter describes the expression that contains the IN
** operator or subquery.
**
** If parameter isRowid is non-zero, then expression pExpr is guaranteed
** to be of the form "&lt;rowid&gt; IN (?, ?, ?)", where &lt;rowid&gt; is a reference
** to some integer key column of a table B-Tree. In this case, use an
** intkey B-Tree to store the set of IN(...) values instead of the usual
** (slower) variable length keys B-Tree.
**
** If rMayHaveNull is non-zero, that means that the operation is an IN
** (not a SELECT or EXISTS) and that the RHS might contains NULLs.
** All this routine does is initialize the register given by rMayHaveNull
** to NULL.  Calling routines will take care of changing this register
** value to non-NULL if the RHS is NULL-free.
**
** For a SELECT or EXISTS operator, return the register that holds the
** result.  For IN operators or if an error occurs, the return value is 0.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3CodeSubselect</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,          <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,            <comment type="block">/* The IN, SELECT, or EXISTS operator */</comment>
  <parameter><decl><type><name>int</name></type> <name>rHasNullFlag</name></decl></parameter>,       <comment type="block">/* Register that records whether NULLs exist in RHS */</comment>
  <parameter><decl><type><name>int</name></type> <name>isRowid</name></decl></parameter>             <comment type="block">/* If true, LHS of IN operator is a rowid */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>jmpIfDynamic</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                      <comment type="block">/* One-time test address */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rReg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                           <comment type="block">/* Register storing resulting */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This code must be run in its entirety every time it is encountered
  ** if any of the following is true:
  **
  **    *  The right-hand side is a correlated subquery
  **    *  The right-hand side is an expression list containing variables
  **    *  We are inside a trigger
  **
  ** If all of the above are false, then we can run this code just once
  ** save the results, and reuse the same result on subsequent invocations.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_VarSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>jmpIfDynamic</name> <operator>=</operator> <call><name>sqlite3CodeOnce</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"EXECUTE %s%s SUBQUERY %d"</literal></expr></argument>,
        <argument><expr><ternary><condition><expr><name>jmpIfDynamic</name><operator>&gt;=</operator><literal type="number">0</literal></expr>?</condition><then><expr><literal type="string">""</literal></expr></then><else>:<expr><literal type="string">"CORRELATED "</literal></expr></else></ternary></expr></argument>,
        <argument><expr><ternary><condition><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name></expr>?</condition><then><expr><literal type="string">"LIST"</literal></expr></then><else>:<expr><literal type="string">"SCALAR"</literal></expr></else></ternary></expr></argument>,
        <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iNextSelectId</name></name></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Explain</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelectId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_IN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name>affinity</name></decl>;</decl_stmt>              <comment type="block">/* Affinity of the LHS of the IN */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>                   <comment type="block">/* Address of OP_OpenEphemeral instruction */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* the LHS of the IN operator */</comment>
      <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Key information */</comment>

      <expr_stmt><expr><name>affinity</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Whether this is an 'x IN(SELECT...)' or an 'x IN(&lt;exprlist&gt;)'
      ** expression it is handled the same way.  An ephemeral table is 
      ** filled with single-field index keys representing the results
      ** from the SELECT or the &lt;exprlist&gt;.
      **
      ** If the 'x' expression is a column value, or the SELECT...
      ** statement returns a column value, then the affinity of that
      ** column is used to build the index keys. If both 'x' and the
      ** SELECT... statement are columns, then numeric affinity is used
      ** if either column has NUMERIC or INTEGER affinity. If neither
      ** 'x' nor the SELECT... statement are columns, then numeric affinity
      ** is used.
      */</comment>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><operator>!</operator><name>isRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <ternary><condition><expr><name>isRowid</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>sqlite3KeyInfoAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* Case 1:     expr IN (SELECT ...)
        **
        ** Generate code to write the results of the select into the temporary
        ** table allocated and opened above.
        */</comment>
        <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>isRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>SRT_Set</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>affSdst</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>affinity</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>&amp;</operator><literal type="number">0x0000FFFF</literal><operator>)</operator><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pKeyInfo</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Caused by OOM in sqlite3KeyInfoAlloc() */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3KeyInfoUnref</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pKeyInfo</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* OOM will cause exit after sqlite3Select() */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3KeyInfoIsWriteable</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>,
                                                         <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* Case 2:     expr IN (exprlist)
        **
        ** For each expression, build an index key from the evaluation and
        ** store it in the temporary table. If &lt;expr&gt; is a column, then use
        ** that columns affinity when building index keys. If &lt;expr&gt; is not
        ** a column, use numeric affinity.
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>, <decl><type ref="prev"/><name>r3</name></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>affinity</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>affinity</name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pKeyInfo</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3KeyInfoIsWriteable</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Loop through each expression in &lt;exprlist&gt;. */</comment>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>isRowid</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr><operator>,</operator> <expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE2</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iValToIns</name></decl>;</decl_stmt>

          <comment type="block">/* If the expression is not constant then we will need to
          ** disable the test that was generated above that makes sure
          ** this code only executes once.  Because for a non-constant
          ** expression we need to rerun this code each time.
          */</comment>
          <if_stmt><if>if<condition>( <expr><name>jmpIfDynamic</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pE2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>jmpIfDynamic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>jmpIfDynamic</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Evaluate the expression and insert it into the temp table */</comment>
          <if_stmt><if>if<condition>( <expr><name>isRowid</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pE2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iValToIns</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InsertInt</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>iValToIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>r3</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>isRowid</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>,
                                <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>affinity</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pKeyInfo</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TK_EXISTS</name></expr>:</case>
    <case>case <expr><name>TK_SELECT</name></expr>:</case>
    <default>default:</default> <block>{<block_content>
      <comment type="block">/* If this has to be a scalar SELECT.  Generate code to put the
      ** value of this select in a memory cell and record the number
      ** of the memory cell in iColumn.  If this is an EXISTS, write
      ** an integer 0 (not exists) or 1 (exists) into a memory cell
      ** and record that memory cell in iColumn.
      */</comment>
      <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name></decl>;</decl_stmt>                         <comment type="block">/* SELECT statement to encode */</comment>
      <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>                      <comment type="block">/* How to deal with SELECt result */</comment>

      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EXISTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EXISTS</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pSel</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SELECT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>eDest</name></name> <operator>=</operator> <name>SRT_Mem</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>iSdst</name></name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Init subquery result"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>eDest</name></name> <operator>=</operator> <name>SRT_Exists</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Init EXISTS result"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pSel</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name><name>sqlite3IntTokens</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>iLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSel</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SF_MultiValue</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rReg</name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>

  <if_stmt><if>if<condition>( <expr><name>rHasNullFlag</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3SetHasNullFlag</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name>rHasNullFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>jmpIfDynamic</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>jmpIfDynamic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rReg</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** Generate code for an IN expression.
**
**      x IN (SELECT ...)
**      x IN (value, value, ...)
**
** The left-hand side (LHS) is a scalar expression.  The right-hand side (RHS)
** is an array of zero or more values.  The expression is true if the LHS is
** contained within the RHS.  The value of the expression is unknown (NULL)
** if the LHS is NULL or if the LHS is not contained within the RHS and the
** RHS contains one or more NULL values.
**
** This routine generates code that jumps to destIfFalse if the LHS is not 
** contained within the RHS.  If due to NULLs we cannot determine if the LHS
** is contained in the RHS then jump to destIfNull.  If the LHS is contained
** within the RHS then fall through.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3ExprCodeIN</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,          <comment type="block">/* The IN expression */</comment>
  <parameter><decl><type><name>int</name></type> <name>destIfFalse</name></decl></parameter>,      <comment type="block">/* Jump here if LHS is not contained in the RHS */</comment>
  <parameter><decl><type><name>int</name></type> <name>destIfNull</name></decl></parameter>        <comment type="block">/* Jump here if the results are unknown due to NULLs */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rRhsHasNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Register that is true if RHS contains NULL values */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>affinity</name></decl>;</decl_stmt>        <comment type="block">/* Comparison affinity to use */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>            <comment type="block">/* Type of the RHS */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>               <comment type="block">/* Temporary use register */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>              <comment type="block">/* Statement under construction */</comment>

  <comment type="block">/* Compute the RHS.   After this step, the table with cursor
  ** pExpr-&gt;iTable will contains the values that make up the RHS.
  */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* OOM detected prior to this routine */</comment>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"begin IN expr"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eType</name> <operator>=</operator> <call><name>sqlite3FindInIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>,
                             <argument><expr><name>IN_INDEX_MEMBERSHIP</name> <operator>|</operator> <name>IN_INDEX_NOOP_OK</name></expr></argument>,
                             <argument><expr><ternary><condition><expr><name>destIfFalse</name><operator>==</operator><name>destIfNull</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>&amp;</operator><name>rRhsHasNull</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out the affinity to use to create a key from the results
  ** of the expression. affinityStr stores a static string suitable for
  ** P4 of OP_MakeRecord.
  */</comment>
  <expr_stmt><expr><name>affinity</name> <operator>=</operator> <call><name>comparisonAffinity</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Code the LHS, the &lt;expr&gt; from "&lt;expr&gt; IN (...)".
  */</comment>
  <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If sqlite3FindInIndex() did not find or create an index that is
  ** suitable for evaluating the IN operator, then evaluate using a
  ** sequence of comparisons.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>IN_INDEX_NOOP</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>labelOk</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r2</name></decl>, <decl><type ref="prev"/><name>regToFree</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regCkNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>destIfNull</name><operator>!=</operator><name>destIfFalse</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>regCkNull</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_BitAnd</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regCkNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>regCkNull</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_BitAnd</name></expr></argument>, <argument><expr><name>regCkNull</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>regCkNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>ii</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>destIfNull</name><operator>!=</operator><name>destIfFalse</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Eq</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>labelOk</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>,
                          <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ii</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ii</name><operator>==</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>destIfNull</name><operator>==</operator><name>destIfFalse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Ne</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>,
                          <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>affinity</name> <operator>|</operator> <name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>regCkNull</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regCkNull</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regCkNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
  
    <comment type="block">/* If the LHS is NULL, then the result is either false or NULL depending
    ** on whether the RHS is empty or not, respectively.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>destIfNull</name><operator>==</operator><name>destIfFalse</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Shortcut for the common case where the false and NULL outcomes are
        ** the same. */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>addr1</name> <init>= <expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>IN_INDEX_ROWID</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* In this case, the RHS is the ROWID of table b-tree
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* In this case, the RHS is an index b-tree.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Affinity</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>affinity</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
      <comment type="block">/* If the set membership test fails, then the result of the 
      ** "x IN (...)" expression must be either 0 or NULL. If the set
      ** contains no NULL values, then the result is 0. If the set 
      ** contains one or more NULL values, then the result of the
      ** expression is also NULL.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>destIfFalse</name><operator>!=</operator><name>destIfNull</name> <operator>||</operator> <name>rRhsHasNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rRhsHasNull</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* This branch runs if it is known at compile time that the RHS
        ** cannot contain NULL values. This happens as the result
        ** of a "NOT NULL" constraint in the database schema.
        **
        ** Also run this branch if NULL is equivalent to FALSE
        ** for this particular IN operator.
        */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* In this branch, the RHS of the IN might contain a NULL and
        ** the presence of a NULL on the RHS makes a difference in the
        ** outcome.
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>
  
        <comment type="block">/* First check to see if the LHS is contained in the RHS.  If so,
        ** then the answer is TRUE the presence of NULLs in the RHS does
        ** not matter.  If the LHS is not contained in the RHS, then the
        ** answer is NULL if the RHS contains NULLs and the answer is
        ** FALSE if the RHS is NULL-free.
        */</comment>
        <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>rRhsHasNull</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"end IN expr"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/*
** Generate an instruction that will put the floating point
** value described by z[0..n-1] into register iMem.
**
** The z[] string will probably not be zero-terminated.  But the 
** z[n] character is guaranteed to be something that does not look
** like the continuation of the number.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeReal</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>negateFlag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>z</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* The new AtoF never returns NaN */</comment>
    <if_stmt><if>if<condition>( <expr><name>negateFlag</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>-</operator><name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Dup8</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Real</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>P4_REAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Generate an instruction that will put the integer describe by
** text z[0..n-1] into register iMem.
**
** Expr.u.zToken is always UTF8 and zero-terminated.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeInteger</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>negFlag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_IntValue</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>negFlag</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3DecOrHexToI64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>negFlag</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>negFlag</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>value</name> <operator>=</operator> <ternary><condition><expr><name>c</name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name>SMALLEST_INT64</name></expr> </then><else>: <expr><operator>-</operator><name>value</name></expr></else></ternary></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Dup8</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Int64</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>P4_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifdef>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"oversized integer: %s%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>negFlag</name></expr> ?</condition><then> <expr><literal type="string">"-"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_HEX_INTEGER</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"0x"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"hex literal too big: %s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
        <expr_stmt><expr><call><name>codeReal</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>negFlag</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Clear a cache entry.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cacheEntryClear</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>yColCache</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>tempReg</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aTempReg</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aTempReg</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iReg</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tempReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Record in the column cache that a particular column from a
** particular table is stored in a particular register.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCacheStore</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>minLru</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idxLru</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>yColCache</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <comment type="block">/* Unless an error has occurred, register numbers are always positive. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iReg</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><literal type="number">32768</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Finite column numbers */</comment>

  <comment type="block">/* The SQLITE_ColumnCache flag disables the column cache.  This is used
  ** for testing only - to verify that SQLite always gets the same answer
  ** with and without the column cache.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_ColumnCache</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* First replace any existing entry.
  **
  ** Actually, the way the column cache is currently used, we are guaranteed
  ** that the object will never already be in cache.  Verify this guarantee.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name>iTab</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name>iCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Find an empty slot and replace it */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLevel</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iCacheLevel</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name> <operator>=</operator> <name>iReg</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tempReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iCacheCnt</name></name><operator>++</operator></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Replace the last recently used */</comment>
  <expr_stmt><expr><name>minLru</name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>idxLru</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>lru</name></name><operator>&lt;</operator><name>minLru</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>idxLru</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>minLru</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>lru</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>idxLru</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name><index>[<expr><name>idxLru</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLevel</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iCacheLevel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name> <operator>=</operator> <name>iReg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tempReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iCacheCnt</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Indicate that registers between iReg..iReg+nReg-1 are being overwritten.
** Purge the range of registers from the column cache.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCacheRemove</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLast</name> <init>= <expr><name>iReg</name> <operator>+</operator> <name>nReg</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>yColCache</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>r</name><operator>&gt;=</operator><name>iReg</name> <operator>&amp;&amp;</operator> <name>r</name><operator>&lt;=</operator><name>iLast</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>cacheEntryClear</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Remember the current column cache context.  Any new entries added
** added to the column cache after this call are removed when the
** corresponding pop occurs.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCachePush</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iCacheLevel</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"PUSH to %d\n"</literal></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iCacheLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Remove from the column cache any entries that were added since the
** the previous sqlite3ExprCachePush operation.  In other words, restore
** the cache to the state it was in prior the most recent Push.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCachePop</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>yColCache</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iCacheLevel</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iCacheLevel</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"POP  to %d\n"</literal></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iCacheLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iLevel</name></name><operator>&gt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>iCacheLevel</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>cacheEntryClear</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** When a cached column is reused, make sure that its register is
** no longer available as a temp register.  ticket #3879:  that same
** register might be in the cache in multiple places, so be sure to
** get them all.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3ExprCachePinRegister</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>yColCache</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name><operator>==</operator><name>iReg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tempReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Generate code that will load into register regOut a value that is
** appropriate for the iIdxCol-th column of index pIdx.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeLoadIndexColumn</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,  <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,    <comment type="block">/* The index whose column is to be loaded */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTabCur</name></decl></parameter>,    <comment type="block">/* Cursor pointing to a table row */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCol</name></decl></parameter>,    <comment type="block">/* The column of the index to be loaded */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOut</name></decl></parameter>      <comment type="block">/* Store the index column value in this register */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i16</name></type> <name>iTabCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iIdxCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iTabCol</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>nExpr</name></name><operator>&gt;</operator><name>iIdxCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <name>iTabCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCodeCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iIdxCol</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>,
                                    <argument><expr><name>iTabCol</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to extract the value of the iCol-th column of a table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeGetColumnOfTable</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,        <comment type="block">/* The VDBE under construction */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,    <comment type="block">/* The table containing the value */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTabCur</name></decl></parameter>,    <comment type="block">/* The table cursor.  Or the PK cursor for WITHOUT ROWID */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,       <comment type="block">/* Index of the column to extract */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOut</name></decl></parameter>      <comment type="block">/* Extract the value into this register */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><ternary><condition><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>OP_VColumn</name></expr> </then><else>: <expr><name>OP_Column</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name>iCol</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3ColumnOfIndex</name><argument_list>(<argument><expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ColumnDefault</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will extract the iColumn-th column from
** table pTab and store the column value in a register. 
**
** An effort is made to store the column value in register iReg.  This
** is not garanteeed for GetColumn() - the result can be stored in
** any register.  But the result is guaranteed to land in register iReg
** for GetColumnToReg().
**
** There must be an open cursor to pTab in iTable when this routine
** is called.  If iColumn&lt;0 then code is generated that extracts the rowid.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeGetColumn</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,   <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,     <comment type="block">/* Description of the table we are reading from */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,     <comment type="block">/* Index of the table column */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTable</name></decl></parameter>,      <comment type="block">/* The cursor pointing to the table */</comment>
  <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>,        <comment type="block">/* Store results here */</comment>
  <parameter><decl><type><name>u8</name></type> <name>p5</name></decl></parameter>            <comment type="block">/* P5 value for OP_Column + FLAGS */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>yColCache</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name>iTable</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>iColumn</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lru</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iCacheCnt</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCachePinRegister</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p5</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>   
    <expr_stmt><expr><call><name>sqlite3ExprCacheStore</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>iReg</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3ExprCodeGetColumnToReg</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,   <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,     <comment type="block">/* Description of the table we are reading from */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,     <comment type="block">/* Index of the table column */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTable</name></decl></parameter>,      <comment type="block">/* The cursor pointing to the table */</comment>
  <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>         <comment type="block">/* Store results here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3ExprCodeGetColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>r1</name><operator>!=</operator><name>iReg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Clear all column cache entries.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCacheClear</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>yColCache</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEBUG</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"CLEAR\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>cacheEntryClear</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Record the fact that an affinity change has occurred on iCount
** registers starting with iStart.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCacheAffinityChange</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCount</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3ExprCacheRemove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>, <argument><expr><name>iCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to move content from registers iFrom...iFrom+nReg-1
** over to iTo..iTo+nReg-1. Keep the column cache up-to-date.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeMove</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iFrom</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFrom</name><operator>&gt;=</operator><name>iTo</name><operator>+</operator><name>nReg</name> <operator>||</operator> <name>iFrom</name><operator>+</operator><name>nReg</name><operator>&lt;=</operator><name>iTo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_Move</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>, <argument><expr><name>nReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCacheRemove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><name>nReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_COVERAGE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Return true if any register in the range iFrom..iTo (inclusive)
** is used as part of the column cache.
**
** This routine is used within assert() and testcase() macros only
** and does not appear in a normal build.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>usedAsColumnCache</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iFrom</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>yColCache</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>r</name><operator>&gt;=</operator><name>iFrom</name> <operator>&amp;&amp;</operator> <name>r</name><operator>&lt;=</operator><name>iTo</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/*NO_TEST*/</comment>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG || SQLITE_COVERAGE_TEST */</comment>

<comment type="block">/*
** Convert an expression node to a TK_REGISTER
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exprToRegister</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_REGISTER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iReg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExprClearProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code into the current Vdbe to evaluate the given
** expression.  Attempt to store the results in register "target".
** Return the register where results are stored.
**
** With this routine, there is no guarantee that results will
** be stored in target.  The result might be stored in some other
** register if it is convenient to do so.  The calling function
** must check the return code and move the results to the desired
** register.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeTarget</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The VM under construction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                   <comment type="block">/* The opcode being coded */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>inReg</name> <init>= <expr><name>target</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Results stored in register inReg */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* If non-zero free this temporary register */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* If non-zero free this temporary register */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>, <decl><type ref="prev"/><name>r3</name></decl>, <decl><type ref="prev"/><name>r4</name></decl>;</decl_stmt>       <comment type="block">/* Various register numbers */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>Expr</name></type> <name>tempX</name></decl>;</decl_stmt>               <comment type="block">/* Temporary expression node */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>target</name><operator>&lt;=</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>TK_NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_AGG_COLUMN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_col</name></name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>directMode</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>iMem</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inReg</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>iMem</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>useSortingIdx</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>sortingIdxPTab</name></name></expr></argument>,
                              <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Otherwise, fall thru into the TK_COLUMN case */</comment>
    </block_content>}</block>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iTab</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iTab</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>ckBase</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Generating CHECK constraints or inserting into partial index */</comment>
          <expr_stmt><expr><name>inReg</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>+</operator> <name><name>pParse</name><operator>-&gt;</operator><name>ckBase</name></name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Coding an expression that is part of an index where column names
          ** in the index refer to the table to which the index belongs */</comment>
          <expr_stmt><expr><name>iTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeGetColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>,
                               <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                               <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_INTEGER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codeInteger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
    <case>case <expr><name>TK_FLOAT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeReal</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>TK_STRING</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeLoadString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_NULL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BLOB_LITERAL</name></cpp:ifndef>
    <case>case <expr><name>TK_BLOB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBlob</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'x'</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'X'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>&amp;</operator><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zBlob</name> <operator>=</operator> <call><name>sqlite3HexToBlob</name><argument_list>(<argument><expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Blob</name></expr></argument>, <argument><expr><name>n</name><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zBlob</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>TK_VARIABLE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Variable</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal> 
             <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>azVar</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>azVar</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_REGISTER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>inReg</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CAST</name></cpp:ifndef>
    <case>case <expr><name>TK_CAST</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* Expressions of the form:   CAST(pLeft AS token) */</comment>
      <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>inReg</name><operator>!=</operator><name>target</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inReg</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Cast</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                        <argument><expr><call><name>sqlite3AffinityType</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>usedAsColumnCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_CAST */</comment>
    <case>case <expr><name>TK_LT</name></expr>:</case>
    <case>case <expr><name>TK_LE</name></expr>:</case>
    <case>case <expr><name>TK_GT</name></expr>:</case>
    <case>case <expr><name>TK_GE</name></expr>:</case>
    <case>case <expr><name>TK_NE</name></expr>:</case>
    <case>case <expr><name>TK_EQ</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>SQLITE_STOREP2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LT</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LE</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GT</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GE</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_EQ</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_NE</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_IS</name></expr>:</case>
    <case>case <expr><name>TK_ISNOT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_ISNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>op</name><operator>==</operator><name>TK_IS</name><operator>)</operator></expr> ?</condition><then> <expr><name>TK_EQ</name></expr> </then><else>: <expr><name>TK_NE</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>SQLITE_STOREP2</name> <operator>|</operator> <name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_NE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_AND</name></expr>:</case>
    <case>case <expr><name>TK_OR</name></expr>:</case>
    <case>case <expr><name>TK_PLUS</name></expr>:</case>
    <case>case <expr><name>TK_STAR</name></expr>:</case>
    <case>case <expr><name>TK_MINUS</name></expr>:</case>
    <case>case <expr><name>TK_REM</name></expr>:</case>
    <case>case <expr><name>TK_BITAND</name></expr>:</case>
    <case>case <expr><name>TK_BITOR</name></expr>:</case>
    <case>case <expr><name>TK_SLASH</name></expr>:</case>
    <case>case <expr><name>TK_LSHIFT</name></expr>:</case>
    <case>case <expr><name>TK_RSHIFT</name></expr>:</case> 
    <case>case <expr><name>TK_CONCAT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_AND</name><operator>==</operator><name>OP_And</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_AND</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_OR</name><operator>==</operator><name>OP_Or</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>              <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_OR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_PLUS</name><operator>==</operator><name>OP_Add</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>           <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_PLUS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_MINUS</name><operator>==</operator><name>OP_Subtract</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>     <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_MINUS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_REM</name><operator>==</operator><name>OP_Remainder</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_REM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_BITAND</name><operator>==</operator><name>OP_BitAnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_BITAND</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_BITOR</name><operator>==</operator><name>OP_BitOr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_BITOR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_SLASH</name><operator>==</operator><name>OP_Divide</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>       <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_SLASH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LSHIFT</name><operator>==</operator><name>OP_ShiftLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_LSHIFT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_RSHIFT</name><operator>==</operator><name>OP_ShiftRight</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_RSHIFT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_CONCAT</name><operator>==</operator><name>OP_Concat</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_CONCAT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_UMINUS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_INTEGER</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>codeInteger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FLOAT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>codeReal</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>tempX</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_INTEGER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tempX</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>EP_IntValue</name><operator>|</operator><name>EP_TokenOnly</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tempX</name><operator>.</operator><name>u</name><operator>.</operator><name>iValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Subtract</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>inReg</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_BITNOT</name></expr>:</case>
    <case>case <expr><name>TK_NOT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_BITNOT</name><operator>==</operator><name>OP_BitNot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_BITNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NOT</name><operator>==</operator><name>OP_Not</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>         <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_NOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>inReg</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_ISNULL</name></expr>:</case>
    <case>case <expr><name>TK_NOTNULL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_ISNULL</name><operator>==</operator><name>OP_IsNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NOTNULL</name><operator>==</operator><name>OP_NotNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_AGG_FUNCTION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"misuse of aggregate: %s()"</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>inReg</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name></expr>]</index></name><operator>.</operator><name>iMem</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pFarg</name></decl>;</decl_stmt>       <comment type="block">/* List of function arguments */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nFarg</name></decl>;</decl_stmt>             <comment type="block">/* Number of function arguments */</comment>
      <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl>;</decl_stmt>         <comment type="block">/* The function definition object */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nId</name></decl>;</decl_stmt>               <comment type="block">/* Length of the function name in bytes */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zId</name></decl>;</decl_stmt>       <comment type="block">/* The function name */</comment>
      <decl_stmt><decl><type><name>u32</name></type> <name>constMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Mask of function arguments that are constant */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Loop counter */</comment>
      <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>      <comment type="block">/* The text encoding used by this database */</comment>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* A collating sequence */</comment>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pFarg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pFarg</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>nFarg</name> <operator>=</operator> <ternary><condition><expr><name>pFarg</name></expr> ?</condition><then> <expr><name><name>pFarg</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zId</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nId</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name>nId</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pDef</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDef</name><operator>-&gt;</operator><name>xFinalize</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"unknown function: %.*s()"</literal></expr></argument>, <argument><expr><name>nId</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Attempt a direct implementation of the built-in COALESCE() and
      ** IFNULL() functions.  This avoids unnecessary evaluation of
      ** arguments past the first non-NULL argument.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_COALESCE</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>endCoalesce</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>&gt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nFarg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>endCoalesce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprCacheRemove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>endCoalesce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* The UNLIKELY() function is a no-op.  The result is the value
      ** of the first argument.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_UNLIKELY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nFarg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">32</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>constMask</name> <operator>|=</operator> <call><name>MASKBIT32</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_NEEDCOLL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>pColl</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pFarg</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>constMask</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>r1</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nFarg</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* For length() and typeof() functions with a column argument,
        ** set the P5 parameter to the OP_Column opcode to OPFLAG_LENGTHARG
        ** or OPFLAG_TYPEOFARG respectively, to avoid unnecessary data
        ** loading.
        */</comment>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_FUNC_LENGTH</name><operator>|</operator><name>SQLITE_FUNC_TYPEOF</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u8</name></type> <name>exprOp</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFarg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>exprOp</name> <operator>=</operator> <name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>exprOp</name><operator>==</operator><name>TK_COLUMN</name> <operator>||</operator> <name>exprOp</name><operator>==</operator><name>TK_AGG_COLUMN</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_LENGTH</name><operator>==</operator><name>OPFLAG_LENGTHARG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_TYPEOF</name><operator>==</operator><name>OPFLAG_TYPEOFARG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>OPFLAG_LENGTHARG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> 
                  <name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>OPFLAG_LENGTHARG</name><operator>|</operator><name>OPFLAG_TYPEOFARG</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* Ticket 2ea2425d34be */</comment>
        <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFarg</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><name>SQLITE_ECEL_DUP</name><operator>|</operator><name>SQLITE_ECEL_FACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Ticket 2ea2425d34be */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      <comment type="block">/* Possibly overload the function if the first argument is
      ** a virtual table column.
      **
      ** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the
      ** second argument, not the first, as the argument to test to
      ** see if it is a column in a virtual table.  This is done because
      ** the left operand of infix functions (the operand we want to
      ** control overloading) ends up as the second argument to the
      ** function.  The expression "A glob B" is equivalent to 
      ** "glob(B,A).  We want to use the A in "A glob B" to test
      ** for function overloading.  But we use the B term in "glob(B,A)".
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>nFarg</name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_InfixFunc</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3VtabOverloadFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nFarg</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3VtabOverloadFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>, <argument><expr><name><name>pFarg</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_NEEDCOLL</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pColl</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CollSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Function0</name></expr></argument>, <argument><expr><name>constMask</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pDef</name></expr></argument>, <argument><expr><name>P4_FUNCDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>nFarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nFarg</name> <operator>&amp;&amp;</operator> <name>constMask</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>nFarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <case>case <expr><name>TK_EXISTS</name></expr>:</case>
    <case>case <expr><name>TK_SELECT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_EXISTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>sqlite3CodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_IN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>destIfFalse</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>destIfNull</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>


    <comment type="block">/*
    **    x BETWEEN y AND z
    **
    ** This is equivalent to
    **
    **    x&gt;=y AND x&lt;=z
    **
    ** X is stored in pExpr-&gt;pLeft.
    ** Y is stored in pExpr-&gt;pList-&gt;a[0].pExpr.
    ** Z is stored in pExpr-&gt;pList-&gt;a[1].pExpr.
    */</comment>
    <case>case <expr><name>TK_BETWEEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pLItem</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pLItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r3</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r4</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>OP_Ge</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>, <argument><expr><name>SQLITE_STOREP2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLItem</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name><name>pLItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>OP_Le</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r4</name></expr></argument>, <argument><expr><name>SQLITE_STOREP2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_And</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>, <argument><expr><name>r4</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_COLLATE</name></expr>:</case> 
    <case>case <expr><name>TK_UPLUS</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TK_TRIGGER</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* If the opcode is TK_TRIGGER, then the expression is a reference
      ** to a column in the new.* or old.* pseudo-tables available to
      ** trigger programs. In this case Expr.iTable is set to 1 for the
      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumn
      ** is set to the column of the pseudo-table to read, or to -1 to
      ** read the rowid field.
      **
      ** The expression is implemented using an OP_Param opcode. The p1
      ** parameter is set to 0 for an old.rowid reference, or to (i+1)
      ** to reference another column of the old.* pseudo-table, where 
      ** i is the index of the column. For a new.rowid reference, p1 is
      ** set to (n+1), where n is the number of columns in each pseudo-table.
      ** For a reference to any other column in the new.* pseudo-table, p1
      ** is set to (n+2+i), where n and i are as defined previously. For
      ** example, if the table on which triggers are being fired is
      ** declared as:
      **
      **   CREATE TABLE t1(a, b);
      **
      ** Then p1 is interpreted as follows:
      **
      **   p1==0   -&gt;    old.rowid     p1==3   -&gt;    new.rowid
      **   p1==1   -&gt;    old.a         p1==4   -&gt;    new.a
      **   p1==2   -&gt;    old.b         p1==5   -&gt;    new.b       
      */</comment>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>p1</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>*</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>&lt;</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Param</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s.%s -&gt; $%d"</literal><operator>,</operator>
        <operator>(</operator><ternary><condition><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr> ?</condition><then> <expr><literal type="string">"new"</literal></expr> </then><else>: <expr><literal type="string">"old"</literal></expr></else></ternary><operator>)</operator><operator>,</operator>
        <operator>(</operator><ternary><condition><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"rowid"</literal></expr> </then><else>: <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>zName</name></expr></else></ternary><operator>)</operator><operator>,</operator>
        <name>target</name>
      <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
      <comment type="block">/* If the column has REAL affinity, it may currently be stored as an
      ** integer. Use OP_RealAffinity to make sure it is really real.
      **
      ** EVIDENCE-OF: R-60985-57662 SQLite will convert the value back to
      ** floating point when extracting it from the record.  */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> 
       <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>affinity</name><operator>==</operator><name>SQLITE_AFF_REAL</name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RealAffinity</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </block_content>}</block>


    <comment type="block">/*
    ** Form A:
    **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
    **
    ** Form B:
    **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
    **
    ** Form A is can be transformed into the equivalent form B as follows:
    **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...
    **        WHEN x=eN THEN rN ELSE y END
    **
    ** X (if it exists) is in pExpr-&gt;pLeft.
    ** Y is in the last element of pExpr-&gt;x.pList if pExpr-&gt;x.pList-&gt;nExpr is
    ** odd.  The Y is also optional.  If the number of elements in x.pList
    ** is even, then Y is omitted and the "otherwise" result is NULL.
    ** Ei is in pExpr-&gt;pList-&gt;a[i*2] and Ri is pExpr-&gt;pList-&gt;a[i*2+1].
    **
    ** The result of the expression is the Ri for the first matching Ei,
    ** or if there is no matching Ei, the ELSE term Y, or if there is
    ** no ELSE term, NULL.
    */</comment>
    <default>default:</default> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_CASE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>endLabel</name></decl>;</decl_stmt>                     <comment type="block">/* GOTO label for end of CASE stmt */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nextCase</name></decl>;</decl_stmt>                     <comment type="block">/* GOTO label for next WHEN clause */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name></decl>;</decl_stmt>                        <comment type="block">/* 2x number of WHEN terms */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                            <comment type="block">/* Loop counter */</comment>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>                 <comment type="block">/* List of WHEN terms */</comment>
      <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>aListelem</name></decl>;</decl_stmt>  <comment type="block">/* Array of WHEN terms */</comment>
      <decl_stmt><decl><type><name>Expr</name></type> <name>opCompare</name></decl>;</decl_stmt>                   <comment type="block">/* The X==Ei expression */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>                         <comment type="block">/* The X expression */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pTest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* X==Ei (form A) or just Ei (form B) */</comment>
      <macro><name>VVA_ONLY</name><argument_list>( <argument>int iCacheLevel = pParse-&gt;iCacheLevel;</argument> )</argument_list></macro>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aListelem</name> <operator>=</operator> <name><name>pEList</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExpr</name> <operator>=</operator> <name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>endLabel</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pX</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>tempX</name> <operator>=</operator> <operator>*</operator><name>pX</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pX</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exprToRegister</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempX</name></expr></argument>, <argument><expr><call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>opCompare</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_EQ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>opCompare</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <operator>&amp;</operator><name>tempX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTest</name> <operator>=</operator> <operator>&amp;</operator><name>opCompare</name></expr>;</expr_stmt>
        <comment type="block">/* Ticket b351d95f9cd5ef17e9d9dbae18f5ca8611190001:
        ** The value in regFree1 might get SCopy-ed into the file result.
        ** So make sure that the regFree1 register is not reused for other
        ** purposes and possibly overwritten.  */</comment>
        <expr_stmt><expr><name>regFree1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nExpr</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pX</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTest</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>opCompare</name><operator>.</operator><name>pRight</name></name> <operator>=</operator> <name><name>aListelem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>pTest</name> <operator>=</operator> <name><name>aListelem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>nextCase</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTest</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTest</name></expr></argument>, <argument><expr><name>nextCase</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aListelem</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>aListelem</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>endLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>nextCase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nExpr</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>nExpr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>&gt;</operator><literal type="number">0</literal> 
           <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iCacheLevel</name></name><operator>==</operator><name>iCacheLevel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>endLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
    <case>case <expr><name>TK_RAISE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>OE_Rollback</name> 
           <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>OE_Abort</name>
           <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>OE_Fail</name>
           <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>OE_Ignore</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                       <argument><expr><literal type="string">"RAISE() may only be used within a trigger-program"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>OE_Abort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name><operator>==</operator><name>OE_Ignore</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(
            <argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr><name>OE_Ignore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3HaltConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_CONSTRAINT_TRIGGER</name></expr></argument>,
                              <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>affinity</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>inReg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Factor out the code of the given expression to initialization time.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeAtInit</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,      <comment type="block">/* The expression to code when the VDBE initializes */</comment>
  <parameter><decl><type><name>int</name></type> <name>regDest</name></decl></parameter>,      <comment type="block">/* Store the value in this register */</comment>
  <parameter><decl><type><name>u8</name></type> <name>reusable</name></decl></parameter>       <comment type="block">/* True if this expression is reusable */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ConstFactorOk</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pConstExpr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
     <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iConstExprReg</name></name> <operator>=</operator> <name>regDest</name></expr>;</expr_stmt>
     <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>reusable</name></name> <operator>=</operator> <name>reusable</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pConstExpr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code to evaluate an expression and store the results
** into a register.  Return the register number where the results
** are stored.
**
** If the register is a temporary register that can be deallocated,
** then write its number into *pReg.  If the result register is not
** a temporary, then set *pReg to zero.
**
** If pExpr is a constant, then this routine might generate this
** code to fill the register in the initialization section of the
** VDBE program, in order to factor it out of the evaluation loop.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeTemp</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r2</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ConstFactorOk</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_REGISTER</name>
   <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstantNotJoin</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pConstExpr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>pReg</name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pItem</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>pItem</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>reusable</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <return>return <expr><name><name>pItem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iConstExprReg</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCodeAtInit</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>r2</name><operator>==</operator><name>r1</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pReg</name> <operator>=</operator> <name>r1</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>r2</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will evaluate expression pExpr and store the
** results in register target.  The results are guaranteed to appear
** in register target.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCode</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>inReg</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>target</name><operator>&lt;=</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_REGISTER</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>inReg</name> <operator>=</operator> <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>inReg</name><operator>!=</operator><name>target</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Make a transient copy of expression pExpr and then code it using
** sqlite3ExprCode().  This routine works just like sqlite3ExprCode()
** except that the input expression is guaranteed to be unchanged.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeCopy</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will evaluate expression pExpr and store the
** results in register target.  The results are guaranteed to appear
** in register target.  If the expression is constant, then this routine
** might choose to code the expression at initialization time.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeFactorable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>okConstFactor</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCodeAtInit</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that evaluates the given expression and puts the result
** in register target.
**
** Also make a copy of the expression results into another "cache" register
** and modify the expression so that the next time it is evaluated,
** the result is a copy of the cache register.
**
** This routine is used for expressions that are used multiple 
** times.  They are evaluated once and the results of the expression
** are reused.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeAndCache</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMem</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_REGISTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iMem</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exprToRegister</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that pushes the value of every element of the given
** expression list into a sequence of registers beginning at target.
**
** Return the number of elements evaluated.
**
** The SQLITE_ECEL_DUP flag prevents the arguments from being
** filled using OP_SCopy.  OP_Copy must be used instead.
**
** The SQLITE_ECEL_FACTOR argument allows constant arguments to be
** factored out into initialization code.
**
** The SQLITE_ECEL_REF flag means that expressions in the list with
** ExprList.a[].u.x.iOrderByCol&gt;0 have already been evaluated and stored
** in registers at srcReg, and so the value can be copied from there.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeExprList</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,   <comment type="block">/* The expression list to be coded */</comment>
  <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>,        <comment type="block">/* Where to write results */</comment>
  <parameter><decl><type><name>int</name></type> <name>srcReg</name></decl></parameter>,        <comment type="block">/* Source registers if SQLITE_ECEL_REF */</comment>
  <parameter><decl><type><name>u8</name></type> <name>flags</name></decl></parameter>           <comment type="block">/* SQLITE_ECEL_* flags */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>copyOp</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_ECEL_DUP</name><operator>)</operator></expr> ?</condition><then> <expr><name>OP_Copy</name></expr> </then><else>: <expr><name>OP_SCopy</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Never gets this far otherwise */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>ConstFactorOk</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_ECEL_FACTOR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_ECEL_REF</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>j</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iOrderByCol</name></name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>copyOp</name></expr></argument>, <argument><expr><name>j</name><operator>+</operator><name>srcReg</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>target</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_ECEL_FACTOR</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprCodeAtInit</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>inReg</name> <init>= <expr><call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>inReg</name><operator>!=</operator><name>target</name><operator>+</operator><name>i</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>copyOp</name><operator>==</operator><name>OP_Copy</name>
         <operator>&amp;&amp;</operator> <operator>(</operator><name>pOp</name><operator>=</operator><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_Copy</name>
         <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>inReg</name>
         <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>target</name><operator>+</operator><name>i</name></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>copyOp</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>target</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code for a BETWEEN operator.
**
**    x BETWEEN y AND z
**
** The above is equivalent to 
**
**    x&gt;=y AND x&lt;=z
**
** Code it as such, taking care to do the common subexpression
** elimination of x.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exprCodeBetween</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,      <comment type="block">/* The BETWEEN expression */</comment>
  <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>,         <comment type="block">/* Jump here if the jump is taken */</comment>
  <parameter><decl><type><name>int</name></type> <name>jumpIfTrue</name></decl></parameter>,   <comment type="block">/* Take the jump if the BETWEEN is true */</comment>
  <parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>    <comment type="block">/* Take the jump if the BETWEEN is NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name></type> <name>exprAnd</name></decl>;</decl_stmt>     <comment type="block">/* The AND operator in  x&gt;=y AND x&lt;=z  */</comment>
  <decl_stmt><decl><type><name>Expr</name></type> <name>compLeft</name></decl>;</decl_stmt>    <comment type="block">/* The  x&gt;=y  term */</comment>
  <decl_stmt><decl><type><name>Expr</name></type> <name>compRight</name></decl>;</decl_stmt>   <comment type="block">/* The  x&lt;=z  term */</comment>
  <decl_stmt><decl><type><name>Expr</name></type> <name>exprX</name></decl>;</decl_stmt>       <comment type="block">/* The  x  subexpression */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Temporary use register */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>exprX</name> <operator>=</operator> <operator>*</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exprAnd</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_AND</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exprAnd</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <operator>&amp;</operator><name>compLeft</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exprAnd</name><operator>.</operator><name>pRight</name></name> <operator>=</operator> <operator>&amp;</operator><name>compRight</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>compLeft</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_GE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>compLeft</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <operator>&amp;</operator><name>exprX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>compLeft</name><operator>.</operator><name>pRight</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>compRight</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_LE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>compRight</name><operator>.</operator><name>pLeft</name></name> <operator>=</operator> <operator>&amp;</operator><name>exprX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>compRight</name><operator>.</operator><name>pRight</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exprToRegister</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exprX</name></expr></argument>, <argument><expr><call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>jumpIfTrue</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprAnd</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprAnd</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Ensure adequate test coverage */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfTrue</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfTrue</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfTrue</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfTrue</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfTrue</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfTrue</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfTrue</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfTrue</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regFree1</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate code for a boolean expression such that a jump is made
** to the label "dest" if the expression is true but execution
** continues straight thru if the expression is false.
**
** If the expression evaluates to NULL (neither true nor false), then
** take the jump if the jumpIfNull flag is SQLITE_JUMPIFNULL.
**
** This code depends on the fact that certain token values (ex: TK_EQ)
** are the same as opcode values (ex: OP_Eq) that implement the corresponding
** operation.  Special comments in vdbe.c and the mkopcodeh.awk script in
** the make process cause these values to align.  Assert()s in the code
** below verify that the numbers are aligned correctly.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprIfTrue</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><name>SQLITE_JUMPIFNULL</name> <operator>||</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content>     <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* Existence of VDBE checked by caller */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* No way this can happen */</comment>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_AND</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>d2</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>d2</name></expr></argument>,<argument><expr><name>jumpIfNull</name><operator>^</operator><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_OR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_NOT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_LT</name></expr>:</case>
    <case>case <expr><name>TK_LE</name></expr>:</case>
    <case>case <expr><name>TK_GT</name></expr>:</case>
    <case>case <expr><name>TK_GE</name></expr>:</case>
    <case>case <expr><name>TK_NE</name></expr>:</case>
    <case>case <expr><name>TK_EQ</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LT</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LE</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GT</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GE</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_EQ</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_NE</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_IS</name></expr>:</case>
    <case>case <expr><name>TK_ISNOT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_ISNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>op</name><operator>==</operator><name>TK_IS</name><operator>)</operator></expr> ?</condition><then> <expr><name>TK_EQ</name></expr> </then><else>: <expr><name>TK_NE</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_NE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_ISNULL</name></expr>:</case>
    <case>case <expr><name>TK_NOTNULL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_ISNULL</name><operator>==</operator><name>OP_IsNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NOTNULL</name><operator>==</operator><name>OP_NotNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_BETWEEN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exprCodeBetween</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <case>case <expr><name>TK_IN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>destIfFalse</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>destIfNull</name> <init>= <expr><ternary><condition><expr><name>jumpIfNull</name></expr> ?</condition><then> <expr><name>dest</name></expr> </then><else>: <expr><name>destIfFalse</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <default>default:</default> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>exprAlwaysTrue</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>exprAlwaysFalse</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* No-op */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
</block_content>}</block></function>

<comment type="block">/*
** Generate code for a boolean expression such that a jump is made
** to the label "dest" if the expression is false but execution
** continues straight thru if the expression is true.
**
** If the expression evaluates to NULL (neither true nor false) then
** jump if jumpIfNull is SQLITE_JUMPIFNULL or fall through if jumpIfNull
** is 0.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprIfFalse</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><name>SQLITE_JUMPIFNULL</name> <operator>||</operator> <name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Existence of VDBE checked by caller */</comment>
  <if_stmt><if>if<condition>( <expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>    <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* The value of pExpr-&gt;op and op are related as follows:
  **
  **       pExpr-&gt;op            op
  **       ---------          ----------
  **       TK_ISNULL          OP_NotNull
  **       TK_NOTNULL         OP_IsNull
  **       TK_NE              OP_Eq
  **       TK_EQ              OP_Ne
  **       TK_GT              OP_Le
  **       TK_LE              OP_Gt
  **       TK_GE              OP_Lt
  **       TK_LT              OP_Ge
  **
  ** For other values of pExpr-&gt;op, op is undefined and unused.
  ** The value of TK_ and OP_ constants are arranged such that we
  ** can compute the mapping above using the following expression.
  ** Assert()s verify that the computation is correct.
  */</comment>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>+</operator><operator>(</operator><name>TK_ISNULL</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>^</operator><literal type="number">1</literal><operator>)</operator><operator>-</operator><operator>(</operator><name>TK_ISNULL</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Verify correct alignment of TK_ and OP_ constants
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_ISNULL</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_NotNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_NOTNULL</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_IsNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_NE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_EQ</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_LT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_LE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_GT</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Le</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_GE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_AND</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_OR</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>d2</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>d2</name></expr></argument>, <argument><expr><name>jumpIfNull</name><operator>^</operator><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCachePush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCachePop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_NOT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_LT</name></expr>:</case>
    <case>case <expr><name>TK_LE</name></expr>:</case>
    <case>case <expr><name>TK_GT</name></expr>:</case>
    <case>case <expr><name>TK_GE</name></expr>:</case>
    <case>case <expr><name>TK_NE</name></expr>:</case>
    <case>case <expr><name>TK_EQ</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LT</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_LE</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GT</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_GE</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_EQ</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TK_NE</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>testcase</name><argument_list>(<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_IS</name></expr>:</case>
    <case>case <expr><name>TK_ISNOT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name><operator>)</operator></expr> ?</condition><then> <expr><name>TK_NE</name></expr> </then><else>: <expr><name>TK_EQ</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>SQLITE_NULLEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_NE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_ISNULL</name></expr>:</case>
    <case>case <expr><name>TK_NOTNULL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>TK_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_BETWEEN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exprCodeBetween</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <case>case <expr><name>TK_IN</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>jumpIfNull</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCodeIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>destIfNull</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>destIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <default>default:</default> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>exprAlwaysFalse</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>exprAlwaysTrue</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* no-op */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Like sqlite3ExprIfFalse() except that a copy is made of pExpr before
** code generation, and that copy is deleted after code generation. This
** ensures that the original pExpr is unchanged.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprIfFalseDup</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCopy</name> <init>= <expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Do a deep comparison of two expression trees.  Return 0 if the two
** expressions are completely identical.  Return 1 if they differ only
** by a COLLATE operator at the top level.  Return 2 if there are differences
** other than the top-level COLLATE operator.
**
** If any subelement of pB has Expr.iTable==(-1) then it is allowed
** to compare equal to an equivalent element in pA with Expr.iTable==iTab.
**
** The pA side might be using TK_REGISTER.  If that is the case and pB is
** not using TK_REGISTER but is otherwise equivalent, then still return 0.
**
** Sometimes this routine will return 2 even if the two expressions
** really are equivalent.  If we cannot prove that the expressions are
** identical, we return 2 just to be safe.  So if this routine
** returns 2, then you do not really know for certain if the two
** expressions are the same.  But if you get a 0 or 1 return, then you
** can be sure the expressions are the same.  In the places where
** this routine is used, it does not hurt to get an extra 2 - that
** just might result in some slightly slower code.  But returning
** an incorrect 0 or 1 could lead to a malfunction.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCompare</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>combinedFlags</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pB</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>pB</name><operator>==</operator><name>pA</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>combinedFlags</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>pB</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>combinedFlags</name> <operator>&amp;</operator> <name>EP_IntValue</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pA</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name><name>pB</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>EP_IntValue</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name><operator>==</operator><name><name>pB</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pB</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AGG_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><name><name>pB</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,<argument><expr><name><name>pB</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><ternary><condition><expr><name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLLATE</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pA</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Distinct</name><operator>)</operator><operator>!=</operator><operator>(</operator><name><name>pB</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Distinct</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><operator>(</operator><name>combinedFlags</name> <operator>&amp;</operator> <name>EP_TokenOnly</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>combinedFlags</name> <operator>&amp;</operator> <name>EP_xIsSelect</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprListCompare</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><operator>(</operator><name>combinedFlags</name> <operator>&amp;</operator> <name>EP_Reduced</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_STRING</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>iTable</name></name> 
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pA</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name>iTab</name> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>pB</name><operator>-&gt;</operator><name>iTable</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare two ExprList objects.  Return 0 if they are identical and 
** non-zero if they differ in any way.
**
** If any subelement of pB has Expr.iTable==(-1) then it is allowed
** to compare equal to an equivalent element in pA with Expr.iTable==iTab.
**
** This routine might return non-zero for equivalent ExprLists.  The
** only consequence will be disabled optimizations.  But this routine
** must never return 0 if the two ExprList objects are different, or
** a malfunction will result.
**
** Two NULL pointers are considered to be the same.  But a NULL pointer
** always differs from a non-NULL pointer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprListCompare</name><parameter_list>(<parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pB</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pB</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>nExpr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pA</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExprA</name> <init>= <expr><name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExprB</name> <init>= <expr><name><name>pB</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sortOrder</name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sortOrder</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pExprA</name></expr></argument>, <argument><expr><name>pExprB</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if we can prove the pE2 will always be true if pE1 is
** true.  Return false if we cannot complete the proof or if pE2 might
** be false.  Examples:
**
**     pE1: x==5       pE2: x==5             Result: true
**     pE1: x&gt;0        pE2: x==5             Result: false
**     pE1: x=21       pE2: x=21 OR y=43     Result: true
**     pE1: x!=123     pE2: x IS NOT NULL    Result: true
**     pE1: x!=?1      pE2: x IS NOT NULL    Result: true
**     pE1: x IS NULL  pE2: x IS NOT NULL    Result: false
**     pE1: x IS ?2    pE2: x IS NOT NULL    Reuslt: false
**
** When comparing TK_COLUMN nodes between pE1 and pE2, if pE2 has
** Expr.iTable&lt;0 then assume a table number given by iTab.
**
** When in doubt, return false.  Returning true might give a performance
** improvement.  Returning false might cause a performance reduction, but
** it will always give the correct answer and is hence always safe.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprImpliesExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE1</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pE1</name></expr></argument>, <argument><expr><name>pE2</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pE2</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_OR</name>
   <operator>&amp;&amp;</operator> <operator>(</operator><call><name>sqlite3ExprImpliesExpr</name><argument_list>(<argument><expr><name>pE1</name></expr></argument>, <argument><expr><name><name>pE2</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call>
             <operator>||</operator> <call><name>sqlite3ExprImpliesExpr</name><argument_list>(<argument><expr><name>pE1</name></expr></argument>, <argument><expr><name><name>pE2</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call> <operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pE2</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NOTNULL</name>
   <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name><name>pE1</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pE2</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pE1</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_ISNULL</name> <operator>&amp;&amp;</operator> <name><name>pE1</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_IS</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An instance of the following structure is used by the tree walker
** to count references to table columns in the arguments of an 
** aggregate function, in order to implement the
** sqlite3FunctionThisSrc() routine.
*/</comment>
<struct>struct <name>SrcCount</name> <block>{
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>   <comment type="block">/* One particular FROM clause in a nested query */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nThis</name></decl>;</decl_stmt>       <comment type="block">/* Number of references to columns in pSrcList */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOther</name></decl>;</decl_stmt>      <comment type="block">/* Number of references to columns in other FROM clauses */</comment>
}</block>;</struct>

<comment type="block">/*
** Count the number of references to columns.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprSrcCount</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* The NEVER() on the second term is because sqlite3FunctionUsesThisSrc()
  ** is always called before sqlite3ExprAnalyzeAggregates() and so the
  ** TK_COLUMNs have not yet been converted into TK_AGG_COLUMN.  If
  ** sqlite3FunctionUsesThisSrc() is used differently in the future, the
  ** NEVER() will need to be removed. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>SrcCount</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pSrcCount</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSrc</name> <init>= <expr><ternary><condition><expr><name>pSrc</name></expr> ?</condition><then> <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSrc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nSrc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nThis</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOther</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Determine if any of the arguments to the pExpr Function reference
** pSrcList.  Return true if they do.  Also return true if the function
** has no arguments or has only constant arguments.  Return false if pExpr
** references columns but not columns of tables found in pSrcList.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3FunctionUsesThisSrc</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrcList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>SrcCount</name></name></type> <name>cnt</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>exprSrcCount</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pSrcCount</name></name> <operator>=</operator> <operator>&amp;</operator><name>cnt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cnt</name><operator>.</operator><name>pSrc</name></name> <operator>=</operator> <name>pSrcList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cnt</name><operator>.</operator><name>nThis</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cnt</name><operator>.</operator><name>nOther</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExprList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>cnt</name><operator>.</operator><name>nThis</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>cnt</name><operator>.</operator><name>nOther</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add a new element to the pAggInfo-&gt;aCol[] array.  Return the index of
** the new element.  Return a negative number if malloc fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>addAggInfoColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <call><name>sqlite3ArrayAllocate</name><argument_list>(
       <argument><expr><name>db</name></expr></argument>,
       <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>,
       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
       <argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>,
       <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>    

<comment type="block">/*
** Add a new element to the pAggInfo-&gt;aFunc[] array.  Return the index of
** the new element.  Return a negative number if malloc fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>addAggInfoFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aFunc</name></name> <operator>=</operator> <call><name>sqlite3ArrayAllocate</name><argument_list>(
       <argument><expr><name>db</name></expr></argument>, 
       <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aFunc</name></name></expr></argument>,
       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
       <argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr></argument>,
       <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>    

<comment type="block">/*
** This is the xExprCallback for a tree walker.  It is used to
** implement sqlite3ExprAnalyzeAggregates().  See sqlite3ExprAnalyzeAggregates
** for additional information.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>analyzeAggregate</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name> <init>= <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNC</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrcList</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>pAggInfo</name> <init>= <expr><name><name>pNC</name><operator>-&gt;</operator><name>pAggInfo</name></name></expr></init></decl>;</decl_stmt>

  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_AGG_COLUMN</name></expr>:</case>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Check to see if the column is in one of the tables in the FROM
      ** clause of the aggregate query */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pSrcList</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>SrcList_item</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><name><name>pSrcList</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrcList</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_col</name></name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr> )</condition><block>{<block_content>
            <comment type="block">/* If we reach this point, it means that pExpr refers to a table
            ** that is in the FROM clause of the aggregate query.  
            **
            ** Make an entry for the column in pAggInfo-&gt;aCol[] if there
            ** is not an entry there already.
            */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>pCol</name> <operator>=</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr><operator>,</operator> <expr><name>pCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>&amp;&amp;</operator>
                  <name><name>pCol</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block>{<block_content>
                <break>break;</break>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>k</name><operator>&gt;=</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nColumn</name></name><operator>)</operator>
             <operator>&amp;&amp;</operator> <operator>(</operator><name>k</name> <operator>=</operator> <call><name>addAggInfoColumn</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> 
            )</condition><block>{<block_content>
              <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iMem</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr> )</condition><block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pGB</name> <init>= <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><name><name>pGB</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pGB</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
                <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>pTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
                  <if_stmt><if>if<condition>( <expr><name><name>pE</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pE</name><operator>-&gt;</operator><name>iTable</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name> <operator>&amp;&amp;</operator>
                      <name><name>pE</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block>{<block_content>
                    <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
                    <break>break;</break>
                  </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
              </block_content>}</block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>iSorterColumn</name></name> <operator>=</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>nSortingColumn</name></name><operator>++</operator></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* There is now an entry for pExpr in pAggInfo-&gt;aCol[] (either
            ** because it was there before or because we just created it).
            ** Convert the pExpr to be a TK_AGG_COLUMN referring to that
            ** pAggInfo-&gt;aCol[] entry.
            */</comment>
            <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name> <operator>=</operator> <name>pAggInfo</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_AGG_COLUMN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name>k</name></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt> <comment type="block">/* endif pExpr-&gt;iTable==pItem-&gt;iCursor */</comment>
        </block_content>}</block></for> <comment type="block">/* end loop over pSrcList */</comment>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_AGG_FUNCTION</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNC</name><operator>-&gt;</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_InAggFunc</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>walkerDepth</name></name><operator>==</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op2</name></name></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* Check to see if pExpr is a duplicate of another aggregate 
        ** function that is already in the pAggInfo structure
        */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>AggInfo_func</name></name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name></name></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>nFunc</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* pExpr is original.  Make a new entry in pAggInfo-&gt;aFunc[]
          */</comment>
          <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><call><name>ENC</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>addAggInfoFunc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>iMem</name></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pFunc</name></name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
                   <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><ternary><condition><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr> ?</condition><then> <expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_Distinct</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>iDistinct</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>iDistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Make pExpr point to the appropriate pAggInfo-&gt;aFunc[] entry
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Reduced</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprSetVVAProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_NoReduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iAgg</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAggInfo</name></name> <operator>=</operator> <name>pAggInfo</name></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Prune</name></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><name>WRC_Continue</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>analyzeAggregatesInSelect</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Analyze the pExpr expression looking for aggregate functions and
** for variables that need to be added to AggInfo object that pNC-&gt;pAggInfo
** points to.  Additional entries are made on the AggInfo object as
** necessary.
**
** This routine should only be called after the expression has been
** analyzed by sqlite3ResolveExprNames().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAnalyzeAggregates</name><parameter_list>(<parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>analyzeAggregate</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <name>analyzeAggregatesInSelect</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pNC</name></name> <operator>=</operator> <name>pNC</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNC</name><operator>-&gt;</operator><name>pSrcList</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Call sqlite3ExprAnalyzeAggregates() for every expression in an
** expression list.  Return the number of errors.
**
** If an error is found, the analysis is cut short.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAnalyzeAggList</name><parameter_list>(<parameter><decl><type><name>NameContext</name> <modifier>*</modifier></type><name>pNC</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ExprList_item</name></name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>pItem</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>a</name></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pItem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggregates</name><argument_list>(<argument><expr><name>pNC</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a single new register for use to hold some intermediate result.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GetTempReg</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pParse</name><operator>-&gt;</operator><name>aTempReg</name><index>[<expr><operator>--</operator><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate a register, making available for reuse for some other
** purpose.
**
** If a register is currently being used by the column cache, then
** the deallocation is deferred until the column cache line that uses
** the register becomes stale.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ReleaseTempReg</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iReg</name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aTempReg</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>yColCache</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name><name>pParse</name><operator>-&gt;</operator><name>aColCache</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>SQLITE_N_COLCACHE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iReg</name></name><operator>==</operator><name>iReg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tempReg</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aTempReg</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>iReg</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate or deallocate a block of nReg consecutive registers
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GetTempRange</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>iRangeReg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nReg</name><operator>&lt;=</operator><name>n</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>usedAsColumnCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iRangeReg</name></name> <operator>+=</operator> <name>nReg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name> <operator>-=</operator> <name>nReg</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nReg</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3ReleaseTempRange</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3ExprCacheRemove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>nReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nReg</name><operator>&gt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name> <operator>=</operator> <name>nReg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iRangeReg</name></name> <operator>=</operator> <name>iReg</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Mark all temporary registers as being unavailable for reuse.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ClearTempRegCache</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
