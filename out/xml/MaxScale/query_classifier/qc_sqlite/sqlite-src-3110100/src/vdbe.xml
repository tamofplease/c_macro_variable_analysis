<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/vdbe.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** The code in this file implements the function that runs the
** bytecode of a prepared statement.
**
** Various scripts scan this source file in order to generate HTML
** documentation, headers files, or other derived files.  The formatting
** of the code in this file is, therefore, important.  See other comments
** in this file for details.  If in doubt, do not deviate from existing
** commenting and indentation practices when changing or adding code.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Invoke this macro on memory cells just prior to changing the
** value of the cell.  This macro verifies that shallow copies are
** not misused.  A shallow copy of a string or blob just copies a
** pointer to the string or blob, not the content.  If the original
** is changed while the copy is still in use, the string or blob might
** be changed out from under the copy.  This macro verifies that nothing
** like that ever happens.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>memAboutToChange</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sqlite3VdbeMemAboutToChange(P,M)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>memAboutToChange</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following global variable is incremented every time a cursor
** moves, either by the OP_SeekXX, OP_Next, or OP_Prev opcodes.  The test
** procedures use this information to make sure that indices are
** working correctly.  This variable has no function other than to
** help verify the correct operation of the library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_search_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** When this global variable is positive, it gets decremented once before
** each instruction in the VDBE.  When it reaches zero, the u1.isInterrupted
** field of the sqlite3 structure is set in order to simulate an interrupt.
**
** This facility is used for testing purposes only.  It does not function
** in an ordinary build.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_interrupt_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The next global variable is incremented each type the OP_Sort opcode
** is executed.  The test procedures use this information to make sure that
** sorting is occurring or not occurring at appropriate times.   This variable
** has no function other than to help verify the correct operation of the
** library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_sort_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The next global variable records the size of the largest MEM_Blob
** or MEM_Str that has been used by a VDBE opcode.  The test procedures
** use this information to make sure that the zero-blob functionality
** is working correctly.   This variable has no function other than to
** help verify the correct operation of the library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_max_blobsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>updateMaxBlobsize</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><name>sqlite3_max_blobsize</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sqlite3_max_blobsize</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The next global variable is incremented each time the OP_Found opcode
** is executed. This is used to test whether or not the foreign key
** operation implemented using OP_FkIsZero is working. This variable
** has no function other than to help verify the correct operation of the
** library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_found_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Test a register to see if it exceeds the current maximum blob size.
** If it does, record the new maximum blob size.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_BUILTIN_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_MAX_BLOBSIZE</name><parameter_list>(<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>updateMaxBlobsize(P)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_MAX_BLOBSIZE</name><parameter_list>(<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Invoke the VDBE coverage callback, if that callback is defined.  This
** feature is used for test suite validation only and does not appear an
** production builds.
**
** M is an integer, 2 or 3, that indices how many different ways the
** branch can go.  It is usually 2.  "I" is the direction the branch
** goes.  0 means falls through.  1 means branch is taken.  2 means the
** second alternative branch is taken.
**
** iSrcLine is the source code line (from the __LINE__ macro) that
** generated the VDBE instruction.  This instrumentation assumes that all
** source code is in a single file (the amalgamation).  Special values 1
** and 2 for the iSrcLine parameter mean that this particular branch is
** always taken or never taken, respectively.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_VDBE_COVERAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>VdbeBranchTaken</name><parameter_list>(<parameter><type><name>I</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>VdbeBranchTaken</name><parameter_list>(<parameter><type><name>I</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vdbeTakeBranch(pOp-&gt;iSrcLine,I,M)</cpp:value></cpp:define>
  <function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeTakeBranch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iSrcLine</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>I</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>M</name></decl></parameter>)</parameter_list><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iSrcLine</name><operator>&lt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>iSrcLine</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>M</name> <operator>=</operator> <name>iSrcLine</name></expr>;</expr_stmt>
      <comment type="block">/* Assert the truth of VdbeCoverageAlwaysTaken() and 
      ** VdbeCoverageNeverTaken() */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>M</name> <operator>&amp;</operator> <name>I</name><operator>)</operator><operator>==</operator><name>I</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xVdbeBranch</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/*NO_TEST*/</comment>
      <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xVdbeBranch</name></name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pVdbeBranchArg</name></name></expr></argument>,
                                      <argument><expr><name>iSrcLine</name></expr></argument>,<argument><expr><name>I</name></expr></argument>,<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Convert the given register into a string if it isn't one
** already. Return non-zero if a malloc() fails.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Stringify</name><parameter_list>(<parameter><type><name>P</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>if(((P)-&gt;flags&amp;(MEM_Str|MEM_Blob))==0 &amp;&amp; sqlite3VdbeMemStringify(P,enc,0)) \
     { goto no_mem; }</cpp:value></cpp:define>

<comment type="block">/*
** An ephemeral string value (signified by the MEM_Ephem flag) contains
** a pointer to a dynamically allocated string where some other entity
** is responsible for deallocating that string.  Because the register
** does not control the string, it might be deleted without the register
** knowing it.
**
** This routine converts an ephemeral string into a dynamically allocated
** string that the register itself controls.  In other words, it
** converts an MEM_Ephem string into a string with P.z==P.zMalloc.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Deephemeralize</name><parameter_list>(<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>if( ((P)-&gt;flags&amp;MEM_Ephem)!=0 \
       &amp;&amp; sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem;}</cpp:value></cpp:define>

<comment type="block">/* Return true if the cursor was opened using the OP_OpenSorter opcode. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isSorter</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)-&gt;eCurType==CURTYPE_SORTER)</cpp:value></cpp:define>

<comment type="block">/*
** Allocate VdbeCursor number iCur.  Return a pointer to it.  Return NULL
** if we run out of memory.
*/</comment>
<function><type><specifier>static</specifier> <name>VdbeCursor</name> <modifier>*</modifier></type><name>allocateCursor</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,              <comment type="block">/* The virtual machine */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,             <comment type="block">/* Index of the new VdbeCursor */</comment>
  <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>,           <comment type="block">/* Number of fields in the table or index */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>,              <comment type="block">/* Database the cursor belongs to, or -1 */</comment>
  <parameter><decl><type><name>u8</name></type> <name>eCurType</name></decl></parameter>           <comment type="block">/* Type of the new cursor */</comment>
)</parameter_list><block>{<block_content>
  <comment type="block">/* Find the memory cell that will be used to store the blob of memory
  ** required for this VdbeCursor structure. It is convenient to use a 
  ** vdbe memory cell to manage the memory allocation required for a
  ** VdbeCursor structure for the following reasons:
  **
  **   * Sometimes cursor numbers are used for a couple of different
  **     purposes in a vdbe program. The different uses might require
  **     different sized allocations. Memory cells provide growable
  **     allocations.
  **
  **   * When using ENABLE_MEMORY_MANAGEMENT, memory cell buffers can
  **     be freed lazily via the sqlite3_release_memory() API. This
  **     minimizes the number of malloc calls made by the system.
  **
  ** Memory cells for cursors are allocated at the top of the address
  ** space. Memory cell (p-&gt;nMem) corresponds to cursor 0. Space for
  ** cursor 1 is managed by memory cell (p-&gt;nMem-1), etc.
  */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name>iCur</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> 
      <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nField</name> <operator>+</operator> 
      <operator>(</operator><ternary><condition><expr><name>eCurType</name><operator>==</operator><name>CURTYPE_BTREE</name></expr>?</condition><then><expr><call><name>sqlite3BtreeCursorSize</name><argument_list>()</argument_list></call></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCur</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeFreeCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name> <operator>=</operator> <name>pCx</name> <operator>=</operator> <operator>(</operator><name>VdbeCursor</name><operator>*</operator><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>eCurType</name></name> <operator>=</operator> <name>eCurType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>iDb</name></name> <operator>=</operator> <name>iDb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>nField</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>aOffset</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pCx</name><operator>-&gt;</operator><name>aType</name><index>[<expr><name>nField</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eCurType</name><operator>==</operator><name>CURTYPE_BTREE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name> <operator>=</operator> <operator>(</operator><name>BtCursor</name><operator>*</operator><operator>)</operator>
          <operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nField</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeCursorZero</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pCx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Try to convert a value into a numeric representation if we can
** do so without loss of information.  In other words, if the string
** looks like a number, convert it into a number.  If it does not
** look like a number, leave it alone.
**
** If the bTryForInt flag is true, then extra effort is made to give
** an integer representation.  Strings that look like floating point
** values but which have no fractional component (example: '48.00')
** will have a MEM_Int representation when bTryForInt is true.
**
** If bTryForInt is false, then if the input string contains a decimal
** point or exponential notation, the result is only MEM_Real, even
** if there is an exact integer representation of the quantity.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>applyNumericAffinity</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bTryForInt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>rValue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iValue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><name><name>pRec</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rValue</name></expr></argument>, <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iValue</name></expr></argument>, <argument><expr><name><name>pRec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>iValue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>rValue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Real</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bTryForInt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeIntegerAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Processing is determine by the affinity parameter:
**
** SQLITE_AFF_INTEGER:
** SQLITE_AFF_REAL:
** SQLITE_AFF_NUMERIC:
**    Try to convert pRec to an integer representation or a 
**    floating-point representation if an integer representation
**    is not possible.  Note that the integer representation is
**    always preferred, even if the affinity is REAL, because
**    an integer representation is more space efficient on disk.
**
** SQLITE_AFF_TEXT:
**    Convert pRec to a text representation.
**
** SQLITE_AFF_BLOB:
**    No-op.  pRec is unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>applyAffinity</name><parameter_list>(
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRec</name></decl></parameter>,          <comment type="block">/* The value to apply affinity to */</comment>
  <parameter><decl><type><name>char</name></type> <name>affinity</name></decl></parameter>,      <comment type="block">/* The affinity to be applied */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>              <comment type="block">/* Use this text encoding */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>affinity</name><operator>&gt;=</operator><name>SQLITE_AFF_NUMERIC</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>affinity</name><operator>==</operator><name>SQLITE_AFF_INTEGER</name> <operator>||</operator> <name>affinity</name><operator>==</operator><name>SQLITE_AFF_REAL</name>
             <operator>||</operator> <name>affinity</name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeIntegerAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>affinity</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Only attempt the conversion to TEXT if there is an integer or real
    ** representation (blob and NULL do not get converted) but no string
    ** representation.
    */</comment>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Str</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Int</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Int</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Try to convert the type of a function argument or a result column
** into a numeric representation.  Use either INTEGER or REAL whichever
** is appropriate.  But only do the conversion if it is possible without
** loss of information and return the revised type of the argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_value_numeric_type</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>eType</name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>eType</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Exported version of applyAffinity(). This one works on sqlite3_value*, 
** not the internal Mem* type.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ValueApplyAffinity</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, 
  <parameter><decl><type><name>u8</name></type> <name>affinity</name></decl></parameter>, 
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name> <operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** pMem currently only holds a string type (or maybe a BLOB that we can
** interpret as a string if we want to).  Compute its corresponding
** numeric type, if has one.  Set the pMem-&gt;u.r and pMem-&gt;u.i fields
** accordingly.
*/</comment>
<function><type><specifier>static</specifier> <name>u16</name> <name>SQLITE_NOINLINE</name></type> <name>computeNumericType</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>MEM_Int</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>MEM_Real</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the numeric type for pMem, either MEM_Int or MEM_Real or both or
** none.  
**
** Unlike applyNumericAffinity(), this routine does not modify pMem-&gt;flags.
** But it does set pMem-&gt;u.r and pMem-&gt;u.i appropriately.
*/</comment>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>numericType</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>computeNumericType</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Write a nice string representation of the contents of cell pMem
** into buffer zBuf, length nBuf.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemPrettyPrint</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCsr</name> <init>= <expr><name>zBuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>encnames</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"(X)"</literal></expr>, <expr><literal type="string">"(8)"</literal></expr>, <expr><literal type="string">"(16LE)"</literal></expr>, <expr><literal type="string">"(16BE)"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>f</name><operator>&amp;</operator><name>MEM_Blob</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Dyn</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'z'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Ephem</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Static</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Dyn</name><operator>|</operator><name>MEM_Ephem</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Ephem</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Dyn</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr><literal type="string">"%d["</literal></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name>z</name> <init>= <expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><argument_list type="generic">&lt;<argument><expr><literal type="number">32</literal> <operator>||</operator> <name>z</name></expr></argument>&gt;</argument_list></name><literal type="number">126</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>zCsr</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>zCsr</name><operator>++</operator> <operator>=</operator> <name>z</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr><literal type="string">"]%s"</literal></expr></argument>, <argument><expr><name><name>encnames</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>zCsr</name></expr></argument>,<argument><expr><literal type="string">"+%dz"</literal></expr></argument>,<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zCsr</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>zCsr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Str</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Dyn</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'z'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Ephem</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Static</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Dyn</name><operator>|</operator><name>MEM_Ephem</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>f</name> <operator>&amp;</operator> <name>MEM_Ephem</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Dyn</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'['</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">15</literal> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name>c</name> <init>= <expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;</operator><literal type="number">0x7f</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>encnames</name><index>[<expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Print the value of a register for tracing purposes:
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memTracePrint</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Undefined</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" undefined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>==</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Str</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" si:%lld"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" i:%lld"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" r:%g"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_RowSet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (rowset)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemPrettyPrint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Subtype</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" subtype=0x%02x"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eSubtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>registerTrace</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>, <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"REG[%d] = "</literal></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memTracePrint</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTER_TRACE</name><parameter_list>(<parameter><type><name>R</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if(db-&gt;flags&amp;SQLITE_VdbeTrace)registerTrace(R,M)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>REGISTER_TRACE</name><parameter_list>(<parameter><type><name>R</name></type></parameter>,<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>

<comment type="block">/* 
** hwtime.h contains inline assembler code for implementing 
** high-performance timing routines.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hwtime.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** This function is only called from within an assert() expression. It
** checks that the sqlite3.nTransaction variable is correctly set to
** the number of non-transaction savepoints currently in the 
** linked list starting at sqlite3.pSavepoint.
** 
** Usage:
**
**     assert( checkSavepointCount(db) );
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>checkSavepointCount</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Savepoint</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>+</operator> <name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return the register of pOp-&gt;p2 after first preparing it to be
** overwritten with an integer value.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>Mem</name> <modifier>*</modifier></type><name>out2PrereleaseWithClear</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  <return>return <expr><name>pOut</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Mem</name> <modifier>*</modifier></type><name>out2Prerelease</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>out2PrereleaseWithClear</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <return>return <expr><name>pOut</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Execute as much of a VDBE program as we can.
** This is the core of sqlite3_step().  
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeExec</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>                    <comment type="block">/* The VDBE */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>aOp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Copy of p-&gt;aOp */</comment>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><name>aOp</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Current operation */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOrigOp</name></decl>;</decl_stmt>               <comment type="block">/* Value of pOp at the top of the loop */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtraDelete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Verifies FORDELETE and AUXDELETE flags */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Value to return */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* The database */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>resetSchemaOnFault</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Reset schema after an error if positive */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>encoding</name> <init>= <expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>     <comment type="block">/* The database encoding */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCompare</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Result of last OP_Compare operation */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nVmStep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Number of virtual machine steps */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nProgressLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt><comment type="block">/* Invoke xProgress() when nVmStep reaches this */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>aMem</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Copy of p-&gt;aMem */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pIn1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* 1st input operand */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pIn2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* 2nd input operand */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pIn3</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* 3rd input operand */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Output operand */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aPermute</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Permutation of columns for OP_Compare */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>lastRowid</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Saved value of the last insert ROWID */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <decl_stmt><decl><type><name>u64</name></type> <name>start</name></decl>;</decl_stmt>                 <comment type="block">/* CPU clock count at start of opcode */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block" format="doxygen">/*** INSERT STACK UNION HERE ***/</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>VDBE_MAGIC_RUN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* sqlite3_step() verifies this */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This happens if a malloc() inside a call to sqlite3_column_text() or
    ** sqlite3_column_text16() failed.  */</comment>
    <goto>goto <name>no_mem</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCurrentTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>nBusy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_interrupt</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeIOTraceSql</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>iPrior</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_VM_STEP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nProgressLimit</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name> <operator>-</operator> <operator>(</operator><name>iPrior</name> <operator>%</operator> <name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_VdbeListing</name><operator>|</operator><name>SQLITE_VdbeEQP</name><operator>|</operator><name>SQLITE_VdbeTrace</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>once</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbePrintSql</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeListing</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"VDBE Program Listing:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeEQP</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Explain</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>once</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"VDBE Query Plan:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>once</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeTrace</name></expr> )</condition><block type="pseudo"><block_content>  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"VDBE Trace:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>pOp</name><operator>=</operator><operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name></expr>]</index></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>pOp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>&gt;=</operator><name>aOp</name> <operator>&amp;&amp;</operator> <name>pOp</name><operator>&lt;</operator><operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>sqlite3Hwtime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>nVmStep</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name><operator>-</operator><name>aOp</name><operator>)</operator></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Only allow tracing if SQLITE_DEBUG is defined.
    */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      

    <comment type="block">/* Check to see if we need to simulate an interrupt.  This only happens
    ** if we have a special test build.
    */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name>sqlite3_interrupt_count</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sqlite3_interrupt_count</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>sqlite3_interrupt_count</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_interrupt</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Sanity checking on other operands */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opflags</name></name><operator>==</operator><name><name>sqlite3OpcodeProperty</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opflags</name></name> <operator>&amp;</operator> <name>OPFLG_IN1</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opflags</name></name> <operator>&amp;</operator> <name>OPFLG_IN2</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opflags</name></name> <operator>&amp;</operator> <name>OPFLG_IN3</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opflags</name></name> <operator>&amp;</operator> <name>OPFLG_OUT2</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opflags</name></name> <operator>&amp;</operator> <name>OPFLG_OUT3</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>pOrigOp</name> <operator>=</operator> <name>pOp</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
    <switch>switch<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr> )</condition><block>{<block_content>

<comment type="block" format="doxygen">/*****************************************************************************
** What follows is a massive switch statement where each case implements a
** separate instruction in the virtual machine.  If we follow the usual
** indentation conventions, each case should be indented by 6 spaces.  But
** that is a lot of wasted space on the left margin.  So the code within
** the switch statement will break with convention and be flush-left. Another
** big comment (similar to this one) will mark the point in the code where
** we transition back to normal indentation.
**
** The formatting of each case is important.  The makefile for SQLite
** generates two C files "opcodes.h" and "opcodes.c" by scanning this
** file looking for lines that begin with "case OP_".  The opcodes.h files
** will be filled with #defines that give unique integer values to each
** opcode and the opcodes.c file is filled with an array of strings where
** each string is the symbolic name for the corresponding opcode.  If the
** case statement is followed by a comment of the form "/# same as ... #/"
** that comment is used to determine the particular value of the opcode.
**
** Other keywords in the comment that follows each case are used to
** construct the OPFLG_INITIALIZER value that initializes opcodeProperty[].
** Keywords include: in1, in2, in3, out2, out3.  See
** the mkopcodeh.awk script for additional information.
**
** Documentation about VDBE opcodes is generated by scanning this file
** for lines of that contain "Opcode:".  That line and all subsequent
** comment lines are used in the generation of the opcode.html documentation
** file.
**
** SUMMARY:
**
**     Formatting is important to scripts that scan this file.
**     Do not deviate from the formatting style currently in use.
**
*****************************************************************************/</comment>

<comment type="block">/* Opcode:  Goto * P2 * * *
**
** An unconditional jump to address P2.
** The next instruction executed will be 
** the one at index P2 from the beginning of
** the program.
**
** The P1 parameter is not actually used by this opcode.  However, it
** is sometimes set to 1 instead of 0 as a hint to the command-line shell
** that this Goto is the bottom of a loop and that the lines from P2 down
** to the current line should be indented for EXPLAIN output.
*/</comment>
<case>case <expr><name>OP_Goto</name></expr>:</case> <block>{<block_content>             <comment type="block">/* jump */</comment>
<label><name>jump_to_p2_and_check_for_interrupt</name>:</label>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Opcodes that are used as the bottom of a loop (OP_Next, OP_Prev,
  ** OP_VNext, OP_RowSetNext, or OP_SorterNext) all jump here upon
  ** completion.  Check to see if sqlite3_interrupt() has been called
  ** or if the progress callback needs to be invoked. 
  **
  ** This code uses unstructured "goto" statements and does not look clean.
  ** But that is not due to sloppy coding habits. The code is written this
  ** way for performance, to avoid having to run the interrupt and progress
  ** checks on every opcode.  This helps sqlite3_step() to run about 1.5%
  ** faster according to "valgrind --tool=cachegrind" */</comment>
<label><name>check_for_interrupt</name>:</label>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_interrupt</name>;</goto></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  <comment type="block">/* Call the progress callback if it is configured and the required number
  ** of VDBE ops have been executed (either since this invocation of
  ** sqlite3VdbeExec() or since last time the progress callback was called).
  ** If the progress callback returns non-zero, exit the virtual machine with
  ** a return code SQLITE_ABORT.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nVmStep</name><operator>&gt;=</operator><name>nProgressLimit</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nProgressLimit</name> <operator>=</operator> <name>nVmStep</name> <operator>+</operator> <name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name> <operator>-</operator> <operator>(</operator><name>nVmStep</name><operator>%</operator><name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pProgressArg</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_INTERRUPT</name></expr>;</expr_stmt>
      <goto>goto <name>vdbe_error_halt</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode:  Gosub P1 P2 * * *
**
** Write the current address onto register P1
** and then jump to address P2.
*/</comment>
<case>case <expr><name>OP_Gosub</name></expr>:</case> <block>{<block_content>            <comment type="block">/* jump */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name><operator>-</operator><name>aOp</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Most jump operations do a goto to this spot in order to update
  ** the pOp pointer. */</comment>
<label><name>jump_to_p2</name>:</label>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode:  Return P1 * * * *
**
** Jump to the next instruction after the address in register P1.  After
** the jump, register P1 becomes undefined.
*/</comment>
<case>case <expr><name>OP_Return</name></expr>:</case> <block>{<block_content>           <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: InitCoroutine P1 P2 P3 * *
**
** Set up register P1 so that it will Yield to the coroutine
** located at address P3.
**
** If P2!=0 then the coroutine implementation immediately follows
** this opcode.  So jump over the coroutine implementation to
** address P2.
**
** See also: EndCoroutine
*/</comment>
<case>case <expr><name>OP_InitCoroutine</name></expr>:</case> <block>{<block_content>     <comment type="block">/* jump */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>  <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode:  EndCoroutine P1 * * * *
**
** The instruction at the address in register P1 is a Yield.
** Jump to the P2 parameter of that Yield.
** After the jump, register P1 becomes undefined.
**
** See also: InitCoroutine
*/</comment>
<case>case <expr><name>OP_EndCoroutine</name></expr>:</case> <block>{<block_content>           <comment type="block">/* in1 */</comment>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pCaller</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCaller</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCaller</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Yield</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCaller</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCaller</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pCaller</name><operator>-&gt;</operator><name>p2</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode:  Yield P1 P2 * * *
**
** Swap the program counter with the value in register P1.  This
** has the effect of yielding to a coroutine.
**
** If the coroutine that is launched by this instruction ends with
** Yield or Return then continue to the next instruction.  But if
** the coroutine launched by this instruction ends with
** EndCoroutine, then jump to P2 rather than continuing with the
** next instruction.
**
** See also: InitCoroutine
*/</comment>
<case>case <expr><name>OP_Yield</name></expr>:</case> <block>{<block_content>            <comment type="block">/* in1, jump */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pcDest</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pcDest</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name>pcDest</name></expr>]</index></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode:  HaltIfNull  P1 P2 P3 P4 P5
** Synopsis:  if r[P3]=null halt
**
** Check the value in register P3.  If it is NULL then Halt using
** parameter P1, P2, and P4 as if this were a Halt instruction.  If the
** value in register P3 is not NULL, then this routine is a no-op.
** The P5 parameter should be 1.
*/</comment>
<case>case <expr><name>OP_HaltIfNull</name></expr>:</case> <block>{<block_content>      <comment type="block">/* in3 */</comment>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <comment type="block">/* Fall through into OP_Halt */</comment>
</block_content>}</block>

<comment type="block">/* Opcode:  Halt P1 P2 * P4 P5
**
** Exit immediately.  All open cursors, etc are closed
** automatically.
**
** P1 is the result code returned by sqlite3_exec(), sqlite3_reset(),
** or sqlite3_finalize().  For a normal halt, this should be SQLITE_OK (0).
** For errors, it can be some other value.  If P1!=0 then P2 will determine
** whether or not to rollback the current transaction.  Do not rollback
** if P2==OE_Fail. Do the rollback if P2==OE_Rollback.  If P2==OE_Abort,
** then back out all changes that have occurred during this execution of the
** VDBE, but do not rollback the transaction. 
**
** If P4 is not null then it is an error message string.
**
** P5 is a value between 0 and 4, inclusive, that modifies the P4 string.
**
**    0:  (no change)
**    1:  NOT NULL contraint failed: P4
**    2:  UNIQUE constraint failed: P4
**    3:  CHECK constraint failed: P4
**    4:  FOREIGN KEY constraint failed: P4
**
** If P5 is not zero and P4 is NULL, then everything after the ":" is
** omitted.
**
** There is an implied "Halt 0 0 0" instruction inserted at the very end of
** every program.  So a jump past the last instruction of the program
** is the same as executing Halt.
*/</comment>
<case>case <expr><name>OP_Halt</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLogFmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pcx</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pcx</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Halt the sub-program. Return control to the parent frame. */</comment>
    <expr_stmt><expr><name>pFrame</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrame</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pcx</name> <operator>=</operator> <call><name>sqlite3VdbeFrameRestore</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lastRowid</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>OE_Ignore</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Instruction pcx is the OP_Program that invoked the sub-program 
      ** currently being halted. If the p2 instruction of this OP_Halt
      ** instruction is set to OE_Ignore, then the sub-program is throwing
      ** an IGNORE exception. In this case jump to the address specified
      ** as the p2 of the calling OP_Program.  */</comment>
      <expr_stmt><expr><name>pcx</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>pcx</name></expr>]</index></name><operator>.</operator><name>p2</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>aOp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMem</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name>pcx</name></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name>pcx</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>azType</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"NOT NULL"</literal></expr>, <expr><literal type="string">"UNIQUE"</literal></expr>, <expr><literal type="string">"CHECK"</literal></expr>,
                                             <expr><literal type="string">"FOREIGN KEY"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>&lt;=</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <name><name>azType</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zType</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zLogFmt</name> <operator>=</operator> <literal type="string">"abort at %d in [%s]: %s"</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zType</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s constraint failed: %s"</literal></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s constraint failed"</literal></expr></argument>, <argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>zLogFmt</name></expr></argument>, <argument><expr><name>pcx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>SQLITE_DONE</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <goto>goto <name>vdbe_return</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: Integer P1 P2 * * *
** Synopsis: r[P2]=P1
**
** The 32-bit integer value P1 is written into register P2.
*/</comment>
<case>case <expr><name>OP_Integer</name></expr>:</case> <block>{<block_content>         <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Int64 * P2 * P4 *
** Synopsis: r[P2]=P4
**
** P4 is a pointer to a 64-bit integer value.
** Write that value into register P2.
*/</comment>
<case>case <expr><name>OP_Int64</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pI64</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>*</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pI64</name></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/* Opcode: Real * P2 * P4 *
** Synopsis: r[P2]=P4
**
** P4 is a pointer to a 64-bit floating point value.
** Write that value into register P2.
*/</comment>
<case>case <expr><name>OP_Real</name></expr>:</case> <block>{<block_content>            <comment type="block">/* same as TK_FLOAT, out2 */</comment>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Real</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><operator>*</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pReal</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>*</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pReal</name></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: String8 * P2 * P4 *
** Synopsis: r[P2]='P4'
**
** P4 points to a nul terminated UTF-8 string. This opcode is transformed 
** into a String opcode before it is executed for the first time.  During
** this transformation, the length of string P4 is computed and stored
** as the P1 parameter.
*/</comment>
<case>case <expr><name>OP_String8</name></expr>:</case> <block>{<block_content>         <comment type="block">/* same as TK_STRING, out2 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_String</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>encoding</name><operator>!=</operator><name>SQLITE_UTF8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_TOOBIG</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>too_big</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>szMalloc</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOut</name><operator>-&gt;</operator><name>zMalloc</name></name><operator>==</operator><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Static</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_DYNAMIC</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_DYNAMIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>pOut</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>too_big</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Fall through to the next case, OP_String */</comment>
</block_content>}</block>
  
<comment type="block">/* Opcode: String P1 P2 P3 P4 P5
** Synopsis: r[P2]='P4' (len=P1)
**
** The string value P4 of length P1 (bytes) is stored in register P2.
**
** If P5!=0 and the content of register P3 is greater than zero, then
** the datatype of the register P2 is converted to BLOB.  The content is
** the same sequence of bytes, it is merely interpreted as a BLOB instead
** of a string, as if it had been CAST.
*/</comment>
<case>case <expr><name>OP_String</name></expr>:</case> <block>{<block_content>          <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Str</name><operator>|</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Blob</name><operator>|</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Null P1 P2 P3 * *
** Synopsis:  r[P2..P3]=NULL
**
** Write a NULL into registers P2.  If P3 greater than P2, then also write
** NULL into register P3 and every register in between P2 and P3.  If P3
** is less than P2 (typically P3 is zero) then only register P2 is
** set to NULL.
**
** If the P1 value is non-zero, then also set the MEM_Cleared flag so that
** NULL values will not compare equal even if SQLITE_NULLEQ is set on
** OP_Ne or OP_Eq.
*/</comment>
<case>case <expr><name>OP_Null</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nullFlag</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cnt</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>-</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>nullFlag</name> <operator>=</operator> <ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Cleared</name><operator>)</operator></expr> </then><else>: <expr><name>MEM_Null</name></expr></else></ternary></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>cnt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pOut</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>nullFlag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cnt</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SoftNull P1 * * * *
** Synopsis:  r[P1]=NULL
**
** Set register P1 to have the value NULL as seen by the OP_MakeRecord
** instruction, but do not free any string or blob memory associated with
** the register, so that if the value was a string or blob that was
** previously copied using OP_SCopy, the copies will continue to be valid.
*/</comment>
<case>case <expr><name>OP_SoftNull</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name><operator>|</operator><name>MEM_Null</name><operator>)</operator><operator>&amp;</operator><operator>~</operator><name>MEM_Undefined</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Blob P1 P2 * P4 *
** Synopsis: r[P2]=P4 (len=P1)
**
** P4 points to a blob of data P1 bytes long.  Store this
** blob in register P2.
*/</comment>
<case>case <expr><name>OP_Blob</name></expr>:</case> <block>{<block_content>                <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>&lt;=</operator> <name>SQLITE_MAX_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Variable P1 P2 * P4 *
** Synopsis: r[P2]=parameter(P1,P4)
**
** Transfer the values of bound parameter P1 into register P2
**
** If the parameter is named, then its name appears in P4.
** The P4 value is used by sqlite3_bind_parameter_name().
*/</comment>
<case>case <expr><name>OP_Variable</name></expr>:</case> <block>{<block_content>            <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pVar</name></decl>;</decl_stmt>       <comment type="block">/* Value being transferred */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nVar</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>azVar</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVar</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pVar</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>too_big</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pVar</name></expr></argument>, <argument><expr><name>MEM_Static</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Move P1 P2 P3 * *
** Synopsis:  r[P2@P3]=r[P1@P3]
**
** Move the P3 values in register P1..P1+P3-1 over into
** registers P2..P2+P3-1.  Registers P1..P1+P3-1 are
** left holding a NULL.  It is an error for register ranges
** P1..P1+P3-1 and P2..P2+P3-1 to overlap.  It is an error
** for P3 to be less than 1.
*/</comment>
<case>case <expr><name>OP_Move</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>           <comment type="block">/* Number of registers left to copy */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name></decl>;</decl_stmt>          <comment type="block">/* Register to copy from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>p2</name></decl>;</decl_stmt>          <comment type="block">/* Register to copy to */</comment>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p1</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p2</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p2</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>+</operator><name>n</name><operator>&lt;=</operator><name>p2</name> <operator>||</operator> <name>p2</name><operator>+</operator><name>n</name><operator>&lt;=</operator><name>p1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOut</name><operator>&lt;=</operator><operator>&amp;</operator><name><name>aMem</name><index>[<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name><operator>&lt;=</operator><operator>&amp;</operator><name><name>aMem</name><index>[<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemMove</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>pOut</name><operator>-&gt;</operator><name>pScopyFrom</name></name><operator>&gt;=</operator><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p1</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pOut</name><operator>-&gt;</operator><name>pScopyFrom</name></name><operator>&lt;</operator><name>pOut</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>+=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>-</operator> <name>p1</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>Deephemeralize</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>p2</name><operator>++</operator></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn1</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><operator>--</operator><name>n</name></expr> )</condition>;</do>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Copy P1 P2 P3 * *
** Synopsis: r[P2@P3+1]=r[P1@P3+1]
**
** Make a copy of registers P1..P1+P3 into registers P2..P2+P3.
**
** This instruction makes a deep copy of the value.  A duplicate
** is made of any string or blob constant.  See also OP_SCopy.
*/</comment>
<case>case <expr><name>OP_Copy</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOut</name><operator>!=</operator><name>pIn1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Deephemeralize</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>-</operator><name>n</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>n</name><operator>--</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pOut</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn1</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SCopy P1 P2 * * *
** Synopsis: r[P2]=r[P1]
**
** Make a shallow copy of register P1 into register P2.
**
** This instruction makes a shallow copy of the value.  If the value
** is a string or blob, then the copy is only a pointer to the
** original and hence if the original changes so will the copy.
** Worse, if the original is deallocated, the copy becomes invalid.
** Thus the program must guarantee that the original will not change
** during the lifetime of the copy.  Use OP_Copy to make a complete
** copy.
*/</comment>
<case>case <expr><name>OP_SCopy</name></expr>:</case> <block>{<block_content>            <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOut</name><operator>!=</operator><name>pIn1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pOut</name><operator>-&gt;</operator><name>pScopyFrom</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>=</operator> <name>pIn1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IntCopy P1 P2 * * *
** Synopsis: r[P2]=r[P1]
**
** Transfer the integer value held in register P1 into register P2.
**
** This is an optimized version of SCopy that works only for integer
** values.
*/</comment>
<case>case <expr><name>OP_IntCopy</name></expr>:</case> <block>{<block_content>            <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ResultRow P1 P2 * * *
** Synopsis:  output=r[P1@P2]
**
** The registers P1 through P1+P2-1 contain a single row of
** results. This opcode causes the sqlite3_step() call to terminate
** with an SQLITE_ROW return code and it sets up the sqlite3_stmt
** structure to provide access to the r(P1)..r(P1+P2-1) values as
** the result row.
*/</comment>
<case>case <expr><name>OP_ResultRow</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name><operator>==</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  <comment type="block">/* Run the progress counter just before returning.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name>nVmStep</name><operator>&gt;=</operator><name>nProgressLimit</name>
   <operator>&amp;&amp;</operator> <call><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pProgressArg</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_INTERRUPT</name></expr>;</expr_stmt>
    <goto>goto <name>vdbe_error_halt</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If this statement has violated immediate foreign key constraints, do
  ** not return the number of rows modified. And do not RELEASE the statement
  ** transaction. It needs to be rolled back.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCheckFk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_CountRows</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>usesStmtJournal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the SQLITE_CountRows flag is set in sqlite3.flags mask, then 
  ** DML statements invoke this opcode to return the number of rows 
  ** modified to the user. This is the only way that a VM that
  ** opens a statement transaction may invoke this opcode.
  **
  ** In case this is such a statement, close any statement transaction
  ** opened by this VM before returning control to the user. This is to
  ** ensure that statement-transactions are always nested, not overlapping.
  ** If the open statement-transaction is not closed here, then the user
  ** may step another VM that opens its own statement transaction. This
  ** may lead to overlapping statement transactions.
  **
  ** The statement transaction is never a top-level transaction.  Hence
  ** the RELEASE call below can never fail.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_CountRows</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCloseStatement</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SAVEPOINT_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Invalidate all ephemeral cursor row caches */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cacheCtr</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>cacheCtr</name></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator><operator>|</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* Make sure the results of the current row are \000 terminated
  ** and have an assigned type.  The results are de-ephemeralized as
  ** a side effect.
  */</comment>
  <expr_stmt><expr><name>pMem</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Deephemeralize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Ephem</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
            <operator>||</operator> <operator>(</operator><name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemNulTerminate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Return SQLITE_ROW
  */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ROW</name></expr>;</expr_stmt>
  <goto>goto <name>vdbe_return</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: Concat P1 P2 P3 * *
** Synopsis: r[P3]=r[P2]+r[P1]
**
** Add the text in register P1 onto the end of the text in
** register P2 and store the result in register P3.
** If either the P1 or P2 text are NULL then store NULL in P3.
**
**   P3 = P2 || P1
**
** It is illegal for P1 and P3 to be the same register. Sometimes,
** if P3 is the same register as P2, the implementation is able
** to avoid a memcpy().
*/</comment>
<case>case <expr><name>OP_Concat</name></expr>:</case> <block>{<block_content>           <comment type="block">/* same as TK_CONCAT, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nByte</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name><operator>!=</operator><name>pOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name><operator>)</operator> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>Stringify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Stringify</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>too_big</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nByte</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>pOut</name><operator>==</operator><name>pIn2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>no_mem</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>!=</operator><name>pIn2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pIn2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pIn2</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOut</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pIn2</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>nByte</name></expr>]</index></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>nByte</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Term</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Add P1 P2 P3 * *
** Synopsis:  r[P3]=r[P1]+r[P2]
**
** Add the value in register P1 to the value in register P2
** and store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Multiply P1 P2 P3 * *
** Synopsis:  r[P3]=r[P1]*r[P2]
**
**
** Multiply the value in register P1 by the value in register P2
** and store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Subtract P1 P2 P3 * *
** Synopsis:  r[P3]=r[P2]-r[P1]
**
** Subtract the value in register P1 from the value in register P2
** and store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Divide P1 P2 P3 * *
** Synopsis:  r[P3]=r[P2]/r[P1]
**
** Divide the value in register P1 by the value in register P2
** and store the result in register P3 (P3=P2/P1). If the value in 
** register P1 is zero, then the result is NULL. If either input is 
** NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Remainder P1 P2 P3 * *
** Synopsis:  r[P3]=r[P2]%r[P1]
**
** Compute the remainder after integer register P2 is divided by 
** register P1 and store the result in register P3. 
** If the value in register P1 is zero the result is NULL.
** If either operand is NULL, the result is NULL.
*/</comment>
<case>case <expr><name>OP_Add</name></expr>:</case>                   <comment type="block">/* same as TK_PLUS, in1, in2, out3 */</comment>
<case>case <expr><name>OP_Subtract</name></expr>:</case>              <comment type="block">/* same as TK_MINUS, in1, in2, out3 */</comment>
<case>case <expr><name>OP_Multiply</name></expr>:</case>              <comment type="block">/* same as TK_STAR, in1, in2, out3 */</comment>
<case>case <expr><name>OP_Divide</name></expr>:</case>                <comment type="block">/* same as TK_SLASH, in1, in2, out3 */</comment>
<case>case <expr><name>OP_Remainder</name></expr>:</case> <block>{<block_content>           <comment type="block">/* same as TK_REM, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>bIntint</name></decl>;</decl_stmt>   <comment type="block">/* Started out as two integer operands */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags</name></decl>;</decl_stmt>      <comment type="block">/* Combined MEM_* flags from both inputs */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>type1</name></decl>;</decl_stmt>      <comment type="block">/* Numeric type of left operand */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>type2</name></decl>;</decl_stmt>      <comment type="block">/* Numeric type of right operand */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iA</name></decl>;</decl_stmt>         <comment type="block">/* Integer value of left operand */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iB</name></decl>;</decl_stmt>         <comment type="block">/* Integer value of right operand */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>rA</name></decl>;</decl_stmt>      <comment type="block">/* Real value of left operand */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>rB</name></decl>;</decl_stmt>      <comment type="block">/* Real value of right operand */</comment>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>type1</name> <operator>=</operator> <call><name>numericType</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>type2</name> <operator>=</operator> <call><name>numericType</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>arithmetic_result_is_null</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>type1</name> <operator>&amp;</operator> <name>type2</name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iA</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iB</name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bIntint</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OP_Add</name></expr>:</case>       <if_stmt><if>if<condition>( <expr><call><name>sqlite3AddInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iB</name></expr></argument>,<argument><expr><name>iA</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fp_math</name>;</goto></block_content></block></if></if_stmt>  <break>break;</break>
      <case>case <expr><name>OP_Subtract</name></expr>:</case>  <if_stmt><if>if<condition>( <expr><call><name>sqlite3SubInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iB</name></expr></argument>,<argument><expr><name>iA</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fp_math</name>;</goto></block_content></block></if></if_stmt>  <break>break;</break>
      <case>case <expr><name>OP_Multiply</name></expr>:</case>  <if_stmt><if>if<condition>( <expr><call><name>sqlite3MulInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iB</name></expr></argument>,<argument><expr><name>iA</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fp_math</name>;</goto></block_content></block></if></if_stmt>  <break>break;</break>
      <case>case <expr><name>OP_Divide</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>arithmetic_result_is_null</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iB</name><operator>==</operator><name>SMALLEST_INT64</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>fp_math</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>iB</name> <operator>/=</operator> <name>iA</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>arithmetic_result_is_null</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>iB</name> <operator>%=</operator> <name>iA</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>iB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>bIntint</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>fp_math</name>:</label>
    <expr_stmt><expr><name>rA</name> <operator>=</operator> <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rB</name> <operator>=</operator> <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OP_Add</name></expr>:</case>         <expr_stmt><expr><name>rB</name> <operator>+=</operator> <name>rA</name></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>OP_Subtract</name></expr>:</case>    <expr_stmt><expr><name>rB</name> <operator>-=</operator> <name>rA</name></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>OP_Multiply</name></expr>:</case>    <expr_stmt><expr><name>rB</name> <operator>*=</operator> <name>rA</name></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>OP_Divide</name></expr>:</case> <block>{<block_content>
        <comment type="block">/* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */</comment>
        <if_stmt><if>if<condition>( <expr><name>rA</name><operator>==</operator><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>arithmetic_result_is_null</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rB</name> <operator>/=</operator> <name>rA</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><name>iA</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>rA</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iB</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>rB</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>arithmetic_result_is_null</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rB</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name>iB</name> <operator>%</operator> <name>iA</name><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>rB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>rB</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>arithmetic_result_is_null</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>rB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Real</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>type1</name><operator>|</operator><name>type2</name><operator>)</operator><operator>&amp;</operator><name>MEM_Real</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>bIntint</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeIntegerAffinity</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>

<label><name>arithmetic_result_is_null</name>:</label>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: CollSeq P1 * * P4
**
** P4 is a pointer to a CollSeq struct. If the next call to a user function
** or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will
** be returned. This is used by the built-in min(), max() and nullif()
** functions.
**
** If P1 is not zero, then it is a register that a subsequent min() or
** max() aggregate will set to 1 if the current row is not the minimum or
** maximum.  The P1 register is initialized to 0 by this instruction.
**
** The interface used by the implementation of the aforementioned functions
** to retrieve the collation sequence set by this opcode is not available
** publicly.  Only built-in functions have access to this feature.
*/</comment>
<case>case <expr><name>OP_CollSeq</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_COLLSEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Function0 P1 P2 P3 P4 P5
** Synopsis: r[P3]=func(r[P2@P5])
**
** Invoke a user function (P4 is a pointer to a FuncDef object that
** defines the function) with P5 arguments taken from register P2 and
** successors.  The result of the function is stored in register P3.
** Register P3 must not be one of the function inputs.
**
** P1 is a 32-bit bitmask indicating whether or not each argument to the 
** function was determined to be constant at compile time. If the first
** argument was constant then bit 0 of P1 is set. This is used to determine
** whether meta data associated with a user function argument using the
** sqlite3_set_auxdata() API may be safely retained until the next
** invocation of this opcode.
**
** See also: Function, AggStep, AggFinal
*/</comment>
<comment type="block">/* Opcode: Function P1 P2 P3 P4 P5
** Synopsis: r[P3]=func(r[P2@P5])
**
** Invoke a user function (P4 is a pointer to an sqlite3_context object that
** contains a pointer to the function to be run) with P5 arguments taken
** from register P2 and successors.  The result of the function is stored
** in register P3.  Register P3 must not be one of the function inputs.
**
** P1 is a 32-bit bitmask indicating whether or not each argument to the 
** function was determined to be constant at compile time. If the first
** argument was constant then bit 0 of P1 is set. This is used to determine
** whether meta data associated with a user function argument using the
** sqlite3_set_auxdata() API may be safely retained until the next
** invocation of this opcode.
**
** SQL functions are initially coded as OP_Function0 with P4 pointing
** to a FuncDef object.  But on first evaluation, the P4 operand is
** automatically converted into an sqlite3_context object and the operation
** changed to this OP_Function opcode.  In this way, the initialization of
** the sqlite3_context object occurs only once, rather than once for each
** evaluation of the function.
**
** See also: Function0, AggStep, AggFinal
*/</comment>
<case>case <expr><name>OP_Function0</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_FUNCDEF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>n</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCtx</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCtx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pFunc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_FUNCCTX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_Function</name></expr>;</expr_stmt>
  <comment type="block">/* Fall through into OP_Function */</comment>
</block_content>}</block>
<case>case <expr><name>OP_Function</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_FUNCCTX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pCtx</name></name></expr>;</expr_stmt>

  <comment type="block">/* If this function is inside of a trigger, the register array in aMem[]
  ** might change from one evaluation to the next.  The next block of code
  ** checks to see if the register array has changed, and if so it
  ** reinitializes the relavant parts of the sqlite3_context object */</comment>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name> <operator>!=</operator> <name>pOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name> <operator>=</operator> <name>pOut</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name>lastRowid</name></expr>;</expr_stmt>
  <expr_stmt><expr><call>(<modifier>*</modifier><name><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>xSFunc</name></name>)<argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="block">/* IMP: R-24505-23230 */</comment>
  <expr_stmt><expr><name>lastRowid</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name></expr>;</expr_stmt>  <comment type="block">/* Remember rowid changes made by xSFunc */</comment>

  <comment type="block">/* If the function returned an error, throw an exception */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeDeleteAuxData</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Copy the result of the function into register P3 */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>too_big</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: BitAnd P1 P2 P3 * *
** Synopsis:  r[P3]=r[P1]&amp;r[P2]
**
** Take the bit-wise AND of the values in register P1 and P2 and
** store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: BitOr P1 P2 P3 * *
** Synopsis:  r[P3]=r[P1]|r[P2]
**
** Take the bit-wise OR of the values in register P1 and P2 and
** store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: ShiftLeft P1 P2 P3 * *
** Synopsis:  r[P3]=r[P2]&lt;&lt;r[P1]
**
** Shift the integer value in register P2 to the left by the
** number of bits specified by the integer in register P1.
** Store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: ShiftRight P1 P2 P3 * *
** Synopsis:  r[P3]=r[P2]&gt;&gt;r[P1]
**
** Shift the integer value in register P2 to the right by the
** number of bits specified by the integer in register P1.
** Store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<case>case <expr><name>OP_BitAnd</name></expr>:</case>                 <comment type="block">/* same as TK_BITAND, in1, in2, out3 */</comment>
<case>case <expr><name>OP_BitOr</name></expr>:</case>                  <comment type="block">/* same as TK_BITOR, in1, in2, out3 */</comment>
<case>case <expr><name>OP_ShiftLeft</name></expr>:</case>              <comment type="block">/* same as TK_LSHIFT, in1, in2, out3 */</comment>
<case>case <expr><name>OP_ShiftRight</name></expr>:</case> <block>{<block_content>           <comment type="block">/* same as TK_RSHIFT, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iA</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>uA</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iB</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>op</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name><operator>)</operator> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iA</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iB</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>OP_BitAnd</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iA</name> <operator>&amp;=</operator> <name>iB</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>OP_BitOr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iA</name> <operator>|=</operator> <name>iB</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iB</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_ShiftRight</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_ShiftLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If shifting by a negative amount, shift in the other direction */</comment>
    <if_stmt><if>if<condition>( <expr><name>iB</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_ShiftRight</name><operator>==</operator><name>OP_ShiftLeft</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>OP_ShiftLeft</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>op</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iB</name> <operator>=</operator> <ternary><condition><expr><name>iB</name><operator>&gt;</operator><operator>(</operator><operator>-</operator><literal type="number">64</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><name>iB</name></expr> </then><else>: <expr><literal type="number">64</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iB</name><operator>&gt;=</operator><literal type="number">64</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iA</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>iA</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_ShiftLeft</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iA</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uA</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>OP_ShiftLeft</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>uA</name> <operator>&lt;&lt;=</operator> <name>iB</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>uA</name> <operator>&gt;&gt;=</operator> <name>iB</name></expr>;</expr_stmt>
        <comment type="block">/* Sign-extend on a right shift of a negative number */</comment>
        <if_stmt><if>if<condition>( <expr><name>iA</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>uA</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">0xffffffff</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator><operator>|</operator><literal type="number">0xffffffff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">64</literal><operator>-</operator><name>iB</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uA</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iA</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>iA</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: AddImm  P1 P2 * * *
** Synopsis:  r[P1]=r[P1]+P2
** 
** Add the constant P2 to the value in register P1.
** The result is always an integer.
**
** To force any register to be an integer, just add 0.
*/</comment>
<case>case <expr><name>OP_AddImm</name></expr>:</case> <block>{<block_content>            <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>+=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: MustBeInt P1 P2 * * *
** 
** Force the value in register P1 to be an integer.  If the value
** in P1 is not an integer and cannot be converted into an integer
** without data loss, then jump immediately to P2, or if P2==0
** raise an SQLITE_MISMATCH exception.
*/</comment>
<case>case <expr><name>OP_MustBeInt</name></expr>:</case> <block>{<block_content>            <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISMATCH</name></expr>;</expr_stmt>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <goto>goto <name>jump_to_p2</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/* Opcode: RealAffinity P1 * * * *
**
** If register P1 holds an integer convert it to a real value.
**
** This opcode is used when extracting information from a column that
** has REAL affinity.  Such column values may still be stored as
** integers, for space efficiency, but after extraction we want them
** to have only a real value.
*/</comment>
<case>case <expr><name>OP_RealAffinity</name></expr>:</case> <block>{<block_content>                  <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRealify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CAST</name></cpp:ifndef>
<comment type="block">/* Opcode: Cast P1 P2 * * *
** Synopsis: affinity(r[P1])
**
** Force the value in register P1 to be the type defined by P2.
** 
** &lt;ul&gt;
** &lt;li value="97"&gt; TEXT
** &lt;li value="98"&gt; BLOB
** &lt;li value="99"&gt; NUMERIC
** &lt;li value="100"&gt; INTEGER
** &lt;li value="101"&gt; REAL
** &lt;/ul&gt;
**
** A NULL value is not changed by this routine.  It remains NULL.
*/</comment>
<case>case <expr><name>OP_Cast</name></expr>:</case> <block>{<block_content>                  <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><name>SQLITE_AFF_BLOB</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;=</operator><name>SQLITE_AFF_REAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_AFF_BLOB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_AFF_NUMERIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_AFF_INTEGER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_AFF_REAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemCast</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_CAST */</comment>

<comment type="block">/* Opcode: Lt P1 P2 P3 P4 P5
** Synopsis: if r[P1]&lt;r[P3] goto P2
**
** Compare the values in register P1 and P3.  If reg(P3)&lt;reg(P1) then
** jump to address P2.  
**
** If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or
** reg(P3) is NULL then take the jump.  If the SQLITE_JUMPIFNULL 
** bit is clear then fall through if either operand is NULL.
**
** The SQLITE_AFF_MASK portion of P5 must be an affinity character -
** SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made 
** to coerce both inputs according to this affinity before the
** comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric
** affinity is used. Note that the affinity conversions are stored
** back into the input registers P1 and P3.  So this opcode can cause
** persistent changes to registers P1 and P3.
**
** Once any conversions have taken place, and neither value is NULL, 
** the values are compared. If both values are blobs then memcmp() is
** used to determine the results of the comparison.  If both values
** are text, then the appropriate collating function specified in
** P4 is  used to do the comparison.  If P4 is not specified then
** memcmp() is used to compare text string.  If both values are
** numeric, then a numeric comparison is used. If the two values
** are of different types, then numbers are considered less than
** strings and strings are considered less than blobs.
**
** If the SQLITE_STOREP2 bit of P5 is set, then do not jump.  Instead,
** store a boolean result (either 0, or 1, or NULL) in register P2.
**
** If the SQLITE_NULLEQ bit is set in P5, then NULL values are considered
** equal to one another, provided that they do not have their MEM_Cleared
** bit set.
*/</comment>
<comment type="block">/* Opcode: Ne P1 P2 P3 P4 P5
** Synopsis: if r[P1]!=r[P3] goto P2
**
** This works just like the Lt opcode except that the jump is taken if
** the operands in registers P1 and P3 are not equal.  See the Lt opcode for
** additional information.
**
** If SQLITE_NULLEQ is set in P5 then the result of comparison is always either
** true or false and is never NULL.  If both operands are NULL then the result
** of comparison is false.  If either operand is NULL then the result is true.
** If neither operand is NULL the result is the same as it would be if
** the SQLITE_NULLEQ flag were omitted from P5.
*/</comment>
<comment type="block">/* Opcode: Eq P1 P2 P3 P4 P5
** Synopsis: if r[P1]==r[P3] goto P2
**
** This works just like the Lt opcode except that the jump is taken if
** the operands in registers P1 and P3 are equal.
** See the Lt opcode for additional information.
**
** If SQLITE_NULLEQ is set in P5 then the result of comparison is always either
** true or false and is never NULL.  If both operands are NULL then the result
** of comparison is true.  If either operand is NULL then the result is false.
** If neither operand is NULL the result is the same as it would be if
** the SQLITE_NULLEQ flag were omitted from P5.
*/</comment>
<comment type="block">/* Opcode: Le P1 P2 P3 P4 P5
** Synopsis: if r[P1]&lt;=r[P3] goto P2
**
** This works just like the Lt opcode except that the jump is taken if
** the content of register P3 is less than or equal to the content of
** register P1.  See the Lt opcode for additional information.
*/</comment>
<comment type="block">/* Opcode: Gt P1 P2 P3 P4 P5
** Synopsis: if r[P1]&gt;r[P3] goto P2
**
** This works just like the Lt opcode except that the jump is taken if
** the content of register P3 is greater than the content of
** register P1.  See the Lt opcode for additional information.
*/</comment>
<comment type="block">/* Opcode: Ge P1 P2 P3 P4 P5
** Synopsis: if r[P1]&gt;=r[P3] goto P2
**
** This works just like the Lt opcode except that the jump is taken if
** the content of register P3 is greater than or equal to the content of
** register P1.  See the Lt opcode for additional information.
*/</comment>
<case>case <expr><name>OP_Eq</name></expr>:</case>               <comment type="block">/* same as TK_EQ, jump, in1, in3 */</comment>
<case>case <expr><name>OP_Ne</name></expr>:</case>               <comment type="block">/* same as TK_NE, jump, in1, in3 */</comment>
<case>case <expr><name>OP_Lt</name></expr>:</case>               <comment type="block">/* same as TK_LT, jump, in1, in3 */</comment>
<case>case <expr><name>OP_Le</name></expr>:</case>               <comment type="block">/* same as TK_LE, jump, in1, in3 */</comment>
<case>case <expr><name>OP_Gt</name></expr>:</case>               <comment type="block">/* same as TK_GT, jump, in1, in3 */</comment>
<case>case <expr><name>OP_Ge</name></expr>:</case> <block>{<block_content>             <comment type="block">/* same as TK_GE, jump, in1, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>            <comment type="block">/* Result of the comparison of pIn1 against pIn3 */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>affinity</name></decl>;</decl_stmt>      <comment type="block">/* Affinity to use for comparison */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags1</name></decl>;</decl_stmt>         <comment type="block">/* Copy of initial value of pIn1-&gt;flags */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags3</name></decl>;</decl_stmt>         <comment type="block">/* Copy of initial value of pIn3-&gt;flags */</comment>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>flags1</name> <operator>=</operator> <name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>flags3</name> <operator>=</operator> <name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>|</operator> <name>flags3</name><operator>)</operator><operator>&amp;</operator><name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* One or both operands are NULL */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_NULLEQ</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If SQLITE_NULLEQ is set (which will only happen if the operator is
      ** OP_Eq or OP_Ne) then take the jump or not depending on whether
      ** or not both operands are null.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Eq</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Ne</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>MEM_Cleared</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_JUMPIFNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name><operator>&amp;</operator><name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>flags3</name><operator>&amp;</operator><name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>flags3</name><operator>&amp;</operator><name>MEM_Cleared</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Results are equal */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Results are not equal */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* SQLITE_NULLEQ is clear and at least one operand is NULL,
      ** then the result is always NULL.
      ** The jump is taken if the SQLITE_JUMPIFNULL bit is set.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_STOREP2</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_JUMPIFNULL</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>jump_to_p2</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Neither operand is NULL.  Do a comparison. */</comment>
    <expr_stmt><expr><name>affinity</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_AFF_MASK</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>affinity</name><operator>&gt;=</operator><name>SQLITE_AFF_NUMERIC</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_Str</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags3</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_Str</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>affinity</name><operator>==</operator><name>SQLITE_AFF_TEXT</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags1</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>flags1</name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>flags1</name> <operator>=</operator> <operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>MEM_TypeMask</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>MEM_TypeMask</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags3</name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags3</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>flags3</name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Dyn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>flags3</name> <operator>=</operator> <operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>MEM_TypeMask</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>flags3</name> <operator>&amp;</operator> <name>MEM_TypeMask</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_COLLSEQ</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pColl</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>flags1</name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemExpandBlob</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags1</name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Zero</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>flags3</name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemExpandBlob</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags3</name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Zero</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pColl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <switch>switch<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>OP_Eq</name></expr>:</case>    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>OP_Ne</name></expr>:</case>    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>OP_Lt</name></expr>:</case>    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>OP_Le</name></expr>:</case>    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name><operator>&lt;=</operator><literal type="number">0</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>OP_Gt</name></expr>:</case>    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</expr_stmt>      <break>break;</break>
    <default>default:</default>       <expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</expr_stmt>     <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Undo any changes made by applyAffinity() to the input registers. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags1</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>flags3</name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags3</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_STOREP2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>SQLITE_NULLEQ</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">2</literal></expr></then><else>:<expr><literal type="number">3</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>jump_to_p2</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Permutation * * * P4 *
**
** Set the permutation used by the OP_Compare operator to be the array
** of integers in P4.
**
** The permutation is only valid until the next OP_Compare that has
** the OPFLAG_PERMUTE bit set in P5. Typically the OP_Permutation should 
** occur immediately prior to the OP_Compare.
**
** The first integer in the P4 integer array is the length of the array
** and does not become part of the permutation.
*/</comment>
<case>case <expr><name>OP_Permutation</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INTARRAY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>ai</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aPermute</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>ai</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Compare P1 P2 P3 P4 P5
** Synopsis: r[P1@P3] &lt;-&gt; r[P2@P3]
**
** Compare two vectors of registers in reg(P1)..reg(P1+P3-1) (call this
** vector "A") and in reg(P2)..reg(P2+P3-1) ("B").  Save the result of
** the comparison for use by the next OP_Jump instruct.
**
** If P5 has the OPFLAG_PERMUTE bit set, then the order of comparison is
** determined by the most recent OP_Permutation operator.  If the
** OPFLAG_PERMUTE bit is clear, then register are compared in sequential
** order.
**
** P4 is a KeyInfo structure that defines collating sequences and sort
** orders for the comparison.  The permutation applies to registers
** only.  The KeyInfo elements are used sequentially.
**
** The comparison is a sort comparison, so NULLs compare equal,
** NULLs are less than numbers, numbers are less than strings,
** and strings are less than blobs.
*/</comment>
<case>case <expr><name>OP_Compare</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>p2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>    <comment type="block">/* Collating sequence to use on this term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRev</name></decl>;</decl_stmt>          <comment type="block">/* True for DESCENDING sort order */</comment>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_PERMUTE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>aPermute</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pKeyInfo</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p1</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p2</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEBUG</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>aPermute</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>mx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><name><name>aPermute</name><index>[<expr><name>k</name></expr>]</index></name><operator>&gt;</operator><name>mx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mx</name> <operator>=</operator> <name><name>aPermute</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>+</operator><name>mx</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p2</name><operator>+</operator><name>mx</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>+</operator><name>n</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p2</name><operator>+</operator><name>n</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <ternary><condition><expr><name>aPermute</name></expr> ?</condition><then> <expr><name><name>aPermute</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p1</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p2</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>p1</name><operator>+</operator><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p1</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>p2</name><operator>+</operator><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p2</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bRev</name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCompare</name> <operator>=</operator> <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p1</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p2</name><operator>+</operator><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCompare</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>bRev</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iCompare</name> <operator>=</operator> <operator>-</operator><name>iCompare</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>aPermute</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Jump P1 P2 P3 * *
**
** Jump to the instruction at address P1, P2, or P3 depending on whether
** in the most recent OP_Compare instruction the P1 vector was less than
** equal to, or greater than the P2 vector, respectively.
*/</comment>
<case>case <expr><name>OP_Jump</name></expr>:</case> <block>{<block_content>             <comment type="block">/* jump */</comment>
  <if_stmt><if>if<condition>( <expr><name>iCompare</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iCompare</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: And P1 P2 P3 * *
** Synopsis: r[P3]=(r[P1] &amp;&amp; r[P2])
**
** Take the logical AND of the values in registers P1 and P2 and
** write the result into register P3.
**
** If either P1 or P2 is 0 (false) then the result is 0 even if
** the other input is NULL.  A NULL and true or two NULLs give
** a NULL output.
*/</comment>
<comment type="block">/* Opcode: Or P1 P2 P3 * *
** Synopsis: r[P3]=(r[P1] || r[P2])
**
** Take the logical OR of the values in register P1 and P2 and
** store the answer in register P3.
**
** If either P1 or P2 is nonzero (true) then the result is 1 (true)
** even if the other input is NULL.  A NULL and false or two NULLs
** give a NULL output.
*/</comment>
<case>case <expr><name>OP_And</name></expr>:</case>              <comment type="block">/* same as TK_AND, in1, in2, out3 */</comment>
<case>case <expr><name>OP_Or</name></expr>:</case> <block>{<block_content>             <comment type="block">/* same as TK_OR, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>v1</name></decl>;</decl_stmt>    <comment type="block">/* Left operand:  0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>v2</name></decl>;</decl_stmt>    <comment type="block">/* Right operand: 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */</comment>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>v1</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>v2</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_And</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>and_logic</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>v1</name> <operator>=</operator> <name><name>and_logic</name><index>[<expr><name>v1</name><operator>*</operator><literal type="number">3</literal><operator>+</operator><name>v2</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>or_logic</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>v1</name> <operator>=</operator> <name><name>or_logic</name><index>[<expr><name>v1</name><operator>*</operator><literal type="number">3</literal><operator>+</operator><name>v2</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v1</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>v1</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Not P1 P2 * * *
** Synopsis: r[P2]= !r[P1]
**
** Interpret the value in register P1 as a boolean value.  Store the
** boolean complement in register P2.  If the value in register P1 is 
** NULL, then a NULL is stored in P2.
*/</comment>
<case>case <expr><name>OP_Not</name></expr>:</case> <block>{<block_content>                <comment type="block">/* same as TK_NOT, in1, out2 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>!</operator><call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: BitNot P1 P2 * * *
** Synopsis: r[P1]= ~r[P1]
**
** Interpret the content of register P1 as an integer.  Store the
** ones-complement of the P1 value into register P2.  If P1 holds
** a NULL then store a NULL in P2.
*/</comment>
<case>case <expr><name>OP_BitNot</name></expr>:</case> <block>{<block_content>             <comment type="block">/* same as TK_BITNOT, in1, out2 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>~</operator><call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Once P1 P2 * * *
**
** Check the "once" flag number P1. If it is set, jump to instruction P2. 
** Otherwise, set the flag and fall through to the next instruction.
** In other words, this opcode causes all following opcodes up through P2
** (but not including P2) to run just once and to be skipped on subsequent
** times through the loop.
**
** All "once" flags are initially cleared whenever a prepared statement
** first begins to run.
*/</comment>
<case>case <expr><name>OP_Once</name></expr>:</case> <block>{<block_content>             <comment type="block">/* jump */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOnceFlag</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOnceFlag</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aOnceFlag</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOnceFlag</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: If P1 P2 P3 * *
**
** Jump to P2 if the value in register P1 is true.  The value
** is considered true if it is numeric and non-zero.  If the value
** in P1 is NULL then take the jump if and only if P3 is non-zero.
*/</comment>
<comment type="block">/* Opcode: IfNot P1 P2 P3 * *
**
** Jump to P2 if the value in register P1 is False.  The value
** is considered false if it has a numeric value of zero.  If the value
** in P1 is NULL then take the jump if and only if P3 is non-zero.
*/</comment>
<case>case <expr><name>OP_If</name></expr>:</case>                 <comment type="block">/* jump, in1 */</comment>
<case>case <expr><name>OP_IfNot</name></expr>:</case> <block>{<block_content>            <comment type="block">/* jump, in1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifdef>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0.0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IfNot</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>!</operator><name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>c</name><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IsNull P1 P2 * * *
** Synopsis:  if r[P1]==NULL goto P2
**
** Jump to P2 if the value in register P1 is NULL.
*/</comment>
<case>case <expr><name>OP_IsNull</name></expr>:</case> <block>{<block_content>            <comment type="block">/* same as TK_ISNULL, jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: NotNull P1 P2 * * *
** Synopsis: if r[P1]!=NULL goto P2
**
** Jump to P2 if the value in register P1 is not NULL.  
*/</comment>
<case>case <expr><name>OP_NotNull</name></expr>:</case> <block>{<block_content>            <comment type="block">/* same as TK_NOTNULL, jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Column P1 P2 P3 P4 P5
** Synopsis:  r[P3]=PX
**
** Interpret the data that cursor P1 points to as a structure built using
** the MakeRecord instruction.  (See the MakeRecord opcode for additional
** information about the format of the data.)  Extract the P2-th column
** from this record.  If there are less that (P2+1) 
** values in the record, extract a NULL.
**
** The value extracted is stored in register P3.
**
** If the column contains fewer than P2 fields, then extract a NULL.  Or,
** if the P4 argument is a P4_MEM use the value of the P4 argument as
** the result.
**
** If the OPFLAG_CLEARCACHE bit is set on P5 and P1 is a pseudo-table cursor,
** then the cache of the cursor is reset prior to extracting the column.
** The first OP_Column against a pseudo-table after the value of the content
** register has changed should have this bit set.
**
** If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 when
** the result is guaranteed to only be used as the argument of a length()
** or typeof() function, respectively.  The loading of large blobs can be
** skipped for length() and all content loading can be skipped for typeof().
*/</comment>
<case>case <expr><name>OP_Column</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>payloadSize64</name></decl>;</decl_stmt> <comment type="block">/* Number of bytes in the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>p2</name></decl>;</decl_stmt>            <comment type="block">/* column number to retrieve */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>    <comment type="block">/* The VDBE cursor */</comment>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>   <comment type="block">/* The BTree cursor */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aOffset</name></decl>;</decl_stmt>      <comment type="block">/* aOffset[i] is offset to start of data for i-th column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>           <comment type="block">/* The length of the serialized data for the column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pDest</name></decl>;</decl_stmt>        <comment type="block">/* Where to write the extracted value */</comment>
  <decl_stmt><decl><type><name>Mem</name></type> <name>sMem</name></decl>;</decl_stmt>          <comment type="block">/* For storing the record being decoded */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zData</name></decl>;</decl_stmt>   <comment type="block">/* Part of the record being decoded */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zHdr</name></decl>;</decl_stmt>    <comment type="block">/* Next unparsed byte of the header */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zEndHdr</name></decl>;</decl_stmt> <comment type="block">/* Pointer to first byte after the header */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>offset</name></decl>;</decl_stmt>        <comment type="block">/* Offset into the data */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>offset64</name></decl>;</decl_stmt>      <comment type="block">/* 64-bit offset */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>avail</name></decl>;</decl_stmt>         <comment type="block">/* Number of bytes of available data */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>t</name></decl>;</decl_stmt>             <comment type="block">/* A type code from the record header */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pReg</name></decl>;</decl_stmt>         <comment type="block">/* PseudoTable input register */</comment>

  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p2</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>

  <comment type="block">/* If the cursor cache is stale, bring it up-to-date */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCursorMoveto</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&lt;</operator><name><name>pC</name><operator>-&gt;</operator><name>nField</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aOffset</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aOffset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_PSEUDO</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_SORTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>cacheCtr</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_PSEUDO</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pseudoTableReg</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pReg</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pseudoTableReg</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pReg</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name> <operator>=</operator> <name>avail</name> <operator>=</operator> <name><name>pReg</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pReg</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>op_column_out</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <macro><name>VVA_ONLY</name><argument_list>(<argument>rc =</argument>)</argument_list></macro> <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>payloadSize64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* True because of CursorMoveto() call above */</comment>
        <comment type="block">/* sqlite3BtreeParseCellPtr() uses getVarint32() to extract the
        ** payload size, so it is impossible for payloadSize64 to be
        ** larger than 32 bits. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>payloadSize64</name> <operator>&amp;</operator> <name>SQLITE_MAX_U32</name><operator>)</operator><operator>==</operator><operator>(</operator><name>u64</name><operator>)</operator><name>payloadSize64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name> <operator>=</operator> <call><name>sqlite3BtreeKeyFetch</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>payloadSize64</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <macro><name>VVA_ONLY</name><argument_list>(<argument>rc =</argument>)</argument_list></macro> <expr_stmt><expr><call><name>sqlite3BtreeDataSize</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* DataSize() cannot fail */</comment>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name> <operator>=</operator> <call><name>sqlite3BtreeDataFetch</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>avail</name><operator>&lt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Maximum page size is 64KiB */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name> <operator>&lt;=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>avail</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name> <operator>&gt;</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <goto>goto <name>too_big</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name> <operator>=</operator> <name>avail</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>cacheCtr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>iHdrOffset</name></name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>


    <if_stmt><if>if<condition>( <expr><name>avail</name><operator>&lt;</operator><name>offset</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* pC-&gt;aRow does not have to hold the entire row, but it does at least
      ** need to cover the header of the record.  If pC-&gt;aRow does not contain
      ** the complete header, then set it to zero, forcing the header to be
      ** dynamically allocated. */</comment>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <comment type="block">/* Make sure a corrupt database has not given us an oversize header.
      ** Do this now to avoid an oversize memory allocation.
      **
      ** Type entries can be between 1 and 5 bytes each.  But 4 and 5 byte
      ** types use so much data space that there can only be 4096 and 32 of
      ** them, respectively.  So the maximum header length results from a
      ** 3-byte type for each of the maximum of 32768 columns plus three
      ** extra bytes for the header length itself.  32768*3 + 3 = 98307.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>offset</name> <operator>&gt;</operator> <literal type="number">98307</literal> <operator>||</operator> <name>offset</name> <operator>&gt;</operator> <name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
        <goto>goto <name>op_column_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* The following goto is an optimization.  It can be omitted and
    ** everything will still work.  But OP_Column is measurably faster
    ** by skipping the subsequent conditional, which is always true.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name><operator>&lt;=</operator><name>p2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* Conditional skipped */</comment>
    <goto>goto <name>op_column_read_header</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure at least the first p2+1 entries of the header have been
  ** parsed and valid information is in aOffset[] and pC-&gt;aType[].
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name><operator>&lt;=</operator><name>p2</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there is more header available for parsing in the record, try
    ** to extract additional fields up through the p2+1-th field 
    */</comment>
    <label><name>op_column_read_header</name>:</label>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>iHdrOffset</name></name><operator>&lt;</operator><name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Make sure zData points to enough of the record to cover the header. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sMem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtree</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>op_column_error</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>zData</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>sMem</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zData</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
  
      <comment type="block">/* Fill in pC-&gt;aType[i] and aOffset[i] values through the p2-th field. */</comment>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset64</name> <operator>=</operator> <name><name>aOffset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zHdr</name> <operator>=</operator> <name>zData</name> <operator>+</operator> <name><name>pC</name><operator>-&gt;</operator><name>iHdrOffset</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zEndHdr</name> <operator>=</operator> <name>zData</name> <operator>+</operator> <name><name>aOffset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;=</operator><name>p2</name> <operator>&amp;&amp;</operator> <name>zHdr</name><operator>&lt;</operator><name>zEndHdr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <do>do<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>t</name> <operator>=</operator> <name><name>zHdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>&lt;</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zHdr</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>offset64</name> <operator>+=</operator> <call><name>sqlite3VdbeOneByteSerialTypeLen</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>zHdr</name> <operator>+=</operator> <call><name>sqlite3GetVarint32</name><argument_list>(<argument><expr><name>zHdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>offset64</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>aType</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aOffset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>offset64</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><name>i</name><operator>&lt;=</operator><name>p2</name> <operator>&amp;&amp;</operator> <name>zHdr</name><operator>&lt;</operator><name>zEndHdr</name></expr> )</condition>;</do>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>iHdrOffset</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>zHdr</name> <operator>-</operator> <name>zData</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
      <comment type="block">/* The record is corrupt if any of the following are true:
      ** (1) the bytes of the header extend past the declared header size
      ** (2) the entire header was used but not all data was used
      ** (3) the end of the data extends beyond the end of the record.
      */</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>zHdr</name><operator>&gt;=</operator><name>zEndHdr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>zHdr</name><operator>&gt;</operator><name>zEndHdr</name> <operator>||</operator> <name>offset64</name><operator>!=</operator><name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name><operator>)</operator><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>offset64</name> <operator>&gt;</operator> <name><name>pC</name><operator>-&gt;</operator><name>payloadSize</name></name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
        <goto>goto <name>op_column_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If after trying to extract new entries from the header, nHdrParsed is
    ** still not up to p2, that means that the record has fewer than p2
    ** columns.  So the result will be either the default value or a NULL.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name><operator>&lt;=</operator><name>p2</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_MEM</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pMem</name></name></expr></argument>, <argument><expr><name>MEM_Static</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <goto>goto <name>op_column_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aType</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Extract the content for the p2+1-th column.  Control can only
  ** reach this point if aOffset[p2], aOffset[p2+1], and pC-&gt;aType[p2] are
  ** all valid.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&lt;</operator><name><name>pC</name><operator>-&gt;</operator><name>nHdrParsed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>VdbeMemDynamic</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>t</name><operator>==</operator><name><name>pC</name><operator>-&gt;</operator><name>aType</name><index>[<expr><name>p2</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>szRow</name></name><operator>&gt;=</operator><name><name>aOffset</name><index>[<expr><name>p2</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This is the common case where the desired content fits on the original
    ** page - where the content is not on an overflow page */</comment>
    <expr_stmt><expr><name>zData</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>aRow</name></name> <operator>+</operator> <name><name>aOffset</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>t</name><operator>&lt;</operator><literal type="number">12</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><name>zData</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* If the column value is a string, we need a persistent value, not
      ** a MEM_Ephem value.  This branch is a fast short-cut that is equivalent
      ** to calling sqlite3VdbeSerialGet() and sqlite3VdbeDeephemeralize().
      */</comment>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u16</name></type> <name><name>aFlag</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>MEM_Blob</name></expr>, <expr><name>MEM_Str</name><operator>|</operator><name>MEM_Term</name></expr> }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>len</name> <operator>=</operator> <operator>(</operator><name>t</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>&lt;</operator> <name>len</name><operator>+</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>pDest</name><operator>-&gt;</operator><name>zMalloc</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>zData</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>aFlag</name><index>[<expr><name>t</name><operator>&amp;</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* This branch happens only when content is on overflow pages */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <operator>(</operator><name>OPFLAG_LENGTHARG</name><operator>|</operator><name>OPFLAG_TYPEOFARG</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
          <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>t</name><operator>&gt;=</operator><literal type="number">12</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>t</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_TYPEOFARG</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name>len</name> <operator>=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* Content is irrelevant for
      **    1. the typeof() function,
      **    2. the length(X) function if X is a blob, and
      **    3. if the content length is zero.
      ** So we might as well use bogus content rather than reading
      ** content from disk. */</comment>
      <decl_stmt><decl><type><specifier>static</specifier> <name>u8</name></type> <name><name>aZero</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* This is the bogus content */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><name>aZero</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtree</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><name><name>aOffset</name><index>[<expr><name>p2</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument>,
                                   <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name><name>pDest</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Ephem</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>op_column_out</name>:</label>
<label><name>op_column_error</name>:</label>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Affinity P1 P2 * P4 *
** Synopsis: affinity(r[P1@P2])
**
** Apply affinities to a range of P2 registers starting with P1.
**
** P4 is a string that is P2 characters long. The nth character of the
** string indicates the column affinity that should be used for the nth
** memory cell in the range.
*/</comment>
<case>case <expr><name>OP_Affinity</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAffinity</name></decl>;</decl_stmt>   <comment type="block">/* The affinity to be applied */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>cAff</name></decl>;</decl_stmt>               <comment type="block">/* A single character of affinity */</comment>

  <expr_stmt><expr><name>zAffinity</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zAffinity</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zAffinity</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>cAff</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zAffinity</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name> <operator>&lt;=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>cAff</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn1</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: MakeRecord P1 P2 P3 P4 *
** Synopsis: r[P3]=mkrec(r[P1@P2])
**
** Convert P2 registers beginning with P1 into the [record format]
** use as a data record in a database table or as a key
** in an index.  The OP_Column opcode can decode the record later.
**
** P4 may be a string that is P2 characters long.  The nth character of the
** string indicates the column affinity that should be used for the nth
** field of the index key.
**
** The mapping from character to affinity is given by the SQLITE_AFF_
** macros defined in sqliteInt.h.
**
** If P4 is NULL then all index fields have the affinity BLOB.
*/</comment>
<case>case <expr><name>OP_MakeRecord</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zNewRecord</name></decl>;</decl_stmt>        <comment type="block">/* A buffer to hold the data for the new record */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>             <comment type="block">/* The new record */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nData</name></decl>;</decl_stmt>             <comment type="block">/* Number of bytes of data space */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nHdr</name></decl>;</decl_stmt>              <comment type="block">/* Number of bytes of header space */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nByte</name></decl>;</decl_stmt>             <comment type="block">/* Data space required for this record */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nZero</name></decl>;</decl_stmt>             <comment type="block">/* Number of zero bytes at the end of the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVarint</name></decl>;</decl_stmt>           <comment type="block">/* Number of bytes in a varint */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>serial_type</name></decl>;</decl_stmt>       <comment type="block">/* Type field */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pData0</name></decl>;</decl_stmt>           <comment type="block">/* First field to be combined into the record */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>            <comment type="block">/* Last field of the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>            <comment type="block">/* Number of fields in the record */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAffinity</name></decl>;</decl_stmt>       <comment type="block">/* The affinity string for the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>file_format</name></decl>;</decl_stmt>       <comment type="block">/* File format to use for encoding */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Space used in zNewRecord[] header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>                 <comment type="block">/* Space used in zNewRecord[] content */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>len</name></decl>;</decl_stmt>               <comment type="block">/* Length of a field */</comment>

  <comment type="block">/* Assuming the record contains N fields, the record format looks
  ** like this:
  **
  ** ------------------------------------------------------------------------
  ** | hdr-size | type 0 | type 1 | ... | type N-1 | data0 | ... | data N-1 | 
  ** ------------------------------------------------------------------------
  **
  ** Data(0) is taken from register P1.  Data(1) comes from register P1+1
  ** and so forth.
  **
  ** Each type field is a varint representing the serial type of the 
  ** corresponding data element (see sqlite3VdbeSerialType()). The
  ** hdr-size field is also a varint which is the offset from the beginning
  ** of the record to data0.
  */</comment>
  <expr_stmt><expr><name>nData</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>         <comment type="block">/* Number of bytes of data space */</comment>
  <expr_stmt><expr><name>nHdr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>          <comment type="block">/* Number of bytes of header space */</comment>
  <expr_stmt><expr><name>nZero</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>         <comment type="block">/* Number of zero bytes at the end of the record */</comment>
  <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zAffinity</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>nField</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData0</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>nField</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLast</name> <operator>=</operator> <operator>&amp;</operator><name><name>pData0</name><index>[<expr><name>nField</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>file_format</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>minWriteFileFormat</name></name></expr>;</expr_stmt>

  <comment type="block">/* Identify the output register */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Apply the requested affinity to all inputs
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData0</name><operator>&lt;=</operator><name>pLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zAffinity</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRec</name> <operator>=</operator> <name>pData0</name></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pRec</name><operator>++</operator></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>zAffinity</name><operator>++</operator><operator>)</operator></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zAffinity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pRec</name><operator>&lt;=</operator><name>pLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name><name>zAffinity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Loop through the elements that will make up the record to figure
  ** out how much space is required for the new record.
  */</comment>
  <expr_stmt><expr><name>pRec</name> <operator>=</operator> <name>pLast</name></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name> <operator>=</operator> <name>serial_type</name> <operator>=</operator> <call><name>sqlite3VdbeSerialType</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>file_format</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pRec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nData</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemExpandBlob</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nZero</name> <operator>+=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>-=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nData</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serial_type</name><operator>==</operator><literal type="number">127</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serial_type</name><operator>==</operator><literal type="number">128</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nHdr</name> <operator>+=</operator> <ternary><condition><expr><name>serial_type</name><operator>&lt;=</operator><literal type="number">127</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>--</operator><name>pRec</name><operator>)</operator><operator>&gt;=</operator><name>pData0</name></expr> )</condition>;</do>

  <comment type="block">/* EVIDENCE-OF: R-22564-11647 The header begins with a single varint
  ** which determines the total number of bytes in the header. The varint
  ** value is the size of the header in bytes including the size varint
  ** itself. */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nHdr</name><operator>==</operator><literal type="number">126</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nHdr</name><operator>==</operator><literal type="number">127</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nHdr</name><operator>&lt;=</operator><literal type="number">126</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The common case */</comment>
    <expr_stmt><expr><name>nHdr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Rare case of a really large header */</comment>
    <expr_stmt><expr><name>nVarint</name> <operator>=</operator> <call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nHdr</name> <operator>+=</operator> <name>nVarint</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nVarint</name><operator>&lt;</operator><call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>nHdr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nHdr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>nHdr</name><operator>+</operator><name>nData</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>+</operator><name>nZero</name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>too_big</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure the output register has a buffer large enough to store 
  ** the new record. The output register (pOp-&gt;p3) is not allowed to
  ** be one of the input registers (because the following call to
  ** sqlite3VdbeMemClearAndResize() could clobber the value before it is used).
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>no_mem</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zNewRecord</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>

  <comment type="block">/* Write the record */</comment>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>putVarint32</name><argument_list>(<argument><expr><name>zNewRecord</name></expr></argument>, <argument><expr><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>j</name> <operator>=</operator> <name>nHdr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData0</name><operator>&lt;=</operator><name>pLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRec</name> <operator>=</operator> <name>pData0</name></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>serial_type</name> <operator>=</operator> <name><name>pRec</name><operator>-&gt;</operator><name>uTemp</name></name></expr>;</expr_stmt>
    <comment type="block">/* EVIDENCE-OF: R-06529-47362 Following the size varint are one or more
    ** additional varints, one per column. */</comment>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>putVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zNewRecord</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* serial type */</comment>
    <comment type="block">/* EVIDENCE-OF: R-64536-51728 The values for each column in the record
    ** immediately follow the header. */</comment>
    <expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialPut</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zNewRecord</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* content */</comment>
  </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>++</operator><name>pRec</name><operator>)</operator><operator>&lt;=</operator><name>pLast</name></expr> )</condition>;</do>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name>nHdr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Blob</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nZero</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name> <operator>=</operator> <name>nZero</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Zero</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>  <comment type="block">/* In case the blob is ever converted to text */</comment>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Count P1 P2 * * *
** Synopsis: r[P2]=count()
**
** Store the number of entries (an integer value) in the table or index 
** opened by cursor P1 in register P2
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BTREECOUNT</name></cpp:ifndef>
<case>case <expr><name>OP_Count</name></expr>:</case> <block>{<block_content>         <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>-&gt;</operator><name>eCurType</name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>-&gt;</operator><name><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nEntry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Not needed.  Only used to silence a warning. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCount</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>nEntry</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: Savepoint P1 * * P4 *
**
** Open, release or rollback the savepoint named by parameter P4, depending
** on the value of P1. To open a new savepoint, P1==0. To release (commit) an
** existing savepoint, P1==1, or to rollback an existing savepoint P1==2.
*/</comment>
<case>case <expr><name>OP_Savepoint</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name></decl>;</decl_stmt>                         <comment type="block">/* Value of P1 operand */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                    <comment type="block">/* Name of savepoint */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Savepoint</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Savepoint</name> <modifier>*</modifier></type><name>pSavepoint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Savepoint</name> <modifier>*</modifier></type><name>pTmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSavepoint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p1</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>

  <comment type="block">/* Assert that the p1 parameter is valid. Also that if there is no open
  ** transaction, then there cannot be any savepoints. 
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>==</operator><name>SAVEPOINT_BEGIN</name><operator>||</operator><name>p1</name><operator>==</operator><name>SAVEPOINT_RELEASE</name><operator>||</operator><name>p1</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>checkSavepointCount</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>p1</name><operator>==</operator><name>SAVEPOINT_BEGIN</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* A new savepoint cannot be created if there are active write 
      ** statements (i.e. open read/write incremental blob handles).
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot open savepoint - SQL statements in progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      <comment type="block">/* This call is Ok even if this savepoint is actually a transaction
      ** savepoint (and therefore should not prompt xSavepoint()) callbacks.
      ** If this is a transaction savepoint being opened, it is guaranteed
      ** that the db-&gt;aVTrans[] array is empty.  */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SAVEPOINT_BEGIN</name></expr></argument>,
                                <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>+</operator><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/* Create a new savepoint structure. */</comment>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Savepoint</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <comment type="block">/* If there is no open transaction, then mark this as a special
        ** "transaction savepoint". */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    
        <comment type="block">/* Link the new savepoint into the database handle's list. */</comment>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iSavepoint</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Find the named savepoint. If there is no such savepoint, then an
    ** an error is returned to the user.  */</comment>
    <for>for<control>(
      <init><expr><name>pSavepoint</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr>;</init> 
      <condition><expr><name>pSavepoint</name> <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pSavepoint</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</condition>
      <incr><expr><name>pSavepoint</name> <operator>=</operator> <name><name>pSavepoint</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>
    )</control><block>{<block_content>
      <expr_stmt><expr><name>iSavepoint</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pSavepoint</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"no such savepoint: %s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* It is not possible to release (commit) a savepoint if there are 
      ** active write statements.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot release savepoint - "</literal>
                          <literal type="string">"SQL statements in progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>

      <comment type="block">/* Determine whether or not this is a transaction savepoint. If so,
      ** and this is a RELEASE command, then the current transaction 
      ** is committed. 
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>isTransaction</name> <init>= <expr><name><name>pSavepoint</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>isTransaction</name> <operator>&amp;&amp;</operator> <name>p1</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCheckFk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>vdbe_return</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
          <goto>goto <name>vdbe_return</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>isSchemaChange</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>iSavepoint</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>-</operator> <name>iSavepoint</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>p1</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>isSchemaChange</name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_InternChanges</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeTripAllCursors</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>,
                                       <argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>,
                                       <argument><expr><name>isSchemaChange</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>isSchemaChange</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeSavepoint</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <goto>goto <name>abort_due_to_error</name>;</goto>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>isSchemaChange</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ResetAllSchemasOfConnection</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name>SQLITE_InternChanges</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
  
      <comment type="block">/* Regardless of whether this is a RELEASE or ROLLBACK, destroy all 
      ** savepoints nested inside of the savepoint being operated on. */</comment>
      <while>while<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name><operator>!=</operator><name>pSavepoint</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name> <operator>=</operator> <name><name>pTmp</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></while>

      <comment type="block">/* If it is a RELEASE, then destroy the savepoint being operated on 
      ** too. If it is a ROLLBACK TO, then set the number of deferred 
      ** constraint violations present in the database to the value stored
      ** when the savepoint was created.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>p1</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSavepoint</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name> <operator>=</operator> <name><name>pSavepoint</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isTransaction</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>=</operator> <name><name>pSavepoint</name><operator>-&gt;</operator><name>nDeferredCons</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>=</operator> <name><name>pSavepoint</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isTransaction</name> <operator>||</operator> <name>p1</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: AutoCommit P1 P2 * * *
**
** Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll
** back any currently active btree transactions. If there are any active
** VMs (apart from this one), then a ROLLBACK fails.  A COMMIT fails if
** there are active writing VMs or active VMs that use shared cache.
**
** This instruction causes the VM to halt.
*/</comment>
<case>case <expr><name>OP_AutoCommit</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>desiredAutoCommit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRollback</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>desiredAutoCommit</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iRollback</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredAutoCommit</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>desiredAutoCommit</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredAutoCommit</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>iRollback</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* At least this one VM is active */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>desiredAutoCommit</name><operator>!=</operator><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iRollback</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredAutoCommit</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>desiredAutoCommit</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* If this instruction implements a COMMIT and other VMs are writing
      ** return an error indicating that the other VMs must complete first. 
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot commit transaction - "</literal>
                          <literal type="string">"SQL statements in progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCheckFk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>vdbe_return</name>;</goto>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>desiredAutoCommit</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><literal type="number">1</literal><operator>-</operator><name>desiredAutoCommit</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
      <goto>goto <name>vdbe_return</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <goto>goto <name>vdbe_return</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name>desiredAutoCommit</name><operator>)</operator></expr>?</condition><then><expr><literal type="string">"cannot start a transaction within a transaction"</literal></expr></then><else>:<expr><operator>(</operator>
        <ternary><condition><expr><operator>(</operator><name>iRollback</name><operator>)</operator></expr>?</condition><then><expr><literal type="string">"cannot rollback - no transaction is active"</literal></expr></then><else>:
                   <expr><literal type="string">"cannot commit - no transaction is active"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Transaction P1 P2 P3 P4 P5
**
** Begin a transaction on database P1 if a transaction is not already
** active.
** If P2 is non-zero, then a write-transaction is started, or if a 
** read-transaction is already active, it is upgraded to a write-transaction.
** If P2 is zero, then a read-transaction is started.
**
** P1 is the index of the database file on which the transaction is
** started.  Index 0 is the main database file and index 1 is the
** file used for temporary tables.  Indices of 2 or more are used for
** attached databases.
**
** If a write-transaction is started and the Vdbe.usesStmtJournal flag is
** true (this flag is set if the Vdbe may modify more than one row and may
** throw an ABORT exception), a statement transaction may also be opened.
** More specifically, a statement transaction is opened iff the database
** connection is currently not in autocommit mode, or if there are other
** active statements. A statement transaction allows the changes made by this
** VDBE to be rolled back after an error without having to roll back the
** entire transaction. If no error is encountered, the statement transaction
** will automatically commit when the VDBE halts.
**
** If P5!=0 then this opcode also checks the schema cookie against P3
** and the schema generation counter against P4.
** The cookie changes its value whenever the database schema changes.
** This operation is used to detect when that the cookie has changed
** and that the current process needs to reread the schema.  If the schema
** cookie in P3 differs from the schema cookie in the database header or
** if the schema generation counter in P4 differs from the current
** generation counter, then an SQLITE_SCHEMA error is raised and execution
** halts.  The sqlite3_step() wrapper function might then reprepare the
** statement and rerun it from the beginning.
*/</comment>
<case>case <expr><name>OP_Transaction</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMeta</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iGen</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_QueryOnly</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_READONLY</name></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY_SNAPSHOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY_RECOVERY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
      <goto>goto <name>vdbe_return</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>usesStmtJournal</name></name> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator></expr> 
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>++</operator></expr>;</expr_stmt> 
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>+</operator> <name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SAVEPOINT_BEGIN</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginStmt</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Store the current value of the database handles deferred constraint
      ** counter. If the statement transaction needs to be rolled back,
      ** the value of this counter needs to be restored too.  */</comment>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nStmtDefCons</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nStmtDefImmCons</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Gather the schema version number for checking:
    ** IMPLEMENTATION-OF: R-32195-19465 The schema version is used by SQLite
    ** each time a query is executed to ensure that the internal cache of the
    ** schema used when compiling the SQL query matches the schema of the
    ** database against which the compiled query is actually executed.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3BtreeGetMeta</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>BTREE_SCHEMA_VERSION</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iGen</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>iGeneration</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iGen</name> <operator>=</operator> <name>iMeta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iMeta</name><operator>!=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>||</operator> <name>iGen</name><operator>!=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"database schema has changed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If the schema-cookie from the database file matches the cookie 
    ** stored with the in-memory representation of the schema, do
    ** not reload the schema from the database file.
    **
    ** If virtual-tables are in use, this is not just an optimization.
    ** Often, v-tables store their data in other SQLite tables, which
    ** are queried from within xNext() and other v-table methods using
    ** prepared queries. If such a query is out-of-date, we do not want to
    ** discard the database schema, as the user code implementing the
    ** v-table would have to be ready for the sqlite3_vtab structure itself
    ** to be invalidated whenever sqlite3_step() is called from within 
    ** a v-table method.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>schema_cookie</name></name><operator>!=</operator><name>iMeta</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ResetOneSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_SCHEMA</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ReadCookie P1 P2 P3 * *
**
** Read cookie number P3 from database P1 and write it into register P2.
** P3==1 is the schema version.  P3==2 is the database format.
** P3==3 is the recommended pager cache size, and so forth.  P1==0 is
** the main database file and P1==1 is the database file used to store
** temporary tables.
**
** There must be a read-lock on the database (either a transaction
** must be started or there must be an open cursor) before
** executing this instruction.
*/</comment>
<case>case <expr><name>OP_ReadCookie</name></expr>:</case> <block>{<block_content>               <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMeta</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCookie</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCookie</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name>SQLITE_N_BTREE_META</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeGetMeta</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name>iCookie</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>iMeta</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SetCookie P1 P2 P3 * *
**
** Write the integer value P3 into cookie number P2 of database P1.
** P2==1 is the schema version.  P2==2 is the database format.
** P2==3 is the recommended pager cache 
** size, and so forth.  P1==0 is the main database file and P1==1 is the 
** database file used to store temporary tables.
**
** A transaction must be started before executing this opcode.
*/</comment>
<case>case <expr><name>OP_SetCookie</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><name>SQLITE_N_BTREE_META</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* See note about index shifting on OP_ReadCookie */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeUpdateMeta</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>BTREE_SCHEMA_VERSION</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* When the schema cookie changes, record the new cookie internally */</comment>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>schema_cookie</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SQLITE_InternChanges</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>BTREE_FILE_FORMAT</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Record changes in the file format */</comment>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>file_format</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Invalidate all prepared statements whenever the TEMP database
    ** schema is changed.  Ticket #1644 */</comment>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: OpenRead P1 P2 P3 P4 P5
** Synopsis: root=P2 iDb=P3
**
** Open a read-only cursor for the database table whose root page is
** P2 in a database file.  The database file is determined by P3. 
** P3==0 means the main database, P3==1 means the database used for 
** temporary tables, and P3&gt;1 means used the corresponding attached
** database.  Give the new cursor an identifier of P1.  The P1
** values need not be contiguous but all P1 values should be small integers.
** It is an error for P1 to be negative.
**
** If P5!=0 then use the content of register P2 as the root page, not
** the value of P2 itself.
**
** There will be a read lock on the database whenever there is an
** open cursor.  If the database was unlocked prior to this instruction
** then a read lock is acquired as part of this instruction.  A read
** lock allows other processes to read the database but prohibits
** any other process from modifying the database.  The read lock is
** released when all cursors are closed.  If this instruction attempts
** to get a read lock but fails, the script terminates with an
** SQLITE_BUSY error code.
**
** The P4 value may be either an integer (P4_INT32) or a pointer to
** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo 
** structure, then said structure defines the content and collating 
** sequence of the index being opened. Otherwise, if P4 is an integer 
** value, it is set to the number of columns in the table.
**
** See also: OpenWrite, ReopenIdx
*/</comment>
<comment type="block">/* Opcode: ReopenIdx P1 P2 P3 P4 P5
** Synopsis: root=P2 iDb=P3
**
** The ReopenIdx opcode works exactly like ReadOpen except that it first
** checks to see if the cursor on P1 is already open with a root page
** number of P2 and if it is this opcode becomes a no-op.  In other words,
** if the cursor is already open, do not reopen it.
**
** The ReopenIdx opcode may only be used with P5==0 and with P4 being
** a P4_KEYINFO object.  Furthermore, the P3 value must be the same as
** every other ReopenIdx or OpenRead for the same cursor number.
**
** See the OpenRead opcode documentation for additional information.
*/</comment>
<comment type="block">/* Opcode: OpenWrite P1 P2 P3 P4 P5
** Synopsis: root=P2 iDb=P3
**
** Open a read/write cursor named P1 on the table or index whose root
** page is P2.  Or if P5!=0 use the content of register P2 to find the
** root page.
**
** The P4 value may be either an integer (P4_INT32) or a pointer to
** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo 
** structure, then said structure defines the content and collating 
** sequence of the index being opened. Otherwise, if P4 is an integer 
** value, it is set to the number of columns in the table, or to the
** largest index of any column of the table that is actually used.
**
** This instruction works just like OpenRead except that it opens the cursor
** in read/write mode.  For a given table, there can be one or more read-only
** cursors or a single read/write cursor but not both.
**
** See also OpenRead.
*/</comment>
<case>case <expr><name>OP_ReopenIdx</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>p2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wrFlag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OPFLAG_SEEKEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_KEYINFO</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iDb</name></name><operator>==</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Guaranteed by the code generator */</comment>
    <goto>goto <name>open_cursor_set_hints</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* If the cursor is not currently open or is open on a different
  ** index, then fall through into OP_OpenRead to force a reopen */</comment>
<case>case <expr><name>OP_OpenRead</name></expr>:</case>
<case>case <expr><name>OP_OpenWrite</name></expr>:</case>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenWrite</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OPFLAG_SEEKEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenRead</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_ReopenIdx</name>
          <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ABORT_ROLLBACK</name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nField</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>p2</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pX</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenWrite</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OPFLAG_FORDELETE</name><operator>==</operator><name>BTREE_FORDELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wrFlag</name> <operator>=</operator> <name>BTREE_WRCSR</name> <operator>|</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_FORDELETE</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>file_format</name></name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>minWriteFileFormat</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>minWriteFileFormat</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>file_format</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>wrFlag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_P2ISREG</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p2</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pIn2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    <comment type="block">/* The p2 value always comes from a prior OP_CreateTable opcode and
    ** that opcode will always set the p2 value to 2 or more or else fail.
    ** If there were a failure, the prepared statement would have halted
    ** before reaching this instruction. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>p2</name><operator>&lt;</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> )</condition> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_KEYINFO</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>nField</name></name><operator>+</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nXField</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nField</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Table with INTEGER PRIMARY KEY and nothing else */</comment>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>nField</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>CURTYPE_BTREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isOrdered</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pgnoRoot</name></name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>wrFlag</name></name> <operator>=</operator> <name>wrFlag</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCursor</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>wrFlag</name></expr></argument>, <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name>pKeyInfo</name></expr>;</expr_stmt>
  <comment type="block">/* Set the VdbeCursor.isTable variable. Previous versions of
  ** SQLite used to check if the root-page flags were sane at this point
  ** and report database corruption if they were not, but this check has
  ** since moved into the btree layer.  */</comment>  
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isTable</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>!=</operator><name>P4_KEYINFO</name></expr>;</expr_stmt>

<label><name>open_cursor_set_hints</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OPFLAG_BULKCSR</name><operator>==</operator><name>BTREE_BULKLOAD</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OPFLAG_SEEKEQ</name><operator>==</operator><name>BTREE_SEEK_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_BULKCSR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>&amp;</operator> <name>OPFLAG_SEEKEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3BtreeCursorHintFlags</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>,
                               <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <operator>(</operator><name>OPFLAG_BULKCSR</name><operator>|</operator><name>OPFLAG_SEEKEQ</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: OpenEphemeral P1 P2 * P4 P5
** Synopsis: nColumn=P2
**
** Open a new cursor P1 to a transient table.
** The cursor is always opened read/write even if 
** the main database is read-only.  The ephemeral
** table is deleted automatically when the cursor is closed.
**
** P2 is the number of columns in the ephemeral table.
** The cursor points to a BTree table if P4==0 and to a BTree index
** if P4 is not 0.  If P4 is not NULL, it points to a KeyInfo structure
** that defines the format of keys in the index.
**
** The P5 parameter can be a mask of the BTREE_* flags defined
** in btree.h.  These flags control aspects of the operation of
** the btree.  The BTREE_OMIT_JOURNAL and BTREE_SINGLE flags are
** added automatically.
*/</comment>
<comment type="block">/* Opcode: OpenAutoindex P1 P2 * P4 *
** Synopsis: nColumn=P2
**
** This opcode works the same as OP_OpenEphemeral.  It has a
** different name to distinguish its use.  Tables created using
** by this opcode will be used for automatically created transient
** indices in joins.
*/</comment>
<case>case <expr><name>OP_OpenAutoindex</name></expr>:</case> 
<case>case <expr><name>OP_OpenEphemeral</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>vfsFlags</name> <init>= 
      <expr><name>SQLITE_OPEN_READWRITE</name> <operator>|</operator>
      <name>SQLITE_OPEN_CREATE</name> <operator>|</operator>
      <name>SQLITE_OPEN_EXCLUSIVE</name> <operator>|</operator>
      <name>SQLITE_OPEN_DELETEONCLOSE</name> <operator>|</operator>
      <name>SQLITE_OPEN_TRANSIENT_DB</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>CURTYPE_BTREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isEphemeral</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeOpen</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCx</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, 
                        <argument><expr><name>BTREE_OMIT_JOURNAL</name> <operator>|</operator> <name>BTREE_SINGLE</name> <operator>|</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>, <argument><expr><name>vfsFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If a transient index is required, create it by calling
    ** sqlite3BtreeCreateTable() with the BTREE_BLOBKEY flag before
    ** opening it. If a transient table is required, just use the
    ** automatically created table with root-page 1 (an BLOB_INTKEY table).
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pKeyInfo</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>pgno</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_KEYINFO</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCreateTable</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgno</name></expr></argument>, <argument><expr><name>BTREE_BLOBKEY</name> <operator>|</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgno</name><operator>==</operator><name>MASTER_ROOT</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name>pKeyInfo</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCursor</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>BTREE_WRCSR</name></expr></argument>,
                                <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isTable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCursor</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><name>MASTER_ROOT</name></expr></argument>, <argument><expr><name>BTREE_WRCSR</name></expr></argument>,
                              <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isTable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isOrdered</name></name> <operator>=</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>!=</operator><name>BTREE_UNORDERED</name><operator>)</operator></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SorterOpen P1 P2 P3 P4 *
**
** This opcode works like OP_OpenEphemeral except that it opens
** a transient index that is specifically designed to sort large
** tables using an external merge-sort algorithm.
**
** If argument P3 is non-zero, then it indicates that the sorter may
** assume that a stable sort considering the first P3 fields of each
** key is sufficient to produce the required results.
*/</comment>
<case>case <expr><name>OP_SorterOpen</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>CURTYPE_SORTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pCx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SequenceTest P1 P2 * * *
** Synopsis: if( cursor[P1].ctr++ ) pc = P2
**
** P1 is a sorter cursor. If the sequence counter is currently zero, jump
** to P2. Regardless of whether or not the jump is taken, increment the
** the sequence value.
*/</comment>
<case>case <expr><name>OP_SequenceTest</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pC</name><operator>-&gt;</operator><name>seqCount</name></name><operator>++</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: OpenPseudo P1 P2 P3 * *
** Synopsis: P3 columns in r[P2]
**
** Open a new cursor that points to a fake table that contains a single
** row of data.  The content of that one row is the content of memory
** register P2.  In other words, cursor P1 becomes an alias for the 
** MEM_Blob content contained in register P2.
**
** A pseudo-table created by this opcode is used to hold a single
** row output from the sorter so that the row can be decomposed into
** individual columns using the OP_Column opcode.  The OP_Column opcode
** is the only cursor opcode that works with a pseudo-table.
**
** P3 is the number of fields in the records that will be stored by
** the pseudo-table.
*/</comment>
<case>case <expr><name>OP_OpenPseudo</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>CURTYPE_PSEUDO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pseudoTableReg</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCx</name><operator>-&gt;</operator><name>isTable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Close P1 * * * *
**
** Close a cursor previously opened as P1.  If P1 is not
** currently open, this instruction is a no-op.
*/</comment>
<case>case <expr><name>OP_Close</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeFreeCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_USED_MASK</name></cpp:ifdef>
<comment type="block">/* Opcode: ColumnsUsed P1 * * P4 *
**
** This opcode (which only exists if SQLite was compiled with
** SQLITE_ENABLE_COLUMN_USED_MASK) identifies which columns of the
** table or index for cursor P1 are used.  P4 is a 64-bit integer
** (P4_INT64) in which the first 63 bits are one for each of the
** first 63 columns of the table or index that are actually used
** by the cursor.  The high-order bit is set if any column after
** the 64th is used.
*/</comment>
<case>case <expr><name>OP_ColumnsUsed</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>maskUsed</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>u64</name><operator>*</operator><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pI64</name></name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: SeekGE P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as the key.  If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that  it points to the smallest entry that 
** is greater than or equal to the key value. If there are no records 
** greater than or equal to the key and P2 is not zero, then jump to P2.
**
** If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this
** opcode will always land on a record that equally equals the key, or
** else jump immediately to P2.  When the cursor is OPFLAG_SEEKEQ, this
** opcode must be followed by an IdxLE opcode with the same arguments.
** The IdxLE opcode will be skipped if this opcode succeeds, but the
** IdxLE opcode will be used on subsequent loop iterations.
**
** This opcode leaves the cursor configured to move in forward order,
** from the beginning toward the end.  In other words, the cursor is
** configured to use Next, not Prev.
**
** See also: Found, NotFound, SeekLt, SeekGt, SeekLe
*/</comment>
<comment type="block">/* Opcode: SeekGT P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as a key. If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that  it points to the smallest entry that 
** is greater than the key value. If there are no records greater than 
** the key and P2 is not zero, then jump to P2.
**
** This opcode leaves the cursor configured to move in forward order,
** from the beginning toward the end.  In other words, the cursor is
** configured to use Next, not Prev.
**
** See also: Found, NotFound, SeekLt, SeekGe, SeekLe
*/</comment>
<comment type="block">/* Opcode: SeekLT P1 P2 P3 P4 * 
** Synopsis: key=r[P3@P4]
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as a key. If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that  it points to the largest entry that 
** is less than the key value. If there are no records less than 
** the key and P2 is not zero, then jump to P2.
**
** This opcode leaves the cursor configured to move in reverse order,
** from the end toward the beginning.  In other words, the cursor is
** configured to use Prev, not Next.
**
** See also: Found, NotFound, SeekGt, SeekGe, SeekLe
*/</comment>
<comment type="block">/* Opcode: SeekLE P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as a key. If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that it points to the largest entry that 
** is less than or equal to the key value. If there are no records 
** less than or equal to the key and P2 is not zero, then jump to P2.
**
** This opcode leaves the cursor configured to move in reverse order,
** from the end toward the beginning.  In other words, the cursor is
** configured to use Prev, not Next.
**
** If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this
** opcode will always land on a record that equally equals the key, or
** else jump immediately to P2.  When the cursor is OPFLAG_SEEKEQ, this
** opcode must be followed by an IdxGE opcode with the same arguments.
** The IdxGE opcode will be skipped if this opcode succeeds, but the
** IdxGE opcode will be used on subsequent loop iterations.
**
** See also: Found, NotFound, SeekGt, SeekGe, SeekLt
*/</comment>
<case>case <expr><name>OP_SeekLT</name></expr>:</case>         <comment type="block">/* jump, in3 */</comment>
<case>case <expr><name>OP_SeekLE</name></expr>:</case>         <comment type="block">/* jump, in3 */</comment>
<case>case <expr><name>OP_SeekGE</name></expr>:</case>         <comment type="block">/* jump, in3 */</comment>
<case>case <expr><name>OP_SeekGT</name></expr>:</case> <block>{<block_content>       <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>           <comment type="block">/* Comparison result */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>oc</name></decl>;</decl_stmt>            <comment type="block">/* Opcode */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>    <comment type="block">/* The cursor to seek */</comment>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>  <comment type="block">/* The key to seek for */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>        <comment type="block">/* Number of columns or fields in the key */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iKey</name></decl>;</decl_stmt>          <comment type="block">/* The rowid we are to seek to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eqOnly</name></decl>;</decl_stmt>        <comment type="block">/* Only interested in == results */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekLE</name> <operator>==</operator> <name>OP_SeekLT</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekGE</name> <operator>==</operator> <name>OP_SeekLT</name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekGT</name> <operator>==</operator> <name>OP_SeekLT</name><operator>+</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isOrdered</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>oc</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>eqOnly</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The BTREE_SEEK_EQ flag is only set on index cursors */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorHasHint</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>BTREE_SEEK_EQ</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The input value in P3 might be of any type: integer, real, string,
    ** blob, or NULL.  But it needs to be an integer before we can do
    ** the seek, so convert it. */</comment>
    <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_Str</name><operator>)</operator><operator>)</operator><operator>==</operator><name>MEM_Str</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iKey</name> <operator>=</operator> <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the P3 value could not be converted into an integer without
    ** loss of information, then special processing is required... */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If the P3 value cannot be converted into any kind of a number,
        ** then the seek is not possible, so jump to P2 */</comment>
        <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <goto>goto <name>jump_to_p2</name>;</goto>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If the approximation iKey is larger than the actual real search
      ** term, substitute &gt;= for &gt; and &lt; for &lt;=. e.g. if the search term
      ** is 4.9 and the integer approximation 5:
      **
      **        (x &gt;  4.9)    -&gt;     (x &gt;= 5)
      **        (x &lt;= 4.9)    -&gt;     (x &lt;  5)
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name><operator>&lt;</operator><operator>(</operator><name>double</name><operator>)</operator><name>iKey</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekGE</name><operator>==</operator><operator>(</operator><name>OP_SeekGT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekLT</name><operator>==</operator><operator>(</operator><name>OP_SeekLE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>OP_SeekLE</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_SeekGT</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>oc</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_SeekGT</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oc</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>

      <comment type="block">/* If the approximation iKey is smaller than the actual real search
      ** term, substitute &lt;= for &lt; and &gt; for &gt;=.  */</comment>
      <if type="elseif">else if<condition>( <expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name><operator>&gt;</operator><operator>(</operator><name>double</name><operator>)</operator><name>iKey</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekLE</name><operator>==</operator><operator>(</operator><name>OP_SeekLT</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OP_SeekGT</name><operator>==</operator><operator>(</operator><name>OP_SeekGE</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>OP_SeekLT</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_SeekGE</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>oc</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_SeekLT</name> <operator>&amp;</operator> <literal type="number">0x0001</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt> 
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>iKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt>  <comment type="block">/* Used by OP_Delete */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* For a cursor with the BTREE_SEEK_EQ hint, only the OP_SeekGE and
    ** OP_SeekLE opcodes are allowed, and these must be immediately followed
    ** by an OP_IdxGT or OP_IdxLT opcode, respectively, with the same key.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeCursorHasHint</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>BTREE_SEEK_EQ</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eqOnly</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SeekGE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SeekLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxLT</name> <operator>||</operator> <name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p1</name><operator>==</operator><name><name>pOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p2</name><operator>==</operator><name><name>pOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p3</name><operator>==</operator><name><name>pOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p3</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>i</name></name><operator>==</operator><name><name>pOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>i</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nField</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nField</name></expr>;</expr_stmt>

    <comment type="block">/* The next line of code computes as follows, only faster:
    **   if( oc==OP_SeekGT || oc==OP_SeekLE ){
    **     r.default_rc = -1;
    **   }else{
    **     r.default_rc = +1;
    **   }
    */</comment>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><literal type="number">1</literal> <operator>&amp;</operator> <operator>(</operator><name>oc</name> <operator>-</operator> <name>OP_SeekLT</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>!=</operator><name>OP_SeekGT</name> <operator>||</operator> <name><name>r</name><operator>.</operator><name>default_rc</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>!=</operator><name>OP_SeekLE</name> <operator>||</operator> <name><name>r</name><operator>.</operator><name>default_rc</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>!=</operator><name>OP_SeekGE</name> <operator>||</operator> <name><name>r</name><operator>.</operator><name>default_rc</name></name><operator>==</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>!=</operator><name>OP_SeekLT</name> <operator>||</operator> <name><name>r</name><operator>.</operator><name>default_rc</name></name><operator>==</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <block>{<block_content> <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt> <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>r</name><operator>.</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>aMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>eqSeen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eqOnly</name> <operator>&amp;&amp;</operator> <name><name>r</name><operator>.</operator><name>eqSeen</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>seek_not_found</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_search_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>oc</name><operator>&gt;=</operator><name>OP_SeekGE</name></expr> )</condition><block>{<block_content>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>==</operator><name>OP_SeekGE</name> <operator>||</operator> <name>oc</name><operator>==</operator><name>OP_SeekGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>oc</name><operator>==</operator><name>OP_SeekGT</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name><operator>==</operator><name>OP_SeekLT</name> <operator>||</operator> <name>oc</name><operator>==</operator><name>OP_SeekLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>oc</name><operator>==</operator><name>OP_SeekLT</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreePrevious</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* res might be negative because the table is empty.  Check to
      ** see if this is the case.
      */</comment>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3BtreeEof</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
<label><name>seek_not_found</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eqOnly</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxLT</name> <operator>||</operator> <name><name>pOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Skip the OP_IdxLt or OP_IdxGT that follows */</comment>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
  

<comment type="block">/* Opcode: Found P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
** P4&gt;0 then register P3 is the first of P4 registers that form an unpacked
** record.
**
** Cursor P1 is on an index btree.  If the record identified by P3 and P4
** is a prefix of any entry in P1 then a jump is made to P2 and
** P1 is left pointing at the matching entry.
**
** This operation leaves the cursor in a state where it can be
** advanced in the forward direction.  The Next instruction will work,
** but not the Prev instruction.
**
** See also: NotFound, NoConflict, NotExists. SeekGe
*/</comment>
<comment type="block">/* Opcode: NotFound P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
** P4&gt;0 then register P3 is the first of P4 registers that form an unpacked
** record.
** 
** Cursor P1 is on an index btree.  If the record identified by P3 and P4
** is not the prefix of any entry in P1 then a jump is made to P2.  If P1 
** does contain an entry whose prefix matches the P3/P4 record then control
** falls through to the next instruction and P1 is left pointing at the
** matching entry.
**
** This operation leaves the cursor in a state where it cannot be
** advanced in either direction.  In other words, the Next and Prev
** opcodes do not work after this operation.
**
** See also: Found, NotExists, NoConflict
*/</comment>
<comment type="block">/* Opcode: NoConflict P1 P2 P3 P4 *
** Synopsis: key=r[P3@P4]
**
** If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
** P4&gt;0 then register P3 is the first of P4 registers that form an unpacked
** record.
** 
** Cursor P1 is on an index btree.  If the record identified by P3 and P4
** contains any NULL value, jump immediately to P2.  If all terms of the
** record are not-NULL then a check is done to determine if any row in the
** P1 index btree has a matching key prefix.  If there are no matches, jump
** immediately to P2.  If there is a match, fall through and leave the P1
** cursor pointing to the matching row.
**
** This opcode is similar to OP_NotFound with the exceptions that the
** branch is always taken if any part of the search key input is NULL.
**
** This operation leaves the cursor in a state where it cannot be
** advanced in either direction.  In other words, the Next and Prev
** opcodes do not work after this operation.
**
** See also: NotFound, Found, NotExists
*/</comment>
<case>case <expr><name>OP_NoConflict</name></expr>:</case>     <comment type="block">/* jump, in3 */</comment>
<case>case <expr><name>OP_NotFound</name></expr>:</case>       <comment type="block">/* jump, in3 */</comment>
<case>case <expr><name>OP_Found</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>alreadyExists</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>takeJump</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pFree</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pIdxKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aTempRec</name><index>[<expr><call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnpackedRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">4</literal> <operator>+</operator> <literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_NoConflict</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sqlite3_found_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <name>pIn3</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>r</name><operator>.</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name>ii</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>+</operator><name>ii</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pIdxKey</name> <operator>=</operator> <operator>&amp;</operator><name>r</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pIdxKey</name> <operator>=</operator> <call><name>sqlite3VdbeAllocUnpackedRecord</name><argument_list>(
        <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>, <argument><expr><name>aTempRec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aTempRec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFree</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIdxKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeRecordUnpack</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>, <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pIdxKey</name><operator>-&gt;</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>takeJump</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_NoConflict</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* For the OP_NoConflict opcode, take the jump if any of the
    ** input fields are NULL, since any key with a NULL will not
    ** conflict */</comment>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pIdxKey</name><operator>-&gt;</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pIdxKey</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>takeJump</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>alreadyExists</name> <operator>=</operator> <operator>(</operator><name>res</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal><operator>-</operator><name>alreadyExists</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Found</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>alreadyExists</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>alreadyExists</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>takeJump</name><operator>||</operator><name>alreadyExists</name><operator>==</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>takeJump</name> <operator>||</operator> <operator>!</operator><name>alreadyExists</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: NotExists P1 P2 P3 * *
** Synopsis: intkey=r[P3]
**
** P1 is the index of a cursor open on an SQL table btree (with integer
** keys).  P3 is an integer rowid.  If P1 does not contain a record with
** rowid P3 then jump immediately to P2.  Or, if P2 is 0, raise an
** SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then 
** leave the cursor pointing at that record and fall through to the next
** instruction.
**
** The OP_NotFound opcode performs the same operation on index btrees
** (with arbitrary multi-value keys).
**
** This opcode leaves the cursor in a state where it cannot be advanced
** in either direction.  In other words, the Next and Prev opcodes will
** not work following this opcode.
**
** See also: Found, NotFound, NoConflict
*/</comment>
<case>case <expr><name>OP_NotExists</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>iKey</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>res</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt>  <comment type="block">/* Used by OP_Delete */</comment>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <goto>goto <name>jump_to_p2</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Sequence P1 P2 * * *
** Synopsis: r[P2]=cursor[P1].ctr++
**
** Find the next available sequence number for cursor P1.
** Write the sequence number into register P2.
** The sequence number on the cursor is incremented after this
** instruction.  
*/</comment>
<case>case <expr><name>OP_Sequence</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>-&gt;</operator><name>eCurType</name><operator>!=</operator><name>CURTYPE_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>-&gt;</operator><name>seqCount</name><operator>++</operator></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>


<comment type="block">/* Opcode: NewRowid P1 P2 P3 * *
** Synopsis: r[P2]=rowid
**
** Get a new integer record number (a.k.a "rowid") used as the key to a table.
** The record number is not previously used as a key in the database
** table that cursor P1 points to.  The new record number is written
** written to register P2.
**
** If P3&gt;0 then P3 is a register in the root frame of this VDBE that holds 
** the largest previously generated record number. No new record numbers are
** allowed to be less than this value. When this value reaches its maximum, 
** an SQLITE_FULL error is generated. The P3 register is updated with the '
** generated record number. This P3 mechanism is used to help implement the
** AUTOINCREMENT feature.
*/</comment>
<case>case <expr><name>OP_NewRowid</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>                 <comment type="block">/* The new rowid */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>        <comment type="block">/* Cursor of table to get the new rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>               <comment type="block">/* Result of an sqlite3BtreeLast() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>               <comment type="block">/* Counter to limit the number of searches */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>             <comment type="block">/* Register holding largest rowid for AUTOINCREMENT */</comment>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>     <comment type="block">/* Root frame of VDBE */</comment>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <block>{<block_content>
    <comment type="block">/* The next rowid or record number (different terms for the same
    ** thing) is obtained in a two-step algorithm.
    **
    ** First we attempt to find the largest existing rowid and add one
    ** to that.  But if the largest existing rowid is already the maximum
    ** positive integer, we have to fall through to the second
    ** probabilistic algorithm
    **
    ** The second algorithm is to select a rowid at random and see if
    ** it already exists in the table.  If it does not exist, we have
    ** succeeded.  If the random rowid does exist, we select a new one
    ** and try again, up to 100 times.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_32BIT_ROWID</name></cpp:ifdef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ROWID</name></cpp:macro> <cpp:value>0x7fffffff</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Some compilers complain about constants of the form 0x7fffffffffffffff.
    ** Others complain about 0x7ffffffffffffffffLL.  The following macro seems
    ** to provide the constant while making all compilers happy.
    */</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ROWID</name></cpp:macro>  <cpp:value>(i64)( (((u64)0x7fffffff)&lt;&lt;32) | (u64)0xffffffff )</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>useRandomRowid</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeLast</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* IMP: R-61914-48074 */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Cannot fail following BtreeLast() */</comment>
        <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;=</operator><name>MAX_ROWID</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>useRandomRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>v</name><operator>++</operator></expr>;</expr_stmt>   <comment type="block">/* IMP: R-29538-34987 */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Assert that P3 is a valid memory cell. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>pFrame</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</init> <condition><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</condition> <incr><expr><name>pFrame</name><operator>=</operator><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
        <comment type="block">/* Assert that P3 is a valid memory cell. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><name><name>pFrame</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>pFrame</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Assert that P3 is a valid memory cell. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mem(P3) holds an integer */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><name>MAX_ROWID</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>useRandomRowid</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_FULL</name></expr>;</expr_stmt>   <comment type="block">/* IMP: R-12275-61338 */</comment>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>useRandomRowid</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* IMPLEMENTATION-OF: R-07677-41881 If the largest ROWID is equal to the
      ** largest possible integer (9223372036854775807) then the database
      ** engine starts picking positive candidate ROWIDs at random until
      ** it finds one that is not previously used. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* We cannot be in random rowid mode if this is
                             ** an AUTOINCREMENT table. */</comment>
      <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <do>do<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name> <operator>&amp;=</operator> <operator>(</operator><name>MAX_ROWID</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>v</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* Ensure that v is greater than zero */</comment>
      </block_content>}</block>while<condition>(  <expr><operator>(</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>v</name></expr></argument>,
                                                 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_OK</name><operator>)</operator>
            <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
            <operator>&amp;&amp;</operator> <operator>(</operator><operator>++</operator><name>cnt</name><operator>&lt;</operator><literal type="number">100</literal><operator>)</operator></expr>)</condition>;</do>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_FULL</name></expr>;</expr_stmt>   <comment type="block">/* IMP: R-38219-53002 */</comment>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* EV: R-40812-03570 */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  </block_content>}</block>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Insert P1 P2 P3 P4 P5
** Synopsis: intkey=r[P3] data=r[P2]
**
** Write an entry into the table of cursor P1.  A new entry is
** created if it doesn't already exist or the data for an existing
** entry is overwritten.  The data is the value MEM_Blob stored in register
** number P2. The key is stored in register P3. The key must
** be a MEM_Int.
**
** If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is
** incremented (otherwise not).  If the OPFLAG_LASTROWID flag of P5 is set,
** then rowid is stored for subsequent return by the
** sqlite3_last_insert_rowid() function (otherwise it is unmodified).
**
** If the OPFLAG_USESEEKRESULT flag of P5 is set and if the result of
** the last seek operation (OP_NotExists) was a success, then this
** operation will not attempt to find the appropriate row before doing
** the insert but will instead overwrite the row that the cursor is
** currently pointing to.  Presumably, the prior OP_NotExists opcode
** has already positioned the cursor correctly.  This is an optimization
** that boosts performance by avoiding redundant seeks.
**
** If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an
** UPDATE operation.  Otherwise (if the flag is clear) then this opcode
** is part of an INSERT operation.  The difference is only important to
** the update hook.
**
** Parameter P4 may point to a string containing the table-name, or
** may be NULL. If it is not NULL, then the update-hook 
** (sqlite3.xUpdateCallback) is invoked following a successful insert.
**
** (WARNING/TODO: If P1 is a pseudo-cursor and P2 is dynamically
** allocated, then ownership of P2 is transferred to the pseudo-cursor
** and register P2 becomes ephemeral.  If the cursor is changed, the
** value of register P2 will then change.  Make sure this does not
** cause any problems.)
**
** This instruction only works on tables.  The equivalent instruction
** for indices is OP_IdxInsert.
*/</comment>
<comment type="block">/* Opcode: InsertInt P1 P2 P3 P4 P5
** Synopsis:  intkey=P3 data=r[P2]
**
** This works exactly like OP_Insert except that the key is the
** integer value P3, not the value of the integer stored in register P3.
*/</comment>
<case>case <expr><name>OP_Insert</name></expr>:</case> 
<case>case <expr><name>OP_InsertInt</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>       <comment type="block">/* MEM cell holding data for the record to be inserted */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>        <comment type="block">/* MEM cell holding key  for the record */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iKey</name></decl>;</decl_stmt>         <comment type="block">/* The integer ROWID or key for the record to be inserted */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>   <comment type="block">/* Cursor to table into which insert is written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nZero</name></decl>;</decl_stmt>        <comment type="block">/* Number of zero-bytes to append */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>seekResult</name></decl>;</decl_stmt>   <comment type="block">/* Result of prior seek or 0 if no USESEEKRESULT flag */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>  <comment type="block">/* database name - used by the update hook */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTbl</name></decl>;</decl_stmt> <comment type="block">/* Table name - used by the opdate hook */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>           <comment type="block">/* Opcode for update hook: SQLITE_UPDATE or SQLITE_INSERT */</comment>

  <expr_stmt><expr><name>pData</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Insert</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pKey</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKey</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>pKey</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_InsertInt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_NCHANGE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_LASTROWID</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name>lastRowid</name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Str</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>seekResult</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_USESEEKRESULT</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pData</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nZero</name> <operator>=</operator> <name><name>pData</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nZero</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeInsert</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iKey</name></expr></argument>,
                          <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pData</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>nZero</name></expr></argument>,
                          <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_APPEND</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>seekResult</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>

  <comment type="block">/* Invoke the update-hook if required. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pC</name><operator>-&gt;</operator><name>iDb</name></name></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zTbl</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_ISUPDATE</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_UPDATE</name></expr> </then><else>: <expr><name>SQLITE_INSERT</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pUpdateArg</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>iDb</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Delete P1 P2 * P4 P5
**
** Delete the record at which the P1 cursor is currently pointing.
**
** If the OPFLAG_SAVEPOSITION bit of the P5 parameter is set, then
** the cursor will be left pointing at  either the next or the previous
** record in the table. If it is left pointing at the next record, then
** the next Next instruction will be a no-op. As a result, in this case
** it is ok to delete a record from within a Next loop. If 
** OPFLAG_SAVEPOSITION bit of P5 is clear, then the cursor will be
** left in an undefined state.
**
** If the OPFLAG_AUXDELETE bit is set on P5, that indicates that this
** delete one of several associated with deleting a table row and all its
** associated index entries.  Exactly one of those deletes is the "primary"
** delete.  The others are all on OPFLAG_FORDELETE cursors or else are
** marked with the AUXDELETE flag.
**
** If the OPFLAG_NCHANGE flag of P2 (NB: P2 not P5) is set, then the row
** change count is incremented (otherwise not).
**
** P1 must not be pseudo-table.  It has to be a real table with
** multiple rows.
**
** If P4 is not NULL, then it is the name of the table that P1 is
** pointing to.  The update hook will be invoked, if it exists.
** If P4 is not NULL then the P1 cursor must have been positioned
** using OP_NotFound prior to invoking this opcode.
*/</comment>
<case>case <expr><name>OP_Delete</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>hasUpdateCallback</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>hasUpdateCallback</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name> <operator>&amp;&amp;</operator> <name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;&amp;</operator> <name>hasUpdateCallback</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* The seek operation that positioned the cursor prior to OP_Delete will
  ** have also set the pC-&gt;movetoTarget field to the rowid of the row that
  ** is being deleted */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name> <operator>&amp;&amp;</operator> <name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name><operator>==</operator><name>iKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Only flags that can be set are SAVEPOISTION and AUXDELETE */</comment> 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>OPFLAG_SAVEPOSITION</name><operator>|</operator><name>OPFLAG_AUXDELETE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OPFLAG_SAVEPOSITION</name><operator>==</operator><name>BTREE_SAVEPOSITION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OPFLAG_AUXDELETE</name><operator>==</operator><name>BTREE_AUXDELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>isEphemeral</name></name><operator>==</operator><literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_AUXDELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pC</name><operator>-&gt;</operator><name>wrFlag</name></name> <operator>&amp;</operator> <name>OPFLAG_FORDELETE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
      <expr_stmt><expr><name>nExtraDelete</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>&amp;</operator> <name>OPFLAG_NCHANGE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nExtraDelete</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeDelete</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>

  <comment type="block">/* Invoke the update-hook if required. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>hasUpdateCallback</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pUpdateArg</name></name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>,
                        <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pC</name><operator>-&gt;</operator><name>iDb</name></name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>iDb</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>&amp;</operator> <name>OPFLAG_NCHANGE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<comment type="block">/* Opcode: ResetCount * * * * *
**
** The value of the change counter is copied to the database handle
** change counter (returned by subsequent calls to sqlite3_changes()).
** Then the VMs internal change counter resets to 0.
** This is used by trigger programs.
*/</comment>
<case>case <expr><name>OP_ResetCount</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: SorterCompare P1 P2 P3 P4
** Synopsis:  if key(P1)!=trim(r[P3],P4) goto P2
**
** P1 is a sorter cursor. This instruction compares a prefix of the
** record blob in register P3 against a prefix of the entry that 
** the sorter cursor currently points to.  Only the first P4 fields
** of r[P3] and the sorter record are compared.
**
** If either P3 or the sorter contains a NULL in one of their significant
** fields (not counting the P4 fields at the end which are ignored) then
** the comparison is assumed to be equal.
**
** Fall through to next instruction if the two records compare equal to
** each other.  Jump to P2 if they are different.
*/</comment>
<case>case <expr><name>OP_SorterCompare</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKeyCol</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nKeyCol</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterCompare</name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pIn3</name></expr></argument>, <argument><expr><name>nKeyCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block><empty_stmt>;</empty_stmt>

<comment type="block">/* Opcode: SorterData P1 P2 P3 * *
** Synopsis: r[P2]=data
**
** Write into register P2 the current sorter data for sorter cursor P1.
** Then clear the column header cache on cursor P3.
**
** This opcode is normally use to move a record out of the sorter and into
** a register that is the source for a pseudo-table cursor created using
** OpenPseudo.  That pseudo-table cursor is the one that is identified by
** parameter P3.  Clearing the P3 column cache as part of this opcode saves
** us from having to issue a separate NullRow instruction to clear that cache.
*/</comment>
<case>case <expr><name>OP_SorterData</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterRowkey</name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name><operator>-&gt;</operator><name>cacheStatus</name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: RowData P1 P2 * * *
** Synopsis: r[P2]=data
**
** Write into register P2 the complete row data for cursor P1.
** There is no interpretation of the data.  
** It is just copied onto the P2 register exactly as 
** it is found in the database file.
**
** If the P1 cursor must be pointing to a valid row (not a NULL row)
** of a real table, not a pseudo-table.
*/</comment>
<comment type="block">/* Opcode: RowKey P1 P2 * * *
** Synopsis: r[P2]=key
**
** Write into register P2 the complete row key for cursor P1.
** There is no interpretation of the data.  
** The key is copied onto the P2 register exactly as 
** it is found in the database file.
**
** If the P1 cursor must be pointing to a valid row (not a NULL row)
** of a real table, not a pseudo-table.
*/</comment>
<case>case <expr><name>OP_RowKey</name></expr>:</case>
<case>case <expr><name>OP_RowData</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>n64</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Note that RowKey and RowData are really exactly the same instruction */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_RowData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_RowData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>

  <comment type="block">/* The OP_RowKey and OP_RowData opcodes always follow OP_NotExists or
  ** OP_Rewind/Op_Next with no intervening instructions that might invalidate
  ** the cursor.  If this where not the case, on of the following assert()s
  ** would fail.  Should this ever change (because of changes in the code
  ** generator) then the fix would be to insert a call to
  ** sqlite3VdbeCursorMoveto().
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>  <comment type="block">/* Not required due to the previous to assert() statements */</comment>
  rc = sqlite3VdbeCursorMoveto(pC);
  if( rc!=SQLITE_OK ) goto abort_due_to_error;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <macro><name>VVA_ONLY</name><argument_list>(<argument>rc =</argument>)</argument_list></macro> <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* True because of CursorMoveto() call above */</comment>
    <if_stmt><if>if<condition>( <expr><name>n64</name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <goto>goto <name>too_big</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>n64</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <macro><name>VVA_ONLY</name><argument_list>(<argument>rc =</argument>)</argument_list></macro> <expr_stmt><expr><call><name>sqlite3BtreeDataSize</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* DataSize() cannot fail */</comment>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <goto>goto <name>too_big</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>no_mem</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeKey</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeData</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>  <comment type="block">/* In case the blob is ever cast to text */</comment>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Rowid P1 P2 * * *
** Synopsis: r[P2]=rowid
**
** Store in register P2 an integer which is the key of the table entry that
** P1 is currently point to.
**
** P1 can be either an ordinary table or a virtual table.  There used to
** be a separate OP_VRowid opcode for use with virtual tables, but this
** one opcode now works for both table types.
*/</comment>
<case>case <expr><name>OP_Rowid</name></expr>:</case> <block>{<block_content>                 <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_PSEUDO</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>movetoTarget</name></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_VTAB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pModule</name><operator>-&gt;</operator><name>xRowid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xRowid</name></name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCursorRestore</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Always so because of CursorRestore() above */</comment>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: NullRow P1 * * * *
**
** Move the cursor P1 to a null row.  Any OP_Column operations
** that occur while the cursor is on the null row will always
** write a NULL.
*/</comment>
<case>case <expr><name>OP_NullRow</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeClearCursor</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Last P1 P2 P3 * *
**
** The next use of the Rowid or Column or Prev instruction for P1 
** will refer to the last entry in the database table or index.
** If the table or index is empty and P2&gt;0, then jump immediately to P2.
** If P2 is 0 or if the table or index is not empty, fall through
** to the following instruction.
**
** This opcode leaves the cursor configured to move in reverse order,
** from the end toward the beginning.  In other words, the cursor is
** configured to use Prev, not Next.
*/</comment>
<case>case <expr><name>OP_Last</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeLast</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>res</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <name>OP_Last</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>


<comment type="block">/* Opcode: Sort P1 P2 * * *
**
** This opcode does exactly the same thing as OP_Rewind except that
** it increments an undocumented global variable used for testing.
**
** Sorting is accomplished by writing records into a sorting index,
** then rewinding that index and playing it back from beginning to
** end.  We use the OP_Sort opcode instead of OP_Rewind to do the
** rewinding so that the global variable will be incremented and
** regression tests can determine whether or not the optimizer is
** correctly optimizing out sorts.
*/</comment>
<case>case <expr><name>OP_SorterSort</name></expr>:</case>    <comment type="block">/* jump */</comment>
<case>case <expr><name>OP_Sort</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_sort_count</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>sqlite3_search_count</name><operator>--</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_SORT</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
  <comment type="block">/* Fall through into OP_Rewind */</comment>
</block_content>}</block>
<comment type="block">/* Opcode: Rewind P1 P2 * * *
**
** The next use of the Rowid or Column or Next instruction for P1 
** will refer to the first entry in the database table or index.
** If the table or index is empty, jump immediately to P2.
** If the table or index is not empty, fall through to the following 
** instruction.
**
** This opcode leaves the cursor configured to move in forward order,
** from the beginning toward the end.  In other words, the cursor is
** configured to use Next, not Prev.
*/</comment>
<case>case <expr><name>OP_Rewind</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SorterSort</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name> <operator>=</operator> <name>OP_Rewind</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterRewind</name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeFirst</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>res</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Next P1 P2 P3 P4 P5
**
** Advance cursor P1 so that it points to the next key/data pair in its
** table or index.  If there are no more key/value pairs then fall through
** to the following instruction.  But if the cursor advance was successful,
** jump immediately to P2.
**
** The Next opcode is only valid following an SeekGT, SeekGE, or
** OP_Rewind opcode used to position the cursor.  Next is not allowed
** to follow SeekLT, SeekLE, or OP_Last.
**
** The P1 cursor must be for a real table, not a pseudo-table.  P1 must have
** been opened prior to this opcode or the program will segfault.
**
** The P3 value is a hint to the btree implementation. If P3==1, that
** means P1 is an SQL index and that this instruction could have been
** omitted if that index had been unique.  P3 is usually 0.  P3 is
** always either 0 or 1.
**
** P4 is always of type P4_ADVANCE. The function pointer points to
** sqlite3BtreeNext().
**
** If P5 is positive and the jump is taken, then event counter
** number P5-1 in the prepared statement is incremented.
**
** See also: Prev, NextIfOpen
*/</comment>
<comment type="block">/* Opcode: NextIfOpen P1 P2 P3 P4 P5
**
** This opcode works just like Next except that if cursor P1 is not
** open it behaves a no-op.
*/</comment>
<comment type="block">/* Opcode: Prev P1 P2 P3 P4 P5
**
** Back up cursor P1 so that it points to the previous key/data pair in its
** table or index.  If there is no previous key/value pairs then fall through
** to the following instruction.  But if the cursor backup was successful,
** jump immediately to P2.
**
**
** The Prev opcode is only valid following an SeekLT, SeekLE, or
** OP_Last opcode used to position the cursor.  Prev is not allowed
** to follow SeekGT, SeekGE, or OP_Rewind.
**
** The P1 cursor must be for a real table, not a pseudo-table.  If P1 is
** not open then the behavior is undefined.
**
** The P3 value is a hint to the btree implementation. If P3==1, that
** means P1 is an SQL index and that this instruction could have been
** omitted if that index had been unique.  P3 is usually 0.  P3 is
** always either 0 or 1.
**
** P4 is always of type P4_ADVANCE. The function pointer points to
** sqlite3BtreePrevious().
**
** If P5 is positive and the jump is taken, then event counter
** number P5-1 in the prepared statement is incremented.
*/</comment>
<comment type="block">/* Opcode: PrevIfOpen P1 P2 P3 P4 P5
**
** This opcode works just like Prev except that if cursor P1 is not
** open it behaves a no-op.
*/</comment>
<case>case <expr><name>OP_SorterNext</name></expr>:</case> <block>{<block_content>  <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterNext</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>next_tail</name>;</goto>
<case>case <expr><name>OP_PrevIfOpen</name></expr>:</case>    <comment type="block">/* jump */</comment>
<case>case <expr><name>OP_NextIfOpen</name></expr>:</case>    <comment type="block">/* jump */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <comment type="block">/* Fall through */</comment>
<case>case <expr><name>OP_Prev</name></expr>:</case>          <comment type="block">/* jump */</comment>
<case>case <expr><name>OP_Next</name></expr>:</case>          <comment type="block">/* jump */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>res</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>res</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_Next</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>xAdvance</name></name><operator>==</operator><name>sqlite3BtreeNext</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_Prev</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>xAdvance</name></name><operator>==</operator><name>sqlite3BtreePrevious</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_NextIfOpen</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>xAdvance</name></name><operator>==</operator><name>sqlite3BtreeNext</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_PrevIfOpen</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>xAdvance</name></name><operator>==</operator><name>sqlite3BtreePrevious</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The Next opcode is only used after SeekGT, SeekGE, and Rewind.
  ** The Prev opcode is only used after SeekLT, SeekLE, and Last. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_Next</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_NextIfOpen</name>
       <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_SeekGT</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_SeekGE</name>
       <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_Rewind</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_Found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_Prev</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>!=</operator><name>OP_PrevIfOpen</name>
       <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_SeekLT</name> <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_SeekLE</name>
       <operator>||</operator> <name><name>pC</name><operator>-&gt;</operator><name>seekOp</name></name><operator>==</operator><name>OP_Last</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>xAdvance</name></name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>next_tail</name>:</label>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <expr_stmt><expr><name>sqlite3_search_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <goto>goto <name>jump_to_p2_and_check_for_interrupt</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <goto>goto <name>check_for_interrupt</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: IdxInsert P1 P2 P3 * P5
** Synopsis: key=r[P2]
**
** Register P2 holds an SQL index key made using the
** MakeRecord instructions.  This opcode writes that key
** into the index P1.  Data for the entry is nil.
**
** P3 is a flag that provides a hint to the b-tree layer that this
** insert is likely to be an append.
**
** If P5 has the OPFLAG_NCHANGE bit set, then the change counter is
** incremented by this instruction.  If the OPFLAG_NCHANGE bit is clear,
** then the change counter is unchanged.
**
** If P5 has the OPFLAG_USESEEKRESULT bit set, then the cursor must have
** just done a seek to the spot where the new entry is to be inserted.
** This flag avoids doing an extra seek.
**
** This instruction only works for indices.  The equivalent instruction
** for tables is OP_Insert.
*/</comment>
<case>case <expr><name>OP_SorterInsert</name></expr>:</case>       <comment type="block">/* in2 */</comment>
<case>case <expr><name>OP_IdxInsert</name></expr>:</case> <block>{<block_content>        <comment type="block">/* in2 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SorterInsert</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_NCHANGE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SorterInsert</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_SorterInsert</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeSorterWrite</name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zKey</name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeInsert</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, 
          <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_USESEEKRESULT</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>pC</name><operator>-&gt;</operator><name>seekResult</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IdxDelete P1 P2 P3 * *
** Synopsis: key=r[P2@P3]
**
** The content of P3 registers starting at register P2 form
** an unpacked index key. This opcode removes that entry from the 
** index opened by cursor P1.
*/</comment>
<case>case <expr><name>OP_IdxDelete</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeDelete</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><name>BTREE_AUXDELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pC</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Seek P1 * P3 P4 *
** Synopsis:  Move P3 to P1.rowid
**
** P1 is an open index cursor and P3 is a cursor on the corresponding
** table.  This opcode does a deferred seek of the P3 table cursor
** to the row that corresponds to the current row of P1.
**
** This is a deferred seek.  Nothing actually happens until
** the cursor is used to read a record.  That way, if no reads
** occur, no unnecessary I/O happens.
**
** P4 may be an array of integers (type P4_INTARRAY) containing
** one entry for each column in the P3 table.  If array entry a(i)
** is non-zero, then reading column a(i)-1 from cursor P3 is 
** equivalent to performing the deferred seek and then reading column i 
** from P1.  This information is stored in P3 and used to redirect
** reads against P3 over to P1, thus possibly avoiding the need to
** seek and read cursor P3.
*/</comment>
<comment type="block">/* Opcode: IdxRowid P1 P2 * * *
** Synopsis: r[P2]=rowid
**
** Write into register P2 an integer which is the last entry in the record at
** the end of the index key pointed to by cursor P1.  This integer should be
** the rowid of the table entry to which this index entry points.
**
** See also: Rowid, MakeRecord.
*/</comment>
<case>case <expr><name>OP_Seek</name></expr>:</case>
<case>case <expr><name>OP_IdxRowid</name></expr>:</case> <block>{<block_content>              <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>                <comment type="block">/* The P1 index cursor */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pTabCur</name></decl>;</decl_stmt>           <comment type="block">/* The P2 table cursor (OP_Seek only) */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>rowid</name></decl>;</decl_stmt>                     <comment type="block">/* Rowid that P1 current points to */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isTable</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The IdxRowid and Seek opcodes are combined because of the commonality
  ** of sqlite3VdbeCursorRestore() and sqlite3VdbeIdxRowid(). */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCursorRestore</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* sqlite3VbeCursorRestore() can only fail if the record has been deleted
  ** out from under the cursor.  That will never happens for an IdxRowid
  ** or Seek opcode */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>abort_due_to_error</name>;</goto></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rowid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Not needed.  Only used to silence a warning. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeIdxRowid</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Seek</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTabCur</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTabCur</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>movetoTarget</name></name> <operator>=</operator> <name>rowid</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INTARRAY</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>ai</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>aAltMap</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>ai</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTabCur</name><operator>-&gt;</operator><name>pAltCursor</name></name> <operator>=</operator> <name>pC</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>rowid</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IdxGE P1 P2 P3 P4 P5
** Synopsis: key=r[P3@P4]
**
** The P4 register values beginning with P3 form an unpacked index 
** key that omits the PRIMARY KEY.  Compare this key value against the index 
** that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID 
** fields at the end.
**
** If the P1 index entry is greater than or equal to the key value
** then jump to P2.  Otherwise fall through to the next instruction.
*/</comment>
<comment type="block">/* Opcode: IdxGT P1 P2 P3 P4 P5
** Synopsis: key=r[P3@P4]
**
** The P4 register values beginning with P3 form an unpacked index 
** key that omits the PRIMARY KEY.  Compare this key value against the index 
** that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID 
** fields at the end.
**
** If the P1 index entry is greater than the key value
** then jump to P2.  Otherwise fall through to the next instruction.
*/</comment>
<comment type="block">/* Opcode: IdxLT P1 P2 P3 P4 P5
** Synopsis: key=r[P3@P4]
**
** The P4 register values beginning with P3 form an unpacked index 
** key that omits the PRIMARY KEY or ROWID.  Compare this key value against
** the index that P1 is currently pointing to, ignoring the PRIMARY KEY or
** ROWID on the P1 index.
**
** If the P1 index entry is less than the key value then jump to P2.
** Otherwise fall through to the next instruction.
*/</comment>
<comment type="block">/* Opcode: IdxLE P1 P2 P3 P4 P5
** Synopsis: key=r[P3@P4]
**
** The P4 register values beginning with P3 form an unpacked index 
** key that omits the PRIMARY KEY or ROWID.  Compare this key value against
** the index that P1 is currently pointing to, ignoring the PRIMARY KEY or
** ROWID on the P1 index.
**
** If the P1 index entry is less than or equal to the key value then jump
** to P2. Otherwise fall through to the next instruction.
*/</comment>
<case>case <expr><name>OP_IdxLE</name></expr>:</case>          <comment type="block">/* jump */</comment>
<case>case <expr><name>OP_IdxGT</name></expr>:</case>          <comment type="block">/* jump */</comment>
<case>case <expr><name>OP_IdxLT</name></expr>:</case>          <comment type="block">/* jump */</comment>
<case>case <expr><name>OP_IdxGE</name></expr>:</case>  <block>{<block_content>       <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isOrdered</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>deferredMoveto</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>pKeyInfo</name></name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nField</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>&lt;</operator><name>OP_IdxLT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxLE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxGE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>aMem</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <block>{<block_content> <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt> <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>r</name><operator>.</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for> </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Not needed.  Only used to silence a warning. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeIdxKeyCompare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>OP_IdxLE</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_IdxLT</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>OP_IdxGE</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_IdxGT</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>OP_IdxLT</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxLE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><name>res</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxGE</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_IdxGT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Destroy P1 P2 P3 * *
**
** Delete an entire database table or index whose root page in the database
** file is given by P1.
**
** The table being destroyed is in the main database file if P3==0.  If
** P3==1 then the table to be clear is in the auxiliary database file
** that is used to store tables create using CREATE TEMPORARY TABLE.
**
** If AUTOVACUUM is enabled then it is possible that another root page
** might be moved into the newly deleted root page in order to keep all
** root pages contiguous at the beginning of the database.  The former
** value of the root page that moved - its value before the move occurred -
** is stored in register P2.  If no page 
** movement was required (because the table being dropped was already 
** the last one in the database) then a zero is stored in register P2.
** If AUTOVACUUM is disabled then a zero is stored in register P2.
**
** See also: Clear
*/</comment>
<case>case <expr><name>OP_Destroy</name></expr>:</case> <block>{<block_content>     <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMoved</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name> <operator>&gt;</operator> <name><name>db</name><operator>-&gt;</operator><name>nVDestroy</name></name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_LOCKED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMoved</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Not needed.  Only to silence a warning. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeDropTable</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>iMoved</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iMoved</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3RootPageMoved</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>iMoved</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* All OP_Destroy operations occur on the same btree */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>resetSchemaOnFault</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>resetSchemaOnFault</name><operator>==</operator><name>iDb</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>resetSchemaOnFault</name> <operator>=</operator> <name>iDb</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Clear P1 P2 P3
**
** Delete all contents of the database table or index whose root page
** in the database file is given by P1.  But, unlike Destroy, do not
** remove the table or index from the database file.
**
** The table being clear is in the main database file if P2==0.  If
** P2==1 then the table to be clear is in the auxiliary database file
** that is used to store tables create using CREATE TEMPORARY TABLE.
**
** If the P3 value is non-zero, then the table referred to must be an
** intkey table (an SQL table, not an index). In this case the row change 
** count is incremented by the number of rows in the table being cleared. 
** If P3 is greater than zero, then the value stored in register P3 is
** also incremented by the number of rows in the table being cleared.
**
** See also: Destroy
*/</comment>
<case>case <expr><name>OP_Clear</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nChange</name></decl>;</decl_stmt>
 
  <expr_stmt><expr><name>nChange</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeClearTable</name><argument_list>(
      <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>nChange</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>+=</operator> <name>nChange</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>i</name></name> <operator>+=</operator> <name>nChange</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ResetSorter P1 * * * *
**
** Delete all contents from the ephemeral table or sorter
** that is open on cursor P1.
**
** This opcode only works for cursors used for sorting and
** opened with OP_OpenEphemeral or OP_SorterOpen.
*/</comment>
<case>case <expr><name>OP_ResetSorter</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>isSorter</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeSorterReset</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pSorter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>isEphemeral</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeClearTableOfCursor</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: CreateTable P1 P2 * * *
** Synopsis: r[P2]=root iDb=P1
**
** Allocate a new table in the main database file if P1==0 or in the
** auxiliary database file if P1==1 or in an attached database if
** P1&gt;1.  Write the root page number of the new table into
** register P2
**
** The difference between a table and an index is this:  A table must
** have a 4-byte integer key and can have arbitrary data.  An index
** has an arbitrary key but no data.
**
** See also: CreateIndex
*/</comment>
<comment type="block">/* Opcode: CreateIndex P1 P2 * * *
** Synopsis: r[P2]=root iDb=P1
**
** Allocate a new index in the main database file if P1==0 or in the
** auxiliary database file if P1==1 or in an attached database if
** P1&gt;1.  Write the root page number of the new table into
** register P2.
**
** See documentation on OP_CreateTable for additional information.
*/</comment>
<case>case <expr><name>OP_CreateIndex</name></expr>:</case>            <comment type="block">/* out2 */</comment>
<case>case <expr><name>OP_CreateTable</name></expr>:</case> <block>{<block_content>          <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pgno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pgno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_CreateTable</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* flags = BTREE_INTKEY; */</comment>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>BTREE_INTKEY</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>BTREE_BLOBKEY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCreateTable</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgno</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>pgno</name></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: ParseSchema P1 * * P4 *
**
** Read and parse all entries from the SQLITE_MASTER table of database P1
** that match the WHERE clause P4. 
**
** This opcode invokes the parser to create a new virtual machine,
** then runs the new virtual machine.  It is thus a re-entrant opcode.
*/</comment>
<case>case <expr><name>OP_ParseSchema</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMaster</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>InitData</name></type> <name>initData</name></decl>;</decl_stmt>

  <comment type="block">/* Any prepared statement that invokes this opcode will hold mutexes
  ** on every btree.  This is a prerequisite for invoking 
  ** sqlite3InitCallback().
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>iDb</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>iDb</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbHasProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>DB_SchemaLoaded</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Used to be a conditional */</comment> <block>{<block_content>
    <expr_stmt><expr><name>zMaster</name> <operator>=</operator> <call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>iDb</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>pzErrMsg</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
       <argument><expr><literal type="string">"SELECT name, rootpage, sql FROM '%q'.%s WHERE %s ORDER BY rowid"</literal></expr></argument>,
       <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>initData</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>sqlite3InitCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>initData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>initData</name><operator>.</operator><name>rc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ResetAllSchemasOfConnection</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>no_mem</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>  
</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_ANALYZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Opcode: LoadAnalysis P1 * * * *
**
** Read the sqlite_stat1 table for database P1 and load the content
** of that table into the internal index hash table.  This will cause
** the analysis to be used when preparing all subsequent queries.
*/</comment>
<case>case <expr><name>OP_LoadAnalysis</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3AnalysisLoad</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>  
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_ANALYZE) */</comment>

<comment type="block">/* Opcode: DropTable P1 * * P4 *
**
** Remove the internal (in-memory) data structures that describe
** the table named P4 in database P1.  This is called after a table
** is dropped from disk (using the Destroy opcode) in order to keep 
** the internal representation of the
** schema consistent with what is on disk.
*/</comment>
<case>case <expr><name>OP_DropTable</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3UnlinkAndDeleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: DropIndex P1 * * P4 *
**
** Remove the internal (in-memory) data structures that describe
** the index named P4 in database P1.  This is called after an index
** is dropped from disk (using the Destroy opcode)
** in order to keep the internal representation of the
** schema consistent with what is on disk.
*/</comment>
<case>case <expr><name>OP_DropIndex</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3UnlinkAndDeleteIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: DropTrigger P1 * * P4 *
**
** Remove the internal (in-memory) data structures that describe
** the trigger named P4 in database P1.  This is called after a trigger
** is dropped from disk (using the Destroy opcode) in order to keep 
** the internal representation of the
** schema consistent with what is on disk.
*/</comment>
<case>case <expr><name>OP_DropTrigger</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3UnlinkAndDeleteTrigger</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>
<comment type="block">/* Opcode: IntegrityCk P1 P2 P3 * P5
**
** Do an analysis of the currently open database.  Store in
** register P1 the text of an error message describing any problems.
** If no problems are found, store a NULL in register P1.
**
** The register P3 contains the maximum number of allowed errors.
** At most reg(P3) errors will be reported.
** In other words, the analysis stops as soon as reg(P1) errors are 
** seen.  Reg(P1) is updated with the number of errors remaining.
**
** The root page numbers of all tables in the database are integer
** stored in reg(P1), reg(P1+1), reg(P1+2), ....  There are P2 tables
** total.
**
** If P5 is not zero, the check is done on the auxiliary database
** file, not the main database file.
**
** This opcode is used to implement the integrity_check pragma.
*/</comment>
<case>case <expr><name>OP_IntegrityCk</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRoot</name></decl>;</decl_stmt>      <comment type="block">/* Number of tables to check.  (Number of root pages.) */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aRoot</name></decl>;</decl_stmt>     <comment type="block">/* Array of rootpage numbers for tables to be checked */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>          <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nErr</name></decl>;</decl_stmt>       <comment type="block">/* Number of errors reported */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>        <comment type="block">/* Text of the error report */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pnErr</name></decl>;</decl_stmt>     <comment type="block">/* Register keeping track of errors remaining */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nRoot</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRoot</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aRoot</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nRoot</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aRoot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pnErr</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pnErr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pnErr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nRoot</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>aRoot</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pIn1</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>aRoot</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3BtreeIntegrityCheck</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name>aRoot</name></expr></argument>, <argument><expr><name>nRoot</name></expr></argument>,
                                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pnErr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pnErr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>-=</operator> <name>nErr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nErr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>no_mem</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<comment type="block">/* Opcode: RowSetAdd P1 P2 * * *
** Synopsis:  rowset(P1)=r[P2]
**
** Insert the integer value held by register P2 into a boolean index
** held in register P1.
**
** An assertion fails if P2 is not an integer.
*/</comment>
<case>case <expr><name>OP_RowSetAdd</name></expr>:</case> <block>{<block_content>       <comment type="block">/* in1, in2 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIn2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_RowSet</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetRowSet</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_RowSet</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3RowSetInsert</name><argument_list>(<argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRowSet</name></name></expr></argument>, <argument><expr><name><name>pIn2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: RowSetRead P1 P2 P3 * *
** Synopsis:  r[P3]=rowset(P1)
**
** Extract the smallest value from boolean index P1 and put that value into
** register P3.  Or, if boolean index P1 is initially empty, leave P3
** unchanged and jump to instruction P2.
*/</comment>
<case>case <expr><name>OP_RowSetRead</name></expr>:</case> <block>{<block_content>       <comment type="block">/* jump, in1, out3 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>val</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_RowSet</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
   <operator>||</operator> <call><name>sqlite3RowSetNext</name><argument_list>(<argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRowSet</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* The boolean index is empty */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>jump_to_p2_and_check_for_interrupt</name>;</goto>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* A value was pulled from the index */</comment>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <goto>goto <name>check_for_interrupt</name>;</goto>
</block_content>}</block>

<comment type="block">/* Opcode: RowSetTest P1 P2 P3 P4
** Synopsis: if r[P3] in rowset(P1) goto P2
**
** Register P3 is assumed to hold a 64-bit integer value. If register P1
** contains a RowSet object and that RowSet object contains
** the value held in P3, jump to register P2. Otherwise, insert the
** integer in P3 into the RowSet and continue on to the
** next opcode.
**
** The RowSet object is optimized for the case where successive sets
** of integers, where each set contains no duplicates. Each set
** of values is identified by a unique P4 value. The first set
** must have P4==0, the final set P4=-1.  P4 must be either -1 or
** non-negative.  For non-negative values of P4 only the lower 4
** bits are significant.
**
** This allows optimizations: (a) when P4==0 there is no need to test
** the rowset object for P3, as it is guaranteed not to contain it,
** (b) when P4==-1 there is no need to insert the value, as it will
** never be tested for, and (c) when a value that is part of set X is
** inserted, there is no need to search to see if the same value was
** previously inserted as part of set X (only if it was previously
** inserted as part of some other set).
*/</comment>
<case>case <expr><name>OP_RowSetTest</name></expr>:</case> <block>{<block_content>                     <comment type="block">/* jump, in1, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>exists</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iSet</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is anything other than a rowset object in memory cell P1,
  ** delete it now and initialize P1 with an empty rowset
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_RowSet</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetRowSet</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_RowSet</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSet</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>iSet</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iSet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>exists</name> <operator>=</operator> <call><name>sqlite3RowSetTest</name><argument_list>(<argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRowSet</name></name></expr></argument>, <argument><expr><name>iSet</name></expr></argument>, <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>exists</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>exists</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iSet</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3RowSetInsert</name><argument_list>(<argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pRowSet</name></name></expr></argument>, <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>

<comment type="block">/* Opcode: Program P1 P2 P3 P4 P5
**
** Execute the trigger program passed as P4 (type P4_SUBPROGRAM). 
**
** P1 contains the address of the memory cell that contains the first memory 
** cell in an array of values used as arguments to the sub-program. P2 
** contains the address to jump to if the sub-program throws an IGNORE 
** exception using the RAISE() function. Register P3 contains the address 
** of a memory cell in this (the parent) VM that is used to allocate the 
** memory required by the sub-vdbe at runtime.
**
** P4 is a pointer to the VM containing the trigger program.
**
** If P5 is non-zero, then recursive program invocation is enabled.
*/</comment>
<case>case <expr><name>OP_Program</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMem</name></decl>;</decl_stmt>               <comment type="block">/* Number of memory registers for sub-program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>              <comment type="block">/* Bytes of runtime space required for sub-program */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRt</name></decl>;</decl_stmt>               <comment type="block">/* Register to allocate runtime space */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>              <comment type="block">/* Used to iterate through memory cells */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>              <comment type="block">/* Last memory cell in new array */</comment>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>      <comment type="block">/* New vdbe frame to execute in */</comment>
  <decl_stmt><decl><type><name>SubProgram</name> <modifier>*</modifier></type><name>pProgram</name></decl>;</decl_stmt>   <comment type="block">/* Sub-program to execute */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>                <comment type="block">/* Token identifying trigger */</comment>

  <expr_stmt><expr><name>pProgram</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pProgram</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRt</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pProgram</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* If the p5 flag is clear, then recursive invocation of triggers is 
  ** disabled for backwards compatibility (p5 is set if this sub-program
  ** is really a trigger, not a foreign key action, and the flag set
  ** and cleared by the "PRAGMA recursive_triggers" command is clear).
  ** 
  ** It is recursive invocation of triggers, at the SQL level, that is 
  ** disabled. In some cases a single trigger may generate more than one 
  ** SubProgram (if the trigger may be executed with more than one different 
  ** ON CONFLICT algorithm). SubProgram structures associated with a
  ** single trigger all have the same value for the SubProgram.token 
  ** variable.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>token</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pFrame</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</init> <condition><expr><name>pFrame</name> <operator>&amp;&amp;</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>token</name></name><operator>!=</operator><name>t</name></expr>;</condition> <incr><expr><name>pFrame</name><operator>=</operator><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <if_stmt><if>if<condition>( <expr><name>pFrame</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nFrame</name></name><operator>&gt;=</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_TRIGGER_DEPTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"too many levels of trigger recursion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register pRt is used to store the memory required to save the state
  ** of the current program, and the memory required at runtime to execute
  ** the trigger program. If this trigger has been fired before, then pRt 
  ** is already allocated. Otherwise, it must be initialized.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRt</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Frame</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* SubProgram.nMem is set to the number of memory cells used by the 
    ** program stored in SubProgram.aOp. As well as these, one memory
    ** cell is required for each cursor used by the program. Set local
    ** variable nMem (and later, VdbeFrame.nChildMem) to this value.
    */</comment>
    <expr_stmt><expr><name>nMem</name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeFrame</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
              <operator>+</operator> <name>nMem</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof>
              <operator>+</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name> <operator>*</operator></expr></argument>)</argument_list></sizeof>
              <operator>+</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nOnce</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u8</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFrame</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pFrame</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>no_mem</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pRt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRt</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Frame</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRt</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pFrame</name></name> <operator>=</operator> <name>pFrame</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nChildMem</name></name> <operator>=</operator> <name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nChildCsr</name></name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nMem</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>apCsr</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nOp</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>token</name></name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>token</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>aOnceFlag</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOnceFlag</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nOnceFlag</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOnceFlag</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>anExec</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>anExec</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <operator>&amp;</operator><call><name>VdbeFrameMem</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call><index>[<expr><name><name>pFrame</name><operator>-&gt;</operator><name>nChildMem</name></name></expr>]</index></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>pMem</name><operator>=</operator><call><name>VdbeFrameMem</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pMem</name><operator>!=</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pMem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pFrame</name> <operator>=</operator> <name><name>pRt</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pFrame</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pProgram</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name><operator>==</operator><name><name>pFrame</name><operator>-&gt;</operator><name>nChildMem</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pProgram</name><operator>-&gt;</operator><name>nCsr</name></name><operator>==</operator><name><name>pFrame</name><operator>-&gt;</operator><name>nChildCsr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator><operator>==</operator><name><name>pFrame</name><operator>-&gt;</operator><name>pc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrame</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name>lastRowid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>nDbChange</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name> <operator>=</operator> <name>pFrame</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <name>aMem</name> <operator>=</operator> <operator>&amp;</operator><call><name>VdbeFrameMem</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nChildMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>pFrame</name><operator>-&gt;</operator><name>nChildCsr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name> <operator>=</operator> <operator>(</operator><name>VdbeCursor</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <name>aOp</name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOnceFlag</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOnceFlag</name></name> <operator>=</operator> <name><name>pProgram</name><operator>-&gt;</operator><name>nOnce</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOnceFlag</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOnceFlag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: Param P1 P2 * * *
**
** This opcode is only ever present in sub-programs called via the 
** OP_Program instruction. Copy a value currently stored in a memory 
** cell of the calling (parent) frame to cell P2 in the current frames 
** address space. This is used by trigger programs to access the new.* 
** and old.* values.
**
** The address of the cell in the parent frame is determined by adding
** the value of the P1 argument to the value of the P1 argument to the
** calling OP_Program instruction.
*/</comment>
<case>case <expr><name>OP_Param</name></expr>:</case> <block>{<block_content>           <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pIn</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFrame</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn</name> <operator>=</operator> <operator>&amp;</operator><name><name>pFrame</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>+</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>pFrame</name><operator>-&gt;</operator><name>pc</name></name></expr>]</index></name><operator>.</operator><name>p1</name></expr>]</index></name></expr>;</expr_stmt>   
  <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_TRIGGER */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
<comment type="block">/* Opcode: FkCounter P1 P2 * * *
** Synopsis: fkctr[P1]+=P2
**
** Increment a "constraint counter" by P2 (P2 may be negative or positive).
** If P1 is non-zero, the database constraint counter is incremented 
** (deferred foreign key constraints). Otherwise, if P1 is zero, the 
** statement counter is incremented (immediate foreign key constraints).
*/</comment>
<case>case <expr><name>OP_FkCounter</name></expr>:</case> <block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_DeferFKs</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>+=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>+=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFkConstraint</name></name> <operator>+=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: FkIfZero P1 P2 * * *
** Synopsis: if fkctr[P1]==0 goto P2
**
** This opcode tests if a foreign key constraint-counter is currently zero.
** If so, jump to instruction P2. Otherwise, fall through to the next 
** instruction.
**
** If P1 is non-zero, then the jump is taken if the database constraint-counter
** is zero (the one that counts deferred constraint violations). If P1 is
** zero, the jump is taken if the statement constraint-counter is zero
** (immediate foreign key constraint violations).
*/</comment>
<case>case <expr><name>OP_FkIfZero</name></expr>:</case> <block>{<block_content>         <comment type="block">/* jump */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nFkConstraint</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nFkConstraint</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_FOREIGN_KEY */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
<comment type="block">/* Opcode: MemMax P1 P2 * * *
** Synopsis: r[P1]=max(r[P1],r[P2])
**
** P1 is a register in the root frame of this VM (the root frame is
** different from the current frame if this instruction is being executed
** within a sub-program). Set the value of register P1 to the maximum of 
** its current value and the value in register P2.
**
** This instruction throws an error if the memory cell is not initially
** an integer.
*/</comment>
<case>case <expr><name>OP_MemMax</name></expr>:</case> <block>{<block_content>        <comment type="block">/* in2 */</comment>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>pFrame</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</init> <condition><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</condition> <incr><expr><name>pFrame</name><operator>=</operator><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>pFrame</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn2</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><name><name>pIn2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>pIn2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTOINCREMENT */</comment>

<comment type="block">/* Opcode: IfPos P1 P2 P3 * *
** Synopsis: if r[P1]&gt;0 then r[P1]-=P3, goto P2
**
** Register P1 must contain an integer.
** If the value of register P1 is 1 or greater, subtract P3 from the
** value in P1 and jump to P2.
**
** If the initial value of register P1 is less than 1, then the
** value is unchanged and control passes through to the next instruction.
*/</comment>
<case>case <expr><name>OP_IfPos</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>-=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: OffsetLimit P1 P2 P3 * *
** Synopsis: if r[P1]&gt;0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)
**
** This opcode performs a commonly used computation associated with
** LIMIT and OFFSET process.  r[P1] holds the limit counter.  r[P3]
** holds the offset counter.  The opcode computes the combined value
** of the LIMIT and OFFSET and stores that value in r[P2].  The r[P2]
** value computed is the total number of rows that will need to be
** visited in order to complete the query.
**
** If r[P3] is zero or negative, that means there is no OFFSET
** and r[P2] is set to be the value of the LIMIT, r[P1].
**
** if r[P1] is zero or negative, that means there is no LIMIT
** and r[P2] is set to -1. 
**
** Otherwise, r[P2] is set to the sum of r[P1] and r[P3].
*/</comment>
<case>case <expr><name>OP_OffsetLimit</name></expr>:</case> <block>{<block_content>    <comment type="block">/* in1, out2, in3 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn3</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn3</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>+</operator><operator>(</operator><ternary><condition><expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><literal type="number">0</literal></expr>?</condition><then><expr><name><name>pIn3</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: IfNotZero P1 P2 P3 * *
** Synopsis: if r[P1]!=0 then r[P1]-=P3, goto P2
**
** Register P1 must contain an integer.  If the content of register P1 is
** initially nonzero, then subtract P3 from the value in register P1 and
** jump to P2.  If register P1 is initially zero, leave it unchanged
** and fall through.
*/</comment>
<case>case <expr><name>OP_IfNotZero</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>-=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
     <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: DecrJumpZero P1 P2 * * *
** Synopsis: if (--r[P1])==0 goto P2
**
** Register P1 must hold an integer.  Decrement the value in register P1
** then jump to P2 if the new value is exactly zero.
*/</comment>
<case>case <expr><name>OP_DecrJumpZero</name></expr>:</case> <block>{<block_content>      <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>


<comment type="block">/* Opcode: JumpZeroIncr P1 P2 * * *
** Synopsis: if (r[P1]++)==0 ) goto P2
**
** The register P1 must contain an integer.  If register P1 is initially
** zero, then jump to P2.  Increment register P1 regardless of whether or
** not the jump is taken.
*/</comment>
<case>case <expr><name>OP_JumpZeroIncr</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><name>pIn1</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pIn1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>++</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: AggStep0 * P2 P3 P4 P5
** Synopsis: accum=r[P3] step(r[P2@P5])
**
** Execute the step function for an aggregate.  The
** function has P5 arguments.   P4 is a pointer to the FuncDef
** structure that specifies the function.  Register P3 is the
** accumulator.
**
** The P5 arguments are taken from register P2 and its
** successors.
*/</comment>
<comment type="block">/* Opcode: AggStep * P2 P3 P4 P5
** Synopsis: accum=r[P3] step(r[P2@P5])
**
** Execute the step function for an aggregate.  The
** function has P5 arguments.   P4 is a pointer to an sqlite3_context
** object that is used to run the function.  Register P3 is
** as the accumulator.
**
** The P5 arguments are taken from register P2 and its
** successors.
**
** This opcode is initially coded as OP_AggStep0.  On first evaluation,
** the FuncDef stored in P4 is converted into an sqlite3_context and
** the opcode is changed.  In this way, the initialization of the
** sqlite3_context only happens once, instead of on each call to the
** step function.
*/</comment>
<case>case <expr><name>OP_AggStep0</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_FUNCDEF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>n</name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;=</operator><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCtx</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCtx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pMem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pFunc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_FUNCCTX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_AggStep</name></expr>;</expr_stmt>
  <comment type="block">/* Fall through into OP_AggStep */</comment>
</block_content>}</block>
<case>case <expr><name>OP_AggStep</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name></type> <name>t</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_FUNCCTX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pCtx</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* If this function is inside of a trigger, the register array in aMem[]
  ** might change from one evaluation to the next.  The next block of code
  ** checks to see if the register array has changed, and if so it
  ** reinitializes the relavant parts of the sqlite3_context object */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pMem</name></name> <operator>!=</operator> <name>pMem</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pMem</name></name> <operator>=</operator> <name>pMem</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name> <operator>=</operator> <operator>&amp;</operator><name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>skipFlag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>xSFunc</name></name><operator>)</operator><operator>(</operator><name>pCtx</name><operator>,</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name><operator>,</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argv</name></name><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* IMP: R-24505-23230 */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>t</name><operator>.</operator><name>flags</name></name><operator>==</operator><name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>skipFlag</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_CollSeq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p1</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block">/* Opcode: AggFinal P1 P2 * P4 *
** Synopsis: accum=r[P1] N=P2
**
** Execute the finalizer function for an aggregate.  P1 is
** the memory location that is the accumulator for the aggregate.
**
** P2 is the number of arguments that the step function takes and
** P4 is a pointer to the FuncDef for this function.  The P2
** argument is not used by this opcode.  It is only there to disambiguate
** functions that can take varying numbers of arguments.  The
** P4 argument is only needed for the degenerate case where
** the step function was not previously called.
*/</comment>
<case>case <expr><name>OP_AggFinal</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Agg</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFinalize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>too_big</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<comment type="block">/* Opcode: Checkpoint P1 P2 P3 * *
**
** Checkpoint database P1. This is a no-op if P1 is not currently in
** WAL mode. Parameter P2 is one of SQLITE_CHECKPOINT_PASSIVE, FULL,
** RESTART, or TRUNCATE.  Write 1 or 0 into mem[P3] if the checkpoint returns
** SQLITE_BUSY or not, respectively.  Write the number of pages in the
** WAL after the checkpoint into mem[P3+1] and the number of pages
** in the WAL that have been checkpointed after the checkpoint
** completes into mem[P3+2].  However on an error, mem[P3+1] and
** mem[P3+2] are initialized to -1.
*/</comment>
<case>case <expr><name>OP_Checkpoint</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aRes</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>                    <comment type="block">/* Results */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl>;</decl_stmt>                      <comment type="block">/* Write results here */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aRes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aRes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_CHECKPOINT_PASSIVE</name>
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_CHECKPOINT_FULL</name>
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_CHECKPOINT_RESTART</name>
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>SQLITE_CHECKPOINT_TRUNCATE</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Checkpoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aRes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aRes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pMem</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pMem</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name><name>aRes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>    
  <break>break;</break>
</block_content>}</block><empty_stmt>;</empty_stmt>  
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PRAGMA</name></cpp:ifndef>
<comment type="block">/* Opcode: JournalMode P1 P2 P3 * *
**
** Change the journal mode of database P1 to P3. P3 must be one of the
** PAGER_JOURNALMODE_XXX values. If changing between the various rollback
** modes (delete, truncate, persist, off and memory), this is a simple
** operation. No IO is required.
**
** If changing into or out of WAL mode the procedure is more complicated.
**
** Write a string containing the final journal-mode to register P2.
*/</comment>
<case>case <expr><name>OP_JournalMode</name></expr>:</case> <block>{<block_content>    <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>                     <comment type="block">/* Btree to change journal mode of */</comment>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>                  <comment type="block">/* Pager associated with pBt */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eNew</name></decl>;</decl_stmt>                       <comment type="block">/* New journal mode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eOld</name></decl>;</decl_stmt>                       <comment type="block">/* The old journal mode */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>          <comment type="block">/* Name of database file for pPager */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_DELETE</name> 
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_TRUNCATE</name> 
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_PERSIST</name> 
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name>
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name>
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name>
       <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_QUERY</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name> <operator>=</operator> <call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>eOld</name> <operator>=</operator> <call><name>sqlite3PagerGetJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_QUERY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>eOld</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3PagerOkToChangeJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>eOld</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <call><name>sqlite3PagerFilename</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Do not allow a transition to journal_mode=WAL for a database
  ** in temporary storage or if the VFS does not support shared memory 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name>
   <operator>&amp;&amp;</operator> <operator>(</operator><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>           <comment type="block">/* Temp file */</comment>
       <operator>||</operator> <operator>!</operator><call><name>sqlite3PagerWalSupported</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr>   <comment type="block">/* No shared-memory support */</comment>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>eOld</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eNew</name><operator>!=</operator><name>eOld</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>eOld</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name> <operator>||</operator> <name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
          <argument><expr><literal type="string">"cannot change %s wal mode from within a transaction"</literal></expr></argument>,
          <argument><expr><operator>(</operator><ternary><condition><expr><name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr> ?</condition><then> <expr><literal type="string">"into"</literal></expr> </then><else>: <expr><literal type="string">"out of"</literal></expr></else></ternary><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if><else>else<block>{<block_content>
 
      <if_stmt><if>if<condition>( <expr><name>eOld</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If leaving WAL mode, close the log file. If successful, the call
        ** to PagerCloseWal() checkpoints and deletes the write-ahead-log 
        ** file. An EXCLUSIVE lock may still be held on the database file 
        ** after a successful return. 
        */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerCloseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3PagerSetJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>eNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eOld</name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Cannot transition directly from MEMORY to WAL.  Use mode OFF
        ** as an intermediate */</comment>
        <expr_stmt><expr><call><name>sqlite3PagerSetJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>PAGER_JOURNALMODE_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
  
      <comment type="block">/* Open a transaction on the database file. Regardless of the journal
      ** mode, this transaction always uses a rollback journal.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeSetVersion</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>eNew</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_WAL */</comment>

  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>eNew</name> <operator>=</operator> <name>eOld</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>eNew</name> <operator>=</operator> <call><name>sqlite3PagerSetJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>eNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Str</name><operator>|</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Term</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3JournalModename</name><argument_list>(<argument><expr><name>eNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_PRAGMA */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VACUUM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_ATTACH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Opcode: Vacuum * * * * *
**
** Vacuum the entire database.  This opcode will cause other virtual
** machines to be created and run.  It may not be called from within
** a transaction.
*/</comment>
<case>case <expr><name>OP_Vacuum</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3RunVacuum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_AUTOVACUUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Opcode: IncrVacuum P1 P2 * * *
**
** Perform a single step of the incremental vacuum procedure on
** the P1 database. If the vacuum has finished, jump to instruction
** P2. Otherwise, fall through to the next instruction.
*/</comment>
<case>case <expr><name>OP_IncrVacuum</name></expr>:</case> <block>{<block_content>        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeIncrVacuum</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <goto>goto <name>jump_to_p2</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: Expire P1 * * * *
**
** Cause precompiled statements to expire.  When an expired statement
** is executed using sqlite3_step() it will either automatically
** reprepare itself (if it was originally created using sqlite3_prepare_v2())
** or it will fail with SQLITE_SCHEMA.
** 
** If P1 is 0, then all SQL statements become expired. If P1 is non-zero,
** then only the currently executing statement is expired.
*/</comment>
<case>case <expr><name>OP_Expire</name></expr>:</case> <block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/* Opcode: TableLock P1 P2 P3 P4 *
** Synopsis: iDb=P1 root=P2 write=P3
**
** Obtain a lock on a particular table. This instruction is only used when
** the shared-cache feature is enabled. 
**
** P1 is the index of the database in sqlite3.aDb[] of the database
** on which the lock is acquired.  A readlock is obtained if P3==0 or
** a write lock if P3==1.
**
** P2 contains the root-page of the table to lock.
**
** P4 contains a pointer to the name of the table being locked. This is only
** used to generate an error message if the lock cannot be obtained.
*/</comment>
<case>case <expr><name>OP_TableLock</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>isWriteLock</name> <init>= <expr><operator>(</operator><name>u8</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>isWriteLock</name> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ReadUncommitted</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>p1</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></init></decl>;</decl_stmt> 
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p1</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isWriteLock</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isWriteLock</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeLockTable</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>p1</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name>isWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xFF</literal><operator>)</operator><operator>==</operator><name>SQLITE_LOCKED</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"database table is locked: %s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SHARED_CACHE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VBegin * * * P4 *
**
** P4 may be a pointer to an sqlite3_vtab structure. If so, call the 
** xBegin method for that table.
**
** Also, whether or not P4 is set, check that this is not being called from
** within a callback to a virtual table xSync() method. If it is, the error
** code will be set to SQLITE_LOCKED.
*/</comment>
<case>case <expr><name>OP_VBegin</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pVTab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabBegin</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVTab</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pVTab</name><operator>-&gt;</operator><name>pVtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VCreate P1 P2 * * *
**
** P2 is a register that holds the name of a virtual table in database 
** P1. Call the xCreate method for that table.
*/</comment>
<case>case <expr><name>OP_VCreate</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name></type> <name>sMem</name></decl>;</decl_stmt>          <comment type="block">/* For storing the record being decoded */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>  <comment type="block">/* Name of the virtual table */</comment>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sMem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sMem</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <comment type="block">/* Because P2 is always a static string, it is impossible for the
  ** sqlite3VdbeMemCopy() to fail */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Static</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTab</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zTab</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabCallCreate</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VDestroy P1 * * P4 *
**
** P4 is the name of a virtual table in database P1.  Call the xDestroy method
** of that table.
*/</comment>
<case>case <expr><name>OP_VDestroy</name></expr>:</case> <block>{<block_content>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVDestroy</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabCallDestroy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVDestroy</name></name><operator>--</operator></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VOpen P1 * * P4 *
**
** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
** P1 is a cursor number.  This opcode opens a cursor to the virtual
** table and stores that cursor in P1.
*/</comment>
<case>case <expr><name>OP_VOpen</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVCur</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVtab</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_LOCKED</name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Initialize sqlite3_vtab_cursor base class */</comment>
    <expr_stmt><expr><name><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name></name> <operator>=</operator> <name>pVtab</name></expr>;</expr_stmt>

    <comment type="block">/* Initialize vdbe cursor object */</comment>
    <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>CURTYPE_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCur</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name> <operator>=</operator> <name>pVCur</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pVtab</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pVCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>no_mem</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VFilter P1 P2 P3 P4 *
** Synopsis: iplan=r[P3] zplan='P4'
**
** P1 is a cursor opened using VOpen.  P2 is an address to jump to if
** the filtered result set is empty.
**
** P4 is either NULL or a string that was generated by the xBestIndex
** method of the module.  The interpretation of the P4 string is left
** to the module implementation.
**
** This opcode invokes the xFilter method on the virtual table specified
** by P1.  The integer query plan parameter to xFilter is stored in register
** P3. Register P3+1 stores the argc parameter to be passed to the
** xFilter method. Registers P3+2..P3+1+argc are the argc
** additional parameters which are passed to
** xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.
**
** A jump is made to P2 if the result set after filtering would be empty.
*/</comment>
<case>case <expr><name>OP_VFilter</name></expr>:</case> <block>{<block_content>   <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iQuery</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pQuery</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pArgc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pQuery</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pArgc</name> <operator>=</operator> <operator>&amp;</operator><name><name>pQuery</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVCur</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>

  <comment type="block">/* Grab the index number and argc parameters */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pQuery</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Int</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pArgc</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nArg</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pArgc</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iQuery</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pQuery</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>

  <comment type="block">/* Invoke the xFilter method */</comment>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>apArg</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apArg</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pArgc</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xFilter</name></name><argument_list>(<argument><expr><name>pVCur</name></expr></argument>, <argument><expr><name>iQuery</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xEof</name></name><argument_list>(<argument><expr><name>pVCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VColumn P1 P2 P3 * *
** Synopsis: r[P3]=vcolumn(P2)
**
** Store the value of the P2-th column of
** the row of the virtual-table that the 
** P1 cursor is pointing to into register P3.
*/</comment>
<case>case <expr><name>OP_VColumn</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pDest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name></type> <name>sContext</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>&lt;=</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pModule</name><operator>-&gt;</operator><name>xColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sContext</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sContext</name><operator>.</operator><name>pOut</name></name> <operator>=</operator> <name>pDest</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xColumn</name></name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sContext</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sContext</name><operator>.</operator><name>isError</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>sContext</name><operator>.</operator><name>isError</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>too_big</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VNext P1 P2 * * *
**
** Advance virtual table P1 to the next row in its result set and
** jump to instruction P2.  Or, if the virtual table has reached
** the end of its result set, then fall through to the next instruction.
*/</comment>
<case>case <expr><name>OP_VNext</name></expr>:</case> <block>{<block_content>   <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRow</name></name></expr> )</condition><block>{<block_content>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Invoke the xNext() method of the module. There is no way for the
  ** underlying implementation to return an error if one occurs during
  ** xNext(). Instead, if an error occurs, true is returned (indicating that 
  ** data is available) and the error code returned when xColumn or
  ** some other method is next invoked on the save virtual table cursor.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xEof</name></name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>VdbeBranchTaken</name><argument_list>(<argument><expr><operator>!</operator><name>res</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>res</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there is data, jump to P2 */</comment>
    <goto>goto <name>jump_to_p2_and_check_for_interrupt</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <goto>goto <name>check_for_interrupt</name>;</goto>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VRename P1 * * P4 *
**
** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
** This opcode invokes the corresponding xRename method. The value
** in register P1 is passed as the zName argument to the xRename method.
*/</comment>
<case>case <expr><name>OP_VRename</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pName</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pName</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xRename</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF8</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF16LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pName</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xRename</name></name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name><name>pName</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VUpdate P1 P2 P3 P4 P5
** Synopsis: data=r[P3@P2]
**
** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
** This opcode invokes the corresponding xUpdate method. P2 values
** are contiguous memory cells starting at P3 to pass to the xUpdate 
** invocation. The value in register (P3+P2-1) corresponds to the 
** p2th element of the argv array passed to xUpdate.
**
** The xUpdate method will do a DELETE or an INSERT or both.
** The argv[0] element (which corresponds to memory cell P3)
** is the rowid of a row to delete.  If argv[0] is NULL then no 
** deletion occurs.  The argv[1] element is the rowid of the new 
** row.  This can be NULL to have the virtual table select the new 
** rowid for itself.  The subsequent elements in the array are 
** the values of columns in the new row.
**
** If P2==1 then no insert is performed.  argv[0] is the rowid of
** a row to delete.
**
** P1 is a boolean flag. If it is set to true and the xUpdate call
** is successful, then the value returned by sqlite3_last_insert_rowid() 
** is set to the value of the rowid for the row just inserted.
**
** P5 is the error actions (OE_Replace, OE_Fail, OE_Ignore, etc) to
** apply in the case of a constraint failure on an insert or update.
*/</comment>
<case>case <expr><name>OP_VUpdate</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>rowid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">1</literal>        <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Fail</name>   <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Rollback</name> 
       <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Abort</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Ignore</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Replace</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>pVtab</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVtab</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_LOCKED</name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nArg</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pModule</name><operator>-&gt;</operator><name>xUpdate</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>vtabOnConflict</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>vtabOnConflict</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>apArg</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apArg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pX</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memIsValid</name><argument_list>(<argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memAboutToChange</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pX</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>vtabOnConflict</name></name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xUpdate</name></name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apArg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>vtabOnConflict</name></name> <operator>=</operator> <name>vtabOnConflict</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>flags</name><operator>&amp;</operator><name>MEM_Null</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name>lastRowid</name> <operator>=</operator> <name>rowid</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>bConstraint</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Ignore</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name><operator>==</operator><name>OE_Replace</name><operator>)</operator></expr> ?</condition><then> <expr><name>OE_Abort</name></expr> </then><else>: <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive>  <name>SQLITE_OMIT_PAGER_PRAGMAS</name></cpp:ifndef>
<comment type="block">/* Opcode: Pagecount P1 P2 * * *
**
** Write the current number of pages in database P1 to memory cell P2.
*/</comment>
<case>case <expr><name>OP_Pagecount</name></expr>:</case> <block>{<block_content>            <comment type="block">/* out2 */</comment>
  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>sqlite3BtreeLastPage</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive>  <name>SQLITE_OMIT_PAGER_PRAGMAS</name></cpp:ifndef>
<comment type="block">/* Opcode: MaxPgcnt P1 P2 P3 * *
**
** Try to set the maximum page count for database P1 to the value in P3.
** Do not let the maximum page count fall below the current page count and
** do not change the maximum page count value if P3==0.
**
** Store the maximum page count after the change in register P2.
*/</comment>
<case>case <expr><name>OP_MaxPgcnt</name></expr>:</case> <block>{<block_content>            <comment type="block">/* out2 */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>newMax</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>out2Prerelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name><operator>.</operator><name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>newMax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>newMax</name> <operator>=</operator> <call><name>sqlite3BtreeLastPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>newMax</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>newMax</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>sqlite3BtreeMaxPageCount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>newMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Opcode: Init * P2 * P4 *
** Synopsis:  Start at P2
**
** Programs contain a single instance of this opcode as the very first
** opcode.
**
** If tracing is enabled (by the sqlite3_trace()) interface, then
** the UTF-8 string contained in P4 is emitted on the trace callback.
** Or if P4 is blank, use the string returned by sqlite3_sql().
**
** If P2 is not zero, jump to instruction P2.
*/</comment>
<case>case <expr><name>OP_Init</name></expr>:</case> <block>{<block_content>          <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTrace</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xTrace</name></name>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>doingRerun</name></name>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>zTrace</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> ?</condition><then> <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></else></ternary><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3VdbeExpandSql</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xTrace</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_USE_FCNTL_TRACE</name></cpp:ifdef>
  <expr_stmt><expr><name>zTrace</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> ?</condition><then> <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTrace</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_TRACE</name></expr></argument>, <argument><expr><name>zTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_USE_FCNTL_TRACE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_SqlTrace</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>zTrace</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> ?</condition><then> <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></else></ternary><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr><literal type="string">"SQL-trace: %s\n"</literal></expr></argument>, <argument><expr><name>zTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRACE */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>jump_to_p2</name>;</goto></block_content></block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
<comment type="block">/* Opcode: CursorHint P1 * * P4 *
**
** Provide a hint to cursor P1 that it only needs to return rows that
** satisfy the Expr in P4.  TK_REGISTER terms in the P4 expression refer
** to values currently held in registers.  TK_COLUMN terms in the P4
** expression refer to columns in the b-tree to which cursor P1 is pointing.
*/</comment>
<case>case <expr><name>OP_CursorHint</name></expr>:</case> <block>{<block_content>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pC</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeCursorHint</name><argument_list>(<argument><expr><name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>BTREE_HINT_RANGE</name></expr></argument>,
                           <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>aMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_CURSOR_HINTS */</comment>

<comment type="block">/* Opcode: Noop * * * * *
**
** Do nothing.  This instruction is often useful as a jump
** destination.
*/</comment>
<comment type="block">/*
** The magic Explain opcode are only inserted when explain==2 (which
** is to say when the EXPLAIN QUERY PLAN syntax is used.)
** This opcode records information from the optimizer.  It is the
** the same as a no-op.  This opcodesnever appears in a real VM program.
*/</comment>
<default>default:</default> <block>{<block_content>          <comment type="block">/* This is really OP_Noop and OP_Explain */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Noop</name> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Explain</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
</block_content>}</block>

<comment type="block" format="doxygen">/*****************************************************************************
** The cases of the switch statement above this line should all be indented
** by 6 spaces.  But the left-most 6 spaces have been removed to improve the
** readability.  From this point on down, the normal indentation rules are
** restored.
*****************************************************************************/</comment>
    </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
    <block>{<block_content>
      <decl_stmt><decl><type><name>u64</name></type> <name>endTime</name> <init>= <expr><call><name>sqlite3Hwtime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>endTime</name><operator>&gt;</operator><name>start</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>cycles</name></name> <operator>+=</operator> <name>endTime</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* The following code adds nothing to the actual functionality
    ** of the program.  It is only here for testing and debugging.
    ** On the other hand, it does burn CPU cycles every time through
    ** the evaluator loop.  So we can leave it out when NDEBUG is defined.
    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>&gt;=</operator><operator>&amp;</operator><name><name>aOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>pOp</name><operator>&lt;</operator><operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeTrace</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"rc=%d\n"</literal></expr></argument>,<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>opflags</name></name> <operator>&amp;</operator> <operator>(</operator><name>OPFLG_OUT2</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>registerTrace</name><argument_list>(<argument><expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>p2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>opflags</name></name> <operator>&amp;</operator> <name>OPFLG_OUT3</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>registerTrace</name><argument_list>(<argument><expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>pOrigOp</name><operator>-&gt;</operator><name>p3</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SQLITE_DEBUG */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* NDEBUG */</comment>
  </block_content>}</block></for>  <comment type="block">/* The end of the for(;;) loop the loops through opcodes */</comment>

  <comment type="block">/* If we reach this point, it means that execution is finished with
  ** an error of some kind.
  */</comment>
<label><name>vdbe_error_halt</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"statement aborts at %d: [%s] %s"</literal></expr></argument>, 
                   <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name>aOp</name><operator>)</operator></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>resetSchemaOnFault</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ResetOneSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>resetSchemaOnFault</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* This is the only way out of this procedure.  We have to
  ** release the mutexes on btrees that were acquired at the
  ** top. */</comment>
<label><name>vdbe_return</name>:</label>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name>lastRowid</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nVmStep</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_VM_STEP</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nVmStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>nExtraDelete</name><operator>==</operator><literal type="number">0</literal> 
       <operator>||</operator> <call><name>sqlite3_strlike</name><argument_list>(<argument><expr><literal type="string">"DELETE%"</literal></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>

  <comment type="block">/* Jump to here if a string or blob larger than SQLITE_MAX_LENGTH
  ** is encountered.
  */</comment>
<label><name>too_big</name>:</label>
  <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"string or blob too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_TOOBIG</name></expr>;</expr_stmt>
  <goto>goto <name>vdbe_error_halt</name>;</goto>

  <comment type="block">/* Jump to here if a malloc() fails.
  */</comment>
<label><name>no_mem</name>:</label>
  <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  <goto>goto <name>vdbe_error_halt</name>;</goto>

  <comment type="block">/* Jump to here for any other kind of fatal error.  The "rc" variable
  ** should hold the error number.
  */</comment>
<label><name>abort_due_to_error</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_IOERR_NOMEM</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <goto>goto <name>vdbe_error_halt</name>;</goto>

  <comment type="block">/* Jump to here if the sqlite3_interrupt() API sets the interrupt
  ** flag.
  */</comment>
<label><name>abort_due_to_interrupt</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> ?</condition><then> <expr><name>SQLITE_NOMEM</name></expr> </then><else>: <expr><name>SQLITE_INTERRUPT</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>vdbe_error_halt</name>;</goto>
</block_content>}</block></function>
</unit>
